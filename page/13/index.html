<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/13/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Stenciling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Stenciling/" class="post-title-link" itemprop="url">模版(Stenciling)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:11:29" itemprop="dateCreated datePublished" datetime="2019-04-11T15:11:29+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>模版缓存是一个远离屏幕的缓存，我们能够用它来完成一些特效。模版缓存与后缓存和深度缓存有相同的定义，因此在模版缓存中的ijth像素与后缓存和深度缓存中的ijth像素是相协调的。就象名字所说，模版缓存就象一个模版它允许我们印刷渲染后缓存的某个部分。<br>举例，当要实现一个镜子时，我们只需要简单地反射一个物体细节到镜子平面上；然而，我们仅仅想只绘制镜子里的反射结果。我们能用模版缓存来印制渲染它。图8.1清楚的显示了这一点。</p>
<p>图8.1<br>模版缓存是Direct3D中的一小部分，它是通过一个简单的表面而被约束的。就象混合，这个简单的表面提供了可变的强大的设置能力。有效地学习使用模版缓存最好的方法是通过学习实际的应用程序。一旦你学懂了一点应用程序中的模版缓存，你将会得到一个更好的用于你自己需要特效的主意。<br>正因为这个原因，这一章我们特别安排学习两个使用模版缓存的应用程序。<br>目标</p>
<ul>
<li>理解模版缓存是怎样工作的，怎样创建一个模版缓存以及怎样控制它。</li>
<li>学习怎样实现一个镜面效果，使用模版缓存来防止绘制反射到不在镜子表面上的物体。</li>
<li>利用模版缓存怎样渲染阴影和防止“双倍混合”。<br>8.1使用模版缓存<br>　　为了使用模版缓存，我们在初始化Direct3D时必须首先请求一个，然后必须启用它。我们在8.1.1中讲述怎样请求一个模版缓存。为了启用模版缓存，我们必须设置D3DRS_STENCILENABLE渲染状态并且指定它为true（关闭它即可指定为false）。下面的代码是启用和关闭模版缓存的代码：<br>Device-&gt;SetRenderState(D3DRS_STENCILENABLE, true);<br>… // do stencil work<br>Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false);<br>我们可以使用IDirect3DDevice9::Clear方法来清除模版缓存并让其拥有默认值。回忆一下，同样的方法被用在清除后缓存和深度缓存中。<br>Device-&gt;Clear(0, 0,<br>  D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,<br>  0xff000000, 1.0f, 0 );<br>注意我们已经添加了D3DCLEAR_STENCIL到第三个参数中，它表示我们想把模版缓存和目标（后缓存）以及深度缓存一起清除。有6种值可以用来指定清除后的模版缓存；在这个例子中我们将它清除为0。<br>8.1.1请求一个模版缓存<br>　　在我们创建深度缓存的同时一个模版缓存能够被创建。当指定深度缓存格式的时候，我们同时指定模版缓存的格式。这样，模版缓存和深度缓存分享同一个离屏表面缓存，但是每个像素被指定到各自缓存内存片段中。下面列出了3种深度/模版缓存的格式：</li>
<li>D3DFMT_D24S8—这种格式是说创建一个32位深度/模版缓存，其中24位为深度缓存，8位为模版缓存。</li>
<li>D3DFMT_D24X4S4—这种格式是说创建一个32位深度/模版缓存，其中24位为深度缓存，4位为模版缓存，还有4位留着不用。</li>
<li>D3DFMT_D15S1—这种格式是说创建一个16位深度/模版缓存，其中15位为深度缓存，1位为模版缓存。<br>注意，还有一些格式没有分配任何位给模版缓存。例如，D3DFMT_D32格式是说只创建一个32位深度缓存。<br>  同样，不同硬件对模版缓存的支持也是不同的。例如有些显卡就不支持8位模版缓存。<br>8.1.2模版测试<br>  如前所述，我们能够使用模版缓存来阻止渲染后缓存中的某些部分。阻止特殊像素被写是通过模版测试（stencil test）来决定的，这是通过下面的表达式来完成的：<br>(ref &amp; mask) ComparisonOperation (value &amp; mask)<br>模版测试是对每个像素进行的，假设模版是被允许。将有两个操作：</li>
<li>左手边操作数（LHS=ref&amp;mask）</li>
<li>右手边操作数（RHS=value&amp;mask）<br>模版测试比较LHS和RHS，通过比较运算来指定。全部的运算都得到一个布尔值（true/false）。假如测试的结果是true，那么我们把像素写入后缓存。假如测试的结果是false,我们就阻止像素被写入后缓存。当然，如果像素不能被写入后缓存，那么它也不能被写入深度缓存。<h3 id="控制模版测试"><a href="#控制模版测试" class="headerlink" title="控制模版测试"></a>控制模版测试</h3>Direct3D允许我们控制变量用于模版测试。换句话说，我们可以指定参考值（stencil reference）和掩码(mask value)，以便进行比较运算。虽然我们不能明确地设定模版值（stencil value）,但是我们能够控制写入模版缓存的值。<h4 id="模版参考值（Reference-Value）"><a href="#模版参考值（Reference-Value）" class="headerlink" title="模版参考值（Reference Value）"></a>模版参考值（Reference Value）</h4>模版参考值ref的默认值为0，但是我们能够通过设置D3DRS_STENCILREF渲染状态来改变它。例如，下面的代码就是设置模版参考值为1：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;SetRenderState(D3DRS_STENCILREF, <span class="number">0x1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意我们往往使用16进制，因为这让它看起来比整数更容易象一个位队列，并且当我们做位操作时这样看起来更有用，比如相加。</p>
<h4 id="模版掩码"><a href="#模版掩码" class="headerlink" title="模版掩码"></a>模版掩码</h4><p>模版掩码值mask是被用来掩饰（隐藏）在ref和value变量中的位。它的默认值是0xffffffff，也就是没有掩饰任何位。我们能够通过设置D3DRS_STENCILMASK渲染状态来改变它。下面的例子就是掩饰高16位：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;SetRenderState(D3DRS_STENCILMASK, <span class="number">0x0000ffff</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="模版值（Stencil-Value）"><a href="#模版值（Stencil-Value）" class="headerlink" title="模版值（Stencil Value）"></a>模版值（Stencil Value）</h4><p>作为以前的规定，在模版缓存中我们进行模版测试的当前像素。例如，假如我们对ijth像素进行模版测试，那么该值将被写入ijth模版缓存。我们不能明确地设置个别模版值，但是可以清除模版缓存。我们能够使用模版渲染状态来控制将什么写入模版缓存。</p>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>我们能够通过设置D3DRS_STENCILFUNC渲染状态来设置比较运算。这个比较运算能够被D3DCMPFUNC的任何成员类型列举：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _D3DCMPFUNC &#123;</span><br><span class="line">    D3DCMP_NEVER = <span class="number">1</span>,          <span class="comment">// 模版测试永不成功</span></span><br><span class="line">    D3DCMP_LESS = <span class="number">2</span>,           <span class="comment">// 假如LHS &lt; RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_EQUAL = <span class="number">3</span>,          <span class="comment">// 假如LHS = RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_LESSEQUAL = <span class="number">4</span>,      <span class="comment">// 假如LHS &lt;= RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_GREATER = <span class="number">5</span>,        <span class="comment">// 假如LHS &gt; RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_NOTEQUAL = <span class="number">6</span>,       <span class="comment">// 假如LHS &lt;&gt; RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_GREATEREQUAL = <span class="number">7</span>,</span><br><span class="line">    D3DCMP_ALWAYS = <span class="number">8</span>,</span><br><span class="line">    D3DCMP_FORCE_DWORD = <span class="number">0x7fffffff</span></span><br><span class="line">&#125; D3DCMPFUNC;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>D3DCMP_GREATEREQUAL——假如LHS &gt;= RHS，那么模版测试成功。</li>
<li>D3DCMP_ALWAYS——模版测试总是成功。<h3 id="更新模版缓存"><a href="#更新模版缓存" class="headerlink" title="更新模版缓存"></a>更新模版缓存</h3>除了决定是否写或阻止一个特殊像素被写入后缓存以外，我们能够定义模版缓存基于三种可能的案例怎样被更新：</li>
<li>对于ijth像素模版测试失败。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILFAIL渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILFAIL, StencilOperation);</li>
<li>对于ijth像素深度测试失败。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILZFAIL渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, StencilOperation);</li>
<li>对于ijth像素模版测试和深度测试都成功。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILPASS渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILPASS, StencilOperation);<br>其中StencilOperation能够是下面预先定义的常数：</li>
<li>D3DSTENCILOP_KEEP——指定不改变模版缓存。</li>
<li>D3DSTENCILOP_ZERO——指定设置模版缓存入口为0。</li>
<li>D3DSTENCILOP_REPLACE——指定用模版参考值（reference value）来替换模版缓存入口。</li>
<li>D3DSTENCILOP_INCRSAT——指定增加模版缓存入口。假如增加的值超过了允许的最大值，我们就设置它为最大值。</li>
<li>D3DSTENCILOP_DECRSAT——指定减少模版缓存入口。假如减少后的值小于了0，我们就设置它0。</li>
<li>D3DSTENCILOP_INVERT——指定按位取反模版缓存入口。</li>
<li>D3DSTENCILOP_INCR——指定增加模版缓存入口。假如增加的值超过了允许的最大值，我们就设置它为0。</li>
<li>D3DSTENCILOP_DECR——指定减少模版缓存入口。假如减少后的值小于了0，我们就设置它为允许的最大值。<h3 id="模版写掩码"><a href="#模版写掩码" class="headerlink" title="模版写掩码"></a>模版写掩码</h3>　　除了已经提及的模版渲染状态之外，我们能够设置一个写掩码（write mask）它将掩饰我们写进模版缓存的任何值的位。我们能够通过D3DRS_STENCILWRITEMASK渲染状态来设置写掩码。它的默认值是0xffffffff。下面的例子是掩饰高16位：<br>Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, 0x0000ffff);<br>8.2实例程序：镜子<br>　　在自然界中的很多表面象镜子一样允许我们通过它的反射来看物体。这一部分讲了我们怎样用3D应用程序来模拟镜子。注意为了简单我们只模拟平面镜。举点例子，一辆擦亮的小汽车能够反射；然而，小车的车身是光滑的，圆的，不是一个平面。我们渲染反射是这些，象光滑的大理石地板、挂在墙上的镜子。换句话说就是在一个平面的镜子。<br>　　实现镜子的程序需要我们解决两个问题。第一，我们必须学习沿着一个面怎样反射一个物体以便能够正确地绘制反射结果。第二，我们必须只能在一个镜子范围内显示反射结果。即，我们必须掩饰一个表面作为一个镜子，且只渲染那些在镜子里物体。图8.1就是说的这个内容。<br>　　第一个问题只需要用一些几何向量就可以简单解决。我们能够利用模版缓存解决第二个问题。下两小节分别介绍怎样解决这两个问题。第三小节把它们柔和在一起并且介绍一下本章的第一个应用程序实例代码——镜子。<br>8.2.1反射数学<br>　　我们现在演示怎样计算点V=（Vx, Vy, Vz）被平面n<em>p+d=0反射的点V’=（V’x, V’y, V’z）。图8.2贯穿整个讨论。<br>　　<br>　　图8.2<br>　　根据Part I中的“平面”部分，我们能够知道q=v-kn,这里k是有符号的从v到平面的距离。下面是v相对与平面（n，d）的反射推导：<br>　　<br>　　我们用下面的矩阵来实现从v到v’的转换：<br>　　<br>　　在D3DX库中用下面的函数来创建反射矩阵R。<br>D3DXMATRIX </em>D3DXMatrixReflect(<br>  D3DXMATRIX <em>pOut, // The resulting reflection matrix.<br>  CONST D3DXPLANE </em>pPlane // The plane to reflect about.<br>);<br>一旦我们说到反射变换的话题，就让我们看看其他3种特殊的反射变换。它们是关于三个坐标平面的反射—yz平面，xz平面，和xy平面—它们分别通过下面三个矩阵来表现：</li>
</ul>
<p>通过yz平面反射一个点，我们只需要简单的将x分量取反就可以了。同样的，通过xz平面反射一个点，我们只需要简单的将y分量取反。通过xy平面反射一个点，我们只需要简单的将z分量取反。这种反射是非常容易理解的。<br>8.2.2镜面实现流程<br>当实现一个镜面，一个物体假如在一面镜子前那么它就会被反射。然而，我们不想测试空间假如一个物体在一面镜子前，要做它是非常复杂的。因此，为了简化事情，我们总是反射物体并且无限制地渲染它。但是这样就有一个象本章开头的图8.1一样的问题。即，物体反射被渲染到了没有镜子的表面。我们能够用模版缓存来解决这个问题，因为模版缓存允许我们阻止渲染在后缓存中的特定区域。因此，我们使用模版缓存来阻止渲染被反射的不在镜子里的茶壶。下面的步骤简要的说明了怎样实现：<br>1、 正常渲染所有的场景——地板，墙，镜子和茶壶——不包含反射的茶壶。注意这一步没有修改模版缓存。<br>2、 清除模版缓存为0。图8.3显示了后缓存和模版缓存。</p>
<p>图8.3<br>3、 渲染只有镜子部分的图元到模版缓存中。设置模版测试总是成功，并且假如测试成功就指定模版缓存入口为1。我们仅仅渲染镜子，在模版缓存中的所有像素都将为0，除了镜子部分为1以外。图8.4显示了更新以后的模版缓存。也就是说，我们在模版缓存中对镜子像素做了标记。</p>
<p>图8.4<br>4、 现在我们渲染被反射的茶壶到后缓存和模版缓存中。但是假如模版测试通过，我们就只渲染后缓存。假如在模版缓存中的值为1，那么我们设置模版测试通过。这样，茶壶就仅仅被渲染到模版缓存为1的地方了。因为只有镜子对应的模版缓存值为1，所以反射的茶壶就只能被渲染到镜子里。<br>8.2.3代码和解释<br>　　这个例子的相关代码在RenderMirror函数中，它首先渲染镜子图元到模版缓存，然后渲染那些能被渲染到镜子里的反射茶壶。我们现在一行一行的分析RenderMirror函数的代码，并解释为什么要这么做。<br>　　假如你想使用8.2.2部分的步骤实现代码，注意我们从第3步开始，因为对模版缓存来说1和2步已经没有什么事做了。同样我们通过这个解释来讨论通过镜子渲染的信息。<br>　　注意我们将分成几个部分来讨论它。<br>8.2.3.1第一部分<br>　　我们通过允许模版缓存和设置渲染状态来开始：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderMirror</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, <span class="literal">true</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILREF, <span class="number">0x1</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILMASK, <span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK,<span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_REPLACE);</span><br></pre></td></tr></table></figure></p>
<p>　　这是非常容易理解的。我们设置模版比较运算为D3DCMP_ALWAYS,这就是说让所有模版测试都通过。<br>　　假如深度测试失败了，我们指定D3DSTENCILOP_KEEP，它表明不更新模版缓存入口。即，我们保存当前值。这样做的原因是假如深度测试失败了，那么就意味着像素被“模糊”了。我们不想渲染被“模糊”的反射像素。<br>　　同样假如模版测试失败了，我们也指定D3DSTENCILOP_KEEP。但是在这里这样做不是必须的，因为我们指定的是D3DCMP_ALWAYS，当然这样的测试也就永远不会失败。然而，我们只改变比较运算的一位，那么设置模版失败渲染状态是必须的。我们现在就这样做。<br>　　假如深度测试和模版测试都通过了，我们就指定D3DSTENCILOP_REPLACE，更新模版缓存入口，设置模版参考值为0x1。<br>8.2.3.2第二部分<br>　　这下一步阻止渲染镜子代码，除了模版缓存。我们通过设置D3DRS_ZWRITEENABLE并指定为false来阻止写深度缓存。我们能够防止更新后缓存，混合和设置源混合要素为D3DBLEND_ZERO目的混合要素为D3DBLEND_ONE。将这些混合要素代入混合等式，我们得到后缓存是不会改变的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disable writes to the depth and back buffers</span></span><br><span class="line">Device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, <span class="literal">false</span>);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, <span class="literal">true</span>);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);</span><br><span class="line"><span class="comment">// draw the mirror to the stencil buffer</span></span><br><span class="line">Device-&gt;SetStreamSource(<span class="number">0</span>, VB, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">Device-&gt;SetFVF(Vertex::FVF);</span><br><span class="line">Device-&gt;SetMaterial(&amp;MirrorMtrl);</span><br><span class="line">Device-&gt;SetTexture(<span class="number">0</span>, MirrorTex);</span><br><span class="line">D3DXMATRIX I;</span><br><span class="line">D3DXMatrixIdentity(&amp;I);</span><br><span class="line">Device-&gt;SetTransform(D3DTS_WORLD, &amp;I);</span><br><span class="line">Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">18</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// re-enable depth writes</span></span><br><span class="line">Device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>8.2.3.3第三部分<br>　　在模版缓存中，符合镜子可视像素的为0x1，因此对已经渲染的镜子区域做记号。我们现在准备渲染被反射的茶壶。回忆一下，我们仅仅想渲染镜子范围内的反射像素。我们现在可以很容易的做到了，因为在模版缓存中这些像素已经被做了记号。<br>　　我们设置下面的渲染状态：<br>    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL);<br>     Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);<br>　　用一个新的比较运算设置，我们进行下面的模版测试：<br>    (ref &amp; mask == (value &amp; mask)<br>    (0x1 &amp; 0xffffffff) == (value &amp; 0xffffffff)<br>     (0x1)== (value &amp; 0xffffffff)<br>　　这说明了只有当value=0x1时模版测试才成功。因为在模版缓存中只有镜子相应位置的值才是0x1，若我们渲染这些地方那么测试将会成功。因此，被反射的茶壶只会在镜子里绘制而不会在镜子以外的表面上绘制。<br>　　注意我们已经将渲染状态由D3DRS_STENCILPASS变为了D3DSTENCILOP_KEEP，简单的说就是假如测试通过那么就保存模版缓存的值。因此，在下一步的渲染中，我们不改变模版缓存的值。我们仅仅使用模版缓存来对镜子相应位置的像素做标记。<br>8.2.3.4第四部分<br>　　RenderMirror函数的下一部分就是计算在场景中反射位置的矩阵：<br>    // position reflection<br>    D3DXMATRIX W, T, R;<br>    D3DXPLANE plane(0.0f, 0.0f, 1.0f, 0.0f); // xy plane<br>    D3DXMatrixReflect(&amp;R, &amp;plane);<br>    D3DXMatrixTranslation(&amp;T,<br>        TeapotPosition.x,<br>        TeapotPosition.y,<br>        TeapotPosition.z);<br>     W = T * R;<br>　　注意我们首先确定没有反射的茶壶位置，然后就通过xy平面来反射。这种变换规则是通过矩阵相乘来指定的。<br>8.2.3.5第五部分<br>　　我们已经为渲染反射茶壶做好了准备。然而，假如我们现在就渲染它，它是不会被显示的。为什么呢？因为被反射的茶壶的深度比镜子的深度大，因此镜子的图元将把被反射茶壶的图元弄模糊。为了避免这种情况，我们清除深度缓存：<br>     Device-&gt;Clear(0, 0, D3DCLEAR_ZBUFFER, 0, 1.0f, 0);<br>　　并不是所有问题都解决了。假如我们简单的清除深度缓存，被反射的茶壶会被绘制到镜子的前面，物体看起来就不对了。我们想做的是清除深度缓存并且要混合被反射的茶壶和镜子。这样，被反射的茶壶看起来就象在镜子里了。我们能够通过下面的混合等式来混合被反射的茶壶和镜子：</p>
<p>　　因为原像素（sourcePixel）来自被反射的茶壶，目的像素（DestPixel）来自镜子，我们能够通过这个等式明白它们是怎么被混合到一起的。我们有如下的代码：<br>    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_DESTCOLOR);<br>     Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);<br>　　最后，我们准备绘制被反射的茶壶：<br>    Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);<br>    Device-&gt;SetMaterial(&amp;TeapotMtrl);<br>    Device-&gt;SetTexture(0, 0);<br>    Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);<br>     Teapot-&gt;DrawSubset(0);<br>　　回顾一下8.2.3.4部分的W，它能够正确的将被反射的茶壶变换到场景中恰当的位置。同样，我们也要改变背面拣选模式。必须这样做的原因是当一个物体被反射以后，它的正面和背面将会被交换。因此为了改变这种情况，我们必须改变背面拣选模式。<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false);<br>    Device-&gt;SetRenderState( D3DRS_STENCILENABLE, false);<br>    Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);<br>} // end RenderMirror()<br>8.3实例程序：平面阴影<br>在场景中被灯光照射的地方会产生阴影，这将使场景变的更真实。在这一部分我们将演示怎样实现平面阴影，即在平面上的阴影（如图8.5）。</p>
<p>图8.5<br>注意这种阴影是“快砍”，虽然它们增强了场景效果，但是这并不是现实中的阴影。阴影值是一个高级的概念，要深入研究它已经超出了本书的范围。然而，特别值得提及的是在DirectX SDK中有一个示例程序演示了阴影值。<br>　　为了实现平面阴影，我们首先必须找到物体投射到平面上的阴影并进行几何建模以便我们能够渲染它。用一些3D数学就能很容易的实现它。我们然后用50%透明度的黑色材质来渲染描述阴影的多边形。渲染阴影时可能出现“双倍混合”，我们将用一小部分进行解释。我们使用模版缓存来防止双倍混合发生。<br>8.3.1平行光阴影</p>
<p>图8.6<br>图8.6显示了物体在平行光照射下得到的阴影。光线是从平行光源放射出的，它的方向是L,通过顶点p得到r（t） = p + tL。光线r（t）和平面n * p + d = 0 相交得到 s 。交点s 通过射线和平面相交测试是非常容易得到的：<br>把r(t)带进平面等式<br>求解t</p>
<p>那么：</p>
<p>8.3.2点光源阴影</p>
<p>图8.7<br>图8.7显示了物体在点光源照射下得到的阴影。点光源的位置是L。光线通过顶点p，则得到 r(t) = p + t ( p – L )。光线r（t）和平面n <em> p + d = 0 相交得到 s 。用8.3.1同样的方法我们可以得到s。<br>注意：在点光源和平行光中的L是不同的。对于点光源，我们用L来表示点光源的位置。而对于平行光，我们则是用L来表示平行光的照射方向。<br>8.3.3阴影矩阵<br>　　注意图8.6中所示的平行光，影子本质上是把物体按照灯光照射方向平行地投射到平面n</em>p+d=0之上。同样的，图8.7中所示的点光源，影子本质上是把物体按照透视画法从光源投射到平面n<em>p+d=0之上。<br>　　我们能够使用一个矩阵来表示从一个顶点p变换到平面n</em>p=d=0上的s的变化。而且，我们能够用同一个矩阵来表现正交投影和透视投影。<br>　　我们用一个4D向量（nx, ny, nz, d）来表示将要用于投射阴影平面的平面等式中的各个系数。让4D向量L=（Lx, Ly, Lz, Lw）来表示平行光的照射方向或点光源的位置。我们用w来区别：<br>１． 假如w＝０，那么L表示平行光的照射方向。<br>２． 假如w＝1 ，那么L表示点光源的位置。<br>规格化的平面是非常不逊的，我们让k＝（nx, ny, nz, d）*（Lx, Ly, Lz, Lw）= nxLx+nyLy+nzLz+dLw<br>那么我们就可得到表示点p到点s的变换矩阵，即阴影矩阵：</p>
<p>因为在其他地方已经被推导出来了，对于我们来说推导它并没有重大的意义，在这里我们就不再演示推导怎样得到这个矩阵的过程了。但是对与感兴趣的读者可以自己到网上查找相应的信息。<br>　　　　在D3DX库中已经给我们提供了一个建立阴影矩阵的函数。其中当w＝０时表示平行光，当w＝１时表示点光源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXMATRIX *<span class="title">D3DXMatrixShadow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    D3DXMATRIX *pOut,</span></span></span><br><span class="line"><span class="function"><span class="params">    CONST D3DXVECTOR4 *pLight, <span class="comment">// L</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST D3DXPLANE *pPlane <span class="comment">// plane to cast shadow onto</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>8.3.4用模版缓存防止双倍混合<br>　　几何学上，当我们将一个物体投影到一个平面上时，很可能会有两个或者更多的投影三角形被重叠到一起。若我们就这样渲染，那么有重叠三角形的地方就会被多次混合以至这些地方将会变得更黑。图8.8就是这种情况。<br>　　<br>　　图8.8<br>　　我们能够使用模版缓存来解决这个问题。我们设置模版测试为允许像素第一次被渲染。即，当把影子像素渲染到后缓存时，我们同时在模版缓存中做好标记。然后，如果试图把像素向一个已经渲染过的地方写，那么模版测试将会失败。这样，我们就防止了重复写像素也就是防止了双倍混合的发生。<br>8.3.5代码和解释<br>　　下面的代码就是讲解影子例子。本例的相关代码都在RenderShadow函数中。注意我们假设模版缓存都已经被清除为０了。<br>　　首先设置模版渲染状态。将模版比较运算设为D3DCMP_EQUAL且将D3DRS_STENCILREF渲染状态设置为0x0，因此假如在模版缓存中相应的值为0x0，那么就指定渲染阴影到后缓存中。<br>　　因为模版缓存是被清除为0x0的，所以我们第一次将影子像素写入的时候总是正确的；不过因为我们设置D3DRS_STENCILPASS为D3DSTENCILOP_INCR,假如你试图将已经写过的像素写入的话，这个测试将会失败。在第一次写入的时候模版像素已经被写成了0x1，因此假如你再一次写入，模版测试将会失败。因此，我们避免了重复写像素，也避免了双倍混合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderShadow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, <span class="literal">true</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILREF, <span class="number">0x0</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILMASK, <span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, <span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">　　Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_INCR);</span><br><span class="line">　　下一步，我们计算阴影变换并将它放置到场景中适当的位置。</span><br><span class="line">    <span class="comment">// compute the transformation to flatten the teapot into a shadow.</span></span><br><span class="line">    <span class="function">D3DXVECTOR4 <span class="title">lightDirection</span><span class="params">(<span class="number">0.707f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">D3DXPLANE <span class="title">groundPlane</span><span class="params">(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    D3DXMATRIX S;</span><br><span class="line">    D3DXMatrixShadow(&amp;S, &amp;lightDirection, &amp;groundPlane);</span><br><span class="line">    D3DXMATRIX T;</span><br><span class="line">    D3DXMatrixTranslation(&amp;T, TeapotPosition.x, TeapotPosition.y,</span><br><span class="line">    TeapotPosition.z);</span><br><span class="line">    D3DXMATRIX W = T * S;</span><br><span class="line">     Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);</span><br></pre></td></tr></table></figure></p>
<p>　　最后，我们设置一个50%透明度的黑色材质，关闭深度测试，渲染阴影，然后开启深度缓存同时关闭alpha混合和模版测试。我们关闭深度缓存来防止z-fighting，它是当两个不同的表面在深度缓存中有同样的深度值时出现的虚拟物体；深度缓存不知道那一个是在前面，此时就会产生讨厌的闪动。因为阴影和地板是在同一个平面上，z-fighting很可能就会出现。通过先渲染地板然后用深度测试屏蔽阴影，这样我们就能够保证阴影将绘制在地面只之上。<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);<br>    Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>    D3DMATERIAL9 mtrl = d3d::InitMtrl(d3d::BLACK, d3d::BLACK,<br>    d3d::BLACK, d3d::BLACK, 0.0f);<br>    mtrl.Diffuse.a = 0.5f; // 50% transparency.<br>    // Disable depth buffer so that z-fighting doesn’t occur when we<br>    // render the shadow on top of the floor.<br>    Device-&gt;SetRenderState(D3DRS_ZENABLE, false);<br>    Device-&gt;SetMaterial(&amp;mtrl);<br>    Device-&gt;SetTexture(0, 0);<br>    Teapot-&gt;DrawSubset(0);<br>    Device-&gt;SetRenderState(D3DRS_ZENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false);<br>    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false);<br>}//end RenderShadow()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Blending/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Blending/" class="post-title-link" itemprop="url">第七章 混合(Blending)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:08:23" itemprop="dateCreated datePublished" datetime="2019-04-11T15:08:23+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="混合因素"><a href="#混合因素" class="headerlink" title="混合因素"></a>混合因素</h1><p>　　观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。<br>　　<br>　　图7.1<br>　　假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。<br>　　<br>　　图7.2<br>　　我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。<br>　　这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循：<br>　　规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。<br>　　下面的公式是用来混合两个像素值的：<br>　　<br>　　上面的所有变量都是一个4D颜色向量（r,g,b,a），并且符号是表示分量相乘。</p>
<ul>
<li>OutputPixel——混合后的像素结果。</li>
<li>SourcePixel——通常被计算的像素，它是利用在后缓存中的像素来被混合的。</li>
<li>SourceBlendFactor——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。</li>
<li>DestPixel——在后缓存中的像素。</li>
<li>DestBlendFactor——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。<br>　　源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。<br>　　混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它：<br>Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>7.2混合要素<br>　　通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效果。你能够通过设置D3DRS_SRCBLEND和D3DRS_DESTBLEND渲染状态来分别设置源混合要素和目的混合要素。例如我们可以这样写：<br>Device-&gt;SetRenderState(D3DRS_SRCBLEND, Source);<br>Device-&gt;SetRenderState(D3DRS_DESTBLEND, Destination);<br>　　这里Source和Destination能够使用下面混合要素中的一个：</li>
<li>D3DBLEND_ZERO——blendFactor=(0, 0, 0, 0)</li>
<li>D3DBLEND_ONE——blendFactor=(1, 1, 1, 1)</li>
<li>D3DBLEND_SRCCOLOR——blendFactor=(rs, gs, bs, as)</li>
<li>D3DBLEND_INVSRCCOLOR——blendFactor=(1-rs, 1-gs, 1-bs, 1-as)</li>
<li>D3DBLEND_SRCALPHA——blendFactor=(as, as, as, as)</li>
<li>D3DBLEND_INVSRCALPHA——blendFactor=(1-as, 1-as, 1-as, 1-as)</li>
<li>D3DBLEND_DESTALPHA——blendFactor=(ad, ad, ad, ad)</li>
<li>D3DBLEND_INVDESTALPHA——blendFactor=(1-ad, 1-ad, 1-ad, 1-ad)</li>
<li>D3DBLEND_DESTCOLOR——blendFactor=(rd, gd, bd, ad)</li>
<li>D3DBLEND_INVDESTCOLOR——blendFactor=(1-rd, 1-gd, 1-bd, 1-ad)</li>
<li>D3DBLEND_SRCALPHASAT——blendFactor=(f, f, f, 1)  ,  f=min(as, 1 – ad)</li>
<li>D3DBLEND_BOTHINVSRCALPHA——这种混合模式设置源混合要素为（1-as, 1-as, 1-as, 1-as,）以及目的混合要素为（as,as,as,as）。这种混合模式仅对D3DRS_SRCBLEND有效。<br>　　源和目的混合要素的默认值分别是D3DBLEND_SRCALPHA和D3DBLEND_INVSRCALPHA。<br>7.3透明度<br>  在以前的章节中我们忽略了颜色顶点和材质中的alpha部分，那是因为当时它并不是必须的。现在它首先被用在混合中。<br>  Alpha部分主要是用来指定像素的透明等级。我们为每个像素的alpha部分保留8位，alpha的有效值在[0,255]范围内，[0,255]代表不透明度[0%,100%]。因此，像素的alpha为0时，表示完全透明，像素的alpha为128时，表示50%透明，像素的alpha为255时，表示完全不透明。<br>  为了让alpha部分描述像素的透明等级，我们必须设置源混合要素为D3DBLEND_SRCALPHA以及目的混合要素为D3DBLEND_INVSRCALPHA。这些值碰巧也是被默认设置的。<br>7.3.1Alpha通道<br>　　代替使用Alpha部分来计算遮影，我们能够从纹理的alpha通道中得到alpha信息。Alpha通道是额外的设置位，用它来保存每一个点的alpha值。当一个纹理被映射到一个图元上时，在alpha通道中的alpha信息也被映射，并且它们利用alpha信息为每个像素赋予纹理。图7.3显示了一个带8位alpha通道的图片。<br>　　<br>　　图7.3<br>　　图7.4显示的是一个利用alpha通道指定透明度来渲染的一个纹理方块。<br>　　<br>　　图7.4<br>7.3.2指定Alpha资源<br>　　默认情况下，假如设置一个有alpha通道的纹理，alpha值从在alpha通道中获得。假如没有alpha通道，那么alpha值是通过顶点颜色获得。然而，你能够通过下面的渲染状态来指定使用哪一个资源：<br>// compute alpha from diffuse colors during shading<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);<br>// take alpha from alpha channel<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);<br>7.4使用DirectX纹理工具创建Alpha通道<br>  绝大多数普通图象文件格式没有存储alpha信息。在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile被读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下（我是放在C:\Program Files\Microsoft DirectX 9.0 SDK (February 2005)\Utilities\Bin\x86下的，文件名是DxTex.exe）。<br>  打开DirectX纹理工具，并且把本章中示例文件夹下的crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。</li>
</ul>
<p>图7.5<br>    它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。</p>
<p>图7.6<br>    现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。<br>7.5实例程序：透明度<br>    这个实例程序是在一个木箱背景上绘制一个透明的茶壶，就象图7.2所显示的一样。在这个例子中alpha值是从材质中得到。应用程序允许我们通过按A或S键来增加/减少alpha的值。<br>    使用混合的必要步骤是：</p>
<ol>
<li>设置混合要素D3DRS_SRCBLEND 和 D3DRS_DESTBLEND。</li>
<li>假如你使用alpha部分，指定资源（材质或alpha通道）。</li>
<li>允许alpha混合渲染状态。<br>　　对于这个例子，我们定义下面的全局变量：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ID3DXMesh* Teapot = <span class="number">0</span>; <span class="comment">// the teapot</span></span><br><span class="line">D3DMATERIAL9 TeapotMtrl; <span class="comment">// the teapot’s material</span></span><br><span class="line"></span><br><span class="line">IDirect3DVertexBuffer9* BkGndQuad = <span class="number">0</span>; <span class="comment">// background quad - crate</span></span><br><span class="line">IDirect3DTexture9* BkGndTex = <span class="number">0</span>; <span class="comment">// crate texture</span></span><br><span class="line">D3DMATERIAL9 BkGndMtrl; <span class="comment">// background material</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Setup方法设置很多东西；我们省略了很多与本章无关的代码。关心混合，Setup方法指定alpha值的获取资源。在这个例子中，我们通过材质指定alpha值。注意我们设置茶壶的材质alpha部分为0.5，也就是说茶壶将按照50%的透明度被渲染。我们在这里也要设置混合要素。要注意的是在这个方法中我们不能将alpha混合设置为启用。理由是alpha混合要进行额外的处理并且应该仅在需要用时才被使用。举例，在这个例子中只有茶壶需要用允许alpha混合来被渲染——而方块不需要。因此，我们在Display函数中启用alpha混合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TeapotMtrl = d3d::RED_MTRL;</span><br><span class="line">    TeapotMtrl.Diffuse.a = <span class="number">0.5f</span>; <span class="comment">// set alpha to 50% opacity</span></span><br><span class="line">    BkGndMtrl = d3d::WHITE_MTRL;</span><br><span class="line"></span><br><span class="line">    D3DXCreateTeapot(Device, &amp;Teapot, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">// Create background quad snipped    </span></span><br><span class="line">    ...<span class="comment">// Light and texture setup snipped</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use alpha in material's diffuse component for alpha</span></span><br><span class="line">    Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);</span><br><span class="line">    Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);</span><br><span class="line">    <span class="comment">// set blending factors so that alpha</span></span><br><span class="line">    <span class="comment">// component determines transparency</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">// view/projection matrix setup snipped</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Display函数中，我们检测假如A或S键被按下那么就通过增加或减少材质的alpha值来反馈。注意这个方法要保证alpha值不会超出[0,1]的范围。我们然后渲染背景。最后，我们启用alpha混合，利用alpha混合来渲染茶壶，关闭alpha混合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// increase/decrease alpha via keyboard input</span></span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'A'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TeapotMtrl.Diffuse.a += <span class="number">0.01f</span>;</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'S'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TeapotMtrl.Diffuse.a -= <span class="number">0.01f</span>;</span><br><span class="line">        <span class="comment">// force alpha to [0, 1] interval</span></span><br><span class="line">        <span class="keyword">if</span>(TeapotMtrl.Diffuse.a &gt; <span class="number">1.0f</span>)</span><br><span class="line">            TeapotMtrl.Diffuse.a = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">if</span>(TeapotMtrl.Diffuse.a &lt; <span class="number">0.0f</span>)</span><br><span class="line">            TeapotMtrl.Diffuse.a = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Render</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,</span><br><span class="line">                        <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw the background</span></span><br><span class="line">        D3DXMATRIX W;</span><br><span class="line">        D3DXMatrixIdentity(&amp;W);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);</span><br><span class="line">        Device-&gt;SetFVF(Vertex::FVF);</span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, BkGndQuad, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        Device-&gt;SetMaterial(&amp;BkGndMtrl);</span><br><span class="line">        Device-&gt;SetTexture(<span class="number">0</span>, BkGndTex);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw the teapot</span></span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, <span class="literal">true</span>);</span><br><span class="line">        D3DXMatrixScaling(&amp;W, <span class="number">1.5f</span>, <span class="number">1.5f</span>, <span class="number">1.5f</span>);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);</span><br><span class="line">        Device-&gt;SetMaterial(&amp;TeapotMtrl);</span><br><span class="line">        Device-&gt;SetTexture(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Teapot-&gt;DrawSubset(<span class="number">0</span>);</span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, <span class="literal">false</span>);</span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：在本章中有另一个使用纹理通道来演示alpha混合的例子texAlpha。与上边的代码不同之处仅仅在于得到alpha值是从纹理而不是从材质。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use alpha channel in texture for alpha</span></span><br><span class="line">Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);</span><br><span class="line">Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);</span><br></pre></td></tr></table></figure></p>
<p>这个应用程序读取的是一个在7.4节中用DX Tex Tool工具创建的带有alpha通道的DDS文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Texturing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Texturing/" class="post-title-link" itemprop="url">第六章 纹理(Texturing)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:06:54" itemprop="dateCreated datePublished" datetime="2019-04-11T15:06:54+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做texel。注意v轴是向下的（如图6.2）。<br>　　<br>　　图6.2<br>同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。<br>对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。<br>　　<br>　　图6.3<br>　　  我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。<br>struct Vertex<br>{<br>    float _x, _y, _z;<br>    float _nx, _ny, _nz;<br>    float _u, _v; // texture coordinates<br>    static const DWORD FVF;<br>};<br>const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;<br>　　我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。<br>　　现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。<br>6.2创建并赋予材质<br>　　纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作：<br>HRESULT D3DXCreateTextureFromFile(<br>    LPDIRECT3DDEVICE9 pDevice, // device to create the texture<br>    LPCSTR pSrcFile, // filename of image to load<br>    LPDIRECT3DTEXTURE9<em> ppTexture // ptr to receive the created texture<br>);<br>这个函数能够读取下面图片格式中的任意一种：BMP,DDS,DIB,JPG,PNG,TGA。<br>　　例如，用一个名为stonewall.bmp的图片创建一个纹理，我们将按照下面的例子来写：<br>IDirect3Dtexture9</em> _stonewall;<br>D3DXCreateTextureFromFile(_device, “stonewall.bmp”, &amp;_stonewall);<br>　　设置当前纹理，我们使用下面的方法：<br>HRESULT IDirect3DDevice9::SetTexture(<br>    DWORD Stage, // A value in the range 0-7 identifying the texture<br>                // stage – see note on Texture Stages<br>    IDirect3DBaseTexture9* pTexture // ptr to the texture to set<br>);<br>　　例子：<br>Device-&gt;SetTexture(0, _stonewall);<br>注意：在Direct3D中，你能够设置八个纹理，它们能够组合起来创建更多细节的图象。这又被叫做多重纹理。在本书的第四部分以前我们不会使用多重纹理；因此现在我们总是设置stage为0。<br>　　为了销毁一个纹理，我们设置pTexture为0。例如，假如不想用一个纹理来渲染物体，那么我们就这样写：<br>Device-&gt;SetTexture(0, 0);<br>renderObjectWithoutTexture();<br>假如场景中有使用不同纹理的三角形，我们就必须添加与下面类似的一些代码：<br>Device-&gt;SetTexture(0, _tex0);<br>drawTrisUsingTex0();</p>
<p>Device-&gt;SetTexture(0, _tex1);<br>drawTrisUsingTex1();<br>6.3过滤器<br>    就象以前提及的，纹理被映射到屏幕中的三角形上。通常纹理三角形和屏幕三角形是不一样大的。当纹理三角形比屏幕三角形小时，纹理三角形会被适当放大。当纹理三角形比屏幕三角形大时，纹理三角形会被适当缩小。这两种情况，变形都将会出现。过滤（Filtering）是一种Direct3D用它来帮助这些变形变的平滑的技术。<br>    Direct3D提供了三种不同的过滤器；每种都提供了一个不同的品质级别。越好的品质越慢，因此你必须在品质与速度之间取得一个平衡。纹理过滤器是用IDirect3DDevice9::SetSamplerState方法来设置的。</p>
<ul>
<li>Nearest point sampling——这是默认的过滤方法且返回最差的效果，但是它的计算是最快的。下面的代码就是设置Nearest point sampling作为缩小放大的过滤器：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);</li>
<li>Linear filtering——这种过滤产生还算比较好的效果，在今天的硬件上处理它还是非常快的。它是被推荐使用的。下面的代码就是设置Linear filtering作为缩小放大的过滤器。<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</li>
<li>Anisotropic filtering——这种过滤产生最好的效果，但是处理时间也是最长的。下面的代码就是设置Anisotropic filtering作为缩小放大的过滤器。<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_ANISOTROPIC);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_ANISOTROPIC);<br>当使用Anisotropic filtering时，我们必须设置D3DSAMP_MAXANISOTROPY等级，它决定处理的质量。该值越高处理的效果越好。检查D3DCAPS9结构确认你的显卡是否支持此功能。下面的代码设置该值为4：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAXANISOTROPY, 4);<br>6.4 Mipmaps<br>　　就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建mipmaps链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。<br>　　<br>　　图6.4<br>6.4.1 Mipmaps过滤器<br>  mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, Filter);<br>在Filter处你能用下面三个选项中的一个：</li>
<li>D3DTEXF_NONE——不使用mipmap。</li>
<li>D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。</li>
<li>D3DTEXF_LINEAR——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。<br>6.4.2 Direct3D中使用Mipmaps<br>  在Direct3D中使用Mipmaps是很简单的。假如你的显卡支持Mipmaps，那么使用D3DXCreateTextureFromFile将为你产生一个Mipmap链。Direct3D自动选择与屏幕三角形最匹配的Mipmap。因此Mipmap有非常广泛的应用，且它能被自动设置。<br>6.5 寻址模式<br>  以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。</li>
</ul>
<p>图6.5（环绕）                          图6.6（边框）</p>
<p>图6.7（截取）                          图6.8（镜像）<br>在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标因该设置为（0,0）（0,5）（5,0）（5,5）。<br>    下面的代码片段列举的是怎样设置这四种寻址模式：<br>// set wrap address mode<br>if( ::GetAsyncKeyState(‘W’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);<br>}<br>// set border color address mode<br>if( ::GetAsyncKeyState(‘B’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0x000000ff);<br>}<br>// set clamp address mode<br>if( ::GetAsyncKeyState(‘C’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);<br>}<br>// set mirror address mode<br>if( ::GetAsyncKeyState(‘M’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);<br>}<br>6.6实例程序：有纹理的方块<br>    这个例子是怎样为方块加上纹理以及设置一个纹理过滤器（如图6.9）。假如你的显卡支持，通过D3DXCreateTextureFromFile函数一个mipmap链将被自动创建。</p>
<p>图6.9<br>注意：还提供了其他两个例子大家就自己看看了。<br>为一个场景增加纹理的必要步骤是：</p>
<ol>
<li>用纹理坐标指定的，创建物体的顶点。</li>
<li>用D3DXCreateTextureFromFile函数读取一个纹理到IDirect3DTexture9接口中。</li>
<li>设置缩小倍数，放大倍数以及mipmap过滤器。</li>
<li>在你绘制一个物体前，用IDirect3DDevice9::SetTexture设置与物体关联的纹理。<br>我们先定义几个全局变量；一个是顶点缓存，它存储方块的顶点。另外一个是我们为方块映射的纹理：<br>IDirect3DVertexBuffer9<em> Quad = 0;<br>IDirect3DTexture9</em>      Tex  = 0;<br>Setup程序是很容易读懂的；我们用已经定义了纹理坐标的两个三角形创建一个方块。然后把文件dx5_logo.bmp读进IDirect3DTexture9接口中。接着使用SetTexture方法赋予纹理。最后设置缩小和放大过滤器进行线性过滤，我们也可以设置mipmap过滤器来进行D3DTEXF_POINT: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create the quad vertex buffer and fill it with the</span></span><br><span class="line">    <span class="comment">// quad geoemtry.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">        <span class="number">6</span> * <span class="keyword">sizeof</span>(Vertex), </span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        Vertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;Quad,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Vertex* v;</span><br><span class="line">    Quad-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// quad built from two triangles, note texture coordinates:</span></span><br><span class="line">    v[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">1</span>] = Vertex(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">2</span>] = Vertex( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">3</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">4</span>] = Vertex( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">5</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    Quad-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create the texture and set filters.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    D3DXCreateTextureFromFile(</span><br><span class="line">        Device,</span><br><span class="line">        <span class="string">"dx5_logo.bmp"</span>,</span><br><span class="line">        &amp;Tex);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetTexture(<span class="number">0</span>, Tex);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">    Device-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">    Device-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MIPFILTER, D3DTEXF_POINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Don't use lighting for this sample.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_LIGHTING, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set the projection matrix.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    D3DXMATRIX proj;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(</span><br><span class="line">            &amp;proj,</span><br><span class="line">            D3DX_PI * <span class="number">0.5f</span>, <span class="comment">// 90 - degree</span></span><br><span class="line">            (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height,</span><br><span class="line">            <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1000.0f</span>);</span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们现在可以渲染方块了，且通常已经为它赋予了纹理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, Quad, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        Device-&gt;SetFVF(Vertex::FVF);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Lighting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Lighting/" class="post-title-link" itemprop="url">第五章 灯光(Lighting)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:03:36" itemprop="dateCreated datePublished" datetime="2019-04-11T15:03:36+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="灯光的组成"><a href="#灯光的组成" class="headerlink" title="灯光的组成"></a>灯光的组成</h1><p>在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。</p>
<ul>
<li>环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。</li>
<li>漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的姿态。这种灯光将成为你的资源中照射的普通灯光。</li>
<li>镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面姿态，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。<br>　　镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;SetRenderState(D3DRS_SPECULARENABLE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXCOLOR <span class="title">redAmbient</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXCOLOR <span class="title">blueDiffuse</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXCOLOR <span class="title">whiteSpecular</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意：在D3DXCOLOR类中的alpha值用在描述灯光颜色时是被忽略的。</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>在现实世界中我们看到的物体颜色将由物体反射回来的灯光颜色来决定。比如，一个红色的球是红色的，因为它吸收所有的灯光颜色除了红色光。红色光是被球反射回来进入我们眼睛的，因此我们看到的球是红色的。Direct3D通过我们定义的物体材质来模拟这些所有的现象。材质允许我们定义表面反射灯光的百分比。在代码中通过D3DMATERIAL9结构描述一个材质。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">D3DMATERIAL9</span> &#123;</span></span><br><span class="line">    D3DCOLORVALUE Diffuse, Ambient, Specular, Emissive;</span><br><span class="line">    <span class="keyword">float</span> Power;</span><br><span class="line">&#125; D3DMATERIAL9;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Diffuse——指定此表面反射的漫射光数量。</li>
<li>Ambient——指定此表面反射的环境光数量。</li>
<li>Specular——指定此表面反射的镜面光数量</li>
<li>Emissive——这个是被用来给表面添加颜色，它使得物体看起来就象是它自己发出的光一样。</li>
<li>Power——指定锐利的镜面高光；它的值是高光的锐利值。<br>　　举例，想得到一个红色的球。我们将定义球的材质来只反射红光吸收其他颜色的所有光：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D3DMATERIAL9 red;</span><br><span class="line">::ZeroMemory(&amp;red, <span class="keyword">sizeof</span>(red));</span><br><span class="line">red.Diffuse = D3DXCOLOR(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// red</span></span><br><span class="line">red.Ambient = D3DXCOLOR(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// red</span></span><br><span class="line">red.Specular = D3DXCOLOR(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// red</span></span><br><span class="line">red.Emissive = D3DXCOLOR(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// no emission</span></span><br><span class="line">red.Power = <span class="number">5.0f</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　这里我们设置绿色和蓝色的值为0，这表明材质反射0%此颜色的光。我们设置红色为1，表示材质反射100%的红光。注意，我们能够控制每种灯光反射的颜色（环境、漫射和镜面光）。<br>　　同样假如我们定义一个只发出蓝色光的光源，对球的光照将失败因为蓝色光将被全部吸收而没有红光被反射。当物体吸收了所有光以后，物体看起来就为黑色。同样的，当物体反射100%的红、绿和蓝光，物体就将呈现为白色。<br>　　因为手工填充一个材质结构将是乏味的工作，我们添加下列有用的函数和全局材质常数到d3dUtility.h/cpp文件中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">D3DMATERIAL9 d3d::InitMtrl(D3DXCOLOR a, D3DXCOLOR d,</span><br><span class="line">D3DXCOLOR s, D3DXCOLOR e, <span class="keyword">float</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    D3DMATERIAL9 mtrl;</span><br><span class="line">    mtrl.Ambient = a;</span><br><span class="line">    mtrl.Diffuse = d;</span><br><span class="line">    mtrl.Specular = s;</span><br><span class="line">    mtrl.Emissive = e;</span><br><span class="line">    mtrl.Power = p;</span><br><span class="line">    <span class="keyword">return</span> mtrl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> d3d</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">D3DMATERIAL9 <span class="title">InitMtrl</span><span class="params">(D3DXCOLOR a, D3DXCOLOR d, D3DXCOLOR s, D3DXCOLOR e, <span class="keyword">float</span> p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 WHITE_MTRL = InitMtrl(WHITE, WHITE, WHITE, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 RED_MTRL = InitMtrl(RED, RED, RED, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 GREEN_MTRL = InitMtrl(GREEN, GREEN, GREEN, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 BLUE_MTRL = InitMtrl(BLUE, BLUE, BLUE, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 YELLOW_MTRL = InitMtrl(YELLOW, YELLOW, YELLOW, BLACK, <span class="number">8.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>顶点结构没有材质属性；一个通用的材质必须被设置。设置它我们使用IDirect3DDevice9::SetMaterial(CONST D3DMATERIAL9 * pMaterial)方法。<br>假设我们想渲染几个不同材质的物体；我们将按照如下的写法去做：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D3DMATERIAL9 blueMaterial, redMaterial;</span><br><span class="line"><span class="comment">// set up material structures</span></span><br><span class="line"></span><br><span class="line">Device-&gt;SetMaterial(&amp;blueMaterial);</span><br><span class="line">drawSphere(); <span class="comment">// blue sphere</span></span><br><span class="line"></span><br><span class="line">Device-&gt;SetMaterial(&amp;redMaterial);</span><br><span class="line">drawSphere(); <span class="comment">// red sphere</span></span><br></pre></td></tr></table></figure></p>
<h1 id="顶点法线"><a href="#顶点法线" class="headerlink" title="顶点法线"></a>顶点法线</h1><pre><code>面法线（face normal）是描述多边形表面方向的一个向量（如图5.1）。
</code></pre><p>图5.1<br>　　顶点法线（Vertex normals）也是基于同样的概念，但是我们与其指定每个多边形的法线，还不如为每个顶点指定（如图5.2）。<br>　　<br>　　图5.2<br>　　Direct3D需要知道顶点法线以便它能够确定灯光照射到物体表面的角度，并且一旦计算了每个顶点的灯光，Direct3D需要知道每个顶点的表面方向。注意顶点法线不一定和面法线相同。球体/环形物就是很好的实物例子，它们的顶点法线和三角形法线是不相同的（如图5.3）。<br>　　<br>　　图5.3<br>为了描述顶点的顶点法线，我们必须更新原来的顶点结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">    <span class="keyword">float</span> _nx, _ny, _nz;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们已经将上一章中使用的颜色成分去除了。这是因为我们将使用灯光来计算顶点的颜色。<br>　　作为一个简单的物体比如立方体和球体，我们能够通过观察看见顶点法线。对于更多复杂的网格，我们需要一个更多的机械方法。假设一个由p0,p1,p2构成的三角形，我们需要计算每个顶点的法线n0,n1,n2。<br>　　简单的步骤，我们列举它是为了找到由三个点构成的三角形的面法线，同时使用面法线作为顶点法线。首先计算三角形上的两个向量：<br>　　<br>　　那么面法线是：<br>　　<br>　　每个顶点的法线和面法线是相等的：<br>　　<br>　　下面是一个C函数，它通过三角形的三个顶点计算三角形的面法线。注意这个函数的三个顶点是按照顺时针方向指定的。假如不是这样，那么法线方向将是相反的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeNormal</span><span class="params">(D3DXVECTOR3* p0,</span></span></span><br><span class="line"><span class="function"><span class="params">                D3DXVECTOR3* p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                D3DXVECTOR3* p2,</span></span></span><br><span class="line"><span class="function"><span class="params">                D3DXVECTOR3* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D3DXVECTOR3 u = *p1 - *p0;</span><br><span class="line">    D3DXVECTOR3 v = *p2 - *p0;</span><br><span class="line">    D3DXVec3Cross(out, &amp;u, &amp;v);</span><br><span class="line">    D3DXVec3Normalize(out, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用三角形近似表示曲面时，使用面法线作为顶点法线不能表现一个平滑的结果。一个更好的方法是找到顶点法线的平均法线。为了找到顶点v的顶点法线vn，我们找到网格模型中所有三角形的面法线记为顶点v。vn是通过计算他们的平均面法线得到的。这里有一个例子，假设有3个三角形它们的面法线分别是n0，n1，n2，指定为顶点v。那么vn的平均法线就是：<br>　　<br>通过改变“舞台”，把顶点法线变为non-normal,这是有可能的。因此这样最好是安全的且在通过D3DRS_NORMALIZENORMALS设置渲染状态来改变“舞台”后，Direct3D从新规格化所有法线。<br>Device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, true);<br>5.4光源<br>　　Direct3D支持三种类型的光源。</p>
<ul>
<li>点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。</li>
</ul>
<p>图5.4</p>
<ul>
<li>方向光源——这种光源没有位置但是向指定方向发出平行光线。</li>
</ul>
<p>图5.5</p>
<ul>
<li>聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。</li>
</ul>
<p>图5.6<br>　　在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。<br>typedef struct _D3DLIGHT9 {<br>    D3DLIGHTTYPE Type;<br>    D3DCOLORVALUE Diffuse;<br>    D3DCOLORVALUE Specular;<br>    D3DCOLORVALUE Ambient;<br>    D3DVECTOR Position;<br>    D3DVECTOR Direction;<br>    float Range;<br>    float Falloff;<br>    float Attenuation0;<br>    float Attenuation1;<br>    float Attenuation2;<br>    float Theta;<br>    float Phi;<br>} D3DLIGHT9;</p>
<ul>
<li>Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL</li>
<li>Diffuse——此光源发出的漫射光颜色。</li>
<li>Specular——此光源发出的镜面光颜色。</li>
<li>Ambient——此光源发出的环境光颜色。</li>
<li>Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。</li>
<li>Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。</li>
<li>Range——灯光能够传播的最大范围。这个值不能比大。且不能用于方向光源。</li>
<li>Falloff——这个值只能用在聚光灯上。它定义灯光在从内圆锥到外圆锥之间的强度衰减。它的值通常设置为1.0f。</li>
<li><p>Attenuation0, Attenuation1, Attenuation2——这些衰减变量被用来定义灯光强度的传播距离衰减。它们只被用于点光源和聚光灯上。Attenuation0定义恒定衰减，Attenuation1定义线性衰减，Attenuation2定义二次衰减。适当的使用这个公式，D是代表到光源的距离，A0,A1,A2与Attenuation0，1，2相匹配。</p>
</li>
<li><p>Theta——只用于聚光灯；指定内圆锥的角度，单位是弧度。</p>
</li>
<li><p>Phi——只用于聚光灯；指定外圆锥的角度，单位是弧度。<br>　　就象初始化D3DMATERIAL9结构一样，初始化D3DLIGHT9结构是一件单调乏味的工作。我们添加下面的函数到d3dUtility.h/cpp文件中用于初始化简单灯光。<br>namespace d3d<br>{<br>  … …<br>  D3DLIGHT9 InitDirectionalLight(D3DXVECTOR3<em> direction, D3DXCOLOR</em> color);</p>
<p>  D3DLIGHT9 InitPointLight(D3DXVECTOR3<em> position, D3DXCOLOR</em> color);</p>
<p>  D3DLIGHT9 InitSpotLight(D3DXVECTOR3<em> position, D3DXVECTOR3</em> direction, D3DXCOLOR<em> color);<br>}<br>　　使用这些函数是非常简单的。我们现在只是演示怎样使用InitDirectionalLight。其他的也很类似：<br>D3DLIGHT9 d3d::InitDirectionalLight(D3DXVECTOR3</em> direction, D3DXCOLOR<em> color)<br>{<br>  D3DLIGHT9 light;<br>  ::ZeroMemory(&amp;light, sizeof(light));<br>  light.Type = D3DLIGHT_DIRECTIONAL;<br>  light.Ambient = </em>color <em> 0.4f;<br>  light.Diffuse = </em>color;<br>  light.Specular = <em>color </em> 0.6f;<br>  light.Direction = *direction;<br>  return light;<br>}<br>　　然后创建一个方向光源，它沿着x轴正方向照射白色灯光。我们按照下面的方法来做：<br>D3DXVECTOR3 dir(1.0f, 0.0f, 0.0f);<br>D3DXCOLOR c = d3d::WHITE;<br>D3DLIGHT9 dirLight = d3d::InitDirectionalLight(&amp;dir, &amp;c);<br>　　在把D3DLIGHT9初始化好以后，我们需要用Direct3D内在支持的灯光来注册。就象这样做：<br>Device-&gt;SetLight(<br>  0, // element in the light list to set, range is 0-maxlights<br>  &amp;light);// address of the D3DLIGHT9 structure to set<br>　　一旦灯光注册了，我们就能使用下面的列举的例子来开或关灯光了：<br>Device-&gt;LightEnable(<br>  0, // the element in the light list to enable/disable<br>  true); // true = enable, false = disable<br>5.5实例程序：灯光<br>  这一章的例子是创建如图5.7所显示的场景。它示范了怎样指定顶点法线，怎样创建材质，以及怎样创建和使用一个方向灯光。注意在这个示例程序中我们不会使用在文件d3dUtility.h/cpp中的材质和灯光函数。因为我们想展示怎样手动来做这些设置。</p>
</li>
</ul>
<p>图5.7<br>    给场景增加灯光的步骤是：<br>1、 允许使用灯光。<br>2、 为每个物体创建材质并且在渲染相应物体前应将材质附予物体。<br>3、 创建一个或多个光源，设置它们，把它们设为可用。<br>4、 将其他附加光源设为可用，比如镜面高光。<br>　　首先我们初始化一个全局顶点缓存用他来存储“金字塔”的顶点：<br>IDirect3DVertexBuffer9* Pyramid = 0;<br>　　Setup函数包含本章的所有代码，因此我们忽略其他函数。它执行刚才讨论的步骤来给场景加入灯光。Setup方法首先允许使用灯光，当然这不是必须的因为默认设置就是允许使用灯光的。<br>bool Setup()<br>{<br>    Device-&gt;SetRenderState(D3DRS_LIGHTING, true);<br>　　下一步，我们创建顶点缓存，锁定，并且把“金字塔”的三角形顶点放入其中。顶点法线是利用5.3节中的运算法则预先计算好的。注意三角形共享顶点，但它们的法线不能共享；因此对这个物体使用索引列表并不是最有利的。例如，所有三角形都共享顶点（0,1,0）；然而，对每个三角形，它们的顶点法线是不相同的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;CreateVertexBuffer(</span><br><span class="line">            <span class="number">12</span> * <span class="keyword">sizeof</span>(Vertex),</span><br><span class="line">            D3DUSAGE_WRITEONLY,</span><br><span class="line">            Vertex::FVF,</span><br><span class="line">            D3DPOOL_MANAGED,</span><br><span class="line">            &amp;Pyramid,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"><span class="comment">// fill the vertex buffer with pyramid data</span></span><br><span class="line">Vertex* v;</span><br><span class="line">Pyramid-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// front face</span></span><br><span class="line">v[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">-0.707f</span>);</span><br><span class="line">v[<span class="number">1</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">-0.707f</span>);</span><br><span class="line">v[<span class="number">2</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">-0.707f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// left face</span></span><br><span class="line">v[<span class="number">3</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">4</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">5</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// right face</span></span><br><span class="line">v[<span class="number">6</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">7</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">8</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// back face</span></span><br><span class="line">v[<span class="number">9</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>);</span><br><span class="line">v[<span class="number">10</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>);</span><br><span class="line">v[<span class="number">11</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>);</span><br><span class="line"></span><br><span class="line">Pyramid-&gt;Unlock();</span><br></pre></td></tr></table></figure></p>
<p>　　为物体产生了顶点数据以后，我们描述利用灯光表现各自材质的物体间是怎样相互影响的。在这个例子中，“金字塔”反射出白光，自身不发光，且会产生一些高光。<br>D3DMATERIAL9 mtrl;<br>mtrl.Ambient = d3d::WHITE;<br>mtrl.Diffuse = d3d::WHITE;<br>mtrl.Specular = d3d::WHITE;<br>mtrl.Emissive = d3d::BLACK;<br>mtrl.Power = 5.0f;<br>Device-&gt;SetMaterial(&amp;mtrl);<br>　　接着，我们创建一个方向光并将其设为可用。方向光是沿着x轴的正方向照射的。灯光照射最强的白色漫射光（dir.Diffuse = WHITE），较弱的白色镜面光（dir.Specular = WHITE <em> 0.3f）以及一个中等强度的白色环境光（dir.Ambient = WHITE </em>0.6f）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">D3DLIGHT9 dir;</span><br><span class="line">::ZeroMemory(&amp;dir, <span class="keyword">sizeof</span>(dir));</span><br><span class="line">dir.Type = D3DLIGHT_DIRECTIONAL;</span><br><span class="line">dir.Diffuse = d3d::WHITE;</span><br><span class="line">dir.Specular = d3d::WHITE * <span class="number">0.3f</span>;</span><br><span class="line">dir.Ambient = d3d::WHITE * <span class="number">0.6f</span>;</span><br><span class="line">dir.Direction = D3DXVECTOR3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">Device-&gt;SetLight(<span class="number">0</span>, &amp;dir);</span><br><span class="line">Device-&gt;LightEnable(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//最后，我们设置状态使法线从新规格化且把镜面高光设置为可用。</span></span><br><span class="line">Device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, <span class="literal">true</span>);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_SPECULARENABLE, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// ... code to set up the view matrix and projection matrix</span></span><br><span class="line"><span class="comment">// omitted</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>5.6附加实例<br>　　这一章中还有三个附加的例子。它们使用D3DXCreate<em>函数来创建组成场景的3D物体。D3DXCreate</em>函数创建的顶点数据是D3DFVF_XYZ | D3DFVF_NORMAL格式。在增加的函数中为我们的网格模型的每个顶点计算了顶点法线。这些实例演示了怎样使用方向光，点光源，以及聚光灯。图5.8显示的是方向光实例中的一个场景图。<br>　　<br>　　图5.8</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/color/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/color/" class="post-title-link" itemprop="url">色彩(Color)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:00:51" itemprop="dateCreated datePublished" datetime="2019-04-11T15:00:51+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="颜色表示法"><a href="#颜色表示法" class="headerlink" title="颜色表示法"></a>颜色表示法</h1><p>　　在Direct3D中，颜色是使用RGB三部分来描述的。也就是说，我们要分别指定红、绿和蓝三种颜色的值。混合这三个颜色决定最终的颜色。利用这三种颜色我们能够表现数万种颜色。<br>　　我们使用两种不同的结构来存储RGB数据。这第一种是D3DCOLOR，它实际上一个DWORD即32位。在D3DCOLOR类型中的这些位按照8-bit被分为4个部分，每一部分存储的是该色的亮度值。如图4.1所示。<br>　　<br>　　图4.1<br>　　每种颜色占用内存的一个字节，各颜色亮度值的取值范围是0-255。这个值越接近0就越暗，越接近255就越亮。<br>注意：现在不要管alpha部分；它被用在alpha混合中——在第7章中会讲解。<br>　　指定其中的每一部分并且把它放到D3DCOLOR中适当的位置需要使用到一些位操作。Direct3D为我们提供了一个完成这个任务的宏D3DCOLOR_ARGB.它使用包含每种颜色以及alpha位一共4个参数。每一个参数的取值必须在0-255之间，如：<br>D3DCOLOR brightRed = D3DCOLOR_ARGB(255, 255, 0, 0);<br>D3DCOLOR someColor = D3DCOLOR_ARGB(255, 144, 87, 201);<br>    另外，我们也能使用D3DCOLOR_XRGB宏，它与刚才的宏类似只不过不必指定alpha部分；不过我们最好还是把alpha指定为0xff（255）。</p>
<h1 id="define-D3DCOLOR-XRGB-r-g-b-D3DCOLOR-ARGB-0xff-r-g-b"><a href="#define-D3DCOLOR-XRGB-r-g-b-D3DCOLOR-ARGB-0xff-r-g-b" class="headerlink" title="define D3DCOLOR_XRGB(r,g,b) D3DCOLOR_ARGB(0xff,r,g,b)"></a>define D3DCOLOR_XRGB(r,g,b) D3DCOLOR_ARGB(0xff,r,g,b)</h1><p>　　在Direct3D中另外一种存储颜色的结构是D3DCOLORVALUE。在这个结构中，我们分别使用一个浮点数来表示每一部分的亮度值。其取值范围是0-1，0表示没有亮度，1表示最大亮度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">D3DCOLORVALUE</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> r; <span class="comment">// the red component, range 0.0-1.0</span></span><br><span class="line">    <span class="keyword">float</span> g; <span class="comment">// the green component, range 0.0-1.0</span></span><br><span class="line">    <span class="keyword">float</span> b; <span class="comment">// the blue component, range 0.0-1.0</span></span><br><span class="line">    <span class="keyword">float</span> a; <span class="comment">// the alpha component, range 0.0-1.0</span></span><br><span class="line">&#125; D3DCOLORVALUE;</span><br></pre></td></tr></table></figure></p>
<p>　　另外，我们能够使用D3DXCOLOR结构，就象D3DCOLORVALUE包含同样的数据成员一样。同时提供有用的构造函数和重载操作符，这将让颜色处理更容易。D3DXCOLOR的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3DXCOLOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        D3DXCOLOR() &#123;&#125;</span><br><span class="line">        D3DXCOLOR( DWORD argb );</span><br><span class="line">        D3DXCOLOR( CONST FLOAT * );</span><br><span class="line">        D3DXCOLOR( CONST D3DXFLOAT16 * );</span><br><span class="line">        D3DXCOLOR( CONST D3DCOLORVALUE&amp; );</span><br><span class="line">        D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// casting</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">DWORD</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">operator</span> FLOAT* ();</span><br><span class="line">        <span class="keyword">operator</span> CONST FLOAT* () <span class="keyword">const</span>;</span><br><span class="line">        <span class="keyword">operator</span> D3DCOLORVALUE* ();</span><br><span class="line">        <span class="keyword">operator</span> CONST D3DCOLORVALUE* () <span class="keyword">const</span>;</span><br><span class="line">        <span class="keyword">operator</span> D3DCOLORVALUE&amp; ();</span><br><span class="line">        <span class="keyword">operator</span> CONST D3DCOLORVALUE&amp; () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assignment operators</span></span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> += ( CONST D3DXCOLOR&amp; );</span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> -= ( CONST D3DXCOLOR&amp; );</span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> *= ( FLOAT );</span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> /= ( FLOAT );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unary operators</span></span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> + () <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> - () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binary operators</span></span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> + ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> - ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> * ( FLOAT ) <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> / ( FLOAT ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> D3DXCOLOR <span class="keyword">operator</span> * (FLOAT, CONST D3DXCOLOR&amp; );</span><br><span class="line"></span><br><span class="line">        BOOL <span class="keyword">operator</span> == ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">        BOOL <span class="keyword">operator</span> != ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__cplusplus</span></span></span><br><span class="line">    FLOAT r, g, b, a;</span><br><span class="line">&#125; D3DXCOLOR, *LPD3DXCOLOR;</span><br></pre></td></tr></table></figure></p>
<p>注意：D3DCOLORVALUE和D3DXCOLOR结构都有4个浮点数成员。这使我们的颜色处理符号能象4D向量一样。颜色向量能被加，减以及缩放。另一方面点积和叉积不能用于颜色向量，但是颜色成员相乘是可以的。因此在D3DXCOLOR类中执行的乘法就是成员相乘。它的定义如下：</p>
<p>现在使用下面全局颜色常量更新我们的d3dUtility.h文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> d3d</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">WHITE</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">BLACK</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">RED</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">GREEN</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">BLUE</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">YELLOW</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">CYAN</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">MAGENTA</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顶点颜色"><a href="#顶点颜色" class="headerlink" title="顶点颜色"></a>顶点颜色</h1><p>图元的颜色是由构成它的顶点的颜色决定的。因此，我们必须把一个颜色成员加入到我们的顶点数据结构中。注意D3DCOLORVALUE类型不能用在这里，因为Direct3D希望用一个32位的值来描述顶点的颜色。（通过使用顶点着色器我们能为顶点颜色使用4D颜色向量，它能提供一个128位的颜色，但是对于我们现在的水平来说那太超前了。顶点着色器将在17章中介绍。）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColorVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">    D3DCOLOR _color;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>const DWORD ColorVertex::FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;</p>
<h1 id="着色处理"><a href="#着色处理" class="headerlink" title="着色处理"></a>着色处理</h1><p>着色处理发生在光栅化和指定图元上的顶点颜色怎样被计算成像素颜色之间。目前这里有2种着色处理模式可用：平面着色（flat shading）和高洛德着色（Gouraud shading）。<br>平面着色，图元像素的颜色是均匀的，且就是指定图元第一个顶点的颜色。因此一旦三角形的第一个顶点被指定成红色，那么它的其他三个顶点也将会是红色。通过使用平面着色来为第二和第三个顶点着色。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ColorVertex t[<span class="number">3</span>];</span><br><span class="line">t[<span class="number">0</span>]._color = D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">t[<span class="number">1</span>]._color = D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">t[<span class="number">2</span>]._color = D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br></pre></td></tr></table></figure></p>
<p>平面着色使物体呈现是斑驳的，因为没有从一个颜色到另一个颜色的平滑过渡。一个更好的着色模式叫做高洛德着色（也被叫做平滑着色）。高洛德着色，图元表面的颜色是由每个顶点通过线性插值来赋予。图4.2显示了分别使用平面着色和高洛德着色处理的红色三角形。</p>
<p>图4.2<br>就象Direct3D中很多东西一样，着色处理模式是受Direct3D设置状态决定的。<br>// set flat shading<br>Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);<br>// set Gouraud shading<br>Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);</p>
<h1 id="实例程序：彩色三角形"><a href="#实例程序：彩色三角形" class="headerlink" title="实例程序：彩色三角形"></a>实例程序：彩色三角形</h1><p>这个实例程序展示了分别使用本章中的平面着色和高洛德着色处理的三角形。渲染出的图片如图4.2所示。首先我们定义如下的全局变量：<br>D3DXMATRIX World;<br>IDirect3DVertexBuffer9* Triangle = 0;<br>    我们包含一个D3DXMATRIX，它将存储我们将要绘制的三角形在世界坐标中的变换信息。Triangle变量是存储三角形顶点数据的顶点缓存。注意，我们只需要存储一个三角形，因为我们能用它在世界坐标系中不同位置绘制若干次。<br>    Setup方法创建顶点缓存同时填充上带颜色信息的三角形顶点数据。三角形的第一个顶点填充为全亮度红色（255）第二个填充全亮度绿色（255），第三个填充全亮度蓝色（255）。最后，在这个例子中我们屏蔽掉灯光。值得注意的是该例子使用的是一个新的ColorVertex结构，就象在4.2节中说明的一样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create vertex buffer</span></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">        <span class="number">3</span> * <span class="keyword">sizeof</span>(ColorVertex),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        ColorVertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;Triangle,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fill the buffers with the triangle data</span></span><br><span class="line">    ColorVertex* v;</span><br><span class="line">    Triangle-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = ColorVertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">2.0f</span>, D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    v[<span class="number">1</span>] = ColorVertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>, D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">    v[<span class="number">2</span>] = ColorVertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">2.0f</span>, D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    Triangle-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set projection matrix</span></span><br><span class="line">    D3DXMATRIX proj;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(</span><br><span class="line">        &amp;proj,</span><br><span class="line">        D3DX_PI * <span class="number">0.5f</span>, <span class="comment">// 90 - degree</span></span><br><span class="line">        (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height,</span><br><span class="line">        <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1000.0f</span>);</span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the render states</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_LIGHTING, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Display函数使用不同的着色模式在两个不同的地方分别绘制2个Triangle。每个三角形的位置由世界矩阵World来决定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetFVF(ColorVertex::FVF);</span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, Triangle, <span class="number">0</span>, <span class="keyword">sizeof</span>(ColorVertex));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw the triangle to the left with flat shading</span></span><br><span class="line">        D3DXMatrixTranslation(&amp;World, <span class="number">-1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw the triangle to the right with gouraud shading</span></span><br><span class="line">        D3DXMatrixTranslation(&amp;World, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/drawing-in-direct3d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/drawing-in-direct3d/" class="post-title-link" itemprop="url">Drawing in Direct3D</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 14:55:06" itemprop="dateCreated datePublished" datetime="2019-04-11T14:55:06+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="顶点-索引缓存"><a href="#顶点-索引缓存" class="headerlink" title="顶点/索引缓存"></a>顶点/索引缓存</h1><p>顶点和索引缓存有相似的接口并且共享相似的方法；一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。<br>在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。</p>
<h2 id="创建一个顶点和索引缓存"><a href="#创建一个顶点和索引缓存" class="headerlink" title="创建一个顶点和索引缓存"></a>创建一个顶点和索引缓存</h2><p>我们能使用下面两个方法创建一个顶点缓存和索引缓存：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HRESULT IDirect3DDevice9::CreateVertexBuffer(</span><br><span class="line">    UINT Length,</span><br><span class="line">    DWORD Usage,</span><br><span class="line">    DWORD FVF,</span><br><span class="line">    D3DPOOL Pool</span><br><span class="line">    IDirect3DVertexBuffer9** ppVertexBuffer,</span><br><span class="line">    HANDLE* pSharedHandle</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">HRESULT IDirect3DDevice9::CreateIndexBuffer(</span><br><span class="line">    UINT Length,</span><br><span class="line">    DWORD Usage,</span><br><span class="line">    D3DFORMAT Format,</span><br><span class="line">    D3DPOOL Pool,</span><br><span class="line">    IDirect3DIndexBuffer9** ppIndexBuffer,</span><br><span class="line">    HANDLE* pSharedHandle</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这两个方法大部分参数是相同的，因此我们一起介绍它们。</p>
<ul>
<li>Length —— 分配给缓存的字节大小。假如想得到一个能存储8个顶点的顶点缓存，那么我们就要在顶点结构中设置这个参数为 8 * sizeof ( Vertex ) 。</li>
<li>Usage —— 指定关于怎样使用缓存的额外信息。这个值可以是0，没有标记，或者是下面标记的一个或多个的组合：</li>
<li>D3DUSAGE_DYNAMIC——设置这个参数可以使缓存是动态的。在下一页说明静态和动态缓存。</li>
<li>D3DUSAGE_POINTS——这个参数指定缓存存储原始点。原始点将在第14章粒子系统中介绍。这个参数仅仅用在顶点缓冲中。</li>
<li>D3DUSAGE_SOFTWAREPROCESSING——使用软件顶点处理</li>
<li>D3DUSAGE_WRITEONLY——指定应用程序只能写缓存。它允许驱动程序分配最适合的内存地址作为写缓存。注意如果从创建好的这种缓存中读数据，将会返回错误信息。</li>
<li>FVF —— 存储在缓存中的顶点格式</li>
<li>Pool —— 缓存放置在哪一个内存池中</li>
<li>ppVertexBuffer ——返回创建好的顶点缓存的指针。</li>
<li>pSharedHandle ——没有使用；设置为0。</li>
<li>Format ——指定索引的大小；使用D3DFMT_INDEX16设置16位索引，使用D3DFMT_INDEX32设置32位索引。注意并非所有设备都支持32位索引；请检查设备能力。</li>
<li>ppIndexBuffer ——返回创建好的索引缓存的指针。</li>
</ul>
<p>注意：不使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做静态缓存。静态缓存通常被放置在显存中，在其中的数据能被很有效的处理。然而，对于静态缓存，从中读取和写入数据是很慢的，因为访问显存是很慢的。因为这个原因我们用静态缓存存储静态数据（不需要被经常改变的数据）。对于静态缓存地形和建筑物是很好的后选例子，因为在应用程序中他们通常不需要被改变。静态缓存应该在应用程序初始话的时候就被填充好，而不是在运行时才做。</p>
<p>注意：使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做动态缓存。动态缓存通常被放在AGP内存中，这种内存中的数据能被很快的更新。处理动态缓存中的数据不会比处理静态缓存中的数据快，因为这些数据必须在渲染前被转移到显存中，动态缓存的好处是它们能够被稍微快点地被更新（比CPU写快）。因此，假如你需要经常更新缓存中的数据，那么你就应该使用动态缓存。对于动态缓存粒子系统是很好的一个应用，因为它们是动态的，并且他们通常每一帧都会被更新。</p>
<p>注意：在程序中读取显存和AGP内存都是非常慢的。因此，假如你在运行时需要读取你的几何物体，最好的方案是指定一块系统内存，都在其中拷贝并且读取数据。<br>　　  下边是创建一个静态顶点缓存的例子，该缓存能存储8个顶点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IDirect3DVertexBuffer9* vb;</span><br><span class="line">device-&gt;CreateVertexBuffer(</span><br><span class="line">    <span class="number">8</span> * <span class="keyword">sizeof</span>( Vertex ),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    D3DFVF_XYZ,</span><br><span class="line">    D3DPOOL_MANAGED,</span><br><span class="line">    &amp;vb,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="访问缓冲内存"><a href="#访问缓冲内存" class="headerlink" title="访问缓冲内存"></a>访问缓冲内存</h2><p>　　为了访问一个顶点/索引缓存，我们需要得到一个指针。我们通过一个指针获得缓存数据必须使用Lock方法。当我们访问完缓存后必须对它解锁。一旦有一个指向内存的指针，我们就能对它进行读写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HRESULT IDirect3DVertexBuffer9::Lock(</span><br><span class="line">    UINT OffsetToLock,</span><br><span class="line">    UINT SizeToLock,</span><br><span class="line">    BYTE** ppbData,</span><br><span class="line">    DWORD Flags</span><br><span class="line">);</span><br><span class="line">HRESULT IDirect3DIndexBuffer9::Lock(</span><br><span class="line">    UINT OffsetToLock,</span><br><span class="line">    UINT SizeToLock,</span><br><span class="line">    BYTE** ppbData,</span><br><span class="line">    DWORD Flags</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>　　图3.1<br>　　这两个方法的参数都是完全相同的。</p>
<ul>
<li>OffsetToLock —— 偏移量，以字节为单位，从缓存开始位置到锁定开始位置的距离。如图3.1。</li>
<li>SizeToLock —— 锁定的字节数。</li>
<li>ppbData —— 一个指向锁定内存开始位置的指针。</li>
<li>Flags —— 标记描述怎样锁定内存。它可能是0或者是下面参数中的1个或多个的组合：</li>
<li>D3DLOCK_DISCARD——这个参数仅仅会在动态缓存时被使用。它指示硬件丢弃缓存并返回一个指向新分配的缓存的指针。这是很有用，因为当我们存取一个新分配的缓存时它允许硬件继续从丢弃的缓存渲染。这防止了硬件延迟。</li>
<li>D3DLOCK_NOOVERWRITE——这个参数仅仅会在动态缓存时被使用。它声明你将向缓存中添加数据。即，你不能向已经渲染的内存中写数据。这是有好处的因为他允许你在添加新数据到缓存的同时让硬件继续渲染。</li>
<li>D3DLOCK_READONLY——这个参数声明你锁定的缓存只能从中读取数据而不能写数据。这允许一些内在的优化。<br>  用参数D3DLOCK_DISCARD和D3DLOCK_NOOVERWRITE的地址实际上就是缓存的一部分被使用（正在渲染）时它被锁定。假如情况允许这些标记被使用，当在锁定时他们防止渲染停止。<br>  下边的例子展示了通常怎样使用Lock方法。注意当我们使用完以后要调用Unlock方法。<br>Vertex<em> vertices;<br>_vb-&gt;Lock(0, 0, (void*</em>)&amp;vertices, 0); // 锁定整个缓存<br>vertices[0] = Vertex(-1.0f, 0.0f, 2.0f); // 向缓存里写顶点<br>vertices[1] = Vertex( 0.0f, 1.0f, 2.0f);<br>vertices[2] = Vertex( 1.0f, 0.0f, 2.0f);<br>_vb-&gt;Unlock(); // 当你访问完缓存时，解锁缓存<br>3.1.3 找回顶点和索引缓存信息<br>有时我们需要得到顶点/索引缓存信息。下面的例子示范了用于获得这些信息的方法：<br>D3DVERTEXBUFFER_DESC vbDescription;<br>_vertexBuffer-&gt;GetDesc(&amp;vbDescription); // 取得顶点缓存信息</li>
</ul>
<p>D3DINDEXBUFFER_DESC ibDescription;<br>_indexBuffer-&gt;GetDesc(&amp;ibDescription); //取得索引缓存信息<br>　　<br>　　D3DVERTEXBUFFER_DESC和D3DINDEXBUFFER_DESC结构的定义如下：<br>typedef struct _D3DVERTEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>    DWORD FVF;<br>} D3DVERTEXBUFFER_DESC;</p>
<p>typedef struct _D3DINDEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>} D3DINDEXBUFFER_DESC;<br>3.2 渲染状态<br>   Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法：<br>HRESULT IDirect3DDevice9::SetRenderState(<br>    D3DRENDERSTATETYPE State, // 更改的渲染状态<br>    DWORD Value // 新的状态值<br>);</p>
<p>例如，在这一章的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态：<br>_device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);<br>注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。<br>3.3 绘制准备<br>　　一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲染前我们还有3个步骤必须先做。<br>1、 设置资源流。设置资源流与一个顶点缓存挂钩，此流就是一个流入渲染管线的几何信息的流。<br>　　下面的方法是用于设置一个资源流：<br>HRESULT IDirect3DDevice9::SetStreamSource(<br>    UINT StreamNumber,<br>    IDirect3DVertexBuffer9* pStreamData,<br>    UINT OffsetInBytes,<br>    UINT Stride<br>);</p>
<ul>
<li>StreamNumber——确定我们的顶点缓存与哪一个资源流挂钩。在这本书中我们不使用多重流；因此我们总是使用0号流。</li>
<li>pStreamData——一个指向我们想与流挂钩的那个顶点缓存的指针。</li>
<li>OffsetInBytes——相对流开始处的偏移量。以字节为单位，它指定被填入渲染管线的顶点数据的开始位置。通过检查D3DCAPS9结构中的D3DDEVCAPS2_STREAMOFFSET标志，假如你的设备支持，那么这个参数就有一些非0值。</li>
<li>Stride——我们在顶点缓存中操作的每个部分的流的字节大小。<br>　　例如，假设vb是一个已经填充了顶点信息的顶点缓存：<br>_device-&gt;SetStreamSource( 0, vb, 0, sizeof( Vertex ) );</li>
</ul>
<p>2、 设置顶点格式。在这里我们指定后面用来绘图调用的顶点的顶点格式。<br>_device-&gt;SetFVF( D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1 );</p>
<p>3、 设置索引缓存。假如我们使用了索引缓存，我们必须设置后面要用于绘制操作的索引缓存。每次我们只能使用一个索引缓存；因此假如你需要用一个不同的索引缓存绘制一个物体时，你必须转换到另一个上。下面的代码设置一个索引缓存：<br>_device-&gt;SetIndices( _ib ); // 传递一个索引缓存指针的拷贝<br>3.4用顶点/索引缓存绘制<br>　　在我们创建好顶点/索引缓存以及做好准备工作以后，我们就能绘制我们的几何物体了。这是通过使用DrawPrimitive或者DrawIndexedPrimitive传送几何信息到达渲染管线。这些方法从顶点流中获得顶点信息以及从索引缓存中获得索引信息。<br>3.4.1 IDirect3DDevice9::DrawPrimitive<br>　　这个方法不使用索引信息绘制图元。<br>HRESULT IDirect3DDevice9::DrawPrimitive(<br>    D3DPRIMITIVETYPE PrimitiveType,<br>    UINT StartVertex,<br>    UINT PrimitiveCount<br>);</p>
<ul>
<li>PrimitiveType——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。</li>
<li>StartVertex——索引到在顶点流中的一个元素。设置渲染顶点中的开始点。这个参数给予我们一定的机动性，可以绘制一个顶点缓存中的某部分。</li>
<li>PrimitiveCount——绘制图元的个数。<br>　　例子：<br>// 绘制4个三角形<br>_device-&gt;DrawPrimitive( D3DPT_TRIANGLELIST, 0, 4);<br>3.4.2 IDirect3DDevice9::DrawIndexedPrimitive<br>　　这个方法使用索引信息来绘制图元。<br>HRESULT IDirect3DDevice9::DrawIndexedPrimitive(<br>  D3DPRIMITIVETYPE Type,<br>  INT BaseVertexIndex,<br>  UINT MinIndex,<br>  UINT NumVertices,<br>  UINT StartIndex,<br>  UINT PrimitiveCount<br>);</li>
<li>Type——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。</li>
<li>BaseVertexIndex——一个基本数字，在调用中用它去加上索引。参看下面的说明。</li>
<li>MinIndex——将被引用的最小索引值。</li>
<li>NumVertices——在此调用中将被引用的顶点数。</li>
<li>StartIndex——索引到索引缓存中的某个位置，它标记开始渲染的开始索引点。</li>
<li>PrimitiveCount——绘制图元的个数。<br>　　例子：<br>_device-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);<br>注意：BaseVertexIndex参数需要一些特别的解释。在解释过程中将会用到的图3.2。</li>
</ul>
<p>图3.2<br>   在索引缓存中定位顶点相应的也就在顶点缓存中定位了。然而，假设我们想将球，盒子，圆柱体的顶点放置到一个公共的顶点缓存中。对于每一个物体，我们将不得不再计算在公共顶点缓存中的索引。这个新的索引值是通过与一个偏移量相加得到。注意这个偏移量是标准的顶点，而不是字节。<br>    我们需要计算物体在公共顶点缓存中的索引值。Direct3D允许我们通过设置BaseVertexIndex参数得到一个顶点偏移量，随后Direct3D就能利用顶点自身的索引重新计算新的索引。<br>3.4.3 开始/结束场景<br>   最后一点就是所有绘制方法都必须在IDirect3DDevice9::BeginScene和IDirect3DDevice9::EndScene方法之间被调用。例如，我们将这样写：<br>_device-&gt;BeginScene();<br>　　// 绘制场景<br>    _device-&gt;DrawPrimitive(…);<br>_device-&gt;EndScene();<br>3.5 D3DX几何物体<br>　　通过在代码中建造每个三角形来建造3D物体是一件非常枯燥的事。幸运的是，D3DX库已经为我们提供了一些方法来产生简单3D物体的网格数据。<br>　　D3DX库提供如下6种网格生成函数。</p>
<ul>
<li>D3DXCreateBox</li>
<li>D3DXCreateSphere</li>
<li>D3DXCreateCylinder</li>
<li>D3DXCreateTeapot</li>
<li>D3DXCreatePolygon</li>
<li>D3DXCreateTorus</li>
</ul>
<p>图3.3<br>　　这6种函数的使用都很类似，并且使用D3DX网格数据结构ID3DXMesh就象使用ID3DXBuffer接口一样。这些接口回在第10章和11章中讲解。现在，我们忽视它们的详细信息，只需简单使用它们即可。<br>HRESULT D3DXCreateTeapot(<br>    LPDIRECT3DDEVICE9 pDevice, // 与mesh关联的设备<br>    LPD3DXMESH<em> ppMesh, // 返回的mesh<br>    LPD3DXBUFFER</em> ppAdjacency // 现在设成0<br>);<br>　　<br>　　一个使用D3DXCreateTeapot函数的例子：<br>ID3DXMesh<em> mesh = 0;<br>D3DXCreateTeapot(_device, &amp;mesh, 0);<br>　　一旦生成了网格数据，我们就能使用ID3DXMesh::DrawSubset方法绘制图形了。这个方法有一个参数，它用来识别网格的一个子集。这个网格是通过上面的D3DXCreate</em>函数中的一个子集创建的，因此可以给这个参数指定0值。一个渲染网格的例子：<br>_device-&gt;BeginScene();<br>    mesh-&gt;DrawSubset(0);<br>_device-&gt;EndScene();</p>
<p>   使用了网格以后，必须释放（release）它：<br>mesh-&gt;Release();<br>_mesh = 0;<br>3.6 实例程序：三角形、立方体、茶壶、D3DXCreate*<br>　　这里有4个例子。</p>
<ul>
<li>三角形——这是非常简单的应用程序，它示范了在线框模式下怎样创建并渲染一个三角形。</li>
<li>立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。</li>
<li>茶壶——这个程序使用D3DXCreateTeapot函数创建并渲染一个纺纱茶壶。</li>
<li>D3DXCreate——这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。<br>让我们简单讨论一下创建立方体的例子。通过对它的学习你自己就能很快地理解其他例子。<br>  这个简单的绘制和渲染立方体的程序的运行结果如图3.4。</li>
</ul>
<p>图3.4<br>　　首先我们定义下边两个全局变量来保存立方体的顶点和索引数据：<br>IDirect3DVertexBuffer9<em> VB = 0;<br>IDirect3DIndexBuffer9</em> IB = 0;<br>　　下一步，我们定义两个全局常量，由它们来指定我们的屏幕大小：<br>const int Width = 800;<br>const int Height = 600;<br>　　接下来定义我们的顶点结构以及结构中顶点的格式。在这个例子中顶点结构只保存顶点的位置信息：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex()&#123;&#125;</span><br><span class="line">    Vertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x; _y = y; _z = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> DWORD Vertex::FVF = D3DFVF_XYZ;</span><br></pre></td></tr></table></figure></p>
<p>让我们把它迁移到框架程序（见1.53节）上。Setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建顶点、索引缓存</span></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">        <span class="number">8</span> * <span class="keyword">sizeof</span>(Vertex),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        Vertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;VB,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Device-&gt;CreateIndexBuffer(</span><br><span class="line">        <span class="number">36</span> * <span class="keyword">sizeof</span>(WORD),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        D3DFMT_INDEX16,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;IB,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向立方体的顶点缓存填充数据</span></span><br><span class="line">    Vertex* vertices;</span><br><span class="line">    VB-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;vertices, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vertices of a unit cube</span></span><br><span class="line">    vertices[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">4</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    VB-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义立方体的三角形</span></span><br><span class="line">    WORD* indices = <span class="number">0</span>;</span><br><span class="line">    IB-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;indices, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面</span></span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>; indices[<span class="number">1</span>] = <span class="number">1</span>; indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    indices[<span class="number">3</span>] = <span class="number">0</span>; indices[<span class="number">4</span>] = <span class="number">2</span>; indices[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 背面</span></span><br><span class="line">    indices[<span class="number">6</span>] = <span class="number">4</span>; indices[<span class="number">7</span>] = <span class="number">6</span>; indices[<span class="number">8</span>] = <span class="number">5</span>;</span><br><span class="line">    indices[<span class="number">9</span>] = <span class="number">4</span>; indices[<span class="number">10</span>] = <span class="number">7</span>; indices[<span class="number">11</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左面</span></span><br><span class="line">    indices[<span class="number">12</span>] = <span class="number">4</span>; indices[<span class="number">13</span>] = <span class="number">5</span>; indices[<span class="number">14</span>] = <span class="number">1</span>;</span><br><span class="line">    indices[<span class="number">15</span>] = <span class="number">4</span>; indices[<span class="number">16</span>] = <span class="number">1</span>; indices[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右面</span></span><br><span class="line">    indices[<span class="number">18</span>] = <span class="number">3</span>; indices[<span class="number">19</span>] = <span class="number">2</span>; indices[<span class="number">20</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">21</span>] = <span class="number">3</span>; indices[<span class="number">22</span>] = <span class="number">6</span>; indices[<span class="number">23</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶部</span></span><br><span class="line">    indices[<span class="number">24</span>] = <span class="number">1</span>; indices[<span class="number">25</span>] = <span class="number">5</span>; indices[<span class="number">26</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">27</span>] = <span class="number">1</span>; indices[<span class="number">28</span>] = <span class="number">6</span>; indices[<span class="number">29</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底部</span></span><br><span class="line">    indices[<span class="number">30</span>] = <span class="number">4</span>; indices[<span class="number">31</span>] = <span class="number">0</span>; indices[<span class="number">32</span>] = <span class="number">3</span>;</span><br><span class="line">    indices[<span class="number">33</span>] = <span class="number">4</span>; indices[<span class="number">34</span>] = <span class="number">3</span>; indices[<span class="number">35</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    IB-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 照相机位置（视图矩阵）</span></span><br><span class="line">    <span class="function">D3DXVECTOR3 <span class="title">position</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-5.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">D3DXVECTOR3 <span class="title">target</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">D3DXVECTOR3 <span class="title">up</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    D3DXMATRIX V;</span><br><span class="line">    D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;target, &amp;up);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetTransform(D3DTS_VIEW, &amp;V);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投影矩阵</span></span><br><span class="line">    D3DXMATRIX proj;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(</span><br><span class="line">        &amp;proj,</span><br><span class="line">        D3DX_PI * <span class="number">0.5f</span>, <span class="comment">// 90 - degree</span></span><br><span class="line">        (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height,</span><br><span class="line">        <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1000.0f</span>);</span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染状态（填充模式：框架填充）</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　Display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 旋转立方体</span></span><br><span class="line">        D3DXMATRIX Rx, Ry;</span><br><span class="line">        <span class="comment">// x轴旋转45弧度</span></span><br><span class="line">        D3DXMatrixRotationX(&amp;Rx, <span class="number">3.14f</span> / <span class="number">4.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一帧中增加y轴的弧度</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">float</span> y = <span class="number">0.0f</span>;</span><br><span class="line">        D3DXMatrixRotationY(&amp;Ry, y);</span><br><span class="line">        y += timeDelta;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当y轴旋转2周时，重新回到0弧度</span></span><br><span class="line">        <span class="keyword">if</span>( y &gt;= <span class="number">6.28f</span> )</span><br><span class="line">            y = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结合x轴与y轴的旋转矩阵</span></span><br><span class="line">        D3DXMATRIX p = Rx * Ry;</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空目标缓存和深度缓存（用0xffffffff, 1.0f）</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,</span><br><span class="line">          <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        Device-&gt;BeginScene(); <span class="comment">// 开始绘制场景</span></span><br><span class="line"></span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, VB, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex)); <span class="comment">// 设置资源流</span></span><br><span class="line">        Device-&gt;SetIndices(IB); <span class="comment">// 设置索引缓存</span></span><br><span class="line">        Device-&gt;SetFVF(Vertex::FVF); <span class="comment">// 设置顶点格式</span></span><br><span class="line">　　　　<span class="comment">// 利用索引缓存绘制</span></span><br><span class="line">        Device-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        Device-&gt;EndScene(); <span class="comment">// 结束绘制场景</span></span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 翻转表面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d3d::Release&lt;IDirect3DVertexBuffer9*&gt;(VB);</span><br><span class="line">    d3d::Release&lt;IDirect3DIndexBuffer9*&gt;(IB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/graphics-learn-step/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/graphics-learn-step/" class="post-title-link" itemprop="url">图形学习步骤</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 08:27:42" itemprop="dateCreated datePublished" datetime="2019-04-11T08:27:42+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图形学/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>3D图形学分3大块的学习内容:<br>a.空间几何数学:   空间几何变换, 加速算法, 多边形技术, 曲线和曲面, 相交测试, 碰撞测试。<br>b.光照着色系统:   光照, 纹理贴图, 高级象素着色光照, 艺术性渲染.<br>c.程序技术性应用: 公告板, 精灵, 天空盒, 体绘制, 材质系统, 场景图, 渲染队列</li>
<li>在实际学习过程中,3个部分相互制约,故不能单方面突进,应保持一种平衡发展,使得相互促进,深化理解,达到比较流畅的学习曲线.</li>
<li>相对重要性以a,b,c序减(时间将无情淘汰现有的程序技术性应用),深刻掌握图形学基础才是王道。</li>
<li>3个部分都略有小成后,大量快速阅读网上各方面的杂家资料,应用基础知识去分析理解,在短时间内掌握各种程序性技巧。</li>
<li>再次通观全局基础,遍览所有细节,以图有更深的理解.</li>
</ol>
<p>如何学习API (OpenGL/Direct3D等)<br>首先，我认为API是工具，不是本质，OpenGL/Direct3D的本质是图形学,而不是OpenGL/Direct3D的本身,API的本身只是一些Interface而已.如果你明白图形学的原理.那么你很容易这些接口的作用,以及为什么要有这些接口的存在.所以,我要说的第一点是:你要学习3D编程,不是学会了OpenGL/Direct3D就可以了。甚至会不会这些API都不是那么的重要(虽然这么说,或许很多人不太赞同).最重要的,最根本的是,你要明白这些API背后的图形学的原理—-因为那才是根本中的根本.</p>
<p>下面我来介绍我对API学习的看法.</p>
<p>我认为API的学习有两种方法:一是正向学习.二是反向学习.</p>
<p>一:正向学习,所谓的正向学习,就是学习API的本身.我觉得这种方法是一种Brute Force行为.不是很好.我们只要看看API的特性,有那些部分.就可以了。比如学习Direct3D的时候,我们要知道它如何初始化,以及它和操作系统的结合.它在Direct3D8里引入了VS/PS.最后就是创建一个Direct3D应用的步骤和方法.这些就足够了。要不然.Direct3D那么多的函数,一个几十个参数。每一个都会要了我的命.</p>
<p>正向学习的第二个作用就是你在熟悉了图形学和大概了解了API后,有空就来看看API的细节,然后思索一下API里提供的一些特性对你的程序有什么作用.比如Direct3D里的Two Side Stencil.OpenGL里的TextureCombine等。</p>
<p>二:逆向学习.这是根本的方法,到了这一步,你就可以真正的算是图形学入门了。这要求你要有一定的图形学基础.比如,你现在开始做一个demo.你预计你的demo里有一堆眩眩的效果,当然你也要明白你的这些眩眩的效果要怎么实现的.然后你去找API里对应的功能,我想如果你的想法正常,一般的功能在Direct3D/OpenGL里应该都会有的.当然你也会碰到你想要的功能在这些API里没有,但是这不重要,重要的是你又学到新东西了—-这个特性在XX API里不支持。</p>
<p>通常我是采用先正向,再逆向,同时再进行正向学习的方法.希望以上的建议,对各位初学者有一定的帮助.</p>
<h1 id="关于计算机图形学的学习"><a href="#关于计算机图形学的学习" class="headerlink" title="关于计算机图形学的学习"></a>关于计算机图形学的学习</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>什么是计算机图形学？ 本文尽量避免给它做严格的定义，但是通常来说，计算机图形学是数字图象处理的逆过程，这只是一个不确切的定义，后面我们会看到，实际上，计算机图形学、数字图象处理和计算机视觉在很多地方的区别不是非常清晰的，很多概念是相通的。<br>计算机图形学是用计算机来画东西的学科，数字图象处理是把外界获得的图象用计算机进行处理的学科。<br>如何学习计算机图形学呢？除了计算机图形学的基础知识以外，你还需要有以下的知识。</p>
<ul>
<li>英语， 你一定要把英语学好，如果你想学习计算机图形学的话，尽量看英文的书籍和资料</li>
<li>数学， 计算机图形学里面的数学用的比较多，，我们可以列举一些常用的：<br>高等数学，数值分析，微分几何，拓扑，概率， 插值理论，（偏）微分方程…</li>
<li>物理， 如果你要进行基于物理的建模，一些物理理论是要学习的：<br>力学（运动学，动力学，流体力学…），光学，有限元…</li>
<li>编程语言： C或C++是计算机图形学最通用的‘普通话’，</li>
<li>数据结构： 你需要数据结构来描述你的图形对象，除了通用的链表、树等数据结构外，图形学还有自己特殊的数据结构</li>
<li>其他类别： 有的时候你需要其他学科的知识，根据你的需要去学习吧</li>
</ul>
<p>上面列举的不是你必须学习的东西，而是计算机图形学可能会用到的东西，一定要记住，不要指望通过一本教材就学会计算机图形学，它比你想象的要复杂的多。</p>
<h2 id="图形学的问题"><a href="#图形学的问题" class="headerlink" title="图形学的问题"></a>图形学的问题</h2><p>每个学科都有自己学科的特定问题，图形学要解决的是如何画出图来，得到需要的效果，当然这是图形学最大的一个问题。<br>在开始学习计算机图形学的时候，找一本简单的书看，对计算机图形学有个大概的认识，你就可以开始图形学之旅了：</p>
<p>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 1.4, Fourth Edition<br>OpenGL SuperBible (3rd Edition) </p>
<p>是比较好的学习计算机图形学的入门教材，在练中去学，一开始就去啃</p>
<p>Foley的Computer Graphics: Principles and Practice, Second Edition in C<br>不是好主意，会看的一头雾水，一本什么都讲的书的结果往往是什么都没讲清楚。<br>当你把OpenGL的基本内容掌握之后，你对图形学就有了大概的了解了</p>
<p>那么下面你可以来学习一下计算机图形学的数据结构和算法，下面的书比较适合Joseph O’Rourke 的Computational Geometry in C，书里面有C的源代码，讲述简单，清晰，适合程序员学习</p>
<p>总的来说，计算机图形学涉及到2大部分：建模和渲染</p>
<h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>你想画一个东西，首先要有它的几何模型，那么这个几何模型从什么地方来呢？下面的书很不错的：<br>Gerald Farin 的Curves and Surfaces for CAGD: A Practical Guide</p>
<p>这本书算是CAGD (计算机辅助几何设计)的经典图书，CAGD方面的全貌，还有2本很好的讲述曲面的书Bezier和Nurbs的书</p>
<p>Les A. Piegl, Wayne Tiller 的The Nurbs Book<br>书里面有NURBS曲线、曲面的程序伪代码，很容易改成C的，书讲的通俗、易懂，但是你要有耐心看的：）</p>
<p>曲线与曲面的数学<br>这本书是法国人写的中文翻译版，里面还有Bezie本人写的序J，翻译的很不错的，看了你就掌握Bezier曲面技术了<br>注意：在后面会有这样的章节，标明<br>里面是我认为的一些高级话题，跳过他们不影响你学习计算机图形学，但是要学好就要注意了，呵呵<br>还有其他的一些造型技术，比如：<br>隐式曲面(Implicit Surface)的造型：<br>就是用函数形式为F( x ,y ,z ) = 0的曲面进行造型，这样的造型技术适合描述动物器官一样的肉乎乎的东西，有2本书推荐大家<br>Jules Bloomenthal编辑的Introduction to Implicit Surfaces，是一本专著，讲述了Implicit Surface建模型(Modeling)，面片化(Polygonization)，渲染(Rendering)的问题<br>Luiz Velho 的 Implicit Objects Computer Graphics 也是一本专著，讲述个更新的一些进展</p>
<p>细分曲面（Subdivision Surface）造型<br>当用NURBS做造型的时候，曲面拼接是复杂的问题，在动画的时候，可能产生撕裂或者褶皱，Subdivision Surface用来解决这个问题<br>Joe Warren的Subdivision Methods for Geometric Design: A Constructive Approach就是这方面的专著</p>
<p>从实际物体中得到造型，现在的技术可以用三维扫描仪得到物体表面的点，然后根据这些点把物体的表面计算出来，称为重建(Reconstruction)，因为这些技术之在文章中论述，所以我们省略对它的描述<br>下面还是一个高级话题<br>在你的几何模型做好之后，有一些问题需要对这个模型进一步处理，得到适合的模型，当面片很多的时候，或者模型很复杂的时候，需要对几何模型进行简化，才可以满足一些实时绘制的需要，这个技术叫做层次细节（LOD-Level of Detail）。下面的书就是讲这个的：<br>David Luebke编著的 Level of Detail for 3D Graphics</p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了模型，怎么把这个几何模型画出来呢？这个步骤就是渲染<br>如果你看了上面的OpenGL的书，那么你就知道一些渲染的知识了，但是别高兴的太早，OpenGL使用的是局部光照模型（Local Illumination Model），不要被这个词吓住了</p>
<p>Local illumination Model指的是在做渲染的时候只考虑光源和物体之间的相互作用，不考虑物体和物体之间的影响，所以OpenGL不支持阴影，一个（半）透明物体的效果..，这些需要考虑物体之间的影响才可以实现。</p>
<p>OpenGL本身不支持，但是通过一些方法可以实现的，用Google搜索一下<br>Shadow Volume, OpenGL就找到答案啦</p>
<p>Global Illumination Model 这类模型考虑的就比较全啦。现在关于Global Illumination的技术有3大类，具体的技术就不在这里介绍了，如果想了解，可以联系我，大家一起讨论：</p>
<p>光线追踪(Ray Tracing)<br>关于Ray Tracing的好书有2本：<br>Andrew Glassner 的An Introduction to Ray tracing<br>Glasser是图形界的名人，这本书也是Ray Tracing的经典<br>R. Keith Morley, Peter Shirley 的Realistic Ray Tracing, Second Edition<br>这本书第一版是伪代码，第二版是C代码。它的结构不是很清楚，虎头蛇尾的感觉。<br>辐射度(Radiosity)<br>关于Radiosity的好书有4本：<br>Michael Cohen 的Radiosity and Realistic Image Synthesis ， Cohen获得SIGGRAPH 1998计算机图形学成就奖，他把Radiosity变成实际可用，现在Cohen在MSR图形 <a href="http://research.microsoft.com/~cohen/CohenSmallBW2.jpg" target="_blank" rel="noopener">http://research.microsoft.com/~cohen/CohenSmallBW2.jpg</a></p>
<p>Francois X. Sillion的Radiosity and Global Illumination ， Sillion是法国人，他的主要研究方向是Radiosity，这本书写的很不错的，非常清晰</p>
<p>Philip Dutre 的新书Advanced Global Illumination ，看起来还不错，刚拿到手，还没看，呵呵，所以不好评价</p>
<p>Ian Ashdown的Radiosity: A Programmer’s Perspective </p>
<p>Photon mapping<br>Henrik Wann Jensen的Realistic Image Synthesis Using Photon Mapping<br>Henrik Wann Jensen是Photon mapping技术的发明者</p>
<h3 id="这些也是图形学吗？-图形和图象的区别模糊了"><a href="#这些也是图形学吗？-图形和图象的区别模糊了" class="headerlink" title="这些也是图形学吗？ 图形和图象的区别模糊了"></a>这些也是图形学吗？ 图形和图象的区别模糊了</h3><h4 id="非真实性图形学（Non-Photorealistic-Graphics）"><a href="#非真实性图形学（Non-Photorealistic-Graphics）" class="headerlink" title="非真实性图形学（Non-Photorealistic Graphics）"></a>非真实性图形学（Non-Photorealistic Graphics）</h4><p>真实性不是计算机图形学的唯一要求，比如：你给我画一个卡通效果的图出来，或者我要用计算机画水彩画怎么办？或者：把图象用文字拼出来怎么做？，解决这些问题要用到非真实性图形学， 好书继续推荐！！！<br>Bruce Gooch, Amy Ashurst Gooch的 Non-Photorealistic Rendering </p>
<h4 id="体图形学-Volume-Graphics"><a href="#体图形学-Volume-Graphics" class="headerlink" title="体图形学(Volume Graphics)"></a>体图形学(Volume Graphics)</h4><p>用CT机做很多切片（比如头骨），那么能通过这些切片得到3D的头骨吗？Volume Graphics就是解决这样的问题的<br>Min Chen 编著的Volume Graphics<br>上面的2个图形学技术就和图象的界限不明显了，实际上他们是图形图象的综合</p>
<h2 id="还有其他的书吗"><a href="#还有其他的书吗" class="headerlink" title="还有其他的书吗"></a>还有其他的书吗</h2><p>Graphics Gems I ~ V，一大帮子人写的书，包括研究人员，程序员…<br>有计算机图形学的各种数据结构，编程技巧</p>
<p>Tomas Akenine-Moller 等人编著的Real-Time Rendering (2nd Edition)<br>许多最新的计算机图形学进展</p>
<p>David Ebert等人的Texturing &amp; Modeling: A Procedural Approach, Third Edition<br>讲述如何通过程序实现纹理、山、地形等图形学要素<br>F. Kenton Musgrave号称分形狂(Fractal Mania)<br>Ken Perlin就是Perlin噪声的发明者，用过3d软件的人对Perlin Noise不会陌生的</p>
<p>关于图形学的特定对象，有特定的专题图书，<br>Evan Pipho Focus On 3D Models,对于图形学的常用模型格式，进行了讲解<br>Trent Polack的 Focus On 3D Terrain Programming ，讲地形的<br>Donald H. House 的Cloth Modeling and Animation ，讲布料的<br>Nik Lever的Real-time 3D Character Animation with Visual C++ ，讲角色动画的</p>
<p>Richard Parent的 Computer Animation: Algorithms and Techniques，当然是讲动画的啦，呵呵。<br>David H. Eberly的3D Game Engine Design : A Practical Approach to Real-Time Computer Graphics ，有代码的啊！呵呵：）</p>
<p>最后，没事情的时候，看看下面的书吧<br>Alan H. Watt， 3D Computer Graphics (3rd Edition) </p>
<p>James D. Foley等人的 Computer Graphics: Principles and Practice in C (2nd Edition) ，这本圣经没事的时候再看吧，呵呵</p>
<h1 id="游戏程序员养成计划"><a href="#游戏程序员养成计划" class="headerlink" title="游戏程序员养成计划"></a>游戏程序员养成计划</h1><p>与玩游戏相比,写游戏要复杂上千万倍,除了需要掌握通用的编程技巧以外，还要有相当的图形学，物理，数学基础，特别是在国内，由于相关资料的缺乏，更是让初学者无从下手。下面总结了一些入门方法和比较容易入手的资料。</p>
<p>首先你要精通一门高级语言，比如C++或者C#，其次，要有良好的英文阅读能力。对游戏开发者来说英文阅读能力是最重要也是最基本的工具之一，因为你遇到的大部分资源都将是英文的，不要总等着别人为你翻译。慢慢尝试着阅读英文资料，你会发现其实也并没有那么难:)</p>
<p>刚开始，你要做的就是选择一门图形API，一般就是DirectX或者OpenGL之间选一个。如果考虑到跨平台，那么OGL是首选. 如果只在ms的平台，则DX是首选。我对OGL并不是很了解，所以下面大部门资料都是和DX相关的。</p>
<p>当然，作为准备工作之一，你首先要到DirectX Develop Center下载最新版的DirectX SDK。</p>
<p>入门书籍非常重要，推荐&lt;<introduction to 3d game programming with directx 9.0>&gt;（好像去年出了中文版）也就是传说中的龙书，这可以说是最好的DX入门教材，Frank Luna从浅入深，讨论了DX的方方面面。另外再配上&lt;&lt; Advanced 3D Game Programming With DirectX 9.0&gt;&gt;，书名虽然是advanced，但实际上没有多少advanced级别的内容。看完这两本书，你基本上已经对DirectX比较熟悉了。如果你希望学习XNA，也是一样的，毕竟XNA是以DX为基础。</introduction></p>
<p>不要一开始就看图形学的书，这个时候你对图形编程还没有一个基本的感性认识，因此八成看的云里雾里。不要以网上的教程和论坛提问作为主要学习途径，找一本好书，系统学习，效率才最高。不要马上看SDK里的例子，很多图形学的基本原理仅仅通过读代码是不会明白的。某些年代太过久远的书就不要看了，比如《windows游戏编程大师技巧》（总看到有人在找这本书）。有人说基本的思想总是不变的，可惜对于现代GPU来说，很多早期的技术和优化技巧早就过时了。图形编程是发展的非常快的技术，看看GPU的发展速度，1~2年就是一代产品的革新。</p>
<p>好了，入门之后，是你巩固和拓展视野的阶段。现在看计算机图形学就比较合适了。吐血推荐&lt;<real-time-rendering>&gt;,这本书算得上是所有图形程序员的必读书籍和参考手册了。最近刚出了第三版。可惜国内只有第二版，稍微有点老，如果实在找不到第三版，还是值得一读。国内其他所有以图形学命名的书都有一个共同点：枯燥，过时。只需看看其中二维三维变换和曲线曲面表示的部分即可。如果这个时候发现你当年数学没有学好，那么有三本数学书是为游戏程序员量身定制的：&lt;<3d math primer for graphics and game development>&gt;, &lt;<mathematics for 3d game programming and computer graphics>&gt;和&lt;<essential mathematics guide 2nd edition>&gt;，第一本书有中文版，最后一本则是08年才出的新书。</essential></mathematics></3d></real-time-rendering></p>
<p>其实入门之后，就没有固定的学习路线了，最好根据你感兴趣的方向来学习。</p>
<p>Shader方面：《Cg_tutorial》和《The Complete Effect and HLSL Guide》都是不错的入门材料，当然还有SDK文档。&lt;<shaders for game programmers and artists>&gt;有大量入门的例子。&lt;<advanced lighting and materials with shaders>&gt;详细介绍了各种光照模型和技术。&lt;<gpu gems>&gt; 1~3册肯定是必读的，虽然有1，2有中文版，但某些翻译并不是很理想，强烈建议直接看英文版。ShaderX系列也是很经典的系列，每年出版一本，包含了最新的实时渲染技术，如今已经出了第6册了。不过网络上只能找到1~3册。1，2册大部分shader都是用asm写的，不过看懂原理，转换为HLSL也并不难。另外Nvidia SDK和ATI SDK也是学习shader的重要资源。最后还有刚出的&lt;&lt; Programming Vertex, Geometry, and Pixel Shaders&gt;&gt;</gpu></advanced></shaders></p>
<p>地形：&lt;<real time 3d terrain engines using c++ and dx9>&gt;非常全面的讨论了关于地形渲染的各种技术，至少应该把第5~9章都浏览一遍。之后便可以 到virtual terrain查阅近期的地形渲染技术。</real></p>
<p>模型导入和动画：&lt;<advanced animation with directx>&gt;，仅此一本足以。</advanced></p>
<p>物理：&lt;<game physics>&gt;和&lt;<game physics engine development>&gt;都不错。&lt;<real-time collision detection>&gt;是碰撞检测方面最好的书，可惜目前还没有电子版。<br>LOD：&lt;<level of detail for 3d graphics>&gt;<br>Ray tracing:&lt;&lt; Physical-Based Rendering - From Theory to Implementation&gt;&gt;<br>引擎设计：说实话，这方面还没有特别好的书，大概越是核心的内容，越少有人愿意写吧。&lt;<3d game engine architecture engineering real-time applications with wild magic>&gt;只有第三章值得一读。&lt;<3d game engine programming>&gt;可以选部分感兴趣的章节看看，不过总的来说，讲的比较浅。<br>AI：&lt;<programming game ai by example>&gt;非常不错，好像还有中文版，备选&lt;<artificial intelligence for games>&gt;。当然&lt;<ai programming wisdom>&gt;系列也是必读作品，不过目前网络上只有1～2册。<br>综合：&lt;<game programming gems>&gt;系列，不过由于内容涉及的过于广泛，文章质量参差不齐，选择性阅读就可以了。历年GDC, Gamefest t,Siggraph等大型会议的paper也是应该关注的。<br>除了书以外，再推荐一些不错的网络资源：<br>www.GameDev.NET 除了大量教程以外，论坛里多年累计下来的内容保罗万象。好好利用论坛搜索，你会发不管你多厉害，那里总有一些比你强大的人在很久以前就遇到了和你同样的问题，并且给出了解决方案。<br>Nvidia和ATI的开发者中心<br>creators.xna.com XNA官方网站<br>www.gamasutra.com 与GameDev类似<br>www.beyond3d.com 这里的除了讨论软件以外，还能看到对硬件构架的分析<br>www.ziggyware.com 最好的XNA教程网站<br>www.gameres.com 国内唯一比较专业的游戏编程网站，可惜和GameDev相比就显得太寒碜了<br><a href="http://imgtec.eetrend.com/" target="_blank" rel="noopener">http://imgtec.eetrend.com/</a><br>www.alanzucconi.com/category/shader/<br><a href="http://shaderbits.com/blog/tiling-within-subuv-or-volume-textures" target="_blank" rel="noopener">http://shaderbits.com/blog/tiling-within-subuv-or-volume-textures</a><br><a href="http://www.iquilezles.org/www/index.htm" target="_blank" rel="noopener">http://www.iquilezles.org/www/index.htm</a><br><a href="http://www.opengpu.org/forum.php?mod=forumdisplay&amp;fid=21" target="_blank" rel="noopener">http://www.opengpu.org/forum.php?mod=forumdisplay&amp;fid=21</a><br><a href="https://www.gamedev.net/" target="_blank" rel="noopener">https://www.gamedev.net/</a><br><a href="http://www.flipcode.com/archives/Light_Mapping_Theory_and_Implementation.shtml" target="_blank" rel="noopener">http://www.flipcode.com/archives/Light_Mapping_Theory_and_Implementation.shtml</a><br><a href="http://www.realtimerendering.com/" target="_blank" rel="noopener">http://www.realtimerendering.com/</a><br><a href="http://kesen.realtimerendering.com/" target="_blank" rel="noopener">http://kesen.realtimerendering.com/</a></game></ai></artificial></programming></3d></3d></level></real-time></game></game></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/10/diffuse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/10/diffuse/" class="post-title-link" itemprop="url">标准光照模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-10 13:29:47" itemprop="dateCreated datePublished" datetime="2019-04-10T13:29:47+08:00">2019-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基本光照模型中漫反射部分的计算公式：<br>$c<em>{diffuse}=(c</em>{light} \cdot m<em>{diffuse})max(0, \vec{n} \cdot I)$<br>从公式可以看出，要计算漫反射需要知道4个参数：入射光线的颜色和强度$c</em>{light}$，表面发现$\vec{n}$以及光源方向$I$。<br>为了防止点击结果为赋值，我们需要使用max操作，而CG提供了这样的函数。在本例中，使用CG的另一个函数可以达到同样的目的，即saturate函数。<br><strong>函数：</strong>saturate(x)<br><strong>参数：</strong>x：用于操作的标量或矢量，可以是float、float2、float3等类型。<br><strong>描述：</strong>把x截取在[0,1]范围内，如果x是一个矢量，那么会对它的每一个分量进行这样的操作。</p>
<h1 id="逐顶点光照"><a href="#逐顶点光照" class="headerlink" title="逐顶点光照"></a>逐顶点光照</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Unity/Diffuse Vertex"</span>&#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (<span class="string">"Diffuse"</span>, Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 材质的漫反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 高光系数</span></span><br><span class="line">    &#125;   </span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tasg&#123;<span class="string">"LightMode"</span>=<span class="string">"ForwardBase"</span>&#125; <span class="comment">// 前向渲染，所有光源都在一个着色器中进行</span></span><br><span class="line">        &#125;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">        #pragma vertex vert</span><br><span class="line">        #pragma fragment frag</span><br><span class="line">        #include <span class="string">"Lighting.cginc"</span></span><br><span class="line">        fixed4 _Diffuse;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span>&#123;</span></span><br><span class="line">            float4 vertex : POSITION;</span><br><span class="line">            float3 normal : NORMAL;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            fixed3 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">v2f <span class="title">vert</span><span class="params">(a2v v)</span></span>&#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            float3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; <span class="comment">// 环境光</span></span><br><span class="line">            float3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); <span class="comment">// 世界法线</span></span><br><span class="line">            float3 lightNormal = normalize(_WorldSpaceLightPos0.xyz); <span class="comment">// 光的方向</span></span><br><span class="line">            float3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, lightNormal));</span><br><span class="line">            o.color = diffuse + ambient;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        fixed4 frag(v2f o) : COLOR</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(o.color,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶点着色器最基本的任务就是把顶点位置从模型空间转换到裁剪空间中，因此我们需要使用Unity内置的模型*世界*投影矩阵UNITY_MATRIX_MVP来完成这样的坐标转换。通过Unity的内置变量UNITY_LIGHTMODEL_AMBIENT得到了环境光部分。<br>然后，就是真正计算漫反射光照的部分。为了计算慢反射光照我们需要知道4个参数。在前面的步骤中，我们已经知道了材质的漫反射颜色_Diffuse以及顶点发现v.normal。我们还需知道光源的颜色和强度信息以及光源方向。Unity提供给我们一个内置变量_LightColor0来访问该Pass处理的光源的颜色和强度信息（注意，想要得到正确的值需要定义合适的LightMode标签），而光源方向可以由_WorldSpaceLightPos0来得到。需要注意的是，这里对光源方向的计算并不具有通用性。这里，我们假设场景中只有一个光源且该光源的类型是平行光。但如果场景中有多个光源并且类型可能是点光源等其他类型，直接使用_WorldSpaceLightPos0就不能得到正确的结果。</p>
<h1 id="半兰伯特光照模型"><a href="#半兰伯特光照模型" class="headerlink" title="半兰伯特光照模型"></a>半兰伯特光照模型</h1><p>$c<em>{diffuse}=(c</em>{light}\cdot m_{diffuse})(\alpha (\vec {n}\cdot I)+\beta)$<br>可以看出，与原兰伯特模型相比，半兰伯特光照模型没有使用max操作来防止$\vec {n}$</p>
<h1 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h1><p>Blinn模型计算高光反射的公式如下：</p>
<font size="4">
$c_{specular}=(c_{light} \cdot m_{specular})max(0,\vec{n} \cdot \vec{h})^{m_{glass}}$    
</font>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/10/new-delete-malloc-free/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/10/new-delete-malloc-free/" class="post-title-link" itemprop="url">new delete malloc free</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-10 11:34:54" itemprop="dateCreated datePublished" datetime="2019-04-10T11:34:54+08:00">2019-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>每个程序在执行时都会占用一块可用的内存空间，用于存放动态分配的对象，此内存空间成为自由存储区或堆。</p>
<h1 id="new和delete用法"><a href="#new和delete用法" class="headerlink" title="new和delete用法"></a>new和delete用法</h1><p>如下几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>第一行这个new表达式在自由存储区中分配创建了一个整型对象，并返回一个指向该对象的地址来初始化指针pi。第二行将指针pi指向的地址的值进行了初始化为0。第三行初始化为1024.<br>当动态创建的对象用完后必须释放内存，避免造成内存泄漏，可以用delete来完成，new和delete是成对使用的，如下命令释放pi指向的int型对象所占用的内存空间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure></p>
<p>此时pi尽管没有定义，但仍然存放了呃它所指向对象的地址，然而pi所指向的内存已经被释放，因此pi不再有效。建议一旦删除指针所指向的对象，立即将指针置为0，这样就清楚的表明指针不再指向任何对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是当执行下列表达式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pi = &amp;i;</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure></p>
<p>编译器一般不会报错，因为编译器通常不能断定一个指针指向什么类型的对象，所以尽管这个语句是错误的，但在大多数编译器上仍然能通过。<br>C++中允许动态创建const对象：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p>
<p>动态创建的const对象必须进行初始化，并且进行初始化后的值不能在改变。<br>当创建一个动态数组对象和进行内存释放时，执行以下语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[];    <span class="comment">// pi所指向的数组未初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[n];   <span class="comment">// pi指向长度为n的数组，未初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[]();  <span class="comment">// 指针pi所指向的地址初始化为0</span></span><br><span class="line"><span class="keyword">delete</span> [] pi;           <span class="comment">// 回收pi所指向的数组</span></span><br></pre></td></tr></table></figure></p>
<h1 id="malloc和free的用法"><a href="#malloc和free的用法" class="headerlink" title="malloc和free的用法"></a>malloc和free的用法</h1><p>两个函数的原型如下，他们都在头文件stdlib.h中声明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *pointer)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>示例代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);            <span class="comment">// 指向整型的指针p指向一个大小为100字节的内存的地址</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">25</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 指向整型的指针p指向一个25个int整型空间的地址</span></span><br></pre></td></tr></table></figure></p>
<p>因为malloc()函数的返回值类型为void *，所以需要在函数前面进行相应的强制类型转换。当int占4个字节内存时，上述的两个语句代码获得的内存空间大小是相同的。分配内存后需要验证内存是否分配成功，完成后free()释放内存，完整语句如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">if</span> (pi == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Out of memory!\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure></p>
<p>另外两个分配内存的函数：calloc和realloc，他们的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num_elements, <span class="keyword">size_t</span> element_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *tr, <span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0。另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数。<br>relloc函数用于修改一个原先已经分配的内存块大小。可以使一块内存扩大或缩小，如果扩大内存，则原来的内存块保持不变，在内存尾部增加新的内存块，切不进行初始化。如果缩小内存，则原来内存块从尾部进行删减。如果原先的内存块无法扩充，则新开辟一块内存，并复制原先的内存的内容，原先内存块失效无法再进行访问。</p>
<h1 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>使用new操作符申请内存分配时无须指定内存的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
<h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符号类型安全的操作符。而malloc内存分配成功则返回void <em>，需要通过强制类型转换将void </em>指针转换成我们需要的类型。</p>
<h2 id="分配失败"><a href="#分配失败" class="headerlink" title="分配失败"></a>分配失败</h2><p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时会返回NULL。</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。<br>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++允许重载new/delete操作符，malloc不允许重载。</p>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统锁维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p>
<hr>
<p>在C++/C#中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；<br>在C中，内存区分为堆、栈、全局/静态存储区、常量存储区；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/protocol-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/protocol-buffer/" class="post-title-link" itemprop="url">Google Protocol Buffer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 22:21:39" itemprop="dateCreated datePublished" datetime="2019-04-09T22:21:39+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Server/" itemprop="url" rel="index"><span itemprop="name">Server</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义一个消息类型"><a href="#定义一个消息类型" class="headerlink" title="定义一个消息类型"></a>定义一个消息类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest</span><br><span class="line">&#123;</span><br><span class="line">    required <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">    optional int32 page_number = <span class="number">2</span>;</span><br><span class="line">    optional int32 result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该消息定义了三个字段，两个int32类型和一个string类型的字段，每个字段由字段限制，字段类型，字段名和Tag四部分组成，对于C++，每一个.proto文件经过编译之后都会对应的生成一个.h和一个.cc文件</p>
<h1 id="字段限制"><a href="#字段限制" class="headerlink" title="字段限制"></a>字段限制</h1><p>字段限制共有3类<br><strong>required</strong>:必须赋值的字段<br><strong>optional</strong>:可有可无的字段<br><strong>repeated</strong>:可重复字段（变长字段），类似于数组<br>由于一些历史原因，repeated字段并没有想象中那么高效，新版本中允许使用特殊的选项来获得更高效的编码：</p>
<pre><code>repeated int32 samples = 4 [packet=true];
</code></pre><h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><p>消息中的每一个字段都由一个独一无二的数值类型的Tag.1到15使用一个字节编码，16到2047使用2个字节编码，所以应该将Tags 1到15留个频繁使用的字段。<br>可以指定的最小的Tag为1，最大位$2^29$-1或536,870,911，但不能使用19000到19999之间的值，这些值是预留给protocol buffer的。</p>
<h1 id="Google-Protocol-Buffer的Encoding"><a href="#Google-Protocol-Buffer的Encoding" class="headerlink" title="Google Protocol Buffer的Encoding"></a>Google Protocol Buffer的Encoding</h1><p>Protobuf序列化所生成的二进制消息非常紧凑，这得益于Protobuf采用的非常巧妙的Encoding方法。<br>考擦消息结构之前，让我首先要介绍一个叫Varint的术语。<br>Varint是一种紧凑的表示数字的方法。它用一个或这个字节来表示一个数字，值越小的数字使用越小的字节数。这能减少用来表示数字的字节数。<br>比如对于int32类型的数字，一般需要4个byte来表示。但是采用Varint，对于很小的int32类型的数字，则可以用1个byte来表示。大的数字则需要5个byte表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用Varint后，可以用更少的字节数来吧iaoshi数字信息。下面就详细介绍一下Varint。<br>Varint中的每个byte的最高位bit有特殊的含义，如果该位为1，表示后续的byte也是该数字的一部分，如果该位为0，则结束。其他的7个bit都用来表示数字。因此小于128的数字都可以用一个byte表示。大于128的数字，比如300，会用两个字节来表示：1010 1100 0000 0010<br>下图演示了Google Protocol Buffer如何解析两个bytes。注意到最终计算前将两个byte的位置相互交换过一次，这是因为Google Protocol Buffer字节序采用little-endian的方式。</p>
<img src="/2019/04/09/protocol-buffer/1.jpg">
<p>消息经过序列化会成为一个二进制数据流，该流中的数据为一系列的Key-Value对。如下图所示：<br><img src="/2019/04/09/protocol-buffer/7.jpg"><br>采用这种Key-Pair结构无需使用分隔符来分割不通的Field。对于可选的Field，如果消息中不存在该Field，那么在最终的Message Buffer中就没有该field，这些特性都有助于节约消息本身的大小。<br>假如我们生成如下的一个消息Test1：</p>
<pre><code>Test1.id = 10;
Test1.str = &quot;hello&quot;;
</code></pre><p>则最终的Message Buffer中有两个Key-Value对，一个对应消息中的id；另一个对应str。<br>Key用来标识具体的field，在解包的时候，Protocol Buffer根据Key就可以知道相应的Value应该对应于消息中那一个Field。<br>Key的定义如下：</p>
<pre><code>(field_number&lt;&lt;3)|wire_type
</code></pre><p>可以看到Key由两部分组成。第一部分是field_number，比如消息Im.helloworld中的field id的field_number为1.第二部分为wire_type。表示Value的传输类型。</p>
<p>Wire Type可能的类型如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>Meaning</th>
<th>Used For</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Varint</td>
<td>int32,int64,uint32,uint64,sint32,sint64,bool,enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td>fixed64,sfixed64,double</td>
</tr>
</tbody>
</table>
</div>
<p>在我们的例子中，field id所采用的数据类型为int32，因此对应的wire type为0。可以看到Type 0所能表示的数据类型中有int32和sint32这两个非常类似的数据类型。Google Protocol Buffer区别它们的主要意图也是为了减少encoding后的字节数。<br>在计算内，一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用Varint表示一个负数，那么一定需要5个byte。为此Google Protocol Buffer定义了sint32这种类型，采用zigzag编码。<br>Zigzag编码用无符号数来表示有符号数字，正数和负数交错，这就是zigzag这个词的含义了。<br>如图所示：<br><img src="/2019/04/09/protocol-buffer/8.jpg"></p>
<p>使用zigzag编码，绝对值小的数字，无论正负都可以采用较少的byte来表示，充分利用了Varint这种技术。<br>其他的数据类型，比如字符串则采用类似数据库中的varchar的表示方法，即用一个varint表示长度，然后将其余部分紧跟在这个长度部分之后即可。<br>通过以上对protobuf Encoding方法的介绍，想必已经发现protobuf消息的内容效，适合网络传输。<br>对于消息Test1，用Protobuf序列化后的字节序为：<br>08 65 12 06 48 65 6C 6C 6F 77<br>而如果用XML，则类似这样<br>31 30 31 3C 2F 69 64 3E 3C 6E 61 6D 65 3E 68 65<br>6C 6C 6F 3C 2F 6E 61 6D 65 3E 3C 2F 68 65 6C 6C<br>6F 77 6F 72 6C 64 3E<br>一共55个字节，这些奇怪的数字需要稍微解释一下，其含义用ASCII表示如下：</p>
<p><helloworld><br>    <id>101</id><br>    <name>hello</name>
</helloworld></p>
<h1 id="封解包的速度"><a href="#封解包的速度" class="headerlink" title="封解包的速度"></a>封解包的速度</h1><p>首先我们来了解一下XML的封解包过程。XML需要从文件中读取出字符串，在转换为XML文档对象结构模型。之后，在从XML文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将XML文件转换为文档对象结构模型的过程通常需要完成词法文法分等大量消耗CPU的复杂计算。<br>反观Protobuf，它只需要简单地将一个二进制序列，按照指定的格式读取到C++对应的结构类型中就可以了。<br><img src="/2019/04/09/protocol-buffer/9.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
