<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Console:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/13/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Basic-Terrain-Rendering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Basic-Terrain-Rendering/" class="post-title-link" itemprop="url">第十三章 地形渲染基础(Basic Terrain Rendering)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:21:54" itemprop="dateCreated datePublished" datetime="2019-04-11T15:21:54+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Basic-Terrain-Rendering/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Basic-Terrain-Rendering/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实际上，地形网格不比三角形网格复杂，图13.1.(a)所示，网络的每个顶点指定了高度，格子模型用这种方式显示从山脉到河流的平滑过渡。图13.1 (b)，模拟自然地形。当然，我们可以用漂亮的纹理表现沙石地，绿色的山丘。图13.1.(c)雪山效果。</p>
<p>图 13.1: (a) 三角网格. (b) 平滑高度过渡的三角网格. (c) 光和纹理，我们在这一章节中写的例子的一个屏幕截图。<br>   这一章的内容是实现一个Terrain（地形）类。这个类的功能很强。我们的意思是，它只是储存整个地形的顶点/索引数据，然后渲染它。因为如果游戏需要一个小的地形，那么它能够在现代图形卡支持的硬件顶点处理下工作。然而实际上，游戏需要大量的地形，你必须对细节做某种（级别）程度的捡选，因为模型需要大量的几何数据，这样大的地形对于再强大的处理方法也是无法处理的。</p>
<p>目标 </p>
<ul>
<li>学习怎样生成地形的高度信息，它能使山丘、河流等地带的平滑的过度，模拟自然界的地形。</li>
<li>了解怎样生成地形的顶点和三角形数据。</li>
<li>学习使用地形的纹理和光照.</li>
<li>找到控制地形上照相机位置的方法，以便模拟在地形上走动。</li>
</ul>
<p>13.1 Heightmaps（高度图）<br>   我们使用高度图去描述地形上的山丘、河流。高度图是一个数组，数组中的每个成员指定地形顶点描述中的高度信息。我们经常把高度图想像成一个矩阵，因为每个元素都一一对应于每个地形网格中的顶点。<br>   当我们保存高度图到磁盘上时，我们通常为高度图的每个元素分配1个byte的内存，所以高度的范围是0..255，0..255的范围对于地形的高度之间保持平滑过渡是足够用的。但为了在我们的程序中匹配3D世界中的物体，可能需要的范围在0..255以外。例如，我们在3D世界中的测量单位是英尺，那么0..255的范围对于表现任何有趣的东西是不够的。因此，当我们读取数据进应用程序时，给每个高度元素分配一个整型数（或浮点型），它允许我们很好的缩放0..255范围之外的任何大小的物品。<br>   高度图图形表示法这一是灰度图(grayscale map)。较黑的值表示地形中较低的地方，较白的值表现地形中较高的地方。</p>
<pre><code> 图13.2: 高度图的灰度图表示
</code></pre><p>13.1.1 创建高度图（Heightmap）<br>   高度图不是用程序生成就是用图像编辑器生成，比如：Adobe Photoshop。使用图像编辑器大概是最容易的方法了。当你想生成地形时，可以交互式的可视化的创建。你可以利用图像编辑器的功能，比如：过滤器，创建一个有趣的高度图，图13.3显示了一个用Adobe Photoshop图像编辑器的工具创建的金字塔形的高度图。注意：当创建图像时我们指定一个灰度图类型。</p>
<pre><code> 图13.3 一幅用Adobe Photoshop创建的灰度图
 一但你画完了你的高度图，你必须将它保存为一个8bit的RAW文件。RAW文件只图像的逐个字节。我们的应用程序可以非常容易的读这样的图像。你的软件可能告诉你保存的RAW文件是有文件头的还是没有文件头的。
 注意：用RAW格式保存高度信息不是必须的；你可以用符合你需要的任何格式。RAW格式是我们能使用的的格式之一。我决定使用RAW格式是因为很多流行的图像编辑器支持导出这种格式，而且应用程序读取RAW文件的数据非常简单。这章中有使用8-bit RAW文件的例子。
</code></pre><p>13.1.2 读取RAW文件<br>   RAW文件与一段连续的bit内存块没什么分别。我们能用很简单的方法读取这段内存块，注意：变量_heightmap是Terrain类的一个成员，定义如下 ：<br>std::vector<int> _heightmap;<br>bool Terrain::readRawFile(std::string fileName)<br>{<br>     // A height for each vertex<br>     std::vector<byte> in(  numVertices );<br>     std::ifstream inFile(fileName.c_str(), std::ios_base::binary);<br>     if( inFile == 0 )<br>          return false;<br>     inFile.read(<br>          (char*)&amp;in[0], // buffer<br>          in.size());// number of bytes to read into buffer<br>     inFile.close();</byte></int></p>
<pre><code> // copy BYTE vector to int vector
 _heightmap.resize( _numVertices );
 for(int i = 0; i &lt; in.size(); i++)
      _heightmap[i] = in[i];

 return true;
</code></pre><p>}<br>我们COPY一个bytes向量到一个整形向量，这样做我们能够缩放 [0,255]以外的高度。这个方法唯一限制是：RAW文件必须读入至少与地形的顶点数一样多的高度信息。因此，如果你读取一个256x256 的RAW文件，你的地形也必须包含256x256个顶点。</p>
<p>13.1.3 访问与修改Heightmap<br>     Terrain类提供以下2个方法访问和修改Heightmap的入口。<br>int Terrain::getHeightmapEntry(int row, int col)<br>{<br>      return _heightmap[row * _numVertsPerRow + col];<br>}</p>
<p>void Terrain::setHeightmapEntry(int row, int col, int value)<br>{<br>     _heightmap[row * _numVertsPerRow + col] = value;<br>}<br>   这些方法允许我们以行和列来访问入口，并且隐藏方法。当使用它去描述矩阵时，我们必须将一个线性数组编入索引。<br>（These methods allow us to refer to an entry by row and column and hide the way we must index a linear array when using it to describe a matrix）</p>
<p>13.2 生成地形几何数据<br>   图13.4显示Terrain类的一些属性、词汇和我们提到的一些关键点。我们定义地形的大小，指定每行、每列顶点的数量，和单元的间隔。传递这些值到Terrain类的构造器中。另外，也传递地形所关联的设备，一个包含高度图数据的字符串文件名，一个用来缩放高度图成员的高度缩放值。</p>
<pre><code>     图13.4：三角形网络的属性，延着方格线上的点是地形的顶点。
</code></pre><p>class Terrain<br>{<br>public:<br>     Terrain(<br>          IDirect3DDevice9* device,<br>          std::string heightmapFileName,<br>          int numVertsPerRow,<br>          int numVertsPerCol,<br>          int cellSpacing,    // space between cells<br>          float heightScale); // value to scale heights by</p>
<pre><code> ... methods snipped
</code></pre><p>private:<br>     …device/vertex buffer etc snipped</p>
<pre><code> int _numVertsPerRow;
 int _numVertsPerCol;
 int _cellSpacing;

 int _numCellsPerRow;
 int _numCellsPerCol;
 int _width;
 int _depth;
 int _numVertices;
 int _numTriangles;

 float _heightScale;
</code></pre><p>};<br>Terrain类定义的全部的源代码，实在是太多了，无法在这里全部包含进来。根据传递给构造器的值，我们能够计算Terrain类的其他变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_numCellsPerRow  = _numVertsPerRow - <span class="number">1</span>;</span><br><span class="line">_numCellsPerCol  = _numVertsPerCol - <span class="number">1</span>;</span><br><span class="line">_width           = _numCellsPerRow * _cellSpacing;</span><br><span class="line">_depth           = _numCellsPerCol * _cellSpacing;</span><br><span class="line">_numVertices     = _numVertsPerRow * _numVertsPerCol;</span><br><span class="line">_numTriangles    = _numCellsPerRow * _numCellsPerCol * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>Terrain类定义的顶点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TerrainVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     TerrainVertex()&#123;&#125;</span><br><span class="line">     TerrainVertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> u, <span class="keyword">float</span> v)</span><br><span class="line">     &#123;</span><br><span class="line">          _x = x; _y = y; _z = z; _u = u; _v = v;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">     <span class="keyword">float</span> _u, _v;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>   注意：TerrainVertex是Terrain类内部的一个嵌套类（译者：看样子是结构啊？），之所以这么做，是因为它在Terrain类外部基本没有什么用处。<br>13.2.1 计算顶点<br>   在图13.4中，计算三角形网格上的顶点，我们只是在开始产生顶点的地方，一行一行的生成顶点数据，直到结束为止。单元格的顶点与顶点之间有一块空白区域，这会让我们取得x、z坐标，但y坐标是什么呢？得到y坐标很容易，当读取高度图数据结构时会找到对应的入口。<br>   注意：这个操作使用一个巨大的顶点缓存去保存所有地形上的所有顶点。这可能会引起硬件局限性的问题。例如：一个原始计数界限的最大值和3D设备设定的最大的顶点索引界限。检查MaxPrimitiveCount和D3DCAPS9结构的MaxVertexlndex成员，查看你的设备的限定值，在13.7节讨论，使用顶点缓存时存在问题和解决方法。<br>   计算纹理坐标，看图13.5，给我们一个简单的设定，允许我们用(u, v)纹理坐标去对应地形顶点坐标。</p>
<p>   图13.5：地形顶点与纹理顶点之间一一对应。<br>   u = j uCoordIncrementSize<br>   v = i vCoordIncrementSize<br>   And where:</p>
<p>   最后，用代码生成顶点：<br>bool Terrain::computeVertices()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> hr = _device-&gt;CreateVertexBuffer(
      _numVertices * sizeof(TerrainVertex),
      D3DUSAGE_WRITEONLY,
      TerrainVertex::FVF,
      D3DPOOL_MANAGED,
      &amp;_vb,
      0);

 if(FAILED(hr))
      return false;

 // 对应第一个生成的顶点坐标
 int startX = -_width / 2;
 int startZ =  _depth / 2;

 // 对应最后一个生成的顶点坐标
 int endX =  _width / 2;
 int endZ = -_depth / 2;

 // compute the increment size of the texture coordinates
 // from one vertex to the next.
 float uCoordIncrementSize = 1.0f / (float)_numCellsPerRow;
 float vCoordIncrementSize = 1.0f / (float)_numCellsPerCol;

 TerrainVertex* v = 0;
 _vb-&gt;Lock(0, 0, (void**)&amp;v, 0);

 int i = 0;
 for(int z = startZ; z &gt;= endZ; z -= _cellSpacing)
 {
      int j = 0;
      for(int x = startX; x &lt;= endX; x += _cellSpacing)
      {
           // compute the correct index into the vertex buffer
           // and heightmap based on where we are in the nested
           // loop.
           int index = i * _numVertsPerRow + j;

           v[index] = TerrainVertex(
                (float)x,
                (float)_heightmap[index],
                (float)z,
                (float)j * uCoordIncrementSize,
                (float)i * vCoordIncrementSize);

           j++; // next column
      }
      i++; // next row
 }

 _vb-&gt;Unlock();

 return true;
</code></pre><p>}</p>
<p>13.2.2 计算索引-定义三角形<br>   计算三角形网格的索引，只需要循环访问每一个格子，从左上到右下，如图13.4，并且计算组成格子的2个三角形。</p>
<p>这里的技巧是：提取出计算第ij格子的2个三角形的公式。用图13.6去推导公式，找到第ij的格子：</p>
<p>?ABC = {i · numVertsPerRow + j i·numVertsPerRow + j + 1 (i + 1). numVertsPerRow + j}<br>?CBD = {(i + 1) numVertsPerRow + j i·numVertsPerRow + j + 1 (i·l) numVertsPerRow + j + 1} </p>
<p>图13.6 方格的顶点</p>
<p>代码生成索引：<br>bool Terrain::computeIndices()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> hr = _device-&gt;CreateIndexBuffer(
      _numTriangles * 3 * sizeof(WORD), // 每个三角形有3个索引
      D3DUSAGE_WRITEONLY,
      D3DFMT_INDEX16,
      D3DPOOL_MANAGED,
      &amp;_ib,
      0);

 if(FAILED(hr))
      return false;

 WORD* indices = 0;
 _ib-&gt;Lock(0, 0, (void**)&amp;indices, 0);

 // 将组成一个方格的2个三角形的一组6个索引的开始位置编入索引
 int baseIndex = 0;

 // 从头到尾计算每一个格子中的三角形
 for(int i = 0; i &lt; _numCellsPerCol; i++) //行循环
 {
      for(int j = 0; j &lt; _numCellsPerRow; j++) //列循环
      {
           indices[baseIndex]     =   i   * _numVertsPerRow + j;
           indices[baseIndex + 1] =   i   * _numVertsPerRow +
                                                 j + 1;
           indices[baseIndex + 2] = (i+1) * _numVertsPerRow + j;

           indices[baseIndex + 3] = (i+1) * _numVertsPerRow + j;
           indices[baseIndex + 4] =   i   * _numVertsPerRow +
                                                 j + 1;
           indices[baseIndex + 5] = (i+1) * _numVertsPerRow +
                                                 j + 1;

           // next quad
           baseIndex += 6;
      }
 }
 _ib-&gt;Unlock();

 return true;
</code></pre><p>};</p>
<h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>Terrain类提供2个方法去处理地形的纹理。最简单的方法是简单地读取一个已经制作好的纹理文件并使用它，下面的方法使用Terrain类实现将一个文件读取纹理到_tex成员中，然后指向一个IDirect3DTexture9接口的指针。关键是，在地形渲染之前先用Terrain: :draw方法设置_tex。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Terrain::loadTexture(<span class="built_in">std</span>::<span class="built_in">string</span> fileName)</span><br><span class="line">&#123;</span><br><span class="line">     HRESULT hr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     hr = D3DXCreateTextureFromFile(</span><br><span class="line">          _device,</span><br><span class="line">          fileName.c_str(),</span><br><span class="line">          &amp;_tex);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>13.3.1 程序上的处理方法<br>   一个可选择的方法是用程序计算地形的纹理，就是说，我们创建一个空纹理，根据定义的参数用代码计算每一个部分的颜色，在例子中，参数是地形的高度。<br>   我们用Terrain::genTexture方法用程序去生成纹理，首先用D3DXCreateTexture方法创建一个空的纹理，锁定高度级别（top level，纹理图的一个成员，有多个级别），不断的循环每一个texel（图素）并给它上色，texel的颜色取决于与方格对应的高度（近似高度）。我们的想法是：地形中较低的地方是沙滩色，中间的地方像是绿色的小山丘，较高的地方颜色好像雪山。我们定义的高度是方格中左上角的近似高度。<br>   一旦每个texel都有了颜色，我们想让每一个texel变暗或是变亮，这基于光打在格子中对应的texel上的角度，由Terrain::lightTerrain方法实现。（Once we have a color for each texel, we want to darken or brighten each texel based on the angle at which sunlight (modeled by a directional light) strikes the cell to which the texel corresponds. This is done in the Terrain::lightTerrain method）<br>   Terrain::genTexture方法通过计算lower mipmap级别的texels来得出结论，它是通过D3DXFilterTexture函数实现。用代码生成纹理：<br>bool Terrain::genTexture(D3DXVECTOR3* directionToLight)<br>{<br>     // Method fills the top surface of a texture procedurally. Then<br>     // lights the top surface. Finally, it fills the other mipmap<br>     // surfaces based on the top surface data using<br>     // D3DXFilterTexture.</p>
<pre><code> HRESULT hr = 0;

 // texel for each quad cell
 int texWidth  = _numCellsPerRow;
 int texHeight = _numCellsPerCol;

 // create an empty texture
 hr = D3DXCreateTexture(
      _device,
      texWidth, texHeight,  // dimensions
      0,                    // create a complete mipmap chain
      0,                    // usage - none
      D3DFMT_X8R8G8B8,      // 32-bit XRGB format
      D3DPOOL_MANAGED,      // memory pool
      &amp;_tex);

 if(FAILED(hr))
      return false;

 D3DSURFACE DESC textureDesc;
 _tex-&gt;GetLevelDesc(0 /*level*/, &amp;textureDesc);

 // make sure we got the requested format because our code
 // that fills the texture is hard coded to a 32-bit pixel depth.
 if( textureDesc.Format != D3DFMT_X8R8G8B8 )
      return false;

 D3DLOCKED_RECT lockedRect;
 _tex-&gt;LockRect(0/*lock top surface*/, &amp;lockedRect,
       0 /* lock entire tex*/, 0/*flags*/);

 // fill the texture
 DWORD* imageData = (DWORD*)lockedRect.pBits;
 for(int i = 0; i &lt; texHeight; i++)
 {
      for(int j = 0; j &lt; texWidth; j++)
      {
      D3DXCOLOR c;

      // get height of upper-left vertex of quad.
      float height = (float)getHeightmapEntry(i, j)/_heightScale;

      // set the color of the texel based on the height
      // of the quad it corresponds to.
      if( (height) &lt; 42.5f )       c = d3d::BEACH SAND;
      else if( (height) &lt; 85.0f )  c = d3d::LIGHT YELLOW GREEN;
      else if( (height) &lt; 127.5f ) c = d3d::PUREGREEN;
      else if( (height) &lt; 170.0f ) c = d3d::DARK YELLOW GREEN;
      else if( (height) &lt; 212.5f ) c = d3d::DARKBROWN;
      else                         c = d3d::WHITE;

      // fill locked data, note we divide the pitch by four
      // because the pitch is given in bytes and there are
      // 4 bytes per DWORD.
      imageData[i * lockedRect.Pitch / 4 + j] = (D3DCOLOR)c;
      }
 }

 _tex-&gt;UnlockRect(0);

 // light the terrain
 if(!lightTerrain(directionToLight))
 {
       ::MessageBox(0, &quot;lightTerrain() - FAILED&quot;, 0, 0);
       return false;
 }

 // fill mipmaps
 hr = D3DXFilterTexture(
      _tex,// texture to fill mipmap levels
      0,   // default palette
       0,   // use top level as source for lower levels
       D3DX_DEFAULT); // default filter

 if (FAILED (hr))
 {
       ::MessageBox(0, &quot;D3DXFilterTexture() - FAILED&quot;, 0, 0);
       return false;
 }

 return true;
</code></pre><p>}</p>
<p>注意：颜色常量BEACH_SAND等定义在d3dUtility.h.文件中。</p>
<p>13.4 光照<br>   Terrain::genTexture方法会调用Terrain::lightTerrain，顾名思义，光照使地形更接近于现实。当我们已经计算完地形纹理以后，我们只需要计算阴影系数（shade factor），使一个定义了光源的地形区域变亮或变暗。在这一节中，我们检验这样一个技巧，你会惊讶于为什么我们照亮地图却没有让Direct3D来做。我们自己来计算有三个好处：</p>
<ul>
<li>内存中不必保存顶点法线。</li>
<li>因为纹理是静态的，所以不能随意的移动光源。虽然我们可以重新计算光源，但因此采用Direct3D实时的照亮地形是很耗时的。</li>
<li>我们获得了一些数学上的经验，熟悉了一些基本的光照概念，并且是用Direct3D函数实践的。</li>
</ul>
<p>13.4.1概览(OVERVIEW)<br>   光照是计算地形阴影（shade）的一个最基本的技巧之一，一般认为的光是漫射光（diffuse lighting），我们定义一个平行光源，指定光的方向，延着光线的相反方向是散发平行光的光源。因此，如果我们想让光线从空中笔直落下，那么lightRaysDirection = (0, -1, 0)，按相反的方向：directionToLight = (0, 1, 0)。注意：创建光照向量要使用单位向量。<br>   注意：虽然指定方向的光是从光源发射出来的，这么说更直接一点，指定方向的光在计算上要比漫谢光更合得来。<br>   对于地形中的每个方格，我们计算光的向量与方格的面法线之间的角度。<br>   在图13.7中我们看到，当角度变得比较大时，方格的面离光源越来越远，接收的光越少。反过来说，角度变小，方格的面则离光源越来越近，相应的会接收更多的光。注意：一旦光向量与法线角度大于90度，表面就接收不到光。</p>
<p>   图13.7 光向量与平面法线的关系，我们能够创建一个阴影（shading） 标量，用0..1之间的范围来表示表面能接收到光的多少。使用阴影标量，角度大则标量接近于0。当颜色与一个阴影标量接近0的值相乘时，得到的结果是：颜色变暗。相反，乘以一个阴影标量的值接近1的值时，颜色则接近于原始亮度。</p>
<p>13.4.2 计算方格的阴影（Shade）<br>   光源的方向是一个单位向量，为了计算光源方向与面法线间的夹角，首先需要找到面法线，这是叉积的一小部分应用，但首先必须在方格里找到二个共面的非0并且不平行的向量。看图 13.8有两个这样的向量：</p>
<p>   图13.8: 计算在同一方格中的共面的二个向量</p>
<p>u = (cellSpacing, by - ay, 0)<br>v = (0, cy, -ay, -cellSpacing) </p>
<p>关于u和v，方格的法线N = u × v，当然要把N标准化：</p>
<p>找到光线与法线的夹角，回忆一下点积，是二个3维空间中的单位向量组成的夹角的余弦。</p>
<p>   它的标量是在-1..1的范围，因为-1..0的sin值符合夹角角度且大于90度，在图13.7中接受不到光照，如果它在-1..0之间那么夹角是0度。<br>float cosine = D3DXVec3Dot(&amp;n, directionToLight);</p>
<p>if(cosine &lt; 0.0f)<br>     cosine = 0.0f;</p>
<p>   现在s的夹角大于90度，s的阴影标量将在0..1之间。因为光线与法线的角度从0增加到90度时，s的值将从1到降到0。这是我们想要的结果，具体讲解请看13.4.1节。<br>   给指定的格子计算阴影系数用Terrain::computeShade方法，它需要参数：行和列来确定方格，还有平行方向光的光源。<br>float Terrain::computeShade(int cellRow, int cellCol,<br>                            D3DXVECTOR3* directionToLight)<br>{<br>     // 取得方格中三个顶点的高度（从高度图中）<br>     float heightA = getHeightmapEntry(cellRow,   cellCol);<br>     float heightB = getHeightmapEntry(cellRow,   cellCol+1);<br>     float heightC = getHeightmapEntry(cellRow+1, cellCol);</p>
<pre><code> // 创建方格中的二个顶点
 D3DXVECTOR3 u( cellSpacing, heightB - heightA, 0.0f);
 D3DXVECTOR3 v(0.0f, heightC - heightA, - cellSpacing);

 //用方格中的二个向量的叉积找到面法线
 D3DXVECTOR3 n;
 D3DXVec3Cross(&amp;n, &amp;u, &amp;v);
 D3DXVec3Normalize(&amp;n, &amp;n);

 float cosine = D3DXVec3Dot(&amp;n, directionToLight);

 if(cosine &lt; 0.0f)
      cosine = 0.0f;

 return cosine;
</code></pre><p>}</p>
<p>13.4.3 地形阴影（Shading）<br>   一旦知道了如何给指定的方格加阴影，我们就能给地形上所有的方格加阴影。只要遍例每一个方格，计算方格的阴影值，并测量方格对应的texel颜色。光照少则方格会变暗。下面一段代码展示了Terrain::lightTerrain方法的重要部分：</p>
<p>DWORD<em> imageData = (DWORD</em>)lockedRect.pBits;<br>for(int i = 0; i &lt; textureDesc.Height; i++)<br>{<br>     for(int j = 0; j &lt; textureDesc.Width; j++)<br>     {<br>          int index = i * lockedRect.Pitch / 4 + j;</p>
<pre><code>      // get current color of cell
      D3DXCOLOR c( imageData[index] );

      // shade current cell
      c *= computeShade(i, j, lightDirection);;

      // save shaded color
      imageData[index] = (D3DCOLOR)c;
 }
</code></pre><p>}</p>
<p>13.5 在地形上“行走”<br>   构造了一个地形以后，我们想要有移动照相机的能力，以便模拟在地形上行走的效果。我们需要调整照相机的高度，这依赖于地形部分的知识，好的，我们继续往下看。我们首先需要找到照相机所在的方格的位置，并给出x轴和z轴坐标，Terrain::getHeight函数能做到这些，它能提供x轴、y轴坐标参数，返回照相机需要被设置在地形上的高度值，现在看实现部分。<br>float Terrain::getHeight(float x, float z)<br>{<br>     // Translate on xz-plane by the transformation that takes<br>     // the terrain START point to the origin.<br>     x = ((float) width / 2.0f) + x;<br>     z = ((float) depth / 2.0f) - z;</p>
<pre><code> // Scale down by the transformation that makes the
 // cellspacing equal to one. This is given by
 // 1 / cellspacing since cellspacing * 1 / cellspacing = 1.
 x /= (float) cellSpacing;
 z /= (float)_cellSpacing;
</code></pre><p>   我们首先转换地形的起始点为原点，然后，我们按反方向去测量空间变量（we scale by the inverse of the cell spacing variable），设置单元空间间隔为1。我们切换到一个新的参考框架，z轴正方向是向下的。当然，没有代码转换参考框架，但现在我们知道+z是向下的。图13.9显示了这些步骤：</p>
<p>图13.9：地形网格在转换前的第一个点，转换后为原点。单元格的空间为1，转换z轴。<br>我们看到我们转换的坐标系统与矩阵的行和列相对应，也就是说左上为原点，列数的增加向右，行数的增加向下。因此，在图13.9中我们知道了单元格的空间是1，通过以下的方法我们马上就能得到单元格行和列：<br>float col = ::floorf(x);<br>float row = ::floorf(z);</p>
<p>换句话说，在x轴部分列是整数，z轴部分行也是整数。回忆floor(t)函数，。<br>现在我们将取得方格的四个顶点的高度。<br>        //  A   B<br>        //  <em>—</em><br>        //  | / |<br>        //  <em>—</em><br>        //  C   D<br>float A = getHeightmapEntry(row,   col);<br>float B = getHeightmapEntry(row,   col+1);<br>float C = getHeightmapEntry(row+1, col);<br>float D = getHeightmapEntry(row+1, col+1);</p>
<p>   现在我们知道了方格的四个顶点的高度，我们需要找到照相机所在的位置的方格的高度，因为一个方格可能同时向几个方向倾斜，这可能会稍微难一点，见图 13.10:</p>
<p>图13.10: 照相机所在的位置的方格的高度<br>   为了找到高度，我们需要知道我们在方格中的哪个三角形里。方格是由二个三角形渲染成的，找到我们所在的三角形，我们要取得我们所在的方格并且转换它，它的左上点是原点。<br>   自从用行和列来描述我们所在的方格左上顶点的位置以来，我们必须转换列x轴与行z轴，转换x、z坐标：<br>   float dx = x - col;<br>   float dz = z - row;</p>
<p>图13.11: 我们所在的方格在转换前与转换后，左上顶点变成了原点。<br>   .现在解释当我们在方格中的上三角形时如何找到高度，这和在下三角形是相似的。马上你会看到这两种情况的代码。在上三角形时，构造2个向量：u = (cellSpacing, B -A, 0) and v = (0, C - A, - cellSpacing)，三角形的边上并且在矢量q = (qx, A, qz)终点点开始的地方，如图13.12(a)。</p>
<p>   图13.12 (a) 计算三角形的邻边和对边这两个向量。 (b)使用线性差值创建高度<br>   注意：我们只关心改变的高度值，我们只修改y值，忽视其他部分，因此，Height=sum A + dxuy + dzvy<br>   以下是Terrian::getHeight函数的实现代码：<br>   （Note that since we are only concerned about the interpolated height value, we can just interpolate the y-components and ignore the other components. Thus, the height is obtained by the sum A + dxuy + dzvy.）<br>if(dz &lt; 1.0f - dx) // upper triangle ABC<br>     {<br>          float uy = B - A; // A-&gt;B<br>          float vy = C - A; // A-&gt;C</p>
<pre><code>      height = A + d3d::Lerp(0.0f, uy, dx) +
                   d3d::Lerp(0.0f, vy, dz) ;
 }
 else // lower triangle DCB
 {
      float uy = C - D; // D-&gt;C
      float vy = B - D; // D-&gt;B

      height = D + d3d::Lerp(0.0f, uy, 1.0f - dx) +
                   d3d::Lerp(0.0f, vy, 1.0f - dz);
 }    return height;
</code></pre><p>}</p>
<p>   Lerp函数是一个沿着一维直线的基本线性插值算法，实现如下：<br>float d3d::Lerp(float a, float b, float t)<br>{<br>     return a - (a<em>t) + (b</em>t);<br>}</p>
<p>13.6 例子程序: Terrain<br>   这章的例子是用一个包含高度信息的RAW文件创建一个地形，纹理和光源。用方向键在地形上行走。注意，下列函数中不相关的代码被省略了，被省略的代码用(…)表示，依赖你的硬件，这个例子可能运行得很慢，请偿试运行一个小地形。<br>   首先，增加全局变量：地形、照相机、每秒帧数。<br>Terrain<em> TheTerrain = 0;<br>Camera   TheCamera(Camera::LANDOBJECT);<br>FPSCounter</em> FPS = 0;</p>
<p>   下面是框架函数：<br>bool Setup()<br>{<br>     D3DXVECTOR3 lightDirection(0.0f, -1.0f, 0.0f);<br>     TheTerrain = new Terrain(Device, “coastMountain256.raw”,<br>                              256, 256, 10, 1.0f);<br>     TheTerrain-&gt;genTexture();<br>     TheTerrain-&gt;lightTerrain(&amp;directionToLight);<br>     …</p>
<pre><code> return true;
</code></pre><p>}</p>
<p>void Cleanup()<br>{<br>     d3d::Delete<terrain*>(TheTerrain);<br>     d3d::Delete<fpscounter*>(FPS);<br>}</fpscounter*></terrain*></p>
<p>bool Display(float timeDelta)<br>{<br>     if( Device )<br>     {<br>          // Update the scene:<br>          …[snipped input checking]</p>
<pre><code>      // Walking on the terrain: Adjust camera&#39;s height so we
      // are standing 5 units above the cell point we are
      // standing on.
      D3DXVECTOR3 pos;
      TheCamera.getPosition(&amp;pos);

      float height = TheTerrain-&gt;getHeight( pos.x, pos.z );

      pos.y = height + 5.0f;

      TheCamera.setPosition(&amp;pos);

      D3DXMATRIX V;
      TheCamera.getViewMatrix(&amp;V);
      Device-&gt;SetTransform(D3DTS VIEW, &amp;V);

      // Draw the scene:
      Device-&gt;Clear(0, 0, D3DCLEAR TARGET | D3DCLEAR ZBUFFER,
                    0xff000000, 1.0f, 0);
      Device-&gt;BeginScene();

      D3DXMATRIX I;
      D3DXMatrixIdentity(&amp;I);

      if( TheTerrain )
          TheTerrain-&gt;draw(&amp;I, false);

      if( FPS )
          FPS-&gt;render(0xffffffff, timeDelta);

      Device-&gt;EndScene();
      Device-&gt;Present(0, 0, 0, 0);
 }
 return true;
</code></pre><p>}</p>
<p>13.7 一些改进<br>   Terrain读取顶点数据到一个很大的缓存，在多重的顶点缓存中划分地形结构，在速度和可测量性方面都十分有利。为我们提出一个问题：顶点缓存最大支持多大？回答是，这依赖于你的硬件。所以你必须先检测。<br>   将地图划分为许多小的顶点缓存是重要的练习，然后将类似矩阵的数据结构编入索引，并且管理数据，这不需要引入新的概念。我们不必详细讨论它。简单的说，你基本上站在地形中一个我们叫做“blocks”的矩阵上,每个block是地形的一个矩形区域。另外，每个block区域（在它自己的顶点索引缓存中）的下方包含地形中的几何信息，为了画它在地形中的位置。<br>   另外，你可以读取地形到一个很大的ID3DXMesh接口。使用D3D函数D3DXSplitMesh划分地形为许多小的Mesh, 以下是D3DXSplitMesh函数原型：<br>void D3DXSplitMesh(<br>    const LPD3DXMESH pMeshIn,<br>    const DWORD <em>pAdjacencyIn,<br>    const DWORD MaxSize,<br>    const DWORD Options,<br>    DWORD </em>pMeshesOut,<br>    LPD3DXBUFFER <em>ppMeshArrayOut,<br>    LPD3DXBUFFER </em>ppAdjacencyArrayOut,<br>    LPD3DXBUFFER <em>ppFaceRemapArrayOut,<br>    LPD3DXBUFFER </em>ppVertRemapArrayOut<br>);<br>       这个函数将一个源Mesh划分多个小的Mesh,，pMeshIn参数是一个指针，指向想划分的Mesh，pAdjacencyIn指向一个邻接数组，MaxSize参数指定作为结果返回的最大顶点数，为返回的Meshe使用指定的创建标记，pMeshesOut参数返回ppMeshArrayOut数组中的Mesh数量，最后3个参数是可选的（可以指定为null），返回邻接信息的数组。<br>13.8 摘要</p>
<ul>
<li>我们能用三角形网格和不同的高度值来模拟地形，创建山丘、河流。</li>
<li>Heightmap数据包含地形顶点的高度值。</li>
<li>我们能通过程序使用磁盘上的图像文件生成地形上的纹理。</li>
<li>我们能照亮地形，通过计算阴影系数来使每个格子变亮或变暗，阴影系数是由光照在格子上的角度决定的。</li>
<li>使照相机在地形上走动，我们需要找到我们站立的三角形。我们计算三角形上的邻边和对边这两个向量，高度是通过…（线性插值在这些向量中每个使用x、z对应的单位向量，以左高顶点为原点为参数。）找到的。<br>（The height is then found by linearly interpolating on each of these vectors using the x- and z-coordinates in a normalized cell with an upper-left vertex at the origin as parameters.）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Building-a-Flexible-Camera-Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Building-a-Flexible-Camera-Class/" class="post-title-link" itemprop="url">第十一章 网格模型II(Building a Flexible Camera Class)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:17:21" itemprop="dateCreated datePublished" datetime="2019-04-11T15:17:21+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Building-a-Flexible-Camera-Class/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Building-a-Flexible-Camera-Class/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ID3DXBuffer"><a href="#ID3DXBuffer" class="headerlink" title="ID3DXBuffer"></a>ID3DXBuffer</h1><p>　　对ID3DXBuffer接口的一些参考是在上一章，这里我们不会详细讲解。在D3DX库中到处都能看见这个接口，因此大概介绍一下该接口还是很有必要的。<br>　　ID3DXBuffer接口是一个很普通的数据结构， D3DX用它将数据存储到邻接内存块中。它只有两个方法：</p>
<ul>
<li>LPVOID GetBufferPointer()——返回一个指向开始数据的指针。</li>
<li>DWORD GetBufferSize()——返回在缓存中的字节大小。<br> 为了保持结构特性，它使用一个空指针。也就是说它让我们知道被存储的数据的类型。例如，D3DXLoadMeshFromX使用一个ID3DXBuffer来返回mesh的邻接信息。因为邻接信息是被存储在DWORD数组中的，所以当我们希望使用缓存中的邻接信息时，我们不得不将缓存转换为DWORD数组。<br>　　例如：<br>DWORD<em> info =(DWORD</em>)adjacencyInfo-&gt;GetBufferPointer();<br>D3DXMATERIAL<em> mtrls = (D3DXMATERIAL</em>)mtrlBuffer-&gt;GetBufferPointer();<br>　　因为ID3DXBuffer是一个COM对象，当你使用完以后就必须释放它以防止内存泄漏：<br>adjacencyInfo-&gt;Release();<br>mtrlBuffer-&gt;Release();<br>　　我们能够使用下面的方法来创建一个空的ID3DXBuffer：<br>HRESULT D3DXCreateBuffer(<br>  DWORD NumBytes, // Size of the buffer, in bytes.<br>  LPD3DXBUFFER <em>ppBuffer // Returns the created buffer.<br>);<br>　　下面的例子是创建一个能包含4个整数的缓存：<br>ID3DXBuffer</em> buffer = 0;<br>D3DXCreateBuffer( 4 <em> sizeof(int), &amp;buffer );<br>11.2 X文件<br> 迄今为止，我们已经使用过了简单的几何物体，如球体，圆柱体，立方体等，它们都是用D3DXCreate</em>函数来创建的。假如你想通过手工指定顶点来创建你自己的3D物体，你能，不用怀疑，不过这是非常枯燥乏味的事情。为了减轻建造3D物体数据的工作，专门的应用程序已经被开发出来了，我们把它们叫做3D建模工具。它们允许我们在一个虚拟的拥有丰富工具的交互环境下建造复杂的真实的mesh，在这建造这些模型都是非常容易的。例如在游戏开发中常用到的有3DSMax（www.discreet.com）,LightWave 3D（www.newtek.com）,以及Maya（www.aliaswavefront.com）。<br> 这些工具，当然能够输出创建好的mesh数据到文件中。因此，我们也能够写一个文件来提取在我们的3D应用程序中要用到的mesh数据。这的确是一种可行的解决办法。不过，还存在一个更方便的解决方案。它是一种叫做X文件的特殊mesh文件格式（扩展名为.X）。很多3D建模软件都能输出这种格式，当然这里存在一个将其他流行的mesh文件转换为X文件的过程。是什么使X文件这么便利呢？因为它是DirectX定义的格式，并且D3DX库很容易地支持X文件。D3DX库提供了读和写X文件的函数。因此，如果我们使用这种格式就避免了还要自己写程序文件来读/写模型文件了。<br> 注意：你能够下载DirectX9 SDK Extra——你能从MSDN（www.msdn.microsoft.com）上得到一些已经开发好的针对3DMax,LightWave,Maya软件导出.X文件的Direct3D工具包。<br>11.2.1读取X文件<br> 我们使用下面的函数来读取存储在X文件中的mesh数据。注意这个方法创建一个ID3DXMesh对象，且从X文件中读取几何信息数据填入其中。<br>HRESULT D3DXLoadMeshFromX(<br>  LPCSTR pFilename,<br>  DWORD Options,<br>  LPDIRECT3DDEVICE9 pDevice,<br>  LPD3DXBUFFER <em>ppAdjacency,<br>  LPD3DXBUFFER </em>ppMaterials,<br>  LPD3DXBUFFER<em> ppEffectInstances,<br>  PDWORD pNumMaterials,<br>  LPD3DXMESH </em>ppMesh<br>);</li>
<li>pFilename — 读取的X文件的文件名。</li>
<li>Options — 用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</li>
<li>D3DXMESH_32BIT — mesh使用32位索引。</li>
<li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li>
<li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li>
<li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li>
<li>pDevice — 与复制mesh有关的设备。</li>
<li>ppAdjacency — 返回一个ID3DXBuffer包含一个DWORD数组，描述mesh的邻接信息。</li>
<li>ppMaterials — 返回一个ID3DXBuffer包含一个D3DXMATERIAL结构的数组，存储了mesh的材质数据。我们在下一节介绍mesh材质。</li>
<li>ppEffectInstances — 返回一个ID3DXBuffer包含一个D3DXEFFECTINSTANCE结构的数组。我们现在通过指定0值来忽略这个参数。</li>
<li>pNumMaterials — 返回mesh的材质数。</li>
<li>ppMesh — 返回填充了X文件几何信息的ID3DXMesh对象。<br>11.2.2 X文件的材质<br>　　D3DXLoadMeshFromX的第七个参数返回的是mesh包含的材质数，第五个参数返回的是包含着材质数据的一个D3DXMATERIAL结构数组。D3DXMATERIAL结构的定义如下：<br>typedef struct D3DXMATERIAL {<br>  D3DMATERIAL9 MatD3D;<br>  LPSTR pTextureFilename;<br>} D3DXMATERIAL;<br>　　这是一个简单的结构；它包含一个基本的D3DMATERAIL9结构和一个用来指定与之相关联的纹理文件名的一个以null结束的字符串指针。一个X文件是不能插入纹理数据的；它只能插入文件名。因此，在使用D3DXLoadMeshFromX读取一个X文件以后，我们还必须从纹理文件中读取纹理数据。我们将在下一节中说明怎样具体实现。<br>　　D3DXLoadMeshFromX函数读取X文件数据以便在返回的D3DXMATERIAL数组中的第i项与第i个子集相对应。因此，子集是使用0，1，2，…，n-1标记的，n是子集和材质的数目。这也就允许使用简单的循环来渲染mesh了。<br>11.2.3 实例程序：X文件<br>　　我们现在演示本章中的第一个实例（X文件）的相关代码。该例子调用一个叫做bigship1.x的x文件，你可以在DirectX SDK下的media文件夹下找到它。完整原代码可以在相应的文件中找到。图11.1是该实例的一个截图。</li>
</ul>
<p>图11.1<br>　　该实例使用下面的全局变量：<br>ID3DXMesh<em>                      Mesh = 0;<br>std::vector<d3dmaterial9>       Mtrls(0);<br>std::vector&lt;IDirect3DTexture9</d3dmaterial9></em>&gt; Textures(0);<br>   这里有一个ID3DXMesh对象，它被用来存储从X文件中读取的mesh数据。也有一个材质vector和纹理vector,我们用它们来分别存储mesh的材质和纹理。<br>　　我们首先在Setup函数中操作。首先，我们读取X文件：<br>bool Setup()<br>{<br>    HRESULT hr = 0;<br>    //<br>    // Load the XFile data.<br>    //<br>    ID3DXBuffer<em> adjBuffer  = 0;<br>    ID3DXBuffer</em> mtrlBuffer = 0;<br>    DWORD        numMtrls   = 0;<br>    hr = D3DXLoadMeshFromX(<br>        “bigship1.x”,<br>        D3DXMESH_MANAGED,<br>        Device,<br>        &amp;adjBuffer,<br>        &amp;mtrlBuffer,<br>        0,<br>        &amp;numMtrls,<br>        &amp;Mesh);<br>    if(FAILED(hr))<br>    {<br>        ::MessageBox(0, “D3DXLoadMeshFromX() - FAILED”, 0, 0);<br>        return false;<br>     }<br>　　读取完X文件数据以后，我们必须遍历D3DXMATERIAL数组来读取mesh中所使用的所有纹理：<br>    //<br>    // Extract the materials, and load textures.<br>    //<br>    if( mtrlBuffer != 0 &amp;&amp; numMtrls != 0 )<br>    {<br>        D3DXMATERIAL<em> mtrls = (D3DXMATERIAL</em>)mtrlBuffer-&gt;GetBufferPointer();<br>        for(int i = 0; i &lt; numMtrls; i++)<br>        {<br>            // the MatD3D property doesn’t have an ambient value set<br>            // when its loaded, so set it now:<br>            mtrls[i].MatD3D.Ambient = mtrls[i].MatD3D.Diffuse;<br>            // save the ith material<br>            Mtrls.push_back( mtrls[i].MatD3D );<br>            // check if the ith material has an associative texture<br>            if( mtrls[i].pTextureFilename != 0 )<br>            {<br>                // yes, load the texture for the ith subset<br>                IDirect3DTexture9<em> tex = 0;<br>                D3DXCreateTextureFromFile(<br>                    Device,<br>                    mtrls[i].pTextureFilename,<br>                    &amp;tex);<br>                // save the loaded texture<br>                Textures.push_back( tex );<br>            }<br>            else<br>            {<br>                // no texture for the ith subset<br>                Textures.push_back( 0 );<br>            }<br>        }<br>    }<br>　　d3d::Release&lt;ID3DXBuffer</em>&gt;(mtrlBuffer); // done w/ buffer<br>    .<br>    . // Snipped irrelevant code to this chapter (e.g., setting up lights,<br>    . // view and projection matrices, etc.)<br>    .<br>    return true;<br>} // end Setup()<br>　　在Display函数中我们让mesh在每一帧中都旋转一个小角度。我们使用简单的循环，Mesh便能够被渲染了：<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        //<br>        // Update: Rotate the mesh.<br>        //</p>
<pre><code>    static float y = 0.0f;
    D3DXMATRIX yRot;
    D3DXMatrixRotationY(&amp;yRot, y);
    y += timeDelta;

    if( y &gt;= 6.28f )
        y = 0.0f;

    D3DXMATRIX World = yRot;

    Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);

    //
    // Render
    //

    Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
    Device-&gt;BeginScene();

    for(int i = 0; i &lt; Mtrls.size(); i++)
    {
        Device-&gt;SetMaterial( &amp;Mtrls[i] );
        Device-&gt;SetTexture(0, Textures[i]);
        Mesh-&gt;DrawSubset(i);
    }   

    Device-&gt;EndScene();
    Device-&gt;Present(0, 0, 0, 0);
}
return true;
</code></pre><p>}<br>11.2.4 产生顶点法线<br>   一个X文件不包含顶点法线数据，这是很有可能的。假如是这种情况，那么手动计算顶点法线以便我们能够使用灯光这是很有必要的。在第5章中我们简要的介绍了一下怎么做。然而，现在我们知道了ID3DXMesh接口和它的父接口ID3DXBaseMesh，我们能够使用下面的函数来产生任何mesh的顶点法线：<br>HRESULT D3DXComputeNormals(<br>    LPD3DXBASEMESH pMesh, // Mesh to compute normals of.<br>    const DWORD <em>pAdjacency // Input adjacency info.<br>);<br>   这个函数通过使用平均法线的方法来产生顶点法线。假如有邻接信息，那么重复的顶点是被忽略的。假如没有邻接信息，那么重复的顶点也会被重复计算。了解这些是很重要的，我们检查pMash必须有一个包含D3DFVF_NORMAL标记的顶点格式。<br>   注意假如X文件不包含顶点法线数据，那么通过D3DXLoadMeshFromX创建的ID3DXMesh对象在它的顶点格式中没有指定的D3DFVF_NORMAL标记。因此，在我们能够使用D3DXComputeNormals之前，我们必须复制mesh并且为其指定包含D3DFVF_NORMAL的顶点格式。下面就是相应的代码：<br>// does the mesh have a D3DFVF_NORMAL in its vertex format?<br>if ( !(pMesh-&gt;GetFVF() &amp; D3DFVF_NORMAL) )<br>{<br>    // no, so clone a new mesh and add D3DFVF_NORMAL to its format:<br>    ID3DXMesh</em> pTempMesh = 0;<br>    pMesh-&gt;CloneMeshFVF(<br>        D3DXMESH_MANAGED,<br>        pMesh-&gt;GetFVF() | D3DFVF_NORMAL, // add it here<br>        Device,<br>        &amp;pTempMesh );</p>
<pre><code>// compute the normals:
D3DXComputeNormals( pTempMesh, 0 );

pMesh-&gt;Release(); // get rid of the old mesh
pMesh = pTempMesh; // save the new mesh with normals
</code></pre><p>}<br>11.3渐进网格（Progressive Meshes）<br>   渐进网格，它通过ID3DXPMesh接口来表现，允许我们通过简化边缩减转换（edge collapse transformations，ECT）来简化mesh。每执行一次ECT就移除一个顶点和一或2个面。因为每个ECT是可逆的（它的逆过程叫顶点分裂），我们能够逆转简化过程并且恢复mesh为它的原始状态。当然，我们不可能得到比原始情况还要精细的网格。我们仅仅只能简化然后恢复简化操作。图11.2显示了同一个mesh的三种不同精细级别（levels of detail，LOD）：高，中，低。</p>
<p>图11.2<br>   渐进网格和mipmaps纹理非常相似。当使用纹理时，我们已经注意到在一个小或远的图元上使用高分辨率的纹理简直就是浪费。对于mesh也是同样的道理；一个小或远的mesh不需要太多三角形，多了也是浪费。因此，我们不会花费渲染高三角形模型的时间来渲染一个只需要表现小的低三角形模型。<br>   我们可以使用渐进网格来根据模型距离摄象机的距离来调整模型的LOD。也就是说，当距离减少时，我们增加mesh的细节，当距离增加时我们减少mesh的细节。<br>   注意我们还没有讨论渐进网格是怎样被实现的；这里我们只讲解怎样使用ID3DXPMesh接口。对此感兴趣的读者可以到渐进网格的原始页面Hoppe上查看。Hoppe的网址：<a href="http://research.microsoft.com/~hoppe/。" target="_blank" rel="noopener">http://research.microsoft.com/~hoppe/。</a><br>11.3.1 产生一个渐进网格<br>   我们能够使用下面的函数来创建一个ID3DXPMesh对象：<br>HRESULT D3DXGeneratePMesh(<br>    LPD3DXMESH pMesh,<br>    CONST DWORD <em>pAdjacency,<br>    CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,<br>    CONST FLOAT </em>pVertexWeights,<br>    DWORD MinValue,<br>    DWORD Options,<br>    LPD3DXPMESH *ppPMesh<br>);</p>
<ul>
<li>pMesh— 输入原始mesh，它包含了我们想要生成的渐进网格的mesh数据。</li>
<li>pAdjacency — 指向一个包含pMesh邻接信息的DWORD数组。</li>
<li>pVertexAttributeWeights — 指向一个D3DXATTRIBUTEWEIGHTS数组，它的大小是pMesh-&gt;GetNumVertices（）。它的第i项与pMesh中的第i个顶点相对应并且指定的是它的品质权重。品质权重被用来确定一个顶点被删除的可能性大小。你能够将此参数设置为null，对于每个顶点一个默认的顶点品质权重将被设置。在11.3.2节中有关于顶点品质权重和D3DXATTRIBUTEWEIGHTS结构的更多信息。</li>
<li>pVertexWeights — 指向一个float数组，它的大小是pMesh-&gt;GetNumVertices（），它的第i项与pMesh中的第i个顶点相对应并且指定的是它的顶点权重。顶点权重越高被删除的可能性越小。你能够将此参数设置为null，对于每个顶点一个默认的顶点品质权重1.0将被设置。</li>
<li>MinValue — 我们想要简化到的最小顶点或面数。注意该值是必须的，而且与顶点/品质权重有关，最终可能达不到该值。</li>
<li>Options — 只能取D3DXMESHSIMP枚举类型中的一个值：</li>
<li>D3DXMESHSIMP_VERTEX — 指定在上一个参数MinValue中提到的数为顶点数。</li>
<li>D3DXMESHSIMP_FACE —指定在上一个参数MinValue中提到的数为面数。</li>
<li><p>ppPMesh — 返回生成好的渐进网格。<br>11.3.2 顶点品质权重<br>typedef struct _D3DXATTRIBUTEWEIGHTS {<br>  FLOAT Position;<br>  FLOAT Boundary;<br>  FLOAT Normal;<br>  FLOAT Diffuse;<br>  FLOAT Specular;<br>  FLOAT Texcoord[8];<br>  FLOAT Tangent;<br>  FLOAT Binormal;<br>} D3DXATTRIBUTEWEIGHTS;<br>　　顶点权重结构允许我们为每个顶点属性指定一个权值。0.0表示该属性没有权重。顶点属性的权重越高在简化过程中被移除的可能性越小。默认的权值如下：<br>D3DXATTRIBUTEWEIGHTS AttributeWeights;<br>AttributeWeights.Position = 1.0;<br>AttributeWeights.Boundary = 1.0;<br>AttributeWeights.Normal = 1.0;<br>AttributeWeights.Diffuse = 0.0;<br>AttributeWeights.Specular = 0.0;<br>AttributeWeights.Tex[8] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};<br>　　默认的权值是被推荐的，除非你的应用程序有一个重要的理由而不使用它。<br>11.3.3 ID3DXPMesh方法<br> ID3DXPMesh接口是继承自ID3DXBaseMesh接口。因此它拥有以前所学习过的ID3DXMesh的所有函数，下面是一些额外的方法：<br>DWORD GetMaxFaces(VOID)——返回渐进网格能够被设置的最大面数。<br>DWORD GetMaxVertices(VOID)——返回渐进网格能够被设置的最大顶点数。<br>DWORD GetMinFaces(VOID)——返回渐进网格能够被设置的最小面数。<br>DWORD GetMinVertices(VOID)——返回渐进网格能够被设置的最小顶点数。<br>HRESULT SetNumFaces(DWORD Faces)——这个方法允许我们设置面的个数，以便让mesh简化/复杂化。例如，假设mesh目前有50个面，我们现在想将它简化到30个面；我们将写成：<br>pmesh-&gt;SetNumFaces(30);<br> 注意调整后的面数可能并不是我们设定的面数。假如面数小于了GetMinFaces（），那么面数将为GetMinFaces（）。同样的，假如面数大于了GetMaxFaces（），那么面数将为GetMaxFaces（）。<br>HRESULT SetNumVertices(DWORD Vertices)——这个方法允许我们设置顶点的个数，以便让mesh简化/复杂化。例如，假设mesh目前有20个顶点，我们现在想将它增加到40个；我们将写成：<br>pmesh-&gt;SetNumVertices(40);<br> 注意调整后的顶点数可能并不是我们设定的数。假如顶点数小于了GetMinVertices（），那么顶点数将为GetMinVertices（）。同样的，假如顶点数大于了GetMaxVertices（），那么顶点数将为GetMaxVertices（）。<br>HRESULT TrimByFaces(<br>DWORD NewFacesMin,<br>DWORD NewFacesMax,<br>DWORD <em>rgiFaceRemap, // Face remap info.<br>DWORD </em>rgiVertRemap // Vertex remap info.<br>);<br> 这个方法允许我们设置新的最小和最大面数，分别通过NewFacesMin和NewFacesMax指定。注意新的最小和最大值必须在现有最小和最大面数之间；也就是说，必须在[GetMinFaces（），GetMaxFaces（）]之中。该函数也返回面和顶点的重影射信息。重影射信息参见10.4节。<br>HRESULT TrimByVertices(<br>DWORD NewVerticesMin,<br>DWORD NewVerticesMax,<br>DWORD <em>rgiFaceRemap, // Face remap info.<br>DWORD </em>rgiVertRemap // Vertex remap info.<br>);<br> 这个方法允许我们设置新的最小和最大顶点数，分别通过NewVerticesMin和NewVerticesMax指定。注意新的最小和最大值必须在现有最小和最大顶点数之间；也就是说，必须在[GetMinVertices（），GetMaxVertices（）]之中。该函数也返回面和顶点的重影射信息。重影射信息参见10.4节。<br>11.3.4实例程序：渐进网格<br> 渐进网格例子与X文件例子很相似，除了实际上我们创建和渲染的是一个渐进网格，通过ID3DXPMesh接口来表现。我们允许用户通过键盘输入进行交互式地改变渐进网格。你能通过按A键来增加mesh的面数，按S键来减少mesh的面数。<br> 在这个例子中使用的全局变量和X文件例子中的是一样的，不过我们增加了一个用来存储渐进网格的变量：<br>ID3DXMesh<em>                      SourceMesh = 0;<br>ID3DXPMesh</em>                     PMesh      = 0; // progressive mesh<br>std::vector<d3dmaterial9>       Mtrls(0);<br>std::vector<idirect3dtexture9*> Textures(0);<br> 回想一下，为了得到一个渐进网格我们必须输入一个包含了数据信息的源mesh。因此，我们首先读取一个X文件数据到ID3DXMesh对象SourceMesh之中，然后再产生渐进网格：<br>bool Setup()<br>{<br>  HRESULT hr = 0;<br>  // …Load XFile data into SourceMesh snipped.<br>  //<br>　　// …Extracting materials and textures snipped.<br> 因为这一部分代码和X文件例子中的是完全一样的，在这里我们就把它省略了。一但有了源mesh，我们就能够象下面一样来生成渐进网格了：<br>  //<br>  // Generate the progressive mesh.<br>  //<br>  hr = D3DXGeneratePMesh(</idirect3dtexture9*></d3dmaterial9></p>
<pre><code>  SourceMesh,
  (DWORD*)adjBuffer-&gt;GetBufferPointer(), // adjacency
  0,                  // default vertex attribute weights
  0,                  // default vertex weights
  1,                  // simplify as low as possible
  D3DXMESHSIMP_FACE,  // simplify by face count
  &amp;PMesh);
</code></pre><p>  d3d::Release<id3dxmesh*>(SourceMesh);  // done w/ source mesh<br>  d3d::Release<id3dxbuffer*>(adjBuffer); // done w/ buffer</id3dxbuffer*></id3dxmesh*></p>
<p>  if(FAILED(hr))<br>  {</p>
<pre><code>  ::MessageBox(0, &quot;D3DXGeneratePMesh() - FAILED&quot;, 0, 0);
  return false;
</code></pre><p>   }<br>　　注意，因为顶点/品质权值的缘故，很难将Mesh简化到只有一个面，但是，如果将其指定为1，则可以将Mesh简化到最低。<br>　　在这一点上，渐进网格已经被产生了，但是假如你现在就渲染它，它将以最简化的方式来渲染。以为我们想开始渲染最高精度的mesh，所以我们设置它为：<br>  // set to original detail<br>  DWORD maxFaces = PMesh-&gt;GetMaxFaces();<br>   PMesh-&gt;SetNumFaces(maxFaces);<br> 在Display函数中，我们测试A键和S键并将结果输入。<br>bool Display(float timeDelta)<br>{<br>  if( Device )<br>  {</p>
<pre><code>  //
  // Update: Mesh resolution.
  //

  // Get the current number of faces the pmesh has.
  int numFaces = PMesh-&gt;GetNumFaces();

  // Add a face, note the SetNumFaces() will  automatically
  // clamp the specified value if it goes out of bounds.
  if( ::GetAsyncKeyState(&#39;A&#39;) &amp; 0x8000f )
  {
      // Sometimes we must add more than one face to invert
      // an edge collapse transformation
      PMesh-&gt;SetNumFaces( numFaces + 1 );
      if( PMesh-&gt;GetNumFaces() == numFaces )
          PMesh-&gt;SetNumFaces( numFaces + 2 );
  }

  // Remove a face, note the SetNumFaces() will  automatically
  // clamp the specified value if it goes out of bounds.
  if( ::GetAsyncKeyState(&#39;S&#39;) &amp; 0x8000f )
</code></pre><p>　　　　　　　　PMesh-&gt;SetNumFaces( numFaces - 1 );<br> 这是很简单的，但是要注意当增加面时我们有时必须增加两个面来完成ECT。<br>　　最后，我们就能象渲染ID3DXMesh对象一样来渲染ID3DXPMesh对象。另外，为了更加直观的观察网格的三角形数的变化情况，使用黄色材质在线框模式（Wireframe Mode）下渲染Mesh的三角形。</p>
<pre><code>  Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
  Device-&gt;BeginScene();
  for(int i = 0; i &lt; Mtrls.size(); i++)
  {
      // draw pmesh
      Device-&gt;SetMaterial( &amp;Mtrls[i] );
      Device-&gt;SetTexture(0, Textures[i]);
      PMesh-&gt;DrawSubset(i);
      // draw wireframe outline
      Device-&gt;SetMaterial(&amp;d3d::YELLOW_MTRL);
      Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
      PMesh-&gt;DrawSubset(i);
      Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
  }   
  Device-&gt;EndScene();
  Device-&gt;Present(0, 0, 0, 0);
</code></pre><p>  }<br>  return true;<br>}<br>　　<br>图11.3<br>11.4 界线容积（Bounding Volumes）<br>　　有时我们需要计算mesh的界线容积（边界范围）。常用的有两种类型：立方体和球。也有使用其它方法的，如圆柱体，椭球体，菱形体，胶囊形。图11.4演示了对同一个mesh分别使用立方体和球体类型。这一节我们只讨论立方体和球体两种边界形式。<br>　　<br>　　图11.4<br>　　边界盒/球常常被用来加速可见性测试，碰撞检测等。例如，假如一个mesh的边界盒/球不可见，那么我们就说mesh不可见。一个盒/球可见性测试是比分别测试mesh中的每个三角形要廉价的多。对于一个碰撞检测例子，如果一枚导弹点火起飞，我们需要检测它是否击中了同一场景中的目标。由于这些物体都是由大量三角形构成，我们可以依次检测每个对象的每个三角形，来测试导弹（可以用射线数学模型）是否碰撞到了这些三角形。这个方法需要进行多次的射线/三角形交点的运算。一个更好的方法是使用边界盒或边界球，计算射线与场景中的每个对象的边界盒/边界球的交点。如果射线与对象的边界范围相交，可以认为该对象被击中了。这是一个公平的近似方法，如果需要更高的精度，可以用边界范围法先去除那些明显不会相撞的对象，然后用更精确地方法检测很可能相撞的对象。如果边界范围检测发现相撞，则该对象就很有可能相撞。<br>　　D3DX库提供了计算mesh的边界盒和边界球的函数。这些函数使用顶点数组作为输入计算边界盒/球。这些函数本来就是设计的很灵活的，它们可以使用各种顶点格式：<br>HRESULT D3DXComputeBoundingSphere(<br>  LPD3DXVECTOR3 pFirstPosition,<br>  DWORD NumVertices,<br>  DWORD dwStride,<br>  D3DXVECTOR3<em> pCenter,<br>  FLOAT</em> pRadius<br>);</p>
</li>
<li>pFirstPosition——指向在顶点数组中第一个顶点的向量，描述顶点位置。</li>
<li>NumVertices——在顶点数组中的的顶点数。</li>
<li>dwStride——每个顶点的字节大小。这是很需要的，因为顶点结构可能有一些额外信息如法向量和纹理坐标，这些信息对计算边界又没有用，函数需要知道应该跳过多少字节来得到下一个顶点的位置。</li>
<li>pCenter——返回边界球的中心。</li>
<li>pRadius——返回边界球的半径。<br>HRESULT D3DXComputeBoundingBox(<br>  LPD3DXVECTOR3 pFirstPosition,<br>  DWORD NumVertices,<br>  DWORD dwStride,<br>  D3DXVECTOR3<em> pMin,<br>  D3DXVECTOR3</em> pMax<br>);<br>前三个参数和D3DXComputeBoundingSphere的前三个参数是完全一样的。最后两个参数分别用来返回边界盒的最小和最大点。<br>11.4.1一些新的特殊常量<br>让我来介绍两个常量，它们在本书中是经常要用到的。我们把它们添加到d3d名称空间中：<br>namespace d3d<br>{<br>  …<br>  const float INFINITY = FLT_MAX;<br>  const float EPSILON = 0.001f;<br>常量INFINITY是用来表示一个浮点数所能存储的最大数。因为我们找不到一个比FLT_MAX还要大的浮点数，我们可以将它视为无穷大。常量EPSILON是一个很小的值，我们这样定义它，凡是比它小的数就视为0。这也是很有必要的，因为得到的浮点是不精确的，一个被读作0的数可能有一点点小偏差。因此，让它和0比较相等肯定会失败。我们因此可以通过把该值与0的差值与EPSILON比较来确定是否相等：<br>bool Equals(float lhs, float rhs)<br>{<br>  // if lhs == rhs their difference should be zero<br>  return fabs(lhs - rhs) &lt; EPSILON ? true : false;<br>}<br>11.4.2界线容积类型<br> 为了更容易的使用边界盒和边界球，我们将它们分别封装到两个类中。现在在d3d名称空间中定义类：<br>struct BoundingBox<br>{<br>  BoundingBox();<br>  bool isPointInside(D3DXVECTOR3&amp; p);<br>  D3DXVECTOR3 _min;<br>  D3DXVECTOR3 _max;<br>};<br>struct BoundingSphere<br>{<br>  BoundingSphere();<br>  D3DXVECTOR3 _center;<br>  float _radius;<br>};<br>d3d::BoundingBox::BoundingBox()<br>{<br>  // infinite small bounding box<br>  _min.x = d3d::INFINITY;<br>  _min.y = d3d::INFINITY;<br>  _min.z = d3d::INFINITY;<br>  _max.x = -d3d::INFINITY;<br>  _max.y = -d3d::INFINITY;<br>  _max.z = -d3d::INFINITY;<br>}<br>bool d3d::BoundingBox::isPointInside(D3DXVECTOR3&amp; p)<br>{<br>  // is the point inside the bounding box?<br>  if(p.x &gt;= _min.x &amp;&amp; p.y &gt;= _min.y &amp;&amp; p.z &gt;= _min.z &amp;&amp;<pre><code>  p.x &lt;= _max.x &amp;&amp; p.y &lt;= _max.y &amp;&amp; p.z &lt;= _max.z)
</code></pre>  {<pre><code>  return true;
</code></pre>  }<br>  else<br>  {<pre><code>  return false;
</code></pre>  }<br>}<br>d3d::BoundingSphere::BoundingSphere()<br>{<br>  _radius = 0.0f;<br>}<br>11.4.3实例程序：界线容积<br>　　在这一章中被叫做界线容积的实例程序主要是演示使用D3DXComputeBoundingSphere和D3DXComputeBoundingBox。程序读取一个X文件并且计算该mesh的边界球。它创建两个ID3DXMesh对象，一个用来作为边界球模型一个用来作为边界盒模型。X文件生成的mesh被渲染，其中的边界球或边界盒不可见（如图11.5）。你能够通过敲空格键来再边界球和边界盒之间切换。</li>
</ul>
<p>图11.5<br>　　这个例子是非常简单的，我们列出你要学习的代码。我们实现的两个函数是用来计算网格的边界球和边界盒的：<br>bool ComputeBoundingSphere(<br>        ID3DXMesh<em> mesh, // mesh to compute bounding sphere for<br>        d3d::BoundingSphere</em> sphere) // return bounding sphere<br>{<br>    HRESULT hr = 0;</p>
<pre><code>BYTE* v = 0;
mesh-&gt;LockVertexBuffer(0, (void**)&amp;v);

hr = D3DXComputeBoundingSphere(
        (D3DXVECTOR3*)v,
        mesh-&gt;GetNumVertices(),
        D3DXGetFVFVertexSize(mesh-&gt;GetFVF()),
        &amp;sphere-&gt;_center,
        &amp;sphere-&gt;_radius);

mesh-&gt;UnlockVertexBuffer();

if( FAILED(hr) )
    return false;
return true;
</code></pre><p>}</p>
<p>bool ComputeBoundingBox(<br>        ID3DXMesh<em> mesh, // mesh to compute bounding box for<br>        d3d::BoundingBox</em> box) // return bounding box<br>{<br>    HRESULT hr = 0;</p>
<pre><code>BYTE* v = 0;
mesh-&gt;LockVertexBuffer(0, (void**)&amp;v);

hr = D3DXComputeBoundingBox(
        (D3DXVECTOR3*)v,
        mesh-&gt;GetNumVertices(),
        D3DXGetFVFVertexSize(mesh-&gt;GetFVF()),
        &amp;box-&gt;_min,
        &amp;box-&gt;_max);

mesh-&gt;UnlockVertexBuffer();

if( FAILED(hr) )
    return false;
return true;
</code></pre><p>}<br>　　注意，类型转换(D3DXVECTOR3*)v假定顶点位置成员是被存储在我们所使用的顶点结构的开始位置。同样要注意我们能够使用D3DXGetFVFVertexSize函数来得到顶点结构的大小。<br>11.5 摘要(略)</p>
<p>第十二章 创建灵活的摄像机类(Building a Flexible Camera Class)<br>　　迄今，我们已经使用过D3DXMatrixLookAtLH函数来计算视图空间变换矩阵。这个函数对于在固定位置布置和对准摄像机是非常好用的，不过它的用户接口对于要响应用户输入来实现摄像机移动就不那么好用了。这就激发我们用我们自己的方法来解决。在这一章我们展示了怎样实现一个Camera类，它使我们能够比D3DXMatrixLookAtLH函数更好地操作摄像机，并且可以用来作为飞行模拟摄像机和第一人称视角摄像机。<br>目标</p>
<ul>
<li>学习怎样实现一个灵活的摄像机类，它可以用作飞行模拟摄像机和第一人称视角摄像机。<br>12.1 摄像机设计<br>　　我们定义一个相对于世界坐标系的位置和摄像机的方向，这里使用四个摄像机向量：right vector ,  up vector, look vector 以及 position vector, 如图12.1所示。这些向量用来为摄像机定义一个坐标系来描述在世界坐标中的对应关系。因为 right ，up 和 look 向量定义了摄像机在世界中的方向，我们有时把它们三个向量一起称为方向向量（orientation vectors）。方向向量必须被标准化。假如彼此互相垂直且都是单位长度，那么我们就称它们是正交标准化向量。我们做这些限制是因为等一会儿我们要将方向向量插入到一个行矩阵中。因为行向量是正交标准化的，所以该矩阵也就是直交矩阵。回忆一下，直交矩阵有一个特性就是它的逆矩阵等于它的转置矩阵。这在等一下的12.2.1.2节中是很有用的。</li>
</ul>
<p>图12.1<br>　　有了这四个向量来描述摄像机，我们的摄像机就能够按照下面六种方式变化了：</p>
<ul>
<li>围绕right向量旋转（pitch倾斜）</li>
<li>围绕up向量旋转（yaw 偏航）</li>
<li>围绕look向量旋转（roll 滚转）</li>
<li>沿着right向量平移（strafe）</li>
<li>沿着up向量飞行（fly）</li>
<li>沿着look向量移动（move）<br>通过这六种操作，我们能够沿着三个轴移动以及饶着三个轴旋转，这给了我们一个六度的自由。下面的Camera类定义了我们要的描述数据以及想要的方法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> CameraType &#123; LANDOBJECT, AIRCRAFT &#125;;</span><br><span class="line">    Camera();</span><br><span class="line">    Camera(CameraType cameraType);</span><br><span class="line">    ~Camera();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">strafe</span><span class="params">(<span class="keyword">float</span> units)</span></span>; <span class="comment">// left/right</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">float</span> units)</span></span>;    <span class="comment">// up/down</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">float</span> units)</span></span>;   <span class="comment">// forward/backward   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pitch</span><span class="params">(<span class="keyword">float</span> angle)</span></span>; <span class="comment">// rotate on right vector</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">yaw</span><span class="params">(<span class="keyword">float</span> angle)</span></span>;   <span class="comment">// rotate on up vector</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">roll</span><span class="params">(<span class="keyword">float</span> angle)</span></span>;  <span class="comment">// rotate on look vector</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getViewMatrix</span><span class="params">(D3DXMATRIX* V)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCameraType</span><span class="params">(CameraType cameraType)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPosition</span><span class="params">(D3DXVECTOR3* pos)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(D3DXVECTOR3* pos)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRight</span><span class="params">(D3DXVECTOR3* right)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUp</span><span class="params">(D3DXVECTOR3* up)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getLook</span><span class="params">(D3DXVECTOR3* look)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CameraType  _cameraType;</span><br><span class="line">    D3DXVECTOR3 _right;</span><br><span class="line">    D3DXVECTOR3 _up;</span><br><span class="line">    D3DXVECTOR3 _look;</span><br><span class="line">    D3DXVECTOR3 _pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在类中我们定义了一个还没有讨论的CameraType枚举类型。目前，我们的摄像机支持两种摄像机模式，LANDOBJECT模式和AIRCRAFT模式。AIRCRAFT模式允许我们在空间中完全自由的移动。不过，在有些游戏中，比如第一人称设计游戏，人是不能飞的；因此我们必须限制它在某些轴上的运动。指定为LANDOBJECT模式的摄像机就限制了这些，你可以在下一部分看见。<br>12.2 执行详细资料<br>12.2.1计算视图矩阵<br>　　我们现在演示怎样根据摄像机向量来计算视图矩阵变换的。让 p = (px, py, pz), r = (rx, ry, rz), u = (ux, uy, uz) 以及 d = (dx, dy, dz) 分别表示 position, right, up 以及 look 向量。<br>　　回忆第二章我们所说的，视图空间变换是指在世界坐标系中进行几何变换以便将照相机平移变换到坐标系的源点并把它的方向旋转至朝向Z轴的正方向（如图12.2）。</p>
<p>图12.2<br>因此，我们希望有一个象这样的变换矩阵V ：</p>
<ul>
<li>pV = (0, 0, 0)—矩阵V能将摄像机移动到原点。</li>
<li>rV = (1, 0, 0)—矩阵V能将摄像机的right向量与世界坐标系中的x轴对齐。</li>
<li>uV = (0, 1, 0)—矩阵V能将摄像机的up向量与世界坐标系中的y轴对齐。</li>
<li>dV = (0, 0, 1)—矩阵V能将摄像机的look向量与世界坐标系中的z轴对齐。<br>我们能将变换任务分为两个部分：1）平移部分，将摄像机的位置移动到原点；2）旋转部分，将摄像机的方向向量与世界坐标系的轴对齐。<br>12.2.1.1 第一部分：平移<br>　　平移只需要利用 –p 就可简单地将 p 移动到原点，因为 p–p=0。因此我们能够用下面的矩阵来描述视图变换中的平移部分：<br>　　<br>12.2.1.2 第二部分：旋转<br>　　矫正摄像机的三个方向向量使其与世界坐标系的轴对齐需要更多的工作。我们需要一个3<em>3的旋转矩阵A ，它能将right，up和look分别与x-，y-以及z轴对齐。这个矩阵将满足如下三个等式：<br>　　<br>注意：我们在这里使用3</em>3矩阵来工作是因为现在不需要额外的信息来表现旋转。等一下我们将它增加到常用的4<em>4矩阵。<br>　　因为这三个等式都有一个相同系数矩阵A ，所以我们能够把它们合在一起。我们把它们从新写到一起来：<br>　　<br>　　求A有很多方法，但是我们知道A是B逆矩阵因为BA = BB-1 = I。因为B 是一个直交矩阵（它的行向量是正交标准化的），我们知道它的逆矩阵就是它的转置矩阵。因此，将方向向量和世界坐标系中的坐标轴对齐的变换如下：<br>　　<br>12.2.1.3 将两部分合并<br>　　最后，将A增加为4</em>4矩阵，同时将平移部分合并到旋转部分形成的视图变换矩阵V：</li>
</ul>
<p>我们在Camera::getViewMatrix方法中建立这个矩阵：<br>void Camera::getViewMatrix(D3DXMATRIX* V)<br>{<br>    // Keep camera’s axes orthogonal to eachother<br>    D3DXVec3Normalize(&amp;_look, &amp;_look);<br>    D3DXVec3Cross(&amp;_up, &amp;_look, &amp;_right);<br>    D3DXVec3Normalize(&amp;_up, &amp;_up);<br>    D3DXVec3Cross(&amp;_right, &amp;_up, &amp;_look);<br>    D3DXVec3Normalize(&amp;_right, &amp;_right);</p>
<pre><code>// Build the view matrix:
float x = -D3DXVec3Dot(&amp;_right, &amp;_pos);
float y = -D3DXVec3Dot(&amp;_up, &amp;_pos);
float z = -D3DXVec3Dot(&amp;_look, &amp;_pos);

(*V)(0,0) = _right.x; (*V)(0, 1) = _up.x; (*V)(0, 2) = _look.x; (*V)(0, 3) = 0.0f;
(*V)(1,0) = _right.y; (*V)(1, 1) = _up.y; (*V)(1, 2) = _look.y; (*V)(1, 3) = 0.0f;
(*V)(2,0) = _right.z; (*V)(2, 1) = _up.z; (*V)(2, 2) = _look.z; (*V)(2, 3) = 0.0f;
(*V)(3,0) = x;        (*V)(3, 1) = y;     (*V)(3, 2) = z;       (*V)(3, 3) = 1.0f;
</code></pre><p>}<br>你可能想知道方法中前面几行代码是干什么的。在几次旋转后，摄像机的方向向量可能变的不相互垂直了。因此，每当该函数被调用时，我们根据look向量从新计算up和right向量，使它们保持相互垂直。新的up向量是这样计算的up = look × right。 接着新的right向量是这样计算的right = up × look。<br>12.2.2围绕任意轴旋转<br>为了实现我们的摄像机旋转方法，我们需要能够绕着任意轴旋转。D3DX库提供下面的函数来解决这个问题：<br>D3DXMATRIX <em>D3DXMatrixRotationAxis(<br>    D3DXMATRIX </em>pOut, // returns rotation matrix<br>    CONST D3DXVECTOR3 *pV, // axis to rotate around<br>    FLOAT Angle // angle, in radians, to rotate<br>);<br>　　<br>　　图12.3<br>例如，假如我们想绕向量（0.707, 0.707, 0）轴旋转π/2角度。我们可以这样写：<br>D3DXMATRIX R;<br>D3DXVECTOR3 axis(0.707f, 0.707f, 0.0f);<br>D3DXMatrixRotationAxis(&amp;R, &amp;axis, D3DX_PI / 2.0f);<br>D3DXMatrixRotationAxis的变换矩阵的来源你可以在Eric Lengyel的 Mathematics for 3D Game Programming &amp;Computer Graphics中找到。<br>12.2.3 Pitch、Yaw和Roll<br>因为方向向量描述了摄像机相对于世界坐标系的方向，我们必须考虑在使用倾斜（pitch）、偏航（yaw）和滚转（roll）时及时更新方向向量。这其实也是非常简单的。图12.4，12.5，12.6分别显示了摄像机的倾斜、偏航和滚转操作。</p>
<p>图12.4</p>
<p>图12.5</p>
<p>图12.6<br>当倾斜（pitch）时，我们需要将up和look向量绕着right向量旋转一定角度。同样的，当偏航（yaw）时，我们需要将look和right向量绕着up向量旋转一定角度。最后，当滚转（roll）时，我们需要将up和right向量绕着look向量旋转一定角度。<br>　　我们现在明白了为什么D3DXMatrixRotationAxis函数是非常必要的，因为这三个向量中的任何一个都可能围绕世界坐标系中的任意轴旋转。<br>　　对于倾斜（pitch）、偏航（yaw）和滚转（roll）的执行我们已经讨论了。然而，对于LANDOBJECT模式就有一些限制。我们在偏航（yaw）方法中只围绕y轴旋转，我们完全屏蔽滚转（roll）。当然你可以根据你的程序需要来改变Camera类。我们这里只是一个示例而已。<br>倾斜（pitch）、偏航（yaw）和滚转（roll）方法代码的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Camera::pitch(<span class="keyword">float</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    D3DXMATRIX T;</span><br><span class="line">    D3DXMatrixRotationAxis(&amp;T, &amp;_right, angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate _up and _look around _right vector</span></span><br><span class="line">    D3DXVec3TransformCoord(&amp;_up,&amp;_up, &amp;T);</span><br><span class="line">    D3DXVec3TransformCoord(&amp;_look,&amp;_look, &amp;T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Camera::yaw(<span class="keyword">float</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    D3DXMATRIX T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate around world y (0, 1, 0) always for land object</span></span><br><span class="line">    <span class="keyword">if</span>( _cameraType == LANDOBJECT )</span><br><span class="line">        D3DXMatrixRotationY(&amp;T, angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate around own up vector for aircraft</span></span><br><span class="line">    <span class="keyword">if</span>( _cameraType == AIRCRAFT )</span><br><span class="line">        D3DXMatrixRotationAxis(&amp;T, &amp;_up, angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate _right and _look around _up or y-axis</span></span><br><span class="line">    D3DXVec3TransformCoord(&amp;_right,&amp;_right, &amp;T);</span><br><span class="line">    D3DXVec3TransformCoord(&amp;_look,&amp;_look, &amp;T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Camera::roll(<span class="keyword">float</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// only roll for aircraft type</span></span><br><span class="line">    <span class="keyword">if</span>( _cameraType == AIRCRAFT )</span><br><span class="line">    &#123;</span><br><span class="line">        D3DXMATRIX T;</span><br><span class="line">        D3DXMatrixRotationAxis(&amp;T, &amp;_look,  angle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rotate _up and _right around _look vector</span></span><br><span class="line">        D3DXVec3TransformCoord(&amp;_right,&amp;_right, &amp;T);</span><br><span class="line">        D3DXVec3TransformCoord(&amp;_up,&amp;_up, &amp;T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>12.2.4 Walking、Strafing和Flying<br>当提到walking时，我们的意思是在我们观察的方向上移动位置（也就是说，沿着look向量）。Strafing是说在我们观察方向的左右移动，也就是沿着right向量移动。最后，我们说flying就是沿着up向量移动。为了沿着这些轴移动，我们只需要简单地加一个向量就可以了（如图12.7）。</p>
<p>图12.7<br>就象旋转一样，我们需要对移动作一些限制。例如，LANDOBJECT不允许飞起来。因此我们把移动限制在xz平面。然而，因为LANDOBJECT能够允许爬楼梯和登山，所以，我们设置Camera::setPosition方法，它允许你手动设置你的摄像机位置来达到你的高度和位置。<br>    移动（walk）、平移（strafe）和飞行（fly）方法代码的具体实现如下：<br>void Camera::walk(float units)<br>{<br>    // move only on xz plane for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos += D3DXVECTOR3(_look.x, 0.0f, _look.z) <em> units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _look </em> units;<br>}<br>void Camera::strafe(float units)<br>{<br>    // move only on xz plane for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos += D3DXVECTOR3(_right.x, 0.0f, _right.z) <em> units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _right </em> units;<br>}<br>void Camera::fly(float units)<br>{<br>    // move only on y-axis for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos.y += units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _up * units;<br>}<br>12.3实例程序：摄像机<br>　　这一章的实例程序是创建和渲染一个如图12.8所示的场景。你能够通过键盘输入在场景中自由地飞行。下面是相应键盘设置：</p>
<ul>
<li>W/S—向前/向后移动</li>
<li>A/D—向左/向右平移</li>
<li>R/F—向上/向下飞行</li>
<li>Up/Down方向键—倾斜</li>
<li>Left/Right方向键—偏航</li>
<li>N/M—滚转</li>
</ul>
<p>图12.8<br>　　例子的执行是非常简单的，因为所有工作都包含在摄像机类中了，这些我们都已经讨论过了。我们在Display函数中获得键盘的输入。记住，我们在全局域中实例化了一个摄像机类对象TheCamera。同样注意我们使用时间变化量来控制移动摄像机；这可以排除帧速度的影响而稳定地移动。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Update: Update the camera.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'W'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.walk(<span class="number">4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'S'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.walk(<span class="number">-4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'A'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.strafe(<span class="number">-4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'D'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.strafe(<span class="number">4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'R'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.fly(<span class="number">4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'F'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.fly(<span class="number">-4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_UP) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.pitch(<span class="number">1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_DOWN) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.pitch(<span class="number">-1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_LEFT) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.yaw(<span class="number">-1.0f</span> * timeDelta);           </span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_RIGHT) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.yaw(<span class="number">1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'N'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.roll(<span class="number">1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'M'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.roll(<span class="number">-1.0f</span> * timeDelta);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the view matrix representing the cameras </span></span><br><span class="line">        <span class="comment">// new position/orientation.</span></span><br><span class="line">        D3DXMATRIX V;</span><br><span class="line">        TheCamera.getViewMatrix(&amp;V);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_VIEW, &amp;V);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Render</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, <span class="number">0x00000000</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line">        d3d::DrawBasicScene(Device, <span class="number">1.0f</span>);</span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：我们已经用一个新的函数DrawBasicScene更新了d3d名称空间。这个函数绘制了如图12.8的场景。我们已经将其添加进了d3d名称空间，这是因为对于建立一个基本的场景它是一个非常方便的函数。以后的例子我们就可以集中精力在例子代码中而不需要关注这些不相关的绘制场景的代码了。它是在d3dUtility.h中被声明的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function references "desert.bmp" internally.  This file must</span></span><br><span class="line"><span class="comment">// be in the working directory.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DrawBasicScene</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IDirect3DDevice9* device,<span class="comment">// Pass in 0 for cleanup.</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> scale)</span></span>;            <span class="comment">// uniform scale</span></span><br></pre></td></tr></table></figure></p>
<p>如果该函数不能任何东西也就是什么都显示不出来，你就需要看看相应的代码了。你可以在本章的代码中找到它。注意这个函数需要调用一张desert.bmp图片用作纹理。当然该文件也可以在同一个文件夹下找到。<br>12.4 摘要<br>   我们以四个向量来描述在世界坐标系中照相机的位置和方向：right、up、look、position向量，藉由这个描述, 我们能轻易的实现一个自由的六角度照相机，为游戏中的模拟飞行器、第一人称视角的游戏玩家提供了一个灵活的照相机接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Meshes-Part-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Meshes-Part-I/" class="post-title-link" itemprop="url">第十章 网格模型I(Meshes Part I)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:14:46" itemprop="dateCreated datePublished" datetime="2019-04-11T15:14:46+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Meshes-Part-I/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Meshes-Part-I/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="几何信息"><a href="#几何信息" class="headerlink" title="几何信息"></a>几何信息</h1><p>ID3DXBaseMesh接口包含一个用来存储网格顶点的顶点缓存和一个用来定义这些顶点怎样连接在一起组成网格三角形的索引缓存。我们能够通过使用下面的方法来得到这些缓存的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXMesh::GetVertexBuffer(LPDIRECT3DVERTEXBUFFER9* ppVB);</span><br><span class="line">HRESULT ID3DXMesh::GetIndexBuffer(LPDIRECT3DINDEXBUFFER9* ppIB);</span><br></pre></td></tr></table></figure></p>
<p>这里有一些使用这些方法的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDirect3DVertexBuffer9* vb = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;GetVertexBuffer( &amp;vb );</span><br><span class="line">IDirect3DIndexBuffer9* ib = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;GetIndexBuffer( &amp;ib );</span><br></pre></td></tr></table></figure></p>
<p>假如想锁定这些缓存来读写数据，那么我们能够使用下面的方法。注意这些方法锁定整个顶点/索引缓存。<br>HRESULT ID3DXMesh::LockVertexBuffer(DWORD Flags, BYTE<strong> ppData);<br>HRESULT ID3DXMesh::LockIndexBuffer(DWORD Flags, BYTE</strong> ppData);<br>Flags参数描述怎样锁定它。这些Flags参数在第三章中我们介绍过。ppData是函数返回的指向锁定内存的指针的地址。<br>　　当然在你锁定以后一定要记得解锁：<br>HRESULT ID3DXMesh::UnlockVertexBuffer();<br>HRESULT ID3DXMesh::UnlockIndexBuffer();<br>　　下面是另外一些与mesh几何结构有关的ID3DXMesh接口方法：</p>
<ul>
<li>DWORD GetFVF() — 返回顶点的格式</li>
<li>DWORD GetNumVertices() — 返回顶点缓存中的顶点数</li>
<li>DWORD GetNumBytesPerVertex() — 返回一个顶点所占的字节数</li>
<li>DWORD GetNumFaces() — 返回在mesh中的面（三角形）数<br>10.2 子集和属性缓存<br>　　一个mesh由一个或数个子集组成。一个子集（subset）是在mesh中的使用相同属性渲染的一组三角形。这里的属性是指材质，纹理和渲染状态。图10.1显示了一座房子mesh可能被分成的几个子集。<br>　　<br>图10.1<br>我们通过给每个子集指定一个唯一非负整数来标识子集。这个值可以是存储在一个DWORD中的任意数值。例如，在图10.1中我们用0，1，2和3来标识子集。<br>　　在mesh中的每个三角形都与一个属性ID相关联，表示该三角形属于该子集。例如，图10.1中组成地板的三角形具有属性ID0，它表示这些三角形属于子集0。同样，组成墙的三角形具有属性ID1，它表示这些三角形属于子集1。<br>　　三角形的属性ID存储在mesh的属性缓存中，它是一个DWORD数组。因为每个面对应属性缓存中的一项，所以属性缓存中的项目数等于mesh中的面的个数。属性缓存中的项目和索引缓存中定义的三角形一一对应。即，属性缓存中的第i项和索引缓存中的第i个三角形相对应。三角形i由下面三个索引缓存中的索引项定义：<br>　　A = i <em> 3<br>　　B = i </em> 3 + 1<br>　　C = i * 3 + 2<br>图10.2显示了这个对应关系：</li>
</ul>
<p>图10.2<br>　　我们可以锁定属性缓存，就象下面的代码片段：<br>DWORD* buffer = 0;<br>Mesh-&gt;LockAttributeBuffer(lockingFlags, &amp;buffer);<br>// Read or write to attribute buffer…<br>Mesh-&gt;UnlockAttributeBuffer();<br>10.3 绘制<br>　　ID3DXMesh接口提供了DrawSubset（DWORD AttribId）方法来绘制AttribId指示的子集中的各个三角形。例如，要绘制子集0中的所有三角形，我们将这样写：<br>Mesh-&gt;DrawSubset(0);<br>　　为了绘制整个mesh，我们必须绘制mesh的所有子集。这是非常方便的用0，1，2，…，n-1来标识子集，这里的n是子集的总数。且有一个相对应的材质和纹理数组，即子集i与材质和纹理数组的第i项对应。这就使我们能够简单的用循环来渲染mesh：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numSubsets; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Device-&gt;SetMaterial( mtrls[i] );</span><br><span class="line">    Device-&gt;SetTexture( <span class="number">0</span>, textures[i] );</span><br><span class="line">    Mesh-&gt;DrawSubset(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10.4 优化<br>　　Mesh的顶点和索引能够被重组以便能更有效的渲染mesh。当我们这样做时，我们说我们优化了一个mesh。我们可以使用下面的方法来进行优化：<br>HRESULT ID3DXMesh::OptimizeInplace(<br>    DWORD Flags,<br>    CONST DWORD<em> pAdjacencyIn,<br>    DWORD</em> pAdjacencyOut,<br>    DWORD<em> pFaceRemap,<br>    LPD3DXBUFFER</em> ppVertexRemap<br>);</p>
<ul>
<li>Flags — 表示执行什么类型的优化方法。它可以是下面的一个或几个的组合：</li>
<li>D3DXMESHOPT_COMPACT — 从mesh中移除没有用的顶点和索引项。</li>
<li>D3DXMESHOPT_ATTRSORT — 根据属性给三角形排序并调整属性表，这将使DrawSubset执行更有效（参见10.5节）。</li>
<li>D3DXMESHOPT_VERTEXCACHE — 增加顶点缓存的命中率。</li>
<li>D3DXMESHOPT_STRIPREORDER — 重组顶点索引使三角带尽可能的长。</li>
<li>D3DXMESHOPT_IGNOREVERTS — 只优化索引信息；忽略顶点信息。<br>注意：D3DXMESHOPT_VERTEXCACHE和D3DXMESHOPT_STRIPREORDER不能同时使用。</li>
<li>pAdjacencyIn — 指向没有优化的mesh的邻接数组。</li>
<li>pAdjacencyOut — 指向一个DWORD数组，它被用来填充优化好了的mesh邻接信息。该数组必须有ID3DXMesh::GetNumFaces() * 3个元素。如果不需要该信息，可以将其设置为0。</li>
<li>pFaceRemap —指向一个DWORD数组，它被用来填充面重影射信息。该数组必须不小于ID3DXMesh::GetNumFaces()。当一个mesh被优化时，由索引缓存定义的面可能被移动；也就是说，在pFaceRemap中的第i项表示第i个原始面被移动到的面索引值。如果不需要该信息，可以将其设置为0。</li>
<li>ppVertexRemap — 指向ID3DXBuffer指针的地址（参见11.1节），它被用来填充顶点重影射信息。这个缓存应该包含ID3DXMesh::GetNumVertices()个顶点。当一个mesh被优化后，顶点可能被移动。顶点重影射信息用来说明原来的顶点被移动到新位置；也就是说，在ppVertexRemap中的第i项表示原来的第i个顶点的新位置。如果不需要该信息，可以将其设置为0。<br>　　例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the adjacency info of the non-optimized mesh.</span></span><br><span class="line">DWORD adjacencyInfo[Mesh-&gt;GetNumFaces() * <span class="number">3</span>];</span><br><span class="line">Mesh-&gt;GenerateAdjacency(<span class="number">0.0f</span>, adjacencyInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array to hold optimized adjacency info.</span></span><br><span class="line">DWORD optimizedAdjacencyInfo[Mesh-&gt;GetNumFaces() * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">Mesh-&gt;OptimizeInplace(</span><br><span class="line">    D3DXMESHOPT_ATTRSORT |</span><br><span class="line">    D3DXMESHOPT_COMPACT |</span><br><span class="line">    D3DXMESHOPT_VERTEXCACHE,</span><br><span class="line">    adjacencyInfo,</span><br><span class="line">    optimizedAdjacencyInfo,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>);</span><br><span class="line">　　一个更简单的方法是Optimize方法，它输出一个优化的mesh，而不是在原来mesh的基础上进行优化：</span><br><span class="line">HRESULT ID3DXMesh::Optimize(</span><br><span class="line">    DWORD Flags,</span><br><span class="line">    CONST DWORD* pAdjacencyIn,</span><br><span class="line">    DWORD* pAdjacencyOut,</span><br><span class="line">    DWORD* pFaceRemap,</span><br><span class="line">    LPD3DXBUFFER* ppVertexRemap,</span><br><span class="line">    LPD3DXMESH* ppOptMesh <span class="comment">// the optimized mesh to be output</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>10.5 属性表<br>　　当一个mesh被使用D3DXMESHOPT_ATTRSORT参数来优化后，mesh的几何信息将按照属性进行排序，这样各个子集的顶点/索引将组成连续的块（如图10.3）。</p>
<p>图10.3<br>　　除了进行几何信息的排序外，D3DXMESHOPT_ATTRSORT优化项还将创建一个属性表。该表是D3DXATTRIBUTERANGE结构的一个数组。在属性表中的每一项对应mesh的一个子集并指示顶点/索引缓存中的一个连续连续内存块，这个子集的几何信息就包含在这个块中。D3DXATTRIBUTERANGE结构的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">D3DXATTRIBUTERANGE</span> &#123;</span></span><br><span class="line">    DWORD AttribId;</span><br><span class="line">    DWORD FaceStart;</span><br><span class="line">    DWORD FaceCount;</span><br><span class="line">    DWORD VertexStart;</span><br><span class="line">    DWORD VertexCount;</span><br><span class="line">&#125; D3DXATTRIBUTERANGE;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>AttribId — 子集的ID。</li>
<li>FaceStart — 该子集的面的起始值，FaceStart*3就是起始三角形在索引缓存中的序号。</li>
<li>FaceCount — 在子集中的面（三角形）数。</li>
<li>VertexStart — 该子集的起始顶点在顶点缓存中的序号。</li>
<li>VertexCount — 在子集中的顶点数。<br>　　我们能够很容易的明白D3DXATTRIBUTERANGE结构的各个成员，如图10.3。在图10.3中mesh的属性表有三项——它们和各个子集一一对应。<br>　　建立了属性表以后，渲染一个子集就很容易了。仅仅查一下属性表就能找出自己的几何信息。注意如果没有属性表，每渲染一个子集就需要对属性缓存进行一次线性搜索来找出子集包含的几何信息。<br>　　可以使用下面的方法来访问mesh的属性表：<br>HRESULT ID3DXMesh::GetAttributeTable(<br>  D3DXATTRIBUTERANGE<em> pAttribTable,<br>  DWORD</em> pAttribTableSize<br>);<br>　　这个方法能够做两件事情：它可以返回属性表的属性数，也可以用属性数据来填充一个D3DXATTRIBUTERANGE结构数组。<br>　　要得到属性表的元素个数，可以就将第一个参数设置为0：<br>DWORD numSubsets = 0;<br>Mesh-&gt;GetAttributeTable(0, &amp;numSubsets);<br>　　一旦我们知道了属性表的元素个数，我们就能够通过写属性表来填充一个D3DXATTRIBUTERANGE结构数组：<br>D3DXATTRIBUTERANGE table = new D3DXATTRIBUTERANGE [numSubsets];<br>Mesh-&gt;GetAttributeTable( table, &amp;numSubsets );<br>　　我们能够使用ID3DXMesh::SetAttributeTable方法来直接设置属性表。下面的代码就是设置一个有12个子集的属性表：<br>D3DXATTRIBUTERANGE attributeTable[12];<br>// …fill attributeTable array with data<br>Mesh-&gt;SetAttributeTable( attributeTable, 12);<br>10.6 邻接信息<br>　　对于mesh的某些操作，如优化，有必要了解的是三角形之间的邻接信息。Mesh的邻接数组存储了这些信息。<br>　　邻接数组是一个DWORD数组，其中的每一项对应了mesh中的一个三角形。例如，第i项对应的三角形由以下三个索引值定义：<br>A = i ??3<br>B = i ??3 + 1<br>C = i ??3 + 2<br>注意，使用ULONG_MAX = 4294967295表示该边没有邻接三角形。我们也可以用-1来表示，因为-1转换成DWORD就是ULONG_MAX。回想一下，DWORD就是一个unsigned32-bit整数。<br>　　因为每个三角形都有三条边，所以他就有三个邻接三角形（如图10.4）。<br>　　<br>　　图10.4<br>　　因此，邻接数组必须有三项（ID3DXBaseMesh::GetNumFaces()<em>3）—— 在mesh中每个三角形都可能有三个邻接三角形。<br>　　很多D3Dxmesh创造函数都能输出邻接信息，但我们也可以使用下面的方法：<br>HRESULT ID3DXMesh::GenerateAdjacency(<br>  FLOAT fEpsilon,<br>  DWORD</em> pAdjacency<br>);</li>
<li>fEpsilon — 指示当两个点距离有多近时，可以认为是一个点。当两点间的距离小于epsilon时，可认为它们是同一个点。</li>
<li><p>pAdjacency — 一个指向填充了邻接信息的DWORD数组指针。<br>　　例子：<br>DWORD adjacencyInfo[Mesh-&gt;GetNumFaces() * 3];<br>Mesh-&gt;GenerateAdjacency(0.001f, adjacencyInfo);<br>10.7 复制<br>　　有时我们需要将一个mesh中的数据拷贝到另一个之中。我们可以使用ID3DXBaseMesh::CloneMeshFVF方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXMesh::CloneMeshFVF(</span><br><span class="line">    DWORD Options,</span><br><span class="line">    DWORD FVF,</span><br><span class="line">    LPDIRECT3DDEVICE9 pDevice,</span><br><span class="line">    LPD3DXMESH* ppCloneMesh</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Options — 用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</p>
</li>
<li>D3DXMESH_32BIT — mesh使用32位索引。</li>
<li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li>
<li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li>
<li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li>
<li>FVF — 创建复制mesh的灵活顶点格式。</li>
<li>pDevice — 与复制mesh有关的设备。</li>
<li>ppCloneMesh — 输出复制的mesh。<br>　　注意这个方法允许指定与原mesh不同的options和FVF。例如我们有顶点格式为D3DFVF_XYZ的mesh，现在想复制一个顶点格式为D3DFVF_XYZ|D3DFVF_NORMAL的mesh。我们可以这样写：<br>// 假设_mesh和device是有效的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID3DXMesh* clone = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;CloneMeshFVF(</span><br><span class="line">    Mesh-&gt;GetOptions(), <span class="comment">// 使用与源模型同样的选项</span></span><br><span class="line">    D3DFVF_XYZ | D3DFVF_NORMAL,<span class="comment">// 指定克隆的FVF</span></span><br><span class="line">    Device,</span><br><span class="line">    &amp;clone</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>10.8 创建一个Mesh（D3DXCreateMeshFVF）<br>　　我们可以使用D3DXCreate*函数来创建mesh物体。然而，我们也可以使用  D3DXCreateMeshFVF函数来创建一个空mesh。所谓空mesh是指我们已经指定了顶点数和面数，函数D3DXCreateMeshFVF也分配了适当大小的内存给顶点、顶点索引、属性缓冲区。有了这些缓冲区后，就可以手动填写上下文数据了（需要分别向顶点缓存，索引缓存、属性缓存提供顶点、索引、属性数据）。<br>　　我们使用D3DXCreateMeshFVF函数来创建空mesh：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateMeshFVF</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumFaces,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumVertices,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD Options,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD FVF,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXMESH* ppMesh</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>NumFaces — mesh将拥有的面数。该值必须大于0。</li>
<li>NumVertices — mesh将拥有的顶点数。该值必须大于0。</li>
<li>Options —用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</li>
<li>D3DXMESH_32BIT — mesh使用32位索引。</li>
<li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li>
<li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li>
<li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li>
<li>FVF — mesh的顶点格式。</li>
<li>pDevice — 与mesh相关的设备。</li>
<li>ppMesh — 输出创建好的mesh。<br>　　下一节将给出实例程序，它演示了用这个函数怎样创建一个mesh以及手动填充mesh的数据内容。<br>　　另外，你也可以使用D3DXCreateMesh来创建空mesh。它的原型是：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateMesh</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumFaces,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumVertices,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD Options,</span></span></span><br><span class="line"><span class="function"><span class="params">    CONST LPD3DVERTEXELEMENT9* pDeclaration,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXMESH* ppMesh</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　这些参数和D3DXCreateMeshFVF的参数是非常相似的，除了第四个。作为替代指定的FVF，我们指定一个D3DVERTEXELEMENT9结构，它描述了顶点格式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXDeclaratorFromFVF</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD FVF, <span class="comment">// input format</span></span></span></span><br><span class="line"><span class="function"><span class="params">    D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]<span class="comment">//output format</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意：D3DVERTEXELEMENT9将在第17章中讨论。<br>　　这个函数通过输入一个FVF返回一个D3DVERTEXELEMENT9结构的数组。注意MAX_FVF_DECL_SIZE的定义如下：<br>typedef enum {<br>    MAX_FVF_DECL_SIZE = 18<br>} MAX_FVF_DECL_SIZE;<br>10.9 实例程序：创建和渲染Mesh<br>这一章的实例程序是渲染一个立方体（如图10.5）</p>
<p>图10.5<br>它演示了这一章中的大部分功能，包括如下一些操作：</p>
<ul>
<li>创建一个空mesh。</li>
<li>用一个立方体几何信息来填充mesh。</li>
<li>根据mesh的每个面指定子集。</li>
<li>产生mesh的邻接信息。</li>
<li>优化mesh。</li>
<li>绘制mesh。<br>　　注意，我们忽略一些无关的代码来讨论本例。你能在叫做D3DXCreateMeshFVF的例子中找到全部的代码。<br>　　另外，为了更容易调试和研究mesh的构成，我们执行如下的函数来将内在内容放进文件中：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpVertices</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpIndices</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAttributeBuffer</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAdjacencyBuffer</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAttributeTable</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　这些函数的名字就显示了它们的功能。执行这些函数是非常简单的，我们在这里讨论时忽略它们（可以看程序的原代码）。在这一节我们只展示一个dumpAttributeTable函数。<br>　　我们首先来浏览一下该例子，看看如下的一些全局变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ID3DXMesh* Mesh = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> DWORD NumSubsets = <span class="number">3</span>;</span><br><span class="line">IDirect3DTexture9* Textures[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">// texture for each subset</span></span><br><span class="line"><span class="built_in">std</span>::ofstream OutFile; <span class="comment">// used to dump mesh data to file</span></span><br></pre></td></tr></table></figure></p>
<p>　　这里我们定义了一个mesh对象的指针，我们以后要创建的。我们也定义了mesh拥有的子集数——三。在这个例子中，每个子集都用一个不同的纹理来渲染；纹理数组包含每个子集的纹理，如第i个纹理对应mesh的第i个子集。最后，Outfile变量被用来把mesh的内容输出为一个文本文件。<br>　　这个例子的大部分工作是在setup函数中进行。我们首先创建一个空的mesh：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HRESULT hr = <span class="number">0</span>;</span><br><span class="line">    hr = D3DXCreateMeshFVF(</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">24</span>,</span><br><span class="line">        D3DXMESH_MANAGED,</span><br><span class="line">        Vertex::FVF,</span><br><span class="line">        Device,</span><br><span class="line">         &amp;Mesh);</span><br></pre></td></tr></table></figure></p>
<p>这里我们分配一个有12个面和24个顶点的mesh，这是描述一个盒子所必须的。<br>　　这样的话，mesh是空的，因此我们需要将组成盒子的顶点和索引分别写入顶点缓存和索引缓存。锁定顶点/索引缓存并手动写入数据这是很容易的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill in vertices of a box</span></span><br><span class="line">Vertex* v = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;LockVertexBuffer(<span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v);</span><br><span class="line"><span class="comment">// fill in the front face vertex data</span></span><br><span class="line">v[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">1</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">v[<span class="number">22</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">v[<span class="number">23</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">Mesh-&gt;UnlockVertexBuffer();</span><br><span class="line"><span class="comment">// Define the triangles of the box</span></span><br><span class="line">WORD* i = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;LockIndexBuffer(<span class="number">0</span>, (<span class="keyword">void</span>**)&amp;i);</span><br><span class="line"><span class="comment">// fill in the front face index data</span></span><br><span class="line">i[<span class="number">0</span>] = <span class="number">0</span>; i[<span class="number">1</span>] = <span class="number">1</span>; i[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">i[<span class="number">3</span>] = <span class="number">0</span>; i[<span class="number">4</span>] = <span class="number">2</span>; i[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill in the right face index data</span></span><br><span class="line">i[<span class="number">30</span>] = <span class="number">20</span>; i[<span class="number">31</span>] = <span class="number">21</span>; i[<span class="number">32</span>] = <span class="number">22</span>;</span><br><span class="line">i[<span class="number">33</span>] = <span class="number">20</span>; i[<span class="number">34</span>] = <span class="number">22</span>; i[<span class="number">35</span>] = <span class="number">23</span>;</span><br><span class="line">Mesh-&gt;UnlockIndexBuffer();</span><br></pre></td></tr></table></figure></p>
<p>　　一旦mesh的几何信息被写入，我们必须指定每个三角形在哪个子集中。回想一下属性缓存就是存储的在mesh中每个三角形所属的子集信息。在这个例子中，我们指定索引缓存中的前四个三角形子集为0，接着的四个三角形子集为1，最后四个三角形子集为2。代码如下：<br>DWORD<em> attributeBuffer = 0;<br>Mesh-&gt;LockAttributeBuffer(0, &amp;attributeBuffer);<br>for(int a = 0; a &lt; 4; a++) // triangles 1-4<br>    attributeBuffer[a] = 0; // subset 0<br>for(int b = 4; b &lt; 8; b++) // triangles 5-8<br>    attributeBuffer[b] = 1; // subset 1<br>for(int c = 8; c &lt; 12; c++) // triangles 9-12<br>    attributeBuffer[c] = 2; // subset 2<br>Mesh-&gt;UnlockAttributeBuffer();<br>　　现在我们已经创建了一个包含有效数据的mesh。在这一小部分我们将渲染mesh，不过首先还是先将其优化一下。注意虽然这对于一个盒子mesh来说，优化mesh数据没有真正的效果，但是我们还是用ID3DXMesh接口方法来实践一下。为了优化一个mesh，我们首先需要计算mesh的邻接信息：<br>std::vector<dword> adjacencyBuffer(Mesh-&gt;GetNumFaces() </dword></em> 3);<br>Mesh-&gt;GenerateAdjacency(0.0f, &amp;adjacencyBuffer[0]);<br>　　然后我们就能够优化mesh了：<br>hr = Mesh-&gt;OptimizeInplace(<br>        D3DXMESHOPT_ATTRSORT |<br>        D3DXMESHOPT_COMPACT |<br>        D3DXMESHOPT_VERTEXCACHE,<br>        &amp;adjacencyBuffer[0],<br>         0, 0, 0);<br>　　设置好了mesh以后，我们就为渲染它做好了准备。不过在setup函数中还有最后一个问题，也就是在前面我们说的将mesh的内在数据内容写入文件的函数。这能够检查mesh的数据，它能帮助我们调试和学习mesh的结构。<br>OutFile.open(“Mesh Dump.txt”);<br>dumpVertices(OutFile, Mesh);<br>dumpIndices(OutFile, Mesh);<br>dumpAttributeTable(OutFile, Mesh);<br>dumpAttributeBuffer(OutFile, Mesh);<br>dumpAdjacencyBuffer(OutFile, Mesh);<br>OutFile.close();<br>…Texturing loading, setting render states, etc., snipped<br>return true;<br>} // end Setup()<br>　　例如，dumpAttributeTable函数将属性表的数据写入文件。它的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAttributeTable</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outFile &lt;&lt; <span class="string">"Attribute Table:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// number of entries in the attribute table</span></span><br><span class="line">    DWORD numEntries = <span class="number">0</span>;</span><br><span class="line">    mesh-&gt;GetAttributeTable(<span class="number">0</span>, &amp;numEntries);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;D3DXATTRIBUTERANGE&gt; table(numEntries);</span><br><span class="line">    mesh-&gt;GetAttributeTable(&amp;table[<span class="number">0</span>], &amp;numEntries);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numEntries; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Entry "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Subset ID: "</span> &lt;&lt; table[i].AttribId &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Face Start: "</span> &lt;&lt; table[i].FaceStart &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Face Count: "</span> &lt;&lt; table[i].FaceCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Vertex Start: "</span> &lt;&lt; table[i].VertexStart &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Vertex Count: "</span> &lt;&lt; table[i].VertexCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outFile &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的文本文件来自于通过dumpAttributeTable函数得到的mesh Dump.txt文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Attribute Table:</span><br><span class="line">----------------</span><br><span class="line">Entry 0</span><br><span class="line">------------</span><br><span class="line">Subset ID: 0</span><br><span class="line">Face Start: 0</span><br><span class="line">Face Count: 4</span><br><span class="line">Vertex Start: 0</span><br><span class="line">Vertex Count: 8</span><br><span class="line">Entry 1</span><br><span class="line">------------</span><br><span class="line">Subset ID: 1</span><br><span class="line">Face Start: 4</span><br><span class="line">Face Count: 4</span><br><span class="line">Vertex Start: 8</span><br><span class="line">Vertex Count: 8</span><br><span class="line">Entry 2</span><br><span class="line">------------</span><br><span class="line">Subset ID: 2</span><br><span class="line">Face Start: 8</span><br><span class="line">Face Count: 4</span><br><span class="line">Vertex Start: 16</span><br><span class="line">Vertex Count: 8</span><br></pre></td></tr></table></figure></p>
<p>我们能够了解到我们为mesh所指定的相匹配的数据——有三个子集且每个子集有4个三角形。建议你去看看本例子Dump.txt的完整信息。该文件在本示例文件目录下。<br>最后，我们使用下面的代码就能够非常容易地渲染mesh了；我们只需要循环每个子集，设置相关联的纹理然后在绘制子集即可。这是非常容易的，因为我们已经为每个子集指定的下标如0，1，2，…，n-1，这里的n就是子集的个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...update frame code snipped</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,<span class="number">0x00000000</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumSubsets; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Device-&gt;SetTexture( <span class="number">0</span>, Textures[i] );</span><br><span class="line">            Mesh-&gt;DrawSubset( i );</span><br><span class="line">        &#125;</span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Fonts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Fonts/" class="post-title-link" itemprop="url">第九章 字体(Fonts)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:12:44" itemprop="dateCreated datePublished" datetime="2019-04-11T15:12:44+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Fonts/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Fonts/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ID3DXFont"><a href="#ID3DXFont" class="headerlink" title="ID3DXFont"></a>ID3DXFont</h1><p>在D3DX库中提供了一个ID3DXFont接口，它能被用于在Direct3D应用程序中绘制文字。这个接口是使用GDI来绘制文字的，因此我们能够使用这个接口来执行这个操作。无论如何，因为ID3DXFont使用的是GUI，所以它能够联合字体句柄和格式化字体。</p>
<h2 id="创建一个ID3DXFont"><a href="#创建一个ID3DXFont" class="headerlink" title="创建一个ID3DXFont"></a>创建一个ID3DXFont</h2><p>　　我们能够使用D3DXCreateFontIndirect函数来创建一个ID3DXFont接口。<br>HRESULT D3DXCreateFontIndirect(<br>    LPDIRECT3DDEVICE9 pDevice, // device to be associated with the font<br>    CONST LOGFONT<em> pLogFont, // LOGFONT structure describing the font<br>    LPD3DXFONT</em> ppFont // return the created font<br>);<br>　　下面的代码片段显示了怎样使用这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LOGFONT lf;</span><br><span class="line">ZeroMemory(&amp;lf, <span class="keyword">sizeof</span>(LOGFONT));</span><br><span class="line">lf.lfHeight = <span class="number">25</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWidth = <span class="number">12</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWeight = <span class="number">500</span>; <span class="comment">// boldness, range 0(light) - 1000(bold)</span></span><br><span class="line">lf.lfItalic = <span class="literal">false</span>;</span><br><span class="line">lf.lfUnderline = <span class="literal">false</span>;</span><br><span class="line">lf.lfStrikeOut = <span class="literal">false</span>;</span><br><span class="line">lf.lfCharSet = DEFAULT_CHARSET;</span><br><span class="line"><span class="built_in">strcpy</span>(lf.lfFaceName, <span class="string">"Times New Roman"</span>); <span class="comment">// font style</span></span><br><span class="line">ID3DXFont* font = <span class="number">0</span>;</span><br><span class="line">D3DXCreateFontIndirect(Device, &amp;lf, &amp;font);</span><br><span class="line">　　我们必须填充一个LOGFONT结构来描述想创建的字体类型。</span><br><span class="line">　　注意：你也能够使用D3DXCreateFont函数来获得一个ID3DXFont接口指针。</span><br><span class="line"><span class="number">9.1</span><span class="number">.2</span>绘制文本</span><br><span class="line">　　一旦我们获得了ID3DXFont接口指针，绘制文本就是很简单的事情了，我们只要调用ID3DXFont::DrawText方法就可以实现了。</span><br><span class="line">INT ID3DXFont::DrawText(</span><br><span class="line">    LPCSTR pString,</span><br><span class="line">    INT Count,</span><br><span class="line">    LPRECT pRect,</span><br><span class="line">    DWORD Format,</span><br><span class="line">    D3DCOLOR Color</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>pString — 指向要绘制的文字。</li>
<li>Count — 字符串中特征字符的数量。假如字符是以null结束的字符串则可将其指定为-1。</li>
<li>pRect — 指向一个RECT结构，它定义一个文字被绘制在屏幕上的范围。</li>
<li>Format — 可选参数，指定文字怎样被格式化；要获得更详细的信息请查看SDK文档。</li>
<li>Color — 文字的颜色。<br>　　例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Font-&gt;DrawText(</span><br><span class="line">    <span class="string">"Hello World"</span>, <span class="comment">// String to draw.</span></span><br><span class="line">    <span class="number">-1</span>, <span class="comment">// Null terminating string.</span></span><br><span class="line">    &amp;rect, <span class="comment">// Rectangle to draw the string in.</span></span><br><span class="line">    DT_TOP | DT_LEFT, <span class="comment">// Draw in top-left corner of rect.</span></span><br><span class="line">     <span class="number">0xff000000</span></span><br><span class="line">     ); <span class="comment">// Black.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>9.1.3计算每秒的渲染帧数<br>　　这一章的ID3DXFont和Cfont例子是计算和显示每秒渲染的帧数（FPS）。这一部分说明怎样计算FPS。<br>　　首先，我们定义如下三个全局变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD FrameCnt; <span class="comment">// The number of frames that have occurred.</span></span><br><span class="line"><span class="keyword">float</span> TimeElapsed; <span class="comment">// The time that has elapsed so far.</span></span><br><span class="line"><span class="keyword">float</span> FPS; <span class="comment">// The frames rendered per second.</span></span><br></pre></td></tr></table></figure></p>
<p>　　我们计算每一秒的FPS；它给我们一个很好的平均。另外，在同一秒中内只保存一个FPS，这给了我们足够时间来读取它，在它再一次改变之前。<br>　　因此每一帧我们增加FrameCnt并且把从上一帧到现在流逝的时间写进TimeElapsed：<br>FrameCnt++;<br>TimeElapsed += timeDelta;<br>这里timeDelta是两帧之间的时间。<br>　　    在一秒种结束以后，我们能够用下面的公式来计算FPS：<br>FPS = (float)FrameCnt / TimeElapsed;<br>我们从新设置FrameCnt和TimeElapsed为计算下一秒的FPS做准备。下面就是合在一起的代码：<br>void CalcFPS(float timeDelta)<br>{<br>    FrameCnt++;<br>    TimeElapsed += timeDelta;<br>    if(TimeElapsed &gt;= 1.0f)<br>    {<br>        FPS = (float)FrameCnt / TimeElapsed;<br>        TimeElapsed = 0.0f;<br>        FrameCnt = 0;<br>    }<br>}<br>9.2 CD3DFont<br>　　DirectX SDK给我们提供了一些很有用的代码，它们在你的DXSDK目录下的\Samples\C++\Commond下。CD3DFont类代码是使用纹理三角形和Direct3D。因为CD3DFont使用Direct3D代替GDI来渲染， 这比ID3DXFont快的多。然而，CD3DFont不能够联合字体句柄和格式化ID3DXFont。假如你追求速度和只需要一些简单的字体，CD3DFont类就能满足你的要求了。<br>　　使用CD3DFont类，你需要添加下列文件到你的程序中：d3dfont.h, d3dfont.cpp, d3dutil.h, d3dutil.cpp, dxutil.h和dxutil.cpp。这些文件可以在刚才所说目录下的Include和Src目录下。<br>9.2.1创建一个CD3DFont<br>　　为了创建一个CD3DFont实例，我们只需要简单地象一般的C++对象那样实例化就可以了；下面是它的构造原型：<br>CD3DFont(const TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags=0L);</p>
<ul>
<li>strFontName — 以null结束的字符串，它指定字体类型。</li>
<li>dwHeight — 字体的高度。</li>
<li>dwFlags — 可选参数；你能设置该参数为0或者用下面参数；D3DFONT_BOLD, D3DFONT_ITALIC, D3DFONT_ZENABLE。<br>　　实例化一个CD3DFont对象以后，我们必须调用下面的方法来初始化字体：<br>Font = new CD3DFont(“Times New Roman”, 16, 0); // instantiate<br>Font-&gt;InitDeviceObjects( Device );<br>Font-&gt;RestoreDeviceObjects();<br>9.2.2绘制文本<br>　　现在我们已经创建和初始化了一个CD3DFont对象，这已经为绘制文字做好了准备。绘制文字是使用下面的方法：<br>HRESULT CD3DFont::DrawText(FLOAT x, FLOAT y, DWORD dwColor,<br>  const TCHAR* strText, DWORD dwFlags=0L);</li>
<li>x — 文字在屏幕上开始绘制的x坐标。</li>
<li>y —文字在屏幕上开始绘制的y坐标。 </li>
<li>dwColor — 文字的颜色。</li>
<li>strText — 要绘制的文字。</li>
<li>dwFlags — 可选参数；你能设置该参数为0或者用下面参数；D3DFONT_CENTERED, D3DFONT_TWOSIDED, D3DFONT_FILTERED。<br>　　例子：<br>   Font-&gt;DrawText(20, 20, 0xff000000, “Hello, World”);<br>9.2.3 清除<br>　　在删除一个CD3DFont对象之前，我们必须首先调用一些清除程序，就象下面列举的代码片段：<br>Font-&gt;InvalidateDeviceObjects();<br>Font-&gt;DeleteDeviceObjects();<br>delete Font;<br>9.3 D3DXCreateText<br>　　最后的函数是被用来创建一个3D 文字网格。图9.1显示了本章FontMes3D实例渲染的3D文字网格。</li>
</ul>
<p>图9.1<br>　　该函数的原型是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    HDC hDC,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pText,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT Deviation,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT Extrusion,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXMESH* ppMesh,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXBUFFER* ppAdjacency,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPGLYPHMETRICSFLOAT pGlyphMetrics</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个函数如果调用成功则返回D3D_OK。</p>
<ul>
<li>pDevice — 和mesh关联的device。</li>
<li>hDC — 我们将要用来产生mesh的包含描述字体的设备环境句柄。 </li>
<li>pText — 指向以null结束的字符串的指针，此字符串是用来指定创建什么文字mesh。</li>
<li>Deviation — 字型轮廓段数间距。该值必须大于等于0。当它为0时，段数等于字体原始设计单位（该值越接近0，那么字体就越光滑）。</li>
<li>Extrusion — 文字在z轴方向的深度。</li>
<li>ppMesh — 返回创建的mesh。</li>
<li>ppAdjacency — 返回创建mesh的相关信息。假如你不需要它可以将其指定为null。</li>
<li>pGlyphMetrics — 一个指向LPGLYPHMETRICSFLOAT结构数组的指针，它包含了字型米数据。假如你不关心此数据，你可以把它设置为0。<br>　　 下面的示例代码展示的是使用这个函数来创建一个文字3D 网格模型。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtain a handle to a device context.</span></span><br><span class="line">HDC hdc = CreateCompatibleDC( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill out a LOGFONT structure that describes the font’s properties.</span></span><br><span class="line">LOGFONT lf;</span><br><span class="line">ZeroMemory(&amp;lf, <span class="keyword">sizeof</span>(LOGFONT));</span><br><span class="line"></span><br><span class="line">lf.lfHeight = <span class="number">25</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWidth = <span class="number">12</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWeight = <span class="number">500</span>; <span class="comment">// boldness, range 0(light) - 1000(bold)</span></span><br><span class="line">lf.lfItalic = <span class="literal">false</span>;</span><br><span class="line">lf.lfUnderline = <span class="literal">false</span>;</span><br><span class="line">lf.lfStrikeOut = <span class="literal">false</span>;</span><br><span class="line">lf.lfCharSet = DEFAULT_CHARSET;</span><br><span class="line"><span class="built_in">strcpy</span>(lf.lfFaceName, <span class="string">"Times New Roman"</span>); <span class="comment">// font style</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a font and select that font with the device context.</span></span><br><span class="line">HFONT hFont;</span><br><span class="line">HFONT hFontOld;</span><br><span class="line">hFont = CreateFontIndirect(&amp;lf);</span><br><span class="line">hFontOld = (HFONT)SelectObject(hdc, hFont);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the 3D mesh of text.</span></span><br><span class="line">ID3DXMesh* Text = <span class="number">0</span>;</span><br><span class="line">D3DXCreateText(_device, hdc, <span class="string">"Direct3D"</span>, <span class="number">0.001f</span>, <span class="number">0.4f</span>, &amp;Text, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reselect the old font, and free resources.</span></span><br><span class="line">SelectObject(hdc, hFontOld);</span><br><span class="line">DeleteObject( hFont );</span><br><span class="line">DeleteDC( hdc );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在你便能简单地调用mesh的DrawSubset方法来渲染一个3D文字：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text-&gt;DrawSubset(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Stenciling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Stenciling/" class="post-title-link" itemprop="url">模版(Stenciling)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:11:29" itemprop="dateCreated datePublished" datetime="2019-04-11T15:11:29+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Stenciling/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Stenciling/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>模版缓存是一个远离屏幕的缓存，我们能够用它来完成一些特效。模版缓存与后缓存和深度缓存有相同的定义，因此在模版缓存中的ijth像素与后缓存和深度缓存中的ijth像素是相协调的。就象名字所说，模版缓存就象一个模版它允许我们印刷渲染后缓存的某个部分。<br>举例，当要实现一个镜子时，我们只需要简单地反射一个物体细节到镜子平面上；然而，我们仅仅想只绘制镜子里的反射结果。我们能用模版缓存来印制渲染它。图8.1清楚的显示了这一点。</p>
<p>图8.1<br>模版缓存是Direct3D中的一小部分，它是通过一个简单的表面而被约束的。就象混合，这个简单的表面提供了可变的强大的设置能力。有效地学习使用模版缓存最好的方法是通过学习实际的应用程序。一旦你学懂了一点应用程序中的模版缓存，你将会得到一个更好的用于你自己需要特效的主意。<br>正因为这个原因，这一章我们特别安排学习两个使用模版缓存的应用程序。<br>目标</p>
<ul>
<li>理解模版缓存是怎样工作的，怎样创建一个模版缓存以及怎样控制它。</li>
<li>学习怎样实现一个镜面效果，使用模版缓存来防止绘制反射到不在镜子表面上的物体。</li>
<li>利用模版缓存怎样渲染阴影和防止“双倍混合”。<br>8.1使用模版缓存<br>　　为了使用模版缓存，我们在初始化Direct3D时必须首先请求一个，然后必须启用它。我们在8.1.1中讲述怎样请求一个模版缓存。为了启用模版缓存，我们必须设置D3DRS_STENCILENABLE渲染状态并且指定它为true（关闭它即可指定为false）。下面的代码是启用和关闭模版缓存的代码：<br>Device-&gt;SetRenderState(D3DRS_STENCILENABLE, true);<br>… // do stencil work<br>Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false);<br>我们可以使用IDirect3DDevice9::Clear方法来清除模版缓存并让其拥有默认值。回忆一下，同样的方法被用在清除后缓存和深度缓存中。<br>Device-&gt;Clear(0, 0,<br>  D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,<br>  0xff000000, 1.0f, 0 );<br>注意我们已经添加了D3DCLEAR_STENCIL到第三个参数中，它表示我们想把模版缓存和目标（后缓存）以及深度缓存一起清除。有6种值可以用来指定清除后的模版缓存；在这个例子中我们将它清除为0。<br>8.1.1请求一个模版缓存<br>　　在我们创建深度缓存的同时一个模版缓存能够被创建。当指定深度缓存格式的时候，我们同时指定模版缓存的格式。这样，模版缓存和深度缓存分享同一个离屏表面缓存，但是每个像素被指定到各自缓存内存片段中。下面列出了3种深度/模版缓存的格式：</li>
<li>D3DFMT_D24S8—这种格式是说创建一个32位深度/模版缓存，其中24位为深度缓存，8位为模版缓存。</li>
<li>D3DFMT_D24X4S4—这种格式是说创建一个32位深度/模版缓存，其中24位为深度缓存，4位为模版缓存，还有4位留着不用。</li>
<li>D3DFMT_D15S1—这种格式是说创建一个16位深度/模版缓存，其中15位为深度缓存，1位为模版缓存。<br>注意，还有一些格式没有分配任何位给模版缓存。例如，D3DFMT_D32格式是说只创建一个32位深度缓存。<br>  同样，不同硬件对模版缓存的支持也是不同的。例如有些显卡就不支持8位模版缓存。<br>8.1.2模版测试<br>  如前所述，我们能够使用模版缓存来阻止渲染后缓存中的某些部分。阻止特殊像素被写是通过模版测试（stencil test）来决定的，这是通过下面的表达式来完成的：<br>(ref &amp; mask) ComparisonOperation (value &amp; mask)<br>模版测试是对每个像素进行的，假设模版是被允许。将有两个操作：</li>
<li>左手边操作数（LHS=ref&amp;mask）</li>
<li>右手边操作数（RHS=value&amp;mask）<br>模版测试比较LHS和RHS，通过比较运算来指定。全部的运算都得到一个布尔值（true/false）。假如测试的结果是true，那么我们把像素写入后缓存。假如测试的结果是false,我们就阻止像素被写入后缓存。当然，如果像素不能被写入后缓存，那么它也不能被写入深度缓存。<h3 id="控制模版测试"><a href="#控制模版测试" class="headerlink" title="控制模版测试"></a>控制模版测试</h3>Direct3D允许我们控制变量用于模版测试。换句话说，我们可以指定参考值（stencil reference）和掩码(mask value)，以便进行比较运算。虽然我们不能明确地设定模版值（stencil value）,但是我们能够控制写入模版缓存的值。<h4 id="模版参考值（Reference-Value）"><a href="#模版参考值（Reference-Value）" class="headerlink" title="模版参考值（Reference Value）"></a>模版参考值（Reference Value）</h4>模版参考值ref的默认值为0，但是我们能够通过设置D3DRS_STENCILREF渲染状态来改变它。例如，下面的代码就是设置模版参考值为1：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;SetRenderState(D3DRS_STENCILREF, <span class="number">0x1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意我们往往使用16进制，因为这让它看起来比整数更容易象一个位队列，并且当我们做位操作时这样看起来更有用，比如相加。</p>
<h4 id="模版掩码"><a href="#模版掩码" class="headerlink" title="模版掩码"></a>模版掩码</h4><p>模版掩码值mask是被用来掩饰（隐藏）在ref和value变量中的位。它的默认值是0xffffffff，也就是没有掩饰任何位。我们能够通过设置D3DRS_STENCILMASK渲染状态来改变它。下面的例子就是掩饰高16位：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;SetRenderState(D3DRS_STENCILMASK, <span class="number">0x0000ffff</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="模版值（Stencil-Value）"><a href="#模版值（Stencil-Value）" class="headerlink" title="模版值（Stencil Value）"></a>模版值（Stencil Value）</h4><p>作为以前的规定，在模版缓存中我们进行模版测试的当前像素。例如，假如我们对ijth像素进行模版测试，那么该值将被写入ijth模版缓存。我们不能明确地设置个别模版值，但是可以清除模版缓存。我们能够使用模版渲染状态来控制将什么写入模版缓存。</p>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>我们能够通过设置D3DRS_STENCILFUNC渲染状态来设置比较运算。这个比较运算能够被D3DCMPFUNC的任何成员类型列举：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _D3DCMPFUNC &#123;</span><br><span class="line">    D3DCMP_NEVER = <span class="number">1</span>,          <span class="comment">// 模版测试永不成功</span></span><br><span class="line">    D3DCMP_LESS = <span class="number">2</span>,           <span class="comment">// 假如LHS &lt; RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_EQUAL = <span class="number">3</span>,          <span class="comment">// 假如LHS = RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_LESSEQUAL = <span class="number">4</span>,      <span class="comment">// 假如LHS &lt;= RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_GREATER = <span class="number">5</span>,        <span class="comment">// 假如LHS &gt; RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_NOTEQUAL = <span class="number">6</span>,       <span class="comment">// 假如LHS &lt;&gt; RHS，那么模版测试成功</span></span><br><span class="line">    D3DCMP_GREATEREQUAL = <span class="number">7</span>,</span><br><span class="line">    D3DCMP_ALWAYS = <span class="number">8</span>,</span><br><span class="line">    D3DCMP_FORCE_DWORD = <span class="number">0x7fffffff</span></span><br><span class="line">&#125; D3DCMPFUNC;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>D3DCMP_GREATEREQUAL——假如LHS &gt;= RHS，那么模版测试成功。</li>
<li>D3DCMP_ALWAYS——模版测试总是成功。<h3 id="更新模版缓存"><a href="#更新模版缓存" class="headerlink" title="更新模版缓存"></a>更新模版缓存</h3>除了决定是否写或阻止一个特殊像素被写入后缓存以外，我们能够定义模版缓存基于三种可能的案例怎样被更新：</li>
<li>对于ijth像素模版测试失败。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILFAIL渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILFAIL, StencilOperation);</li>
<li>对于ijth像素深度测试失败。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILZFAIL渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, StencilOperation);</li>
<li>对于ijth像素模版测试和深度测试都成功。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILPASS渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILPASS, StencilOperation);<br>其中StencilOperation能够是下面预先定义的常数：</li>
<li>D3DSTENCILOP_KEEP——指定不改变模版缓存。</li>
<li>D3DSTENCILOP_ZERO——指定设置模版缓存入口为0。</li>
<li>D3DSTENCILOP_REPLACE——指定用模版参考值（reference value）来替换模版缓存入口。</li>
<li>D3DSTENCILOP_INCRSAT——指定增加模版缓存入口。假如增加的值超过了允许的最大值，我们就设置它为最大值。</li>
<li>D3DSTENCILOP_DECRSAT——指定减少模版缓存入口。假如减少后的值小于了0，我们就设置它0。</li>
<li>D3DSTENCILOP_INVERT——指定按位取反模版缓存入口。</li>
<li>D3DSTENCILOP_INCR——指定增加模版缓存入口。假如增加的值超过了允许的最大值，我们就设置它为0。</li>
<li>D3DSTENCILOP_DECR——指定减少模版缓存入口。假如减少后的值小于了0，我们就设置它为允许的最大值。<h3 id="模版写掩码"><a href="#模版写掩码" class="headerlink" title="模版写掩码"></a>模版写掩码</h3>　　除了已经提及的模版渲染状态之外，我们能够设置一个写掩码（write mask）它将掩饰我们写进模版缓存的任何值的位。我们能够通过D3DRS_STENCILWRITEMASK渲染状态来设置写掩码。它的默认值是0xffffffff。下面的例子是掩饰高16位：<br>Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, 0x0000ffff);<br>8.2实例程序：镜子<br>　　在自然界中的很多表面象镜子一样允许我们通过它的反射来看物体。这一部分讲了我们怎样用3D应用程序来模拟镜子。注意为了简单我们只模拟平面镜。举点例子，一辆擦亮的小汽车能够反射；然而，小车的车身是光滑的，圆的，不是一个平面。我们渲染反射是这些，象光滑的大理石地板、挂在墙上的镜子。换句话说就是在一个平面的镜子。<br>　　实现镜子的程序需要我们解决两个问题。第一，我们必须学习沿着一个面怎样反射一个物体以便能够正确地绘制反射结果。第二，我们必须只能在一个镜子范围内显示反射结果。即，我们必须掩饰一个表面作为一个镜子，且只渲染那些在镜子里物体。图8.1就是说的这个内容。<br>　　第一个问题只需要用一些几何向量就可以简单解决。我们能够利用模版缓存解决第二个问题。下两小节分别介绍怎样解决这两个问题。第三小节把它们柔和在一起并且介绍一下本章的第一个应用程序实例代码——镜子。<br>8.2.1反射数学<br>　　我们现在演示怎样计算点V=（Vx, Vy, Vz）被平面n<em>p+d=0反射的点V’=（V’x, V’y, V’z）。图8.2贯穿整个讨论。<br>　　<br>　　图8.2<br>　　根据Part I中的“平面”部分，我们能够知道q=v-kn,这里k是有符号的从v到平面的距离。下面是v相对与平面（n，d）的反射推导：<br>　　<br>　　我们用下面的矩阵来实现从v到v’的转换：<br>　　<br>　　在D3DX库中用下面的函数来创建反射矩阵R。<br>D3DXMATRIX </em>D3DXMatrixReflect(<br>  D3DXMATRIX <em>pOut, // The resulting reflection matrix.<br>  CONST D3DXPLANE </em>pPlane // The plane to reflect about.<br>);<br>一旦我们说到反射变换的话题，就让我们看看其他3种特殊的反射变换。它们是关于三个坐标平面的反射—yz平面，xz平面，和xy平面—它们分别通过下面三个矩阵来表现：</li>
</ul>
<p>通过yz平面反射一个点，我们只需要简单的将x分量取反就可以了。同样的，通过xz平面反射一个点，我们只需要简单的将y分量取反。通过xy平面反射一个点，我们只需要简单的将z分量取反。这种反射是非常容易理解的。<br>8.2.2镜面实现流程<br>当实现一个镜面，一个物体假如在一面镜子前那么它就会被反射。然而，我们不想测试空间假如一个物体在一面镜子前，要做它是非常复杂的。因此，为了简化事情，我们总是反射物体并且无限制地渲染它。但是这样就有一个象本章开头的图8.1一样的问题。即，物体反射被渲染到了没有镜子的表面。我们能够用模版缓存来解决这个问题，因为模版缓存允许我们阻止渲染在后缓存中的特定区域。因此，我们使用模版缓存来阻止渲染被反射的不在镜子里的茶壶。下面的步骤简要的说明了怎样实现：<br>1、 正常渲染所有的场景——地板，墙，镜子和茶壶——不包含反射的茶壶。注意这一步没有修改模版缓存。<br>2、 清除模版缓存为0。图8.3显示了后缓存和模版缓存。</p>
<p>图8.3<br>3、 渲染只有镜子部分的图元到模版缓存中。设置模版测试总是成功，并且假如测试成功就指定模版缓存入口为1。我们仅仅渲染镜子，在模版缓存中的所有像素都将为0，除了镜子部分为1以外。图8.4显示了更新以后的模版缓存。也就是说，我们在模版缓存中对镜子像素做了标记。</p>
<p>图8.4<br>4、 现在我们渲染被反射的茶壶到后缓存和模版缓存中。但是假如模版测试通过，我们就只渲染后缓存。假如在模版缓存中的值为1，那么我们设置模版测试通过。这样，茶壶就仅仅被渲染到模版缓存为1的地方了。因为只有镜子对应的模版缓存值为1，所以反射的茶壶就只能被渲染到镜子里。<br>8.2.3代码和解释<br>　　这个例子的相关代码在RenderMirror函数中，它首先渲染镜子图元到模版缓存，然后渲染那些能被渲染到镜子里的反射茶壶。我们现在一行一行的分析RenderMirror函数的代码，并解释为什么要这么做。<br>　　假如你想使用8.2.2部分的步骤实现代码，注意我们从第3步开始，因为对模版缓存来说1和2步已经没有什么事做了。同样我们通过这个解释来讨论通过镜子渲染的信息。<br>　　注意我们将分成几个部分来讨论它。<br>8.2.3.1第一部分<br>　　我们通过允许模版缓存和设置渲染状态来开始：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderMirror</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, <span class="literal">true</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILREF, <span class="number">0x1</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILMASK, <span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK,<span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_REPLACE);</span><br></pre></td></tr></table></figure></p>
<p>　　这是非常容易理解的。我们设置模版比较运算为D3DCMP_ALWAYS,这就是说让所有模版测试都通过。<br>　　假如深度测试失败了，我们指定D3DSTENCILOP_KEEP，它表明不更新模版缓存入口。即，我们保存当前值。这样做的原因是假如深度测试失败了，那么就意味着像素被“模糊”了。我们不想渲染被“模糊”的反射像素。<br>　　同样假如模版测试失败了，我们也指定D3DSTENCILOP_KEEP。但是在这里这样做不是必须的，因为我们指定的是D3DCMP_ALWAYS，当然这样的测试也就永远不会失败。然而，我们只改变比较运算的一位，那么设置模版失败渲染状态是必须的。我们现在就这样做。<br>　　假如深度测试和模版测试都通过了，我们就指定D3DSTENCILOP_REPLACE，更新模版缓存入口，设置模版参考值为0x1。<br>8.2.3.2第二部分<br>　　这下一步阻止渲染镜子代码，除了模版缓存。我们通过设置D3DRS_ZWRITEENABLE并指定为false来阻止写深度缓存。我们能够防止更新后缓存，混合和设置源混合要素为D3DBLEND_ZERO目的混合要素为D3DBLEND_ONE。将这些混合要素代入混合等式，我们得到后缓存是不会改变的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disable writes to the depth and back buffers</span></span><br><span class="line">Device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, <span class="literal">false</span>);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, <span class="literal">true</span>);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);</span><br><span class="line"><span class="comment">// draw the mirror to the stencil buffer</span></span><br><span class="line">Device-&gt;SetStreamSource(<span class="number">0</span>, VB, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">Device-&gt;SetFVF(Vertex::FVF);</span><br><span class="line">Device-&gt;SetMaterial(&amp;MirrorMtrl);</span><br><span class="line">Device-&gt;SetTexture(<span class="number">0</span>, MirrorTex);</span><br><span class="line">D3DXMATRIX I;</span><br><span class="line">D3DXMatrixIdentity(&amp;I);</span><br><span class="line">Device-&gt;SetTransform(D3DTS_WORLD, &amp;I);</span><br><span class="line">Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">18</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// re-enable depth writes</span></span><br><span class="line">Device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>8.2.3.3第三部分<br>　　在模版缓存中，符合镜子可视像素的为0x1，因此对已经渲染的镜子区域做记号。我们现在准备渲染被反射的茶壶。回忆一下，我们仅仅想渲染镜子范围内的反射像素。我们现在可以很容易的做到了，因为在模版缓存中这些像素已经被做了记号。<br>　　我们设置下面的渲染状态：<br>    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL);<br>     Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);<br>　　用一个新的比较运算设置，我们进行下面的模版测试：<br>    (ref &amp; mask == (value &amp; mask)<br>    (0x1 &amp; 0xffffffff) == (value &amp; 0xffffffff)<br>     (0x1)== (value &amp; 0xffffffff)<br>　　这说明了只有当value=0x1时模版测试才成功。因为在模版缓存中只有镜子相应位置的值才是0x1，若我们渲染这些地方那么测试将会成功。因此，被反射的茶壶只会在镜子里绘制而不会在镜子以外的表面上绘制。<br>　　注意我们已经将渲染状态由D3DRS_STENCILPASS变为了D3DSTENCILOP_KEEP，简单的说就是假如测试通过那么就保存模版缓存的值。因此，在下一步的渲染中，我们不改变模版缓存的值。我们仅仅使用模版缓存来对镜子相应位置的像素做标记。<br>8.2.3.4第四部分<br>　　RenderMirror函数的下一部分就是计算在场景中反射位置的矩阵：<br>    // position reflection<br>    D3DXMATRIX W, T, R;<br>    D3DXPLANE plane(0.0f, 0.0f, 1.0f, 0.0f); // xy plane<br>    D3DXMatrixReflect(&amp;R, &amp;plane);<br>    D3DXMatrixTranslation(&amp;T,<br>        TeapotPosition.x,<br>        TeapotPosition.y,<br>        TeapotPosition.z);<br>     W = T * R;<br>　　注意我们首先确定没有反射的茶壶位置，然后就通过xy平面来反射。这种变换规则是通过矩阵相乘来指定的。<br>8.2.3.5第五部分<br>　　我们已经为渲染反射茶壶做好了准备。然而，假如我们现在就渲染它，它是不会被显示的。为什么呢？因为被反射的茶壶的深度比镜子的深度大，因此镜子的图元将把被反射茶壶的图元弄模糊。为了避免这种情况，我们清除深度缓存：<br>     Device-&gt;Clear(0, 0, D3DCLEAR_ZBUFFER, 0, 1.0f, 0);<br>　　并不是所有问题都解决了。假如我们简单的清除深度缓存，被反射的茶壶会被绘制到镜子的前面，物体看起来就不对了。我们想做的是清除深度缓存并且要混合被反射的茶壶和镜子。这样，被反射的茶壶看起来就象在镜子里了。我们能够通过下面的混合等式来混合被反射的茶壶和镜子：</p>
<p>　　因为原像素（sourcePixel）来自被反射的茶壶，目的像素（DestPixel）来自镜子，我们能够通过这个等式明白它们是怎么被混合到一起的。我们有如下的代码：<br>    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_DESTCOLOR);<br>     Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);<br>　　最后，我们准备绘制被反射的茶壶：<br>    Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);<br>    Device-&gt;SetMaterial(&amp;TeapotMtrl);<br>    Device-&gt;SetTexture(0, 0);<br>    Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);<br>     Teapot-&gt;DrawSubset(0);<br>　　回顾一下8.2.3.4部分的W，它能够正确的将被反射的茶壶变换到场景中恰当的位置。同样，我们也要改变背面拣选模式。必须这样做的原因是当一个物体被反射以后，它的正面和背面将会被交换。因此为了改变这种情况，我们必须改变背面拣选模式。<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false);<br>    Device-&gt;SetRenderState( D3DRS_STENCILENABLE, false);<br>    Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);<br>} // end RenderMirror()<br>8.3实例程序：平面阴影<br>在场景中被灯光照射的地方会产生阴影，这将使场景变的更真实。在这一部分我们将演示怎样实现平面阴影，即在平面上的阴影（如图8.5）。</p>
<p>图8.5<br>注意这种阴影是“快砍”，虽然它们增强了场景效果，但是这并不是现实中的阴影。阴影值是一个高级的概念，要深入研究它已经超出了本书的范围。然而，特别值得提及的是在DirectX SDK中有一个示例程序演示了阴影值。<br>　　为了实现平面阴影，我们首先必须找到物体投射到平面上的阴影并进行几何建模以便我们能够渲染它。用一些3D数学就能很容易的实现它。我们然后用50%透明度的黑色材质来渲染描述阴影的多边形。渲染阴影时可能出现“双倍混合”，我们将用一小部分进行解释。我们使用模版缓存来防止双倍混合发生。<br>8.3.1平行光阴影</p>
<p>图8.6<br>图8.6显示了物体在平行光照射下得到的阴影。光线是从平行光源放射出的，它的方向是L,通过顶点p得到r（t） = p + tL。光线r（t）和平面n * p + d = 0 相交得到 s 。交点s 通过射线和平面相交测试是非常容易得到的：<br>把r(t)带进平面等式<br>求解t</p>
<p>那么：</p>
<p>8.3.2点光源阴影</p>
<p>图8.7<br>图8.7显示了物体在点光源照射下得到的阴影。点光源的位置是L。光线通过顶点p，则得到 r(t) = p + t ( p – L )。光线r（t）和平面n <em> p + d = 0 相交得到 s 。用8.3.1同样的方法我们可以得到s。<br>注意：在点光源和平行光中的L是不同的。对于点光源，我们用L来表示点光源的位置。而对于平行光，我们则是用L来表示平行光的照射方向。<br>8.3.3阴影矩阵<br>　　注意图8.6中所示的平行光，影子本质上是把物体按照灯光照射方向平行地投射到平面n</em>p+d=0之上。同样的，图8.7中所示的点光源，影子本质上是把物体按照透视画法从光源投射到平面n<em>p+d=0之上。<br>　　我们能够使用一个矩阵来表示从一个顶点p变换到平面n</em>p=d=0上的s的变化。而且，我们能够用同一个矩阵来表现正交投影和透视投影。<br>　　我们用一个4D向量（nx, ny, nz, d）来表示将要用于投射阴影平面的平面等式中的各个系数。让4D向量L=（Lx, Ly, Lz, Lw）来表示平行光的照射方向或点光源的位置。我们用w来区别：<br>１． 假如w＝０，那么L表示平行光的照射方向。<br>２． 假如w＝1 ，那么L表示点光源的位置。<br>规格化的平面是非常不逊的，我们让k＝（nx, ny, nz, d）*（Lx, Ly, Lz, Lw）= nxLx+nyLy+nzLz+dLw<br>那么我们就可得到表示点p到点s的变换矩阵，即阴影矩阵：</p>
<p>因为在其他地方已经被推导出来了，对于我们来说推导它并没有重大的意义，在这里我们就不再演示推导怎样得到这个矩阵的过程了。但是对与感兴趣的读者可以自己到网上查找相应的信息。<br>　　　　在D3DX库中已经给我们提供了一个建立阴影矩阵的函数。其中当w＝０时表示平行光，当w＝１时表示点光源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXMATRIX *<span class="title">D3DXMatrixShadow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    D3DXMATRIX *pOut,</span></span></span><br><span class="line"><span class="function"><span class="params">    CONST D3DXVECTOR4 *pLight, <span class="comment">// L</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST D3DXPLANE *pPlane <span class="comment">// plane to cast shadow onto</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>8.3.4用模版缓存防止双倍混合<br>　　几何学上，当我们将一个物体投影到一个平面上时，很可能会有两个或者更多的投影三角形被重叠到一起。若我们就这样渲染，那么有重叠三角形的地方就会被多次混合以至这些地方将会变得更黑。图8.8就是这种情况。<br>　　<br>　　图8.8<br>　　我们能够使用模版缓存来解决这个问题。我们设置模版测试为允许像素第一次被渲染。即，当把影子像素渲染到后缓存时，我们同时在模版缓存中做好标记。然后，如果试图把像素向一个已经渲染过的地方写，那么模版测试将会失败。这样，我们就防止了重复写像素也就是防止了双倍混合的发生。<br>8.3.5代码和解释<br>　　下面的代码就是讲解影子例子。本例的相关代码都在RenderShadow函数中。注意我们假设模版缓存都已经被清除为０了。<br>　　首先设置模版渲染状态。将模版比较运算设为D3DCMP_EQUAL且将D3DRS_STENCILREF渲染状态设置为0x0，因此假如在模版缓存中相应的值为0x0，那么就指定渲染阴影到后缓存中。<br>　　因为模版缓存是被清除为0x0的，所以我们第一次将影子像素写入的时候总是正确的；不过因为我们设置D3DRS_STENCILPASS为D3DSTENCILOP_INCR,假如你试图将已经写过的像素写入的话，这个测试将会失败。在第一次写入的时候模版像素已经被写成了0x1，因此假如你再一次写入，模版测试将会失败。因此，我们避免了重复写像素，也避免了双倍混合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderShadow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, <span class="literal">true</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILREF, <span class="number">0x0</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILMASK, <span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, <span class="number">0xffffffff</span>);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);</span><br><span class="line">　　Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_INCR);</span><br><span class="line">　　下一步，我们计算阴影变换并将它放置到场景中适当的位置。</span><br><span class="line">    <span class="comment">// compute the transformation to flatten the teapot into a shadow.</span></span><br><span class="line">    <span class="function">D3DXVECTOR4 <span class="title">lightDirection</span><span class="params">(<span class="number">0.707f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">D3DXPLANE <span class="title">groundPlane</span><span class="params">(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    D3DXMATRIX S;</span><br><span class="line">    D3DXMatrixShadow(&amp;S, &amp;lightDirection, &amp;groundPlane);</span><br><span class="line">    D3DXMATRIX T;</span><br><span class="line">    D3DXMatrixTranslation(&amp;T, TeapotPosition.x, TeapotPosition.y,</span><br><span class="line">    TeapotPosition.z);</span><br><span class="line">    D3DXMATRIX W = T * S;</span><br><span class="line">     Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);</span><br></pre></td></tr></table></figure></p>
<p>　　最后，我们设置一个50%透明度的黑色材质，关闭深度测试，渲染阴影，然后开启深度缓存同时关闭alpha混合和模版测试。我们关闭深度缓存来防止z-fighting，它是当两个不同的表面在深度缓存中有同样的深度值时出现的虚拟物体；深度缓存不知道那一个是在前面，此时就会产生讨厌的闪动。因为阴影和地板是在同一个平面上，z-fighting很可能就会出现。通过先渲染地板然后用深度测试屏蔽阴影，这样我们就能够保证阴影将绘制在地面只之上。<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);<br>    Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>    D3DMATERIAL9 mtrl = d3d::InitMtrl(d3d::BLACK, d3d::BLACK,<br>    d3d::BLACK, d3d::BLACK, 0.0f);<br>    mtrl.Diffuse.a = 0.5f; // 50% transparency.<br>    // Disable depth buffer so that z-fighting doesn’t occur when we<br>    // render the shadow on top of the floor.<br>    Device-&gt;SetRenderState(D3DRS_ZENABLE, false);<br>    Device-&gt;SetMaterial(&amp;mtrl);<br>    Device-&gt;SetTexture(0, 0);<br>    Teapot-&gt;DrawSubset(0);<br>    Device-&gt;SetRenderState(D3DRS_ZENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false);<br>    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false);<br>}//end RenderShadow()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Blending/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Blending/" class="post-title-link" itemprop="url">第七章 混合(Blending)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:08:23" itemprop="dateCreated datePublished" datetime="2019-04-11T15:08:23+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Blending/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Blending/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="混合因素"><a href="#混合因素" class="headerlink" title="混合因素"></a>混合因素</h1><p>　　观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。<br>　　<br>　　图7.1<br>　　假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。<br>　　<br>　　图7.2<br>　　我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。<br>　　这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循：<br>　　规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。<br>　　下面的公式是用来混合两个像素值的：<br>　　<br>　　上面的所有变量都是一个4D颜色向量（r,g,b,a），并且符号是表示分量相乘。</p>
<ul>
<li>OutputPixel——混合后的像素结果。</li>
<li>SourcePixel——通常被计算的像素，它是利用在后缓存中的像素来被混合的。</li>
<li>SourceBlendFactor——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。</li>
<li>DestPixel——在后缓存中的像素。</li>
<li>DestBlendFactor——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。<br>　　源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。<br>　　混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它：<br>Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>7.2混合要素<br>　　通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效果。你能够通过设置D3DRS_SRCBLEND和D3DRS_DESTBLEND渲染状态来分别设置源混合要素和目的混合要素。例如我们可以这样写：<br>Device-&gt;SetRenderState(D3DRS_SRCBLEND, Source);<br>Device-&gt;SetRenderState(D3DRS_DESTBLEND, Destination);<br>　　这里Source和Destination能够使用下面混合要素中的一个：</li>
<li>D3DBLEND_ZERO——blendFactor=(0, 0, 0, 0)</li>
<li>D3DBLEND_ONE——blendFactor=(1, 1, 1, 1)</li>
<li>D3DBLEND_SRCCOLOR——blendFactor=(rs, gs, bs, as)</li>
<li>D3DBLEND_INVSRCCOLOR——blendFactor=(1-rs, 1-gs, 1-bs, 1-as)</li>
<li>D3DBLEND_SRCALPHA——blendFactor=(as, as, as, as)</li>
<li>D3DBLEND_INVSRCALPHA——blendFactor=(1-as, 1-as, 1-as, 1-as)</li>
<li>D3DBLEND_DESTALPHA——blendFactor=(ad, ad, ad, ad)</li>
<li>D3DBLEND_INVDESTALPHA——blendFactor=(1-ad, 1-ad, 1-ad, 1-ad)</li>
<li>D3DBLEND_DESTCOLOR——blendFactor=(rd, gd, bd, ad)</li>
<li>D3DBLEND_INVDESTCOLOR——blendFactor=(1-rd, 1-gd, 1-bd, 1-ad)</li>
<li>D3DBLEND_SRCALPHASAT——blendFactor=(f, f, f, 1)  ,  f=min(as, 1 – ad)</li>
<li>D3DBLEND_BOTHINVSRCALPHA——这种混合模式设置源混合要素为（1-as, 1-as, 1-as, 1-as,）以及目的混合要素为（as,as,as,as）。这种混合模式仅对D3DRS_SRCBLEND有效。<br>　　源和目的混合要素的默认值分别是D3DBLEND_SRCALPHA和D3DBLEND_INVSRCALPHA。<br>7.3透明度<br>  在以前的章节中我们忽略了颜色顶点和材质中的alpha部分，那是因为当时它并不是必须的。现在它首先被用在混合中。<br>  Alpha部分主要是用来指定像素的透明等级。我们为每个像素的alpha部分保留8位，alpha的有效值在[0,255]范围内，[0,255]代表不透明度[0%,100%]。因此，像素的alpha为0时，表示完全透明，像素的alpha为128时，表示50%透明，像素的alpha为255时，表示完全不透明。<br>  为了让alpha部分描述像素的透明等级，我们必须设置源混合要素为D3DBLEND_SRCALPHA以及目的混合要素为D3DBLEND_INVSRCALPHA。这些值碰巧也是被默认设置的。<br>7.3.1Alpha通道<br>　　代替使用Alpha部分来计算遮影，我们能够从纹理的alpha通道中得到alpha信息。Alpha通道是额外的设置位，用它来保存每一个点的alpha值。当一个纹理被映射到一个图元上时，在alpha通道中的alpha信息也被映射，并且它们利用alpha信息为每个像素赋予纹理。图7.3显示了一个带8位alpha通道的图片。<br>　　<br>　　图7.3<br>　　图7.4显示的是一个利用alpha通道指定透明度来渲染的一个纹理方块。<br>　　<br>　　图7.4<br>7.3.2指定Alpha资源<br>　　默认情况下，假如设置一个有alpha通道的纹理，alpha值从在alpha通道中获得。假如没有alpha通道，那么alpha值是通过顶点颜色获得。然而，你能够通过下面的渲染状态来指定使用哪一个资源：<br>// compute alpha from diffuse colors during shading<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);<br>// take alpha from alpha channel<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);<br>7.4使用DirectX纹理工具创建Alpha通道<br>  绝大多数普通图象文件格式没有存储alpha信息。在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile被读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下（我是放在C:\Program Files\Microsoft DirectX 9.0 SDK (February 2005)\Utilities\Bin\x86下的，文件名是DxTex.exe）。<br>  打开DirectX纹理工具，并且把本章中示例文件夹下的crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。</li>
</ul>
<p>图7.5<br>    它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。</p>
<p>图7.6<br>    现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。<br>7.5实例程序：透明度<br>    这个实例程序是在一个木箱背景上绘制一个透明的茶壶，就象图7.2所显示的一样。在这个例子中alpha值是从材质中得到。应用程序允许我们通过按A或S键来增加/减少alpha的值。<br>    使用混合的必要步骤是：</p>
<ol>
<li>设置混合要素D3DRS_SRCBLEND 和 D3DRS_DESTBLEND。</li>
<li>假如你使用alpha部分，指定资源（材质或alpha通道）。</li>
<li>允许alpha混合渲染状态。<br>　　对于这个例子，我们定义下面的全局变量：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ID3DXMesh* Teapot = <span class="number">0</span>; <span class="comment">// the teapot</span></span><br><span class="line">D3DMATERIAL9 TeapotMtrl; <span class="comment">// the teapot’s material</span></span><br><span class="line"></span><br><span class="line">IDirect3DVertexBuffer9* BkGndQuad = <span class="number">0</span>; <span class="comment">// background quad - crate</span></span><br><span class="line">IDirect3DTexture9* BkGndTex = <span class="number">0</span>; <span class="comment">// crate texture</span></span><br><span class="line">D3DMATERIAL9 BkGndMtrl; <span class="comment">// background material</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Setup方法设置很多东西；我们省略了很多与本章无关的代码。关心混合，Setup方法指定alpha值的获取资源。在这个例子中，我们通过材质指定alpha值。注意我们设置茶壶的材质alpha部分为0.5，也就是说茶壶将按照50%的透明度被渲染。我们在这里也要设置混合要素。要注意的是在这个方法中我们不能将alpha混合设置为启用。理由是alpha混合要进行额外的处理并且应该仅在需要用时才被使用。举例，在这个例子中只有茶壶需要用允许alpha混合来被渲染——而方块不需要。因此，我们在Display函数中启用alpha混合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TeapotMtrl = d3d::RED_MTRL;</span><br><span class="line">    TeapotMtrl.Diffuse.a = <span class="number">0.5f</span>; <span class="comment">// set alpha to 50% opacity</span></span><br><span class="line">    BkGndMtrl = d3d::WHITE_MTRL;</span><br><span class="line"></span><br><span class="line">    D3DXCreateTeapot(Device, &amp;Teapot, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">// Create background quad snipped    </span></span><br><span class="line">    ...<span class="comment">// Light and texture setup snipped</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use alpha in material's diffuse component for alpha</span></span><br><span class="line">    Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);</span><br><span class="line">    Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);</span><br><span class="line">    <span class="comment">// set blending factors so that alpha</span></span><br><span class="line">    <span class="comment">// component determines transparency</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);</span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">// view/projection matrix setup snipped</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Display函数中，我们检测假如A或S键被按下那么就通过增加或减少材质的alpha值来反馈。注意这个方法要保证alpha值不会超出[0,1]的范围。我们然后渲染背景。最后，我们启用alpha混合，利用alpha混合来渲染茶壶，关闭alpha混合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// increase/decrease alpha via keyboard input</span></span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'A'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TeapotMtrl.Diffuse.a += <span class="number">0.01f</span>;</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'S'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TeapotMtrl.Diffuse.a -= <span class="number">0.01f</span>;</span><br><span class="line">        <span class="comment">// force alpha to [0, 1] interval</span></span><br><span class="line">        <span class="keyword">if</span>(TeapotMtrl.Diffuse.a &gt; <span class="number">1.0f</span>)</span><br><span class="line">            TeapotMtrl.Diffuse.a = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">if</span>(TeapotMtrl.Diffuse.a &lt; <span class="number">0.0f</span>)</span><br><span class="line">            TeapotMtrl.Diffuse.a = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Render</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,</span><br><span class="line">                        <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw the background</span></span><br><span class="line">        D3DXMATRIX W;</span><br><span class="line">        D3DXMatrixIdentity(&amp;W);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);</span><br><span class="line">        Device-&gt;SetFVF(Vertex::FVF);</span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, BkGndQuad, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        Device-&gt;SetMaterial(&amp;BkGndMtrl);</span><br><span class="line">        Device-&gt;SetTexture(<span class="number">0</span>, BkGndTex);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw the teapot</span></span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, <span class="literal">true</span>);</span><br><span class="line">        D3DXMatrixScaling(&amp;W, <span class="number">1.5f</span>, <span class="number">1.5f</span>, <span class="number">1.5f</span>);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);</span><br><span class="line">        Device-&gt;SetMaterial(&amp;TeapotMtrl);</span><br><span class="line">        Device-&gt;SetTexture(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Teapot-&gt;DrawSubset(<span class="number">0</span>);</span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, <span class="literal">false</span>);</span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：在本章中有另一个使用纹理通道来演示alpha混合的例子texAlpha。与上边的代码不同之处仅仅在于得到alpha值是从纹理而不是从材质。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use alpha channel in texture for alpha</span></span><br><span class="line">Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);</span><br><span class="line">Device-&gt;SetTextureStageState(<span class="number">0</span>, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);</span><br></pre></td></tr></table></figure></p>
<p>这个应用程序读取的是一个在7.4节中用DX Tex Tool工具创建的带有alpha通道的DDS文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Texturing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Texturing/" class="post-title-link" itemprop="url">第六章 纹理(Texturing)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:06:54" itemprop="dateCreated datePublished" datetime="2019-04-11T15:06:54+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Texturing/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Texturing/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做texel。注意v轴是向下的（如图6.2）。<br>　　<br>　　图6.2<br>同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。<br>对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。<br>　　<br>　　图6.3<br>　　  我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。<br>struct Vertex<br>{<br>    float _x, _y, _z;<br>    float _nx, _ny, _nz;<br>    float _u, _v; // texture coordinates<br>    static const DWORD FVF;<br>};<br>const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;<br>　　我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。<br>　　现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。<br>6.2创建并赋予材质<br>　　纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作：<br>HRESULT D3DXCreateTextureFromFile(<br>    LPDIRECT3DDEVICE9 pDevice, // device to create the texture<br>    LPCSTR pSrcFile, // filename of image to load<br>    LPDIRECT3DTEXTURE9<em> ppTexture // ptr to receive the created texture<br>);<br>这个函数能够读取下面图片格式中的任意一种：BMP,DDS,DIB,JPG,PNG,TGA。<br>　　例如，用一个名为stonewall.bmp的图片创建一个纹理，我们将按照下面的例子来写：<br>IDirect3Dtexture9</em> _stonewall;<br>D3DXCreateTextureFromFile(_device, “stonewall.bmp”, &amp;_stonewall);<br>　　设置当前纹理，我们使用下面的方法：<br>HRESULT IDirect3DDevice9::SetTexture(<br>    DWORD Stage, // A value in the range 0-7 identifying the texture<br>                // stage – see note on Texture Stages<br>    IDirect3DBaseTexture9* pTexture // ptr to the texture to set<br>);<br>　　例子：<br>Device-&gt;SetTexture(0, _stonewall);<br>注意：在Direct3D中，你能够设置八个纹理，它们能够组合起来创建更多细节的图象。这又被叫做多重纹理。在本书的第四部分以前我们不会使用多重纹理；因此现在我们总是设置stage为0。<br>　　为了销毁一个纹理，我们设置pTexture为0。例如，假如不想用一个纹理来渲染物体，那么我们就这样写：<br>Device-&gt;SetTexture(0, 0);<br>renderObjectWithoutTexture();<br>假如场景中有使用不同纹理的三角形，我们就必须添加与下面类似的一些代码：<br>Device-&gt;SetTexture(0, _tex0);<br>drawTrisUsingTex0();</p>
<p>Device-&gt;SetTexture(0, _tex1);<br>drawTrisUsingTex1();<br>6.3过滤器<br>    就象以前提及的，纹理被映射到屏幕中的三角形上。通常纹理三角形和屏幕三角形是不一样大的。当纹理三角形比屏幕三角形小时，纹理三角形会被适当放大。当纹理三角形比屏幕三角形大时，纹理三角形会被适当缩小。这两种情况，变形都将会出现。过滤（Filtering）是一种Direct3D用它来帮助这些变形变的平滑的技术。<br>    Direct3D提供了三种不同的过滤器；每种都提供了一个不同的品质级别。越好的品质越慢，因此你必须在品质与速度之间取得一个平衡。纹理过滤器是用IDirect3DDevice9::SetSamplerState方法来设置的。</p>
<ul>
<li>Nearest point sampling——这是默认的过滤方法且返回最差的效果，但是它的计算是最快的。下面的代码就是设置Nearest point sampling作为缩小放大的过滤器：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);</li>
<li>Linear filtering——这种过滤产生还算比较好的效果，在今天的硬件上处理它还是非常快的。它是被推荐使用的。下面的代码就是设置Linear filtering作为缩小放大的过滤器。<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</li>
<li>Anisotropic filtering——这种过滤产生最好的效果，但是处理时间也是最长的。下面的代码就是设置Anisotropic filtering作为缩小放大的过滤器。<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_ANISOTROPIC);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_ANISOTROPIC);<br>当使用Anisotropic filtering时，我们必须设置D3DSAMP_MAXANISOTROPY等级，它决定处理的质量。该值越高处理的效果越好。检查D3DCAPS9结构确认你的显卡是否支持此功能。下面的代码设置该值为4：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAXANISOTROPY, 4);<br>6.4 Mipmaps<br>　　就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建mipmaps链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。<br>　　<br>　　图6.4<br>6.4.1 Mipmaps过滤器<br>  mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, Filter);<br>在Filter处你能用下面三个选项中的一个：</li>
<li>D3DTEXF_NONE——不使用mipmap。</li>
<li>D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。</li>
<li>D3DTEXF_LINEAR——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。<br>6.4.2 Direct3D中使用Mipmaps<br>  在Direct3D中使用Mipmaps是很简单的。假如你的显卡支持Mipmaps，那么使用D3DXCreateTextureFromFile将为你产生一个Mipmap链。Direct3D自动选择与屏幕三角形最匹配的Mipmap。因此Mipmap有非常广泛的应用，且它能被自动设置。<br>6.5 寻址模式<br>  以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。</li>
</ul>
<p>图6.5（环绕）                          图6.6（边框）</p>
<p>图6.7（截取）                          图6.8（镜像）<br>在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标因该设置为（0,0）（0,5）（5,0）（5,5）。<br>    下面的代码片段列举的是怎样设置这四种寻址模式：<br>// set wrap address mode<br>if( ::GetAsyncKeyState(‘W’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);<br>}<br>// set border color address mode<br>if( ::GetAsyncKeyState(‘B’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0x000000ff);<br>}<br>// set clamp address mode<br>if( ::GetAsyncKeyState(‘C’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);<br>}<br>// set mirror address mode<br>if( ::GetAsyncKeyState(‘M’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);<br>}<br>6.6实例程序：有纹理的方块<br>    这个例子是怎样为方块加上纹理以及设置一个纹理过滤器（如图6.9）。假如你的显卡支持，通过D3DXCreateTextureFromFile函数一个mipmap链将被自动创建。</p>
<p>图6.9<br>注意：还提供了其他两个例子大家就自己看看了。<br>为一个场景增加纹理的必要步骤是：</p>
<ol>
<li>用纹理坐标指定的，创建物体的顶点。</li>
<li>用D3DXCreateTextureFromFile函数读取一个纹理到IDirect3DTexture9接口中。</li>
<li>设置缩小倍数，放大倍数以及mipmap过滤器。</li>
<li>在你绘制一个物体前，用IDirect3DDevice9::SetTexture设置与物体关联的纹理。<br>我们先定义几个全局变量；一个是顶点缓存，它存储方块的顶点。另外一个是我们为方块映射的纹理：<br>IDirect3DVertexBuffer9<em> Quad = 0;<br>IDirect3DTexture9</em>      Tex  = 0;<br>Setup程序是很容易读懂的；我们用已经定义了纹理坐标的两个三角形创建一个方块。然后把文件dx5_logo.bmp读进IDirect3DTexture9接口中。接着使用SetTexture方法赋予纹理。最后设置缩小和放大过滤器进行线性过滤，我们也可以设置mipmap过滤器来进行D3DTEXF_POINT: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create the quad vertex buffer and fill it with the</span></span><br><span class="line">    <span class="comment">// quad geoemtry.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">        <span class="number">6</span> * <span class="keyword">sizeof</span>(Vertex), </span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        Vertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;Quad,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Vertex* v;</span><br><span class="line">    Quad-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// quad built from two triangles, note texture coordinates:</span></span><br><span class="line">    v[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">1</span>] = Vertex(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">2</span>] = Vertex( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">3</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">4</span>] = Vertex( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">5</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    Quad-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create the texture and set filters.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    D3DXCreateTextureFromFile(</span><br><span class="line">        Device,</span><br><span class="line">        <span class="string">"dx5_logo.bmp"</span>,</span><br><span class="line">        &amp;Tex);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetTexture(<span class="number">0</span>, Tex);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">    Device-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">    Device-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MIPFILTER, D3DTEXF_POINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Don't use lighting for this sample.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_LIGHTING, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set the projection matrix.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    D3DXMATRIX proj;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(</span><br><span class="line">            &amp;proj,</span><br><span class="line">            D3DX_PI * <span class="number">0.5f</span>, <span class="comment">// 90 - degree</span></span><br><span class="line">            (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height,</span><br><span class="line">            <span class="number">1.0f</span>,</span><br><span class="line">            <span class="number">1000.0f</span>);</span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们现在可以渲染方块了，且通常已经为它赋予了纹理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, Quad, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        Device-&gt;SetFVF(Vertex::FVF);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Lighting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Lighting/" class="post-title-link" itemprop="url">第五章 灯光(Lighting)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:03:36" itemprop="dateCreated datePublished" datetime="2019-04-11T15:03:36+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Lighting/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Lighting/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="灯光的组成"><a href="#灯光的组成" class="headerlink" title="灯光的组成"></a>灯光的组成</h1><p>在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。</p>
<ul>
<li>环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。</li>
<li>漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的姿态。这种灯光将成为你的资源中照射的普通灯光。</li>
<li>镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面姿态，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。<br>　　镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;SetRenderState(D3DRS_SPECULARENABLE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXCOLOR <span class="title">redAmbient</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXCOLOR <span class="title">blueDiffuse</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXCOLOR <span class="title">whiteSpecular</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意：在D3DXCOLOR类中的alpha值用在描述灯光颜色时是被忽略的。</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>在现实世界中我们看到的物体颜色将由物体反射回来的灯光颜色来决定。比如，一个红色的球是红色的，因为它吸收所有的灯光颜色除了红色光。红色光是被球反射回来进入我们眼睛的，因此我们看到的球是红色的。Direct3D通过我们定义的物体材质来模拟这些所有的现象。材质允许我们定义表面反射灯光的百分比。在代码中通过D3DMATERIAL9结构描述一个材质。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">D3DMATERIAL9</span> &#123;</span></span><br><span class="line">    D3DCOLORVALUE Diffuse, Ambient, Specular, Emissive;</span><br><span class="line">    <span class="keyword">float</span> Power;</span><br><span class="line">&#125; D3DMATERIAL9;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Diffuse——指定此表面反射的漫射光数量。</li>
<li>Ambient——指定此表面反射的环境光数量。</li>
<li>Specular——指定此表面反射的镜面光数量</li>
<li>Emissive——这个是被用来给表面添加颜色，它使得物体看起来就象是它自己发出的光一样。</li>
<li>Power——指定锐利的镜面高光；它的值是高光的锐利值。<br>　　举例，想得到一个红色的球。我们将定义球的材质来只反射红光吸收其他颜色的所有光：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D3DMATERIAL9 red;</span><br><span class="line">::ZeroMemory(&amp;red, <span class="keyword">sizeof</span>(red));</span><br><span class="line">red.Diffuse = D3DXCOLOR(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// red</span></span><br><span class="line">red.Ambient = D3DXCOLOR(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// red</span></span><br><span class="line">red.Specular = D3DXCOLOR(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// red</span></span><br><span class="line">red.Emissive = D3DXCOLOR(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// no emission</span></span><br><span class="line">red.Power = <span class="number">5.0f</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　这里我们设置绿色和蓝色的值为0，这表明材质反射0%此颜色的光。我们设置红色为1，表示材质反射100%的红光。注意，我们能够控制每种灯光反射的颜色（环境、漫射和镜面光）。<br>　　同样假如我们定义一个只发出蓝色光的光源，对球的光照将失败因为蓝色光将被全部吸收而没有红光被反射。当物体吸收了所有光以后，物体看起来就为黑色。同样的，当物体反射100%的红、绿和蓝光，物体就将呈现为白色。<br>　　因为手工填充一个材质结构将是乏味的工作，我们添加下列有用的函数和全局材质常数到d3dUtility.h/cpp文件中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">D3DMATERIAL9 d3d::InitMtrl(D3DXCOLOR a, D3DXCOLOR d,</span><br><span class="line">D3DXCOLOR s, D3DXCOLOR e, <span class="keyword">float</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    D3DMATERIAL9 mtrl;</span><br><span class="line">    mtrl.Ambient = a;</span><br><span class="line">    mtrl.Diffuse = d;</span><br><span class="line">    mtrl.Specular = s;</span><br><span class="line">    mtrl.Emissive = e;</span><br><span class="line">    mtrl.Power = p;</span><br><span class="line">    <span class="keyword">return</span> mtrl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> d3d</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">D3DMATERIAL9 <span class="title">InitMtrl</span><span class="params">(D3DXCOLOR a, D3DXCOLOR d, D3DXCOLOR s, D3DXCOLOR e, <span class="keyword">float</span> p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 WHITE_MTRL = InitMtrl(WHITE, WHITE, WHITE, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 RED_MTRL = InitMtrl(RED, RED, RED, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 GREEN_MTRL = InitMtrl(GREEN, GREEN, GREEN, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 BLUE_MTRL = InitMtrl(BLUE, BLUE, BLUE, BLACK, <span class="number">8.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> D3DMATERIAL9 YELLOW_MTRL = InitMtrl(YELLOW, YELLOW, YELLOW, BLACK, <span class="number">8.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>顶点结构没有材质属性；一个通用的材质必须被设置。设置它我们使用IDirect3DDevice9::SetMaterial(CONST D3DMATERIAL9 * pMaterial)方法。<br>假设我们想渲染几个不同材质的物体；我们将按照如下的写法去做：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D3DMATERIAL9 blueMaterial, redMaterial;</span><br><span class="line"><span class="comment">// set up material structures</span></span><br><span class="line"></span><br><span class="line">Device-&gt;SetMaterial(&amp;blueMaterial);</span><br><span class="line">drawSphere(); <span class="comment">// blue sphere</span></span><br><span class="line"></span><br><span class="line">Device-&gt;SetMaterial(&amp;redMaterial);</span><br><span class="line">drawSphere(); <span class="comment">// red sphere</span></span><br></pre></td></tr></table></figure></p>
<h1 id="顶点法线"><a href="#顶点法线" class="headerlink" title="顶点法线"></a>顶点法线</h1><pre><code>面法线（face normal）是描述多边形表面方向的一个向量（如图5.1）。
</code></pre><p>图5.1<br>　　顶点法线（Vertex normals）也是基于同样的概念，但是我们与其指定每个多边形的法线，还不如为每个顶点指定（如图5.2）。<br>　　<br>　　图5.2<br>　　Direct3D需要知道顶点法线以便它能够确定灯光照射到物体表面的角度，并且一旦计算了每个顶点的灯光，Direct3D需要知道每个顶点的表面方向。注意顶点法线不一定和面法线相同。球体/环形物就是很好的实物例子，它们的顶点法线和三角形法线是不相同的（如图5.3）。<br>　　<br>　　图5.3<br>为了描述顶点的顶点法线，我们必须更新原来的顶点结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">    <span class="keyword">float</span> _nx, _ny, _nz;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们已经将上一章中使用的颜色成分去除了。这是因为我们将使用灯光来计算顶点的颜色。<br>　　作为一个简单的物体比如立方体和球体，我们能够通过观察看见顶点法线。对于更多复杂的网格，我们需要一个更多的机械方法。假设一个由p0,p1,p2构成的三角形，我们需要计算每个顶点的法线n0,n1,n2。<br>　　简单的步骤，我们列举它是为了找到由三个点构成的三角形的面法线，同时使用面法线作为顶点法线。首先计算三角形上的两个向量：<br>　　<br>　　那么面法线是：<br>　　<br>　　每个顶点的法线和面法线是相等的：<br>　　<br>　　下面是一个C函数，它通过三角形的三个顶点计算三角形的面法线。注意这个函数的三个顶点是按照顺时针方向指定的。假如不是这样，那么法线方向将是相反的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeNormal</span><span class="params">(D3DXVECTOR3* p0,</span></span></span><br><span class="line"><span class="function"><span class="params">                D3DXVECTOR3* p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                D3DXVECTOR3* p2,</span></span></span><br><span class="line"><span class="function"><span class="params">                D3DXVECTOR3* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D3DXVECTOR3 u = *p1 - *p0;</span><br><span class="line">    D3DXVECTOR3 v = *p2 - *p0;</span><br><span class="line">    D3DXVec3Cross(out, &amp;u, &amp;v);</span><br><span class="line">    D3DXVec3Normalize(out, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用三角形近似表示曲面时，使用面法线作为顶点法线不能表现一个平滑的结果。一个更好的方法是找到顶点法线的平均法线。为了找到顶点v的顶点法线vn，我们找到网格模型中所有三角形的面法线记为顶点v。vn是通过计算他们的平均面法线得到的。这里有一个例子，假设有3个三角形它们的面法线分别是n0，n1，n2，指定为顶点v。那么vn的平均法线就是：<br>　　<br>通过改变“舞台”，把顶点法线变为non-normal,这是有可能的。因此这样最好是安全的且在通过D3DRS_NORMALIZENORMALS设置渲染状态来改变“舞台”后，Direct3D从新规格化所有法线。<br>Device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, true);<br>5.4光源<br>　　Direct3D支持三种类型的光源。</p>
<ul>
<li>点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。</li>
</ul>
<p>图5.4</p>
<ul>
<li>方向光源——这种光源没有位置但是向指定方向发出平行光线。</li>
</ul>
<p>图5.5</p>
<ul>
<li>聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。</li>
</ul>
<p>图5.6<br>　　在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。<br>typedef struct _D3DLIGHT9 {<br>    D3DLIGHTTYPE Type;<br>    D3DCOLORVALUE Diffuse;<br>    D3DCOLORVALUE Specular;<br>    D3DCOLORVALUE Ambient;<br>    D3DVECTOR Position;<br>    D3DVECTOR Direction;<br>    float Range;<br>    float Falloff;<br>    float Attenuation0;<br>    float Attenuation1;<br>    float Attenuation2;<br>    float Theta;<br>    float Phi;<br>} D3DLIGHT9;</p>
<ul>
<li>Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL</li>
<li>Diffuse——此光源发出的漫射光颜色。</li>
<li>Specular——此光源发出的镜面光颜色。</li>
<li>Ambient——此光源发出的环境光颜色。</li>
<li>Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。</li>
<li>Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。</li>
<li>Range——灯光能够传播的最大范围。这个值不能比大。且不能用于方向光源。</li>
<li>Falloff——这个值只能用在聚光灯上。它定义灯光在从内圆锥到外圆锥之间的强度衰减。它的值通常设置为1.0f。</li>
<li><p>Attenuation0, Attenuation1, Attenuation2——这些衰减变量被用来定义灯光强度的传播距离衰减。它们只被用于点光源和聚光灯上。Attenuation0定义恒定衰减，Attenuation1定义线性衰减，Attenuation2定义二次衰减。适当的使用这个公式，D是代表到光源的距离，A0,A1,A2与Attenuation0，1，2相匹配。</p>
</li>
<li><p>Theta——只用于聚光灯；指定内圆锥的角度，单位是弧度。</p>
</li>
<li><p>Phi——只用于聚光灯；指定外圆锥的角度，单位是弧度。<br>　　就象初始化D3DMATERIAL9结构一样，初始化D3DLIGHT9结构是一件单调乏味的工作。我们添加下面的函数到d3dUtility.h/cpp文件中用于初始化简单灯光。<br>namespace d3d<br>{<br>  … …<br>  D3DLIGHT9 InitDirectionalLight(D3DXVECTOR3<em> direction, D3DXCOLOR</em> color);</p>
<p>  D3DLIGHT9 InitPointLight(D3DXVECTOR3<em> position, D3DXCOLOR</em> color);</p>
<p>  D3DLIGHT9 InitSpotLight(D3DXVECTOR3<em> position, D3DXVECTOR3</em> direction, D3DXCOLOR<em> color);<br>}<br>　　使用这些函数是非常简单的。我们现在只是演示怎样使用InitDirectionalLight。其他的也很类似：<br>D3DLIGHT9 d3d::InitDirectionalLight(D3DXVECTOR3</em> direction, D3DXCOLOR<em> color)<br>{<br>  D3DLIGHT9 light;<br>  ::ZeroMemory(&amp;light, sizeof(light));<br>  light.Type = D3DLIGHT_DIRECTIONAL;<br>  light.Ambient = </em>color <em> 0.4f;<br>  light.Diffuse = </em>color;<br>  light.Specular = <em>color </em> 0.6f;<br>  light.Direction = *direction;<br>  return light;<br>}<br>　　然后创建一个方向光源，它沿着x轴正方向照射白色灯光。我们按照下面的方法来做：<br>D3DXVECTOR3 dir(1.0f, 0.0f, 0.0f);<br>D3DXCOLOR c = d3d::WHITE;<br>D3DLIGHT9 dirLight = d3d::InitDirectionalLight(&amp;dir, &amp;c);<br>　　在把D3DLIGHT9初始化好以后，我们需要用Direct3D内在支持的灯光来注册。就象这样做：<br>Device-&gt;SetLight(<br>  0, // element in the light list to set, range is 0-maxlights<br>  &amp;light);// address of the D3DLIGHT9 structure to set<br>　　一旦灯光注册了，我们就能使用下面的列举的例子来开或关灯光了：<br>Device-&gt;LightEnable(<br>  0, // the element in the light list to enable/disable<br>  true); // true = enable, false = disable<br>5.5实例程序：灯光<br>  这一章的例子是创建如图5.7所显示的场景。它示范了怎样指定顶点法线，怎样创建材质，以及怎样创建和使用一个方向灯光。注意在这个示例程序中我们不会使用在文件d3dUtility.h/cpp中的材质和灯光函数。因为我们想展示怎样手动来做这些设置。</p>
</li>
</ul>
<p>图5.7<br>    给场景增加灯光的步骤是：<br>1、 允许使用灯光。<br>2、 为每个物体创建材质并且在渲染相应物体前应将材质附予物体。<br>3、 创建一个或多个光源，设置它们，把它们设为可用。<br>4、 将其他附加光源设为可用，比如镜面高光。<br>　　首先我们初始化一个全局顶点缓存用他来存储“金字塔”的顶点：<br>IDirect3DVertexBuffer9* Pyramid = 0;<br>　　Setup函数包含本章的所有代码，因此我们忽略其他函数。它执行刚才讨论的步骤来给场景加入灯光。Setup方法首先允许使用灯光，当然这不是必须的因为默认设置就是允许使用灯光的。<br>bool Setup()<br>{<br>    Device-&gt;SetRenderState(D3DRS_LIGHTING, true);<br>　　下一步，我们创建顶点缓存，锁定，并且把“金字塔”的三角形顶点放入其中。顶点法线是利用5.3节中的运算法则预先计算好的。注意三角形共享顶点，但它们的法线不能共享；因此对这个物体使用索引列表并不是最有利的。例如，所有三角形都共享顶点（0,1,0）；然而，对每个三角形，它们的顶点法线是不相同的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Device-&gt;CreateVertexBuffer(</span><br><span class="line">            <span class="number">12</span> * <span class="keyword">sizeof</span>(Vertex),</span><br><span class="line">            D3DUSAGE_WRITEONLY,</span><br><span class="line">            Vertex::FVF,</span><br><span class="line">            D3DPOOL_MANAGED,</span><br><span class="line">            &amp;Pyramid,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"><span class="comment">// fill the vertex buffer with pyramid data</span></span><br><span class="line">Vertex* v;</span><br><span class="line">Pyramid-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// front face</span></span><br><span class="line">v[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">-0.707f</span>);</span><br><span class="line">v[<span class="number">1</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">-0.707f</span>);</span><br><span class="line">v[<span class="number">2</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">-0.707f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// left face</span></span><br><span class="line">v[<span class="number">3</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">4</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">5</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">-0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// right face</span></span><br><span class="line">v[<span class="number">6</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">7</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">8</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// back face</span></span><br><span class="line">v[<span class="number">9</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>);</span><br><span class="line">v[<span class="number">10</span>] = Vertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>);</span><br><span class="line">v[<span class="number">11</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.707f</span>, <span class="number">0.707f</span>);</span><br><span class="line"></span><br><span class="line">Pyramid-&gt;Unlock();</span><br></pre></td></tr></table></figure></p>
<p>　　为物体产生了顶点数据以后，我们描述利用灯光表现各自材质的物体间是怎样相互影响的。在这个例子中，“金字塔”反射出白光，自身不发光，且会产生一些高光。<br>D3DMATERIAL9 mtrl;<br>mtrl.Ambient = d3d::WHITE;<br>mtrl.Diffuse = d3d::WHITE;<br>mtrl.Specular = d3d::WHITE;<br>mtrl.Emissive = d3d::BLACK;<br>mtrl.Power = 5.0f;<br>Device-&gt;SetMaterial(&amp;mtrl);<br>　　接着，我们创建一个方向光并将其设为可用。方向光是沿着x轴的正方向照射的。灯光照射最强的白色漫射光（dir.Diffuse = WHITE），较弱的白色镜面光（dir.Specular = WHITE <em> 0.3f）以及一个中等强度的白色环境光（dir.Ambient = WHITE </em>0.6f）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">D3DLIGHT9 dir;</span><br><span class="line">::ZeroMemory(&amp;dir, <span class="keyword">sizeof</span>(dir));</span><br><span class="line">dir.Type = D3DLIGHT_DIRECTIONAL;</span><br><span class="line">dir.Diffuse = d3d::WHITE;</span><br><span class="line">dir.Specular = d3d::WHITE * <span class="number">0.3f</span>;</span><br><span class="line">dir.Ambient = d3d::WHITE * <span class="number">0.6f</span>;</span><br><span class="line">dir.Direction = D3DXVECTOR3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">Device-&gt;SetLight(<span class="number">0</span>, &amp;dir);</span><br><span class="line">Device-&gt;LightEnable(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//最后，我们设置状态使法线从新规格化且把镜面高光设置为可用。</span></span><br><span class="line">Device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, <span class="literal">true</span>);</span><br><span class="line">Device-&gt;SetRenderState(D3DRS_SPECULARENABLE, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// ... code to set up the view matrix and projection matrix</span></span><br><span class="line"><span class="comment">// omitted</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>5.6附加实例<br>　　这一章中还有三个附加的例子。它们使用D3DXCreate<em>函数来创建组成场景的3D物体。D3DXCreate</em>函数创建的顶点数据是D3DFVF_XYZ | D3DFVF_NORMAL格式。在增加的函数中为我们的网格模型的每个顶点计算了顶点法线。这些实例演示了怎样使用方向光，点光源，以及聚光灯。图5.8显示的是方向光实例中的一个场景图。<br>　　<br>　　图5.8</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/color/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/color/" class="post-title-link" itemprop="url">色彩(Color)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:00:51" itemprop="dateCreated datePublished" datetime="2019-04-11T15:00:51+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/color/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/color/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="颜色表示法"><a href="#颜色表示法" class="headerlink" title="颜色表示法"></a>颜色表示法</h1><p>　　在Direct3D中，颜色是使用RGB三部分来描述的。也就是说，我们要分别指定红、绿和蓝三种颜色的值。混合这三个颜色决定最终的颜色。利用这三种颜色我们能够表现数万种颜色。<br>　　我们使用两种不同的结构来存储RGB数据。这第一种是D3DCOLOR，它实际上一个DWORD即32位。在D3DCOLOR类型中的这些位按照8-bit被分为4个部分，每一部分存储的是该色的亮度值。如图4.1所示。<br>　　<br>　　图4.1<br>　　每种颜色占用内存的一个字节，各颜色亮度值的取值范围是0-255。这个值越接近0就越暗，越接近255就越亮。<br>注意：现在不要管alpha部分；它被用在alpha混合中——在第7章中会讲解。<br>　　指定其中的每一部分并且把它放到D3DCOLOR中适当的位置需要使用到一些位操作。Direct3D为我们提供了一个完成这个任务的宏D3DCOLOR_ARGB.它使用包含每种颜色以及alpha位一共4个参数。每一个参数的取值必须在0-255之间，如：<br>D3DCOLOR brightRed = D3DCOLOR_ARGB(255, 255, 0, 0);<br>D3DCOLOR someColor = D3DCOLOR_ARGB(255, 144, 87, 201);<br>    另外，我们也能使用D3DCOLOR_XRGB宏，它与刚才的宏类似只不过不必指定alpha部分；不过我们最好还是把alpha指定为0xff（255）。</p>
<h1 id="define-D3DCOLOR-XRGB-r-g-b-D3DCOLOR-ARGB-0xff-r-g-b"><a href="#define-D3DCOLOR-XRGB-r-g-b-D3DCOLOR-ARGB-0xff-r-g-b" class="headerlink" title="define D3DCOLOR_XRGB(r,g,b) D3DCOLOR_ARGB(0xff,r,g,b)"></a>define D3DCOLOR_XRGB(r,g,b) D3DCOLOR_ARGB(0xff,r,g,b)</h1><p>　　在Direct3D中另外一种存储颜色的结构是D3DCOLORVALUE。在这个结构中，我们分别使用一个浮点数来表示每一部分的亮度值。其取值范围是0-1，0表示没有亮度，1表示最大亮度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">D3DCOLORVALUE</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> r; <span class="comment">// the red component, range 0.0-1.0</span></span><br><span class="line">    <span class="keyword">float</span> g; <span class="comment">// the green component, range 0.0-1.0</span></span><br><span class="line">    <span class="keyword">float</span> b; <span class="comment">// the blue component, range 0.0-1.0</span></span><br><span class="line">    <span class="keyword">float</span> a; <span class="comment">// the alpha component, range 0.0-1.0</span></span><br><span class="line">&#125; D3DCOLORVALUE;</span><br></pre></td></tr></table></figure></p>
<p>　　另外，我们能够使用D3DXCOLOR结构，就象D3DCOLORVALUE包含同样的数据成员一样。同时提供有用的构造函数和重载操作符，这将让颜色处理更容易。D3DXCOLOR的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3DXCOLOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        D3DXCOLOR() &#123;&#125;</span><br><span class="line">        D3DXCOLOR( DWORD argb );</span><br><span class="line">        D3DXCOLOR( CONST FLOAT * );</span><br><span class="line">        D3DXCOLOR( CONST D3DXFLOAT16 * );</span><br><span class="line">        D3DXCOLOR( CONST D3DCOLORVALUE&amp; );</span><br><span class="line">        D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// casting</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">DWORD</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">operator</span> FLOAT* ();</span><br><span class="line">        <span class="keyword">operator</span> CONST FLOAT* () <span class="keyword">const</span>;</span><br><span class="line">        <span class="keyword">operator</span> D3DCOLORVALUE* ();</span><br><span class="line">        <span class="keyword">operator</span> CONST D3DCOLORVALUE* () <span class="keyword">const</span>;</span><br><span class="line">        <span class="keyword">operator</span> D3DCOLORVALUE&amp; ();</span><br><span class="line">        <span class="keyword">operator</span> CONST D3DCOLORVALUE&amp; () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assignment operators</span></span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> += ( CONST D3DXCOLOR&amp; );</span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> -= ( CONST D3DXCOLOR&amp; );</span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> *= ( FLOAT );</span><br><span class="line">        D3DXCOLOR&amp; <span class="keyword">operator</span> /= ( FLOAT );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unary operators</span></span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> + () <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> - () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binary operators</span></span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> + ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> - ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> * ( FLOAT ) <span class="keyword">const</span>;</span><br><span class="line">        D3DXCOLOR <span class="keyword">operator</span> / ( FLOAT ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> D3DXCOLOR <span class="keyword">operator</span> * (FLOAT, CONST D3DXCOLOR&amp; );</span><br><span class="line"></span><br><span class="line">        BOOL <span class="keyword">operator</span> == ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">        BOOL <span class="keyword">operator</span> != ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__cplusplus</span></span></span><br><span class="line">    FLOAT r, g, b, a;</span><br><span class="line">&#125; D3DXCOLOR, *LPD3DXCOLOR;</span><br></pre></td></tr></table></figure></p>
<p>注意：D3DCOLORVALUE和D3DXCOLOR结构都有4个浮点数成员。这使我们的颜色处理符号能象4D向量一样。颜色向量能被加，减以及缩放。另一方面点积和叉积不能用于颜色向量，但是颜色成员相乘是可以的。因此在D3DXCOLOR类中执行的乘法就是成员相乘。它的定义如下：</p>
<p>现在使用下面全局颜色常量更新我们的d3dUtility.h文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> d3d</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">WHITE</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">BLACK</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">RED</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">GREEN</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">BLUE</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">YELLOW</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">CYAN</span><span class="params">( D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> D3DXCOLOR <span class="title">MAGENTA</span><span class="params">( D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>) )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顶点颜色"><a href="#顶点颜色" class="headerlink" title="顶点颜色"></a>顶点颜色</h1><p>图元的颜色是由构成它的顶点的颜色决定的。因此，我们必须把一个颜色成员加入到我们的顶点数据结构中。注意D3DCOLORVALUE类型不能用在这里，因为Direct3D希望用一个32位的值来描述顶点的颜色。（通过使用顶点着色器我们能为顶点颜色使用4D颜色向量，它能提供一个128位的颜色，但是对于我们现在的水平来说那太超前了。顶点着色器将在17章中介绍。）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColorVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">    D3DCOLOR _color;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>const DWORD ColorVertex::FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;</p>
<h1 id="着色处理"><a href="#着色处理" class="headerlink" title="着色处理"></a>着色处理</h1><p>着色处理发生在光栅化和指定图元上的顶点颜色怎样被计算成像素颜色之间。目前这里有2种着色处理模式可用：平面着色（flat shading）和高洛德着色（Gouraud shading）。<br>平面着色，图元像素的颜色是均匀的，且就是指定图元第一个顶点的颜色。因此一旦三角形的第一个顶点被指定成红色，那么它的其他三个顶点也将会是红色。通过使用平面着色来为第二和第三个顶点着色。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ColorVertex t[<span class="number">3</span>];</span><br><span class="line">t[<span class="number">0</span>]._color = D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">t[<span class="number">1</span>]._color = D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">t[<span class="number">2</span>]._color = D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br></pre></td></tr></table></figure></p>
<p>平面着色使物体呈现是斑驳的，因为没有从一个颜色到另一个颜色的平滑过渡。一个更好的着色模式叫做高洛德着色（也被叫做平滑着色）。高洛德着色，图元表面的颜色是由每个顶点通过线性插值来赋予。图4.2显示了分别使用平面着色和高洛德着色处理的红色三角形。</p>
<p>图4.2<br>就象Direct3D中很多东西一样，着色处理模式是受Direct3D设置状态决定的。<br>// set flat shading<br>Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);<br>// set Gouraud shading<br>Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);</p>
<h1 id="实例程序：彩色三角形"><a href="#实例程序：彩色三角形" class="headerlink" title="实例程序：彩色三角形"></a>实例程序：彩色三角形</h1><p>这个实例程序展示了分别使用本章中的平面着色和高洛德着色处理的三角形。渲染出的图片如图4.2所示。首先我们定义如下的全局变量：<br>D3DXMATRIX World;<br>IDirect3DVertexBuffer9* Triangle = 0;<br>    我们包含一个D3DXMATRIX，它将存储我们将要绘制的三角形在世界坐标中的变换信息。Triangle变量是存储三角形顶点数据的顶点缓存。注意，我们只需要存储一个三角形，因为我们能用它在世界坐标系中不同位置绘制若干次。<br>    Setup方法创建顶点缓存同时填充上带颜色信息的三角形顶点数据。三角形的第一个顶点填充为全亮度红色（255）第二个填充全亮度绿色（255），第三个填充全亮度蓝色（255）。最后，在这个例子中我们屏蔽掉灯光。值得注意的是该例子使用的是一个新的ColorVertex结构，就象在4.2节中说明的一样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create vertex buffer</span></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">        <span class="number">3</span> * <span class="keyword">sizeof</span>(ColorVertex),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        ColorVertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;Triangle,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fill the buffers with the triangle data</span></span><br><span class="line">    ColorVertex* v;</span><br><span class="line">    Triangle-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = ColorVertex(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">2.0f</span>, D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    v[<span class="number">1</span>] = ColorVertex( <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>, D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">    v[<span class="number">2</span>] = ColorVertex( <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">2.0f</span>, D3DCOLOR_XRGB( <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    Triangle-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set projection matrix</span></span><br><span class="line">    D3DXMATRIX proj;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(</span><br><span class="line">        &amp;proj,</span><br><span class="line">        D3DX_PI * <span class="number">0.5f</span>, <span class="comment">// 90 - degree</span></span><br><span class="line">        (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height,</span><br><span class="line">        <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1000.0f</span>);</span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the render states</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_LIGHTING, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Display函数使用不同的着色模式在两个不同的地方分别绘制2个Triangle。每个三角形的位置由世界矩阵World来决定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetFVF(ColorVertex::FVF);</span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, Triangle, <span class="number">0</span>, <span class="keyword">sizeof</span>(ColorVertex));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw the triangle to the left with flat shading</span></span><br><span class="line">        D3DXMatrixTranslation(&amp;World, <span class="number">-1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw the triangle to the right with gouraud shading</span></span><br><span class="line">        D3DXMatrixTranslation(&amp;World, <span class="number">1.25f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);</span><br><span class="line"></span><br><span class="line">        Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);</span><br><span class="line">        Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/drawing-in-direct3d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/drawing-in-direct3d/" class="post-title-link" itemprop="url">Drawing in Direct3D</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 14:55:06" itemprop="dateCreated datePublished" datetime="2019-04-11T14:55:06+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/drawing-in-direct3d/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/drawing-in-direct3d/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="顶点-索引缓存"><a href="#顶点-索引缓存" class="headerlink" title="顶点/索引缓存"></a>顶点/索引缓存</h1><p>顶点和索引缓存有相似的接口并且共享相似的方法；一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。<br>在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。</p>
<h2 id="创建一个顶点和索引缓存"><a href="#创建一个顶点和索引缓存" class="headerlink" title="创建一个顶点和索引缓存"></a>创建一个顶点和索引缓存</h2><p>我们能使用下面两个方法创建一个顶点缓存和索引缓存：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HRESULT IDirect3DDevice9::CreateVertexBuffer(</span><br><span class="line">    UINT Length,</span><br><span class="line">    DWORD Usage,</span><br><span class="line">    DWORD FVF,</span><br><span class="line">    D3DPOOL Pool</span><br><span class="line">    IDirect3DVertexBuffer9** ppVertexBuffer,</span><br><span class="line">    HANDLE* pSharedHandle</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">HRESULT IDirect3DDevice9::CreateIndexBuffer(</span><br><span class="line">    UINT Length,</span><br><span class="line">    DWORD Usage,</span><br><span class="line">    D3DFORMAT Format,</span><br><span class="line">    D3DPOOL Pool,</span><br><span class="line">    IDirect3DIndexBuffer9** ppIndexBuffer,</span><br><span class="line">    HANDLE* pSharedHandle</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这两个方法大部分参数是相同的，因此我们一起介绍它们。</p>
<ul>
<li>Length —— 分配给缓存的字节大小。假如想得到一个能存储8个顶点的顶点缓存，那么我们就要在顶点结构中设置这个参数为 8 * sizeof ( Vertex ) 。</li>
<li>Usage —— 指定关于怎样使用缓存的额外信息。这个值可以是0，没有标记，或者是下面标记的一个或多个的组合：</li>
<li>D3DUSAGE_DYNAMIC——设置这个参数可以使缓存是动态的。在下一页说明静态和动态缓存。</li>
<li>D3DUSAGE_POINTS——这个参数指定缓存存储原始点。原始点将在第14章粒子系统中介绍。这个参数仅仅用在顶点缓冲中。</li>
<li>D3DUSAGE_SOFTWAREPROCESSING——使用软件顶点处理</li>
<li>D3DUSAGE_WRITEONLY——指定应用程序只能写缓存。它允许驱动程序分配最适合的内存地址作为写缓存。注意如果从创建好的这种缓存中读数据，将会返回错误信息。</li>
<li>FVF —— 存储在缓存中的顶点格式</li>
<li>Pool —— 缓存放置在哪一个内存池中</li>
<li>ppVertexBuffer ——返回创建好的顶点缓存的指针。</li>
<li>pSharedHandle ——没有使用；设置为0。</li>
<li>Format ——指定索引的大小；使用D3DFMT_INDEX16设置16位索引，使用D3DFMT_INDEX32设置32位索引。注意并非所有设备都支持32位索引；请检查设备能力。</li>
<li>ppIndexBuffer ——返回创建好的索引缓存的指针。</li>
</ul>
<p>注意：不使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做静态缓存。静态缓存通常被放置在显存中，在其中的数据能被很有效的处理。然而，对于静态缓存，从中读取和写入数据是很慢的，因为访问显存是很慢的。因为这个原因我们用静态缓存存储静态数据（不需要被经常改变的数据）。对于静态缓存地形和建筑物是很好的后选例子，因为在应用程序中他们通常不需要被改变。静态缓存应该在应用程序初始话的时候就被填充好，而不是在运行时才做。</p>
<p>注意：使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做动态缓存。动态缓存通常被放在AGP内存中，这种内存中的数据能被很快的更新。处理动态缓存中的数据不会比处理静态缓存中的数据快，因为这些数据必须在渲染前被转移到显存中，动态缓存的好处是它们能够被稍微快点地被更新（比CPU写快）。因此，假如你需要经常更新缓存中的数据，那么你就应该使用动态缓存。对于动态缓存粒子系统是很好的一个应用，因为它们是动态的，并且他们通常每一帧都会被更新。</p>
<p>注意：在程序中读取显存和AGP内存都是非常慢的。因此，假如你在运行时需要读取你的几何物体，最好的方案是指定一块系统内存，都在其中拷贝并且读取数据。<br>　　  下边是创建一个静态顶点缓存的例子，该缓存能存储8个顶点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IDirect3DVertexBuffer9* vb;</span><br><span class="line">device-&gt;CreateVertexBuffer(</span><br><span class="line">    <span class="number">8</span> * <span class="keyword">sizeof</span>( Vertex ),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    D3DFVF_XYZ,</span><br><span class="line">    D3DPOOL_MANAGED,</span><br><span class="line">    &amp;vb,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="访问缓冲内存"><a href="#访问缓冲内存" class="headerlink" title="访问缓冲内存"></a>访问缓冲内存</h2><p>　　为了访问一个顶点/索引缓存，我们需要得到一个指针。我们通过一个指针获得缓存数据必须使用Lock方法。当我们访问完缓存后必须对它解锁。一旦有一个指向内存的指针，我们就能对它进行读写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HRESULT IDirect3DVertexBuffer9::Lock(</span><br><span class="line">    UINT OffsetToLock,</span><br><span class="line">    UINT SizeToLock,</span><br><span class="line">    BYTE** ppbData,</span><br><span class="line">    DWORD Flags</span><br><span class="line">);</span><br><span class="line">HRESULT IDirect3DIndexBuffer9::Lock(</span><br><span class="line">    UINT OffsetToLock,</span><br><span class="line">    UINT SizeToLock,</span><br><span class="line">    BYTE** ppbData,</span><br><span class="line">    DWORD Flags</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>　　图3.1<br>　　这两个方法的参数都是完全相同的。</p>
<ul>
<li>OffsetToLock —— 偏移量，以字节为单位，从缓存开始位置到锁定开始位置的距离。如图3.1。</li>
<li>SizeToLock —— 锁定的字节数。</li>
<li>ppbData —— 一个指向锁定内存开始位置的指针。</li>
<li>Flags —— 标记描述怎样锁定内存。它可能是0或者是下面参数中的1个或多个的组合：</li>
<li>D3DLOCK_DISCARD——这个参数仅仅会在动态缓存时被使用。它指示硬件丢弃缓存并返回一个指向新分配的缓存的指针。这是很有用，因为当我们存取一个新分配的缓存时它允许硬件继续从丢弃的缓存渲染。这防止了硬件延迟。</li>
<li>D3DLOCK_NOOVERWRITE——这个参数仅仅会在动态缓存时被使用。它声明你将向缓存中添加数据。即，你不能向已经渲染的内存中写数据。这是有好处的因为他允许你在添加新数据到缓存的同时让硬件继续渲染。</li>
<li>D3DLOCK_READONLY——这个参数声明你锁定的缓存只能从中读取数据而不能写数据。这允许一些内在的优化。<br>  用参数D3DLOCK_DISCARD和D3DLOCK_NOOVERWRITE的地址实际上就是缓存的一部分被使用（正在渲染）时它被锁定。假如情况允许这些标记被使用，当在锁定时他们防止渲染停止。<br>  下边的例子展示了通常怎样使用Lock方法。注意当我们使用完以后要调用Unlock方法。<br>Vertex<em> vertices;<br>_vb-&gt;Lock(0, 0, (void*</em>)&amp;vertices, 0); // 锁定整个缓存<br>vertices[0] = Vertex(-1.0f, 0.0f, 2.0f); // 向缓存里写顶点<br>vertices[1] = Vertex( 0.0f, 1.0f, 2.0f);<br>vertices[2] = Vertex( 1.0f, 0.0f, 2.0f);<br>_vb-&gt;Unlock(); // 当你访问完缓存时，解锁缓存<br>3.1.3 找回顶点和索引缓存信息<br>有时我们需要得到顶点/索引缓存信息。下面的例子示范了用于获得这些信息的方法：<br>D3DVERTEXBUFFER_DESC vbDescription;<br>_vertexBuffer-&gt;GetDesc(&amp;vbDescription); // 取得顶点缓存信息</li>
</ul>
<p>D3DINDEXBUFFER_DESC ibDescription;<br>_indexBuffer-&gt;GetDesc(&amp;ibDescription); //取得索引缓存信息<br>　　<br>　　D3DVERTEXBUFFER_DESC和D3DINDEXBUFFER_DESC结构的定义如下：<br>typedef struct _D3DVERTEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>    DWORD FVF;<br>} D3DVERTEXBUFFER_DESC;</p>
<p>typedef struct _D3DINDEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>} D3DINDEXBUFFER_DESC;<br>3.2 渲染状态<br>   Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法：<br>HRESULT IDirect3DDevice9::SetRenderState(<br>    D3DRENDERSTATETYPE State, // 更改的渲染状态<br>    DWORD Value // 新的状态值<br>);</p>
<p>例如，在这一章的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态：<br>_device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);<br>注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。<br>3.3 绘制准备<br>　　一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲染前我们还有3个步骤必须先做。<br>1、 设置资源流。设置资源流与一个顶点缓存挂钩，此流就是一个流入渲染管线的几何信息的流。<br>　　下面的方法是用于设置一个资源流：<br>HRESULT IDirect3DDevice9::SetStreamSource(<br>    UINT StreamNumber,<br>    IDirect3DVertexBuffer9* pStreamData,<br>    UINT OffsetInBytes,<br>    UINT Stride<br>);</p>
<ul>
<li>StreamNumber——确定我们的顶点缓存与哪一个资源流挂钩。在这本书中我们不使用多重流；因此我们总是使用0号流。</li>
<li>pStreamData——一个指向我们想与流挂钩的那个顶点缓存的指针。</li>
<li>OffsetInBytes——相对流开始处的偏移量。以字节为单位，它指定被填入渲染管线的顶点数据的开始位置。通过检查D3DCAPS9结构中的D3DDEVCAPS2_STREAMOFFSET标志，假如你的设备支持，那么这个参数就有一些非0值。</li>
<li>Stride——我们在顶点缓存中操作的每个部分的流的字节大小。<br>　　例如，假设vb是一个已经填充了顶点信息的顶点缓存：<br>_device-&gt;SetStreamSource( 0, vb, 0, sizeof( Vertex ) );</li>
</ul>
<p>2、 设置顶点格式。在这里我们指定后面用来绘图调用的顶点的顶点格式。<br>_device-&gt;SetFVF( D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1 );</p>
<p>3、 设置索引缓存。假如我们使用了索引缓存，我们必须设置后面要用于绘制操作的索引缓存。每次我们只能使用一个索引缓存；因此假如你需要用一个不同的索引缓存绘制一个物体时，你必须转换到另一个上。下面的代码设置一个索引缓存：<br>_device-&gt;SetIndices( _ib ); // 传递一个索引缓存指针的拷贝<br>3.4用顶点/索引缓存绘制<br>　　在我们创建好顶点/索引缓存以及做好准备工作以后，我们就能绘制我们的几何物体了。这是通过使用DrawPrimitive或者DrawIndexedPrimitive传送几何信息到达渲染管线。这些方法从顶点流中获得顶点信息以及从索引缓存中获得索引信息。<br>3.4.1 IDirect3DDevice9::DrawPrimitive<br>　　这个方法不使用索引信息绘制图元。<br>HRESULT IDirect3DDevice9::DrawPrimitive(<br>    D3DPRIMITIVETYPE PrimitiveType,<br>    UINT StartVertex,<br>    UINT PrimitiveCount<br>);</p>
<ul>
<li>PrimitiveType——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。</li>
<li>StartVertex——索引到在顶点流中的一个元素。设置渲染顶点中的开始点。这个参数给予我们一定的机动性，可以绘制一个顶点缓存中的某部分。</li>
<li>PrimitiveCount——绘制图元的个数。<br>　　例子：<br>// 绘制4个三角形<br>_device-&gt;DrawPrimitive( D3DPT_TRIANGLELIST, 0, 4);<br>3.4.2 IDirect3DDevice9::DrawIndexedPrimitive<br>　　这个方法使用索引信息来绘制图元。<br>HRESULT IDirect3DDevice9::DrawIndexedPrimitive(<br>  D3DPRIMITIVETYPE Type,<br>  INT BaseVertexIndex,<br>  UINT MinIndex,<br>  UINT NumVertices,<br>  UINT StartIndex,<br>  UINT PrimitiveCount<br>);</li>
<li>Type——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。</li>
<li>BaseVertexIndex——一个基本数字，在调用中用它去加上索引。参看下面的说明。</li>
<li>MinIndex——将被引用的最小索引值。</li>
<li>NumVertices——在此调用中将被引用的顶点数。</li>
<li>StartIndex——索引到索引缓存中的某个位置，它标记开始渲染的开始索引点。</li>
<li>PrimitiveCount——绘制图元的个数。<br>　　例子：<br>_device-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);<br>注意：BaseVertexIndex参数需要一些特别的解释。在解释过程中将会用到的图3.2。</li>
</ul>
<p>图3.2<br>   在索引缓存中定位顶点相应的也就在顶点缓存中定位了。然而，假设我们想将球，盒子，圆柱体的顶点放置到一个公共的顶点缓存中。对于每一个物体，我们将不得不再计算在公共顶点缓存中的索引。这个新的索引值是通过与一个偏移量相加得到。注意这个偏移量是标准的顶点，而不是字节。<br>    我们需要计算物体在公共顶点缓存中的索引值。Direct3D允许我们通过设置BaseVertexIndex参数得到一个顶点偏移量，随后Direct3D就能利用顶点自身的索引重新计算新的索引。<br>3.4.3 开始/结束场景<br>   最后一点就是所有绘制方法都必须在IDirect3DDevice9::BeginScene和IDirect3DDevice9::EndScene方法之间被调用。例如，我们将这样写：<br>_device-&gt;BeginScene();<br>　　// 绘制场景<br>    _device-&gt;DrawPrimitive(…);<br>_device-&gt;EndScene();<br>3.5 D3DX几何物体<br>　　通过在代码中建造每个三角形来建造3D物体是一件非常枯燥的事。幸运的是，D3DX库已经为我们提供了一些方法来产生简单3D物体的网格数据。<br>　　D3DX库提供如下6种网格生成函数。</p>
<ul>
<li>D3DXCreateBox</li>
<li>D3DXCreateSphere</li>
<li>D3DXCreateCylinder</li>
<li>D3DXCreateTeapot</li>
<li>D3DXCreatePolygon</li>
<li>D3DXCreateTorus</li>
</ul>
<p>图3.3<br>　　这6种函数的使用都很类似，并且使用D3DX网格数据结构ID3DXMesh就象使用ID3DXBuffer接口一样。这些接口回在第10章和11章中讲解。现在，我们忽视它们的详细信息，只需简单使用它们即可。<br>HRESULT D3DXCreateTeapot(<br>    LPDIRECT3DDEVICE9 pDevice, // 与mesh关联的设备<br>    LPD3DXMESH<em> ppMesh, // 返回的mesh<br>    LPD3DXBUFFER</em> ppAdjacency // 现在设成0<br>);<br>　　<br>　　一个使用D3DXCreateTeapot函数的例子：<br>ID3DXMesh<em> mesh = 0;<br>D3DXCreateTeapot(_device, &amp;mesh, 0);<br>　　一旦生成了网格数据，我们就能使用ID3DXMesh::DrawSubset方法绘制图形了。这个方法有一个参数，它用来识别网格的一个子集。这个网格是通过上面的D3DXCreate</em>函数中的一个子集创建的，因此可以给这个参数指定0值。一个渲染网格的例子：<br>_device-&gt;BeginScene();<br>    mesh-&gt;DrawSubset(0);<br>_device-&gt;EndScene();</p>
<p>   使用了网格以后，必须释放（release）它：<br>mesh-&gt;Release();<br>_mesh = 0;<br>3.6 实例程序：三角形、立方体、茶壶、D3DXCreate*<br>　　这里有4个例子。</p>
<ul>
<li>三角形——这是非常简单的应用程序，它示范了在线框模式下怎样创建并渲染一个三角形。</li>
<li>立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。</li>
<li>茶壶——这个程序使用D3DXCreateTeapot函数创建并渲染一个纺纱茶壶。</li>
<li>D3DXCreate——这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。<br>让我们简单讨论一下创建立方体的例子。通过对它的学习你自己就能很快地理解其他例子。<br>  这个简单的绘制和渲染立方体的程序的运行结果如图3.4。</li>
</ul>
<p>图3.4<br>　　首先我们定义下边两个全局变量来保存立方体的顶点和索引数据：<br>IDirect3DVertexBuffer9<em> VB = 0;<br>IDirect3DIndexBuffer9</em> IB = 0;<br>　　下一步，我们定义两个全局常量，由它们来指定我们的屏幕大小：<br>const int Width = 800;<br>const int Height = 600;<br>　　接下来定义我们的顶点结构以及结构中顶点的格式。在这个例子中顶点结构只保存顶点的位置信息：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex()&#123;&#125;</span><br><span class="line">    Vertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x; _y = y; _z = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> DWORD Vertex::FVF = D3DFVF_XYZ;</span><br></pre></td></tr></table></figure></p>
<p>让我们把它迁移到框架程序（见1.53节）上。Setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建顶点、索引缓存</span></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">        <span class="number">8</span> * <span class="keyword">sizeof</span>(Vertex),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        Vertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;VB,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Device-&gt;CreateIndexBuffer(</span><br><span class="line">        <span class="number">36</span> * <span class="keyword">sizeof</span>(WORD),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        D3DFMT_INDEX16,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;IB,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向立方体的顶点缓存填充数据</span></span><br><span class="line">    Vertex* vertices;</span><br><span class="line">    VB-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;vertices, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vertices of a unit cube</span></span><br><span class="line">    vertices[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    vertices[<span class="number">4</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    VB-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义立方体的三角形</span></span><br><span class="line">    WORD* indices = <span class="number">0</span>;</span><br><span class="line">    IB-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;indices, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面</span></span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>; indices[<span class="number">1</span>] = <span class="number">1</span>; indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    indices[<span class="number">3</span>] = <span class="number">0</span>; indices[<span class="number">4</span>] = <span class="number">2</span>; indices[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 背面</span></span><br><span class="line">    indices[<span class="number">6</span>] = <span class="number">4</span>; indices[<span class="number">7</span>] = <span class="number">6</span>; indices[<span class="number">8</span>] = <span class="number">5</span>;</span><br><span class="line">    indices[<span class="number">9</span>] = <span class="number">4</span>; indices[<span class="number">10</span>] = <span class="number">7</span>; indices[<span class="number">11</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左面</span></span><br><span class="line">    indices[<span class="number">12</span>] = <span class="number">4</span>; indices[<span class="number">13</span>] = <span class="number">5</span>; indices[<span class="number">14</span>] = <span class="number">1</span>;</span><br><span class="line">    indices[<span class="number">15</span>] = <span class="number">4</span>; indices[<span class="number">16</span>] = <span class="number">1</span>; indices[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右面</span></span><br><span class="line">    indices[<span class="number">18</span>] = <span class="number">3</span>; indices[<span class="number">19</span>] = <span class="number">2</span>; indices[<span class="number">20</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">21</span>] = <span class="number">3</span>; indices[<span class="number">22</span>] = <span class="number">6</span>; indices[<span class="number">23</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶部</span></span><br><span class="line">    indices[<span class="number">24</span>] = <span class="number">1</span>; indices[<span class="number">25</span>] = <span class="number">5</span>; indices[<span class="number">26</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">27</span>] = <span class="number">1</span>; indices[<span class="number">28</span>] = <span class="number">6</span>; indices[<span class="number">29</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底部</span></span><br><span class="line">    indices[<span class="number">30</span>] = <span class="number">4</span>; indices[<span class="number">31</span>] = <span class="number">0</span>; indices[<span class="number">32</span>] = <span class="number">3</span>;</span><br><span class="line">    indices[<span class="number">33</span>] = <span class="number">4</span>; indices[<span class="number">34</span>] = <span class="number">3</span>; indices[<span class="number">35</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    IB-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 照相机位置（视图矩阵）</span></span><br><span class="line">    <span class="function">D3DXVECTOR3 <span class="title">position</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-5.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">D3DXVECTOR3 <span class="title">target</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">D3DXVECTOR3 <span class="title">up</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    D3DXMATRIX V;</span><br><span class="line">    D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;target, &amp;up);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetTransform(D3DTS_VIEW, &amp;V);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投影矩阵</span></span><br><span class="line">    D3DXMATRIX proj;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(</span><br><span class="line">        &amp;proj,</span><br><span class="line">        D3DX_PI * <span class="number">0.5f</span>, <span class="comment">// 90 - degree</span></span><br><span class="line">        (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height,</span><br><span class="line">        <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1000.0f</span>);</span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染状态（填充模式：框架填充）</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　Display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 旋转立方体</span></span><br><span class="line">        D3DXMATRIX Rx, Ry;</span><br><span class="line">        <span class="comment">// x轴旋转45弧度</span></span><br><span class="line">        D3DXMatrixRotationX(&amp;Rx, <span class="number">3.14f</span> / <span class="number">4.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一帧中增加y轴的弧度</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">float</span> y = <span class="number">0.0f</span>;</span><br><span class="line">        D3DXMatrixRotationY(&amp;Ry, y);</span><br><span class="line">        y += timeDelta;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当y轴旋转2周时，重新回到0弧度</span></span><br><span class="line">        <span class="keyword">if</span>( y &gt;= <span class="number">6.28f</span> )</span><br><span class="line">            y = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结合x轴与y轴的旋转矩阵</span></span><br><span class="line">        D3DXMATRIX p = Rx * Ry;</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_WORLD, &amp;p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空目标缓存和深度缓存（用0xffffffff, 1.0f）</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,</span><br><span class="line">          <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        Device-&gt;BeginScene(); <span class="comment">// 开始绘制场景</span></span><br><span class="line"></span><br><span class="line">        Device-&gt;SetStreamSource(<span class="number">0</span>, VB, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vertex)); <span class="comment">// 设置资源流</span></span><br><span class="line">        Device-&gt;SetIndices(IB); <span class="comment">// 设置索引缓存</span></span><br><span class="line">        Device-&gt;SetFVF(Vertex::FVF); <span class="comment">// 设置顶点格式</span></span><br><span class="line">　　　　<span class="comment">// 利用索引缓存绘制</span></span><br><span class="line">        Device-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        Device-&gt;EndScene(); <span class="comment">// 结束绘制场景</span></span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 翻转表面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d3d::Release&lt;IDirect3DVertexBuffer9*&gt;(VB);</span><br><span class="line">    d3d::Release&lt;IDirect3DIndexBuffer9*&gt;(IB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">334</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DTWMWSlnxcXcuUgR1H2qlVt9-gzGzoHsz',
      appKey     : 'Ms2yHVyCinQmWnsKtVv7NOHR',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
