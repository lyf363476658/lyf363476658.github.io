<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Console:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/25/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/25/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/10/unity-nature-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/10/unity-nature-review/" class="post-title-link" itemprop="url">unity-nature-review</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-10 15:36:26" itemprop="dateCreated datePublished" datetime="2018-04-10T15:36:26+08:00">2018-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/04/10/unity-nature-review/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/04/10/unity-nature-review/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>是否有多维子材质：多维子材质材质测试，三个子材质，50个物体，使用多维子材质12帧，330个dc，343面。拆开之后20帧，154dc，134面。多维子材质Unity无法动态合并。<br>叠加模式贴图，可以不用Alpha通道<br>特效粒子贴图是否合并<br>是否有些粒子能使用序列帧，不过和视角有关，去掉alpha贴图合并。<br>动画boneweight,没有特殊需要的情况下受两个骨骼影响就够了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/Unix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/Unix/" class="post-title-link" itemprop="url">大端模式与小端模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 10:42:38" itemprop="dateCreated datePublished" datetime="2018-04-02T10:42:38+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/04/02/Unix/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/04/02/Unix/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><ul>
<li>Little-Endian         低位字节放在内存的低地址端，高位字节放在内存的高地址端。</li>
<li>Big-Endian            高位字节放在内存的高地址端，低位字节放在内存的低地址端。</li>
<li>Network byte order    TPC/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。</li>
</ul>
<h3 id="高-低地址端"><a href="#高-低地址端" class="headerlink" title="高/低地址端"></a>高/低地址端</h3><p>首先要知道C程序中内存的空间布局情况：在《C专家编程》和《Unix环境高级编程》中关于内存空间布局情况的说明，大致如下图：</p>
<p>——————————————— 最高内存地址 0xffffffff<br>栈底<br>栈<br>栈顶<br>NULL（空洞）<br>堆<br>未初始化的数据<br>正文段（代码段<br>——————————————— 最高内存地址 0x00000000</p>
<p>在内存分布中，栈是向下增长的，而堆是向上增长的。</p>
<p>加入在栈分配unisgned char buf[4]，他在栈上分布如下<br>栈底（高地址）<br>buf[3]<br>buf[2]<br>buf[1]<br>buf[0]<br>栈顶（低地址）</p>
<h3 id="高-低位字节"><a href="#高-低位字节" class="headerlink" title="高/低位字节"></a>高/低位字节</h3><p>在十进制中靠左边的是高位，靠右边的地址，在其它进制也是如此</p>
<p>unisgned int value = 0x12345678;</p>
<p>Big-Endian:低地址存放高位<br>栈底（高地址）<br>buf[3] (0x78)<br>buf[2] (0x56)<br>buf[1] (0x34)<br>buf[0] (0x12)<br>栈顶（低地址）</p>
<p>Litter-Endian:高地址存高位<br>栈顶（高地址）<br>buf[0] (0x78)<br>buf[1] (0x56)<br>buf[2] (0x34)<br>buf[3] (0x12)<br>栈底（低地址）</p>
<p><td bgcolor="orange"> 主机序（Host Order）就是遵循Little-Endian规则</td>。所以当两台主机之间通过TCP/IP协议进行通信的时候就需要调用相应的函数进行主机序（Little-Endian）和网络（Big-Endian）的转换。</p>
<h2 id="Big-Endian和Little-Endian优缺点"><a href="#Big-Endian和Little-Endian优缺点" class="headerlink" title="Big-Endian和Little-Endian优缺点"></a>Big-Endian和Little-Endian优缺点</h2><p>Big-Endian 优点：</p>
<ol>
<li>靠首先提取高位字节，总是可以在偏移位置为0的字节来确定这个数字是正数还是负数。</li>
<li>数值打印是按顺序存放的</li>
</ol>
<p>Litter-Endian 优点：</p>
<ol>
<li>数学计算，精度处理。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/Lua-5-1-refer-manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/Lua-5-1-refer-manual/" class="post-title-link" itemprop="url">Lua参考手册上半部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 10:42:38" itemprop="dateCreated datePublished" datetime="2018-04-02T10:42:38+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/04/02/Lua-5-1-refer-manual/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/04/02/Lua-5-1-refer-manual/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua 是一个扩展式程序设计语言，它被设计成支持通用的过程式编程，并有相关数据描述的设施。 Lua 也能对面向对象编程，函数式编程，数据驱动式编程提供很好的支持。 它可以作为一个强大、轻量的脚本语言，供任何需要的程序使用。 Lua 以一个用 clean C 写成的库形式提供。（所谓 Clean C ，指的 ANSI C 和 C++ 中共通的一个子集）<br>作为一个扩展式语言，Lua 没有 “main” 程序的概念：它只能 嵌入 一个宿主程序中工作，这个宿主程序被称作 embedding program 或简称为 host 。 宿主程序可以通过调用函数执行一小段 Lua 代码，可以读写 Lua 变量，可以注入 C 函数让 Lua 代码调用。 这些扩展的 C 函数，可以大大的扩展了 Lua 可以处理事务的领域，这样就可以订制出各种语言， 而它们共享一个统一的句法格式的框架。 Lua 的官方发布版就包含了一个叫做 lua 的简单的宿主程序，它用 Lua 库提供了一个保证独立的 Lua 解释器。<br>Lua 是一个自由软件，它的使用许可决定了对它的使用过程一般没有任何保证。 这份手册中描述的东西的实现，可以在 Lua 的官方网站 www.lua.org 找到，<br>跟其它的许多参考手册一样，这份文档有些地方比较枯燥。 关于 Lua 的设计想法的探讨，可以看看 Lua 网站上提供的技术论文。 有关用 Lua 编程的细节介绍，可以读一下 Roberto 的书，Programming in Lua (Second Edition) 。</p>
<p>这一节从词法、语法、句法上描述 Lua 。 换句话说，这一节描述了哪些 token （符记）是有效的，它们如何被组合起来，这些组合方式有什么含义。<br>关于语言的构成概念将用常见的扩展 BNF 表达式写出。也就是这个样子： {a} 意思是 0 或多个 a ， [a] 意思是一个可选的 a 。 非最终的符号会保留原来的样子，关键字则看起来像这样 kword ， 其它最终的符号则写成 `=´ 。 完整的 Lua 语法可以在本手册最后找到。</p>
<p>Lua 中用到的 名字（也称作 标识符）可以是任何非数字开头的字母、数字、下划线组成的字符串。 这符合几乎所有编程语言中关于名字的定义。 （字母的定义依赖于当前环境：系统环境中定义的字母表中的字母都可以被用于标识符。） 标识符用来命名变量，或作为表的域名。</p>
<p>下面的关键字是保留的，不能用作名字：</p>
<pre><code>and       break     do        else      elseif
end       false     for       function  if
in        local     nil       not       or
repeat    return    then      true      until     while
</code></pre><p>Lua 是一个大小写敏感的语言： and 是一个保留字，但是 And 和 AND 则是两个不同的合法的名字。 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<p>下面这些是其它的 token ：</p>
<pre><code> +     -     *     /     %     ^     #
 ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
 (     )     {     }     [     ]
 ;     :     ,     .     ..    ...
</code></pre><p>字符串既可以用一对单引号引起，也可以是双引号，里面还可以包含类似 C 的转义符： ‘\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （表单）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\‘ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\’’ （单引号)。 而且，如果在一个反斜杠后跟了一个真正的换行符，其结果就是在字符串中产生一个换行符。 我们还可以用反斜杠加数字的形式 \ddd 来描述一个字符。这里， ddd 是一串最多三位的十进制数字。（注意，如果需要在这种描述方法后接一个是数字的字符， 那么反斜杠后必须写满三个数字。）Lua 中的字符串可以包含任何 8 位的值。包括用 ‘\0’ 表示的零。<br>只有在你需要把不同的引号、换行、反斜杠、或是零结束符这些字符置入字符串时， 你才必须使用转义符。别的任何字符都可以直接写在文本里。（一些控制符可以会影响文件系统造成某些问题， 但是不会引起 Lua 的任何问题。）<br>字符串还可以用一种长括号括起来的方式定义。 我们把两个正的方括号间插入 n 个等号定义为第 n 级正长括号。 就是说，0 级正的长括号写作 [[ ， 一级正的长括号写作 [=[ ，如此等等。 反的长扩展也作类似定义； 举个例子，4 级反的长括号写作 ]====] 。 一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。 整个词法分析过程将不受分行限制，不处理任何转意符，并且忽略掉任何不同级别的长括号。 这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。<br>另一个约定是，当正的长括号后面立即跟了一个换行符， 这个换行符就不包含在这个字符串内。 举个例子，假设一个系统使用 ASCII 码 （这时，’a’ 编码为 97 ，换行符编码为 10 ，’1’ 编码为 49 ）， 下面五种方式描述了完全相同的字符串：</p>
<pre><code> a = &#39;alo\n123&quot;&#39;
 a = &quot;alo\n123\&quot;&quot;
 a = &#39;\97lo\10\04923&quot;&#39;
 a = [[alo
 123&quot;]]
 a = [==[
 alo
 123&quot;]==]
</code></pre><p>数字常量可以分两部分写，十进制底数部分和十进制的指数部分。指数部分是可选的。 Lua 也支持十六进制整数常量，只需要在前面加上前缀 0x 。 下面是一些合法的数字常量的例子：</p>
<pre><code> 3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56
</code></pre><p>注释可以在除字符串内的任何地方是以两横 (—) 开始。 如果跟在两横后面的不是一个长括号，这就是一个短注释，它的作用范围直到行末； 否则就是一个长注释，其作用范围直到遇到反的长括号。 长注释通常被用来临时屏蔽代码块。<br>Lua 是一种 动态类型语言。 这意味着变量没有类型，只有值才有类型。 语言中不存在类型定义。而所有的值本身携带它们自己的类型信息。<br>Lua 中的所有值都是一致 (first-class) 的。 这意味着所有的值都可以被放在变量里，当作参数传递到另一个函数中，并被函数作为结果返回。<br>Lua 中有八种基本类型： nil, boolean, number, string, function, userdata, thread, and table. Nil 类型只有一种值 nil ，它的主要用途用于标表识和别的任何值的差异； 通常，当需要描述一个无意义的值时会用到它。 Boolean 类型只有两种值：false 和 true。 nil 和 false 都能导致条件为假；而另外所有的值都被当作真。 Number 表示实数（双精度浮点数）。 （编译一个其它内部数字类型的 Lua 解释器是件很容易的事；比如把内部数字类型改作 单精度浮点数或长整型。参见文件 luaconf.h 。） String 表示一串字符的数组。 Lua 是 8-bit clean 的： 字符串可以包含任何 8 位字符， 包括零结束符 (‘\0’) （参见 §2.1）。<br>Lua 可以调用（和处理）用 Lua 写的函数以及用 C 写的函数<br>userdata 类型用来将任意 C 数据保存在 Lua 变量中。 这个类型相当于一块原生的内存，除了赋值和相同性判断，Lua 没有为之预定义任何操作。 然而，通过使用 metatable （元表） ，程序员可以为 userdata 自定义一组操作。 userdata 不能在 Lua 中创建出来，也不能在 Lua 中修改。这样的操作只能通过 C API。 这一点保证了宿主程序完全掌管其中的数据。<br>thread 类型用来区别独立的执行线程，它被用来实现 coroutine （协同例程）。 不要把 Lua 线程跟操作系统的线程搞混。 Lua 可以在所有的系统上提供对 coroutine 的支持，即使系统并不支持线程。<br>table 类型实现了一个关联数组。也就是说， 数组可以用任何东西（除了nil）做索引，而不限于数字。 table 可以以不同类型的值构成；它可以包含所有的类型的值（除 nil 外）。 table 是 lua 中唯一的一种数据结构；它可以用来描述原始的数组、符号表、集合、 记录、图、树、等等。 用于表述记录时，lua 使用域名作为索引。 语言本身采用一种语法糖，支持以 a.name 的形式表示 a[“name”]。 有很多形式用于在 lua 中创建一个 table （参见 §2.5.7）。<br>跟索引一样， table 每个域中的值也可以是任何类型（除 nil外）。 特别的，因为函数本身也是值，所以 table 的域中也可以放函数。 这样 table 中就可以有一些 methods 了 。<br>table， function ，thread ，和 (full) userdata 这些类型的值是所谓的对象： 变量本身并不会真正的存放它们的值，而只是放了一个对对象的引用。 赋值，参数传递，函数返回，都是对这些对象的引用进行操作； 这些操作不会做暗地里做任何性质的拷贝。<br>库函数 type 可以返回一个描述给定值的类型的字符串。<br>Lua 提供运行时字符串到数字的自动转换。 任何对字符串的数学运算操作都会尝试用一般的转换规则把这个字符串转换成一个数字。 相反，无论何时，一个数字需要作为字符串来使用时，数字都会以合理的格式转换为字符串。 需要完全控制数字怎样转换为字符串，可以使用字符串库中的 format 函数 （参见 string.format）。<br>写上变量的地方意味着当以其保存的值来替代之。 Lua 中有三类变量：全局变量，局部变量，还有 table 的域。<br>一个单一的名字可以表示一个全局变量，也可以表示一个局部变量 （或者是一个函数的参数，这是一种特殊形式的局部变量）：</p>
<pre><code>var ::= Name
</code></pre><p>Name 就是所定义的标识符。<br>任何变量都被假定为全局变量，除非显式的以 local 修饰定义。 局部变量有其作用范围： 局部变量可以被定义在它作用范围中的函数自由使用。<br>在变量的首次赋值之前，变量的值均为 nil。<br>方括号被用来对 table 作索引：</p>
<pre><code>var ::= prefixexp `[´ exp `]´
</code></pre><p>对全局变量以及 table 域之访问的含义可以通过 metatable 来改变。 以取一个变量下标指向的量 t[i] 等价于调用 gettable_event(t,i)。 （参见 §2.8 ，有一份完整的关于 gettable_event 函数的说明。 这个函数并没有在 lua 中定义出来，也不能在 lua 中调用。 这里我们把它列出来只是方便说明。）</p>
<p>var.Name 这种语法只是一个语法糖，用来表示 var[“Name”]：</p>
<pre><code>var ::= prefixexp `.´ Name
</code></pre><p>所有的全局变量都是放在一个特定 lua table 的诸个域中，这个特定的 table 叫作 environment （环境）table 或者简称为 环境 （参见 §2.9）。 每个函数都有对一个环境的引用， 所以一个函数中可见的所有全局变量都放在这个函数所引用的环境表（environment table）中。 当一个函数被创建出来，它会从创建它的函数中继承其环境，你可以调用 getfenv 取得其环境。 如果想改变环境，可以调用 setfenv。 （对于 C 函数，你只能通过 debug 库来改变其环境； 参见 §5.9）。</p>
<p>对一个全局变量 x 的访问 等价于 _env.x，而这又可以等价于</p>
<pre><code>gettable_event(_env, &quot;x&quot;)
</code></pre><p>这里，_env 是当前运行的函数的环境。 （函数 gettable_event 的完整说明参见 §2.8。 这个函数并没有在 lua 中定义出来，也不能调用。 当然，_env 这个变量也同样没有在 Lua 中定义出来。 我们在这里使用它们，仅仅只是方便解释而已。）</p>
<p>2.4 - 语句段（Statement）<br>Lua 支持惯例形式的语句段，它和 Pascal 或是 C 很相象。 这个集合包括赋值，控制结构，函数调用，还有变量声明。</p>
<p>2.4.1 - Chunk（语句组）<br>Lua 的一个执行单元被称作 chunk。 一个 chunk 就是一串语句段，它们会被循序的执行。 每个语句段可以以一个分号结束：</p>
<pre><code>chunk ::= {stat [`;´]}
</code></pre><p>这儿不允许有空的语句段，所以 ‘;;’ 是非法的。</p>
<p>lua 把一个 chunk 当作一个拥有不定参数的匿名函数 （参见 §2.5.9）处理。 正是这样，chunk 内可以定义局部变量，接收参数，并且返回值。</p>
<p>chunk 可以被保存在一个文件中，也可以保存在宿主程序的一个字符串中。 当一个 chunk 被执行，首先它会被预编译成虚拟机中的指令序列， 然后被虚拟机解释运行这些指令。</p>
<p>chunk 也可以被预编译成二进制形式；细节参考程序 luac。 用源码形式提供的程序和被编译过的二进制形式的程序是可以相互替换的； Lua 会自动识别文件类型并做正确的处理。</p>
<p>语句块是一列语句段；从语法上来说，一个语句块跟一个 chunk 相同：</p>
<pre><code>block ::= chunk
</code></pre><p>一个语句块可以被显式的写成一个单独的语句段：</p>
<pre><code>stat ::= do block end
</code></pre><p>显式的语句块对于控制变量的作用范围很有用。 有时候，显式的语句块被用来在另一个语句块中插入 return 或是 break （参见 §2.4.4）。</p>
<p>Lua 允许多重赋值。 因此，赋值的语法定义是等号左边放一系列变量， 而等号右边放一系列的表达式。 两边的元素都用逗号间开：</p>
<pre><code>stat ::= varlist1 `=´ explist1
varlist1 ::= var {`,´ var}
explist1 ::= exp {`,´ exp}
</code></pre><p>在作赋值操作之前， 那一系列的右值会被对齐到左边变量需要的个数。 如果右值比需要的更多的话，多余的值就被扔掉。 如果右值的数量不够需求， 将会按所需扩展若干个 nil。 如果表达式列表以一个函数调用结束， 这个函数所返回的所有值都会在对齐操作之前被置入右值序列中。 （除非这个函数调用被用括号括了起来；参见 §2.5）。</p>
<p>赋值段首先会做运算完所有的表达式，然后仅仅做赋值操作。 因此，下面这段代码</p>
<pre><code> i = 3
 i, a[i] = i+1, 20
</code></pre><p>会把 a[3] 设置为 20，而不会影响到 a[4] 。 这是因为 a[i] 中的 i 在被赋值为 4 之前就被拿出来了（那时是 3 ）。 简单说 ，这样一行</p>
<pre><code> x, y = y, x
</code></pre><p>可以用来交换 x 和 y 中的值。</p>
<p>对全局变量以及 table 中的域的赋值操作的含义可以通过 metatable 来改变。 对变量下标指向的赋值，即 t[i] = val 等价于 settable_event(t,i,val)。 （关于函数 settable_event 的详细说明，参见 §2.8。 这个函数并没有在 Lua 中定义出来，也不可以被调用。 这里我们列出来，仅仅出于方便解释的目的）</p>
<p>对于全局变量的赋值 x = val 等价于 _env.x = val，这个又可以等价于</p>
<pre><code>settable_event(_env, &quot;x&quot;, val)
</code></pre><p>这里，_env 指的是正在运行中的函数的环境。 （变量 _env 并没有在 Lua 中定义出来。 我们仅仅出于解释的目的在这里写出来。）</p>
<p>if、 while、以及 repeat 这些控制结构符合通常的意义，而且也有类似的语法：</p>
<pre><code>stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
</code></pre><p>Lua 也有一个 for 语句，它有两种形式。<br>控制结构中的条件表达式可以返回任何值。 false 和 nil 两者都被认为是假条件。 所有不同于 nil 和 false 的其它值都被认为是真 （特别需要注意的是，数字 0 和空字符串也被认为是真）。<br>在 repeat–until 循环中， 内部语句块的结束点不是在 until 这个关键字处， 它还包括了其后的条件表达式。 因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。<br>return 被用于从函数或是 chunk（其实它就是一个函数）中 返回值。 函数和 chunk 可以返回不只一个值， 所以 return 的语法为</p>
<pre><code>stat ::= return [explist1]
</code></pre><p>break 被用来结束 while、 repeat、或 for 循环， 它将忽略掉循环中下面的语句段的运行：</p>
<pre><code>stat ::= break
</code></pre><p>break 跳出最内层的循环。<br>return 和 break 只能被写在一个语句块的最后一句。 如果你真的需要从语句块的中间 return 或是 break ， 你可以使用显式的声名一个内部语句块。 一般写作 do return end 或是 do break end， 可以这样写是因为现在 return 或 break 都成了一个语句块的最后一句了。</p>
<p>for 有两种形式：一种是数字形式，另一种是一般形式。</p>
<p>数字形式的 for 循环，通过一个数学运算不断的运行内部的代码块。 下面是它的语法：</p>
<pre><code>stat ::= for Name `=´ exp `,´ exp [`,´ exp] do block end
</code></pre><p>block 将把 name 作循环变量。从第一个 exp 开始起，直到第二个 exp 的值为止，其步长为 第三个 exp 。 更确切的说，一个 for 循环看起来是这个样子</p>
<pre><code> for v = e1, e2, e3 do block end
</code></pre><p>这等价于代码：</p>
<pre><code>do
   local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
   if not (var and limit and step) then error() end
   while (step &gt; 0 and var &lt;= limit) or (step &lt;= 0 and var &gt;= limit) do
     local v = var
     block
     var = var + step
   end
end
</code></pre><p>注意下面这几点：</p>
<p>所有三个控制表达式都只被运算一次，表达式的计算在循环开始之前。 这些表达式的结果必须是数字。<br>var 、limit 、以及 step 都是一些不可见的变量。 这里给它们起的名字都仅仅用于解释方便。<br>如果第三个表达式（步长）没有给出，会把步长设为 1 。<br>你可以用 break 来退出 for 循环。<br>循环变量 v 是一个循环内部的局部变量； 当 for 循环结束后，你就不能在使用它。 如果你需要这个值，在退出循环前把它赋给另一个变量。<br>一般形式的 for 通过一个叫作迭代器（iterators）的函数工作。 每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。 一般形式的 for 循环的语法如下：</p>
<pre><code>stat ::= for namelist in explist1 do block end
namelist ::= Name {`,´ Name}
</code></pre><p>for 语句好似这样</p>
<pre><code> for var_1, ···, var_n in explist do block end
</code></pre><p>它等价于这样一段代码：</p>
<pre><code> do
   local f, s, var = explist
   while true do
     local var_1, ···, var_n = f(s, var)
     var = var_1
     if var == nil then break end
     block
   end
 end
</code></pre><p>注意以下几点：</p>
<p>explist 只会被计算一次。 它返回三个值， 一个迭代器函数，一个状态，一个迭代器的初始值。<br>f、 s、 以及 var 都是不可见的变量。 这里给它们起的名字都只是为了解说方便。<br>你可以使用 break 来跳出 for 循环。<br>循环变量 var_i 对于循环来说是一个局部变量； 你不可以在 for 循环结束后继续使用。 如果你需要保留这些值，那么就在循环结束前赋值到别的变量里去。<br>2.4.6 - 把函数调用作为语句段<br>为了允许使用可能的副作用， 函数调用可以被作为一个语句段执行：</p>
<pre><code>stat ::= functioncall
</code></pre><p>在这种情况下，所有的返回值都被舍弃。 函数调用在 §2.5.8 中解释。</p>
<p>2.4.7 - 局部变量声名<br>局部变量可以在语句块中任何地方声名。 声名可以包含一个初始化赋值操作：</p>
<pre><code>stat ::= local namelist [`=´ explist1]
</code></pre><p>如果有的话，初始化赋值操作的行为等同于赋值操作（参见 §2.4.3）。 否则，所有的变量将被初始化为 nil。</p>
<p>一个 chunk 同时也是一个语句块（参见 §2.4.1）， 所以局部变量可以放在 chunk 中那些显式注明的语句块之外。 这些局部变量的作用范围从声明起一直延伸到 chunk 末尾。</p>
<p>局部变量的可见规则在 §2.6 中解释。</p>
<p>2.5 - 表达式<br>Lua 中有这些基本表达式：</p>
<pre><code>exp ::= prefixexp
exp ::= nil | false | true
exp ::= Number
exp ::= String
exp ::= function
exp ::= tableconstructor
exp ::= `...´
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | `(´ exp `)´
</code></pre><p>数字和字符串在 §2.1 中解释； 变量在 §2.3 中解释； 函数定义在 §2.5.9 中解释； 函数调用在 §2.5.8 中解释； table 的构造在 §2.5.7 中解释； 可变参数的表达式写作三个点 (‘…’) ，它只能被用在有可变参数的函数中； 这些在 §2.5.9 中解释。</p>
<p>二元操作符包含有数学运算操作符（参见 §2.5.1）， 比较操作符（参见 §2.5.2），逻辑操作符（参见 §2.5.3）， 以及连接操作符（参见 §2.5.4）。 一元操作符包括负号（参见see §2.5.1）， 取反 not（参见 §2.5.3）， 和取长度操作符（参见 §2.5.5）。</p>
<p>函数调用和可变参数表达式都可以放在多重返回值中。 如果表达式作为一个独立语句段出现（参见 §2.4.6） （这只能是一个函数调用）， 它们的返回列表将被对齐到零个元素，也就是忽略所有返回值。 如果表达式用于表达式列表的最后（或者是唯一）的元素， 就不会有任何的对齐操作（除非函数调用用括号括起来）。 在任何其它的情况下，Lua 将把表达式结果看成单一元素， 忽略除第一个之外的任何值。</p>
<p>这里有一些例子：</p>
<pre><code> f()                -- 调整到 0 个结果
 g(f(), x)          -- f() 被调整到一个结果
 g(x, f())          -- g 被传入 x 加上所有 f() 的返回值
 a,b,c = f(), x     -- f() 被调整到一个结果 （ c 在这里被赋为 nil ）
 a,b = ...          -- a 被赋值为可变参数中的第一个，
                    -- b 被赋值为第二个 （如果可变参数中并没有对应的值，
                    -- 这里 a 和 b 都有可能被赋为 nil）

 a,b,c = x, f()     -- f() 被调整为两个结果
 a,b,c = f()        -- f() 被调整为三个结果
 return f()         -- 返回 f() 返回的所有结果
 return ...         -- 返回所有从可变参数中接收来的值
 return x,y,f()     -- 返回 x, y, 以及所有 f() 的返回值
 {f()}              -- 用 f() 的所有返回值创建一个列表
 {...}              -- 用可变参数中的所有值创建一个列表
 {f(), nil}         -- f() 被调整为一个结果
</code></pre><p>被括号括起来的表达式永远被当作一个值。所以， (f(x,y,z)) 即使 f 返回多个值，这个表达式永远是一个单一值。 （(f(x,y,z)) 的值是 f 返回的第一个值。如果 f 不返回值的话，那么它的值就是 nil 。）</p>
<p>2.5.1 - 数学运算操作符<br>Lua 支持常见的数学运算操作符： 二元操作 + （加法）， - （减法），* （乘法）， / （除法）， % （取模），以及 ^ （幂）； 和一元操作 - （取负）。 如果对数字操作，或是可以转换为数字的字符串（参见 §2.2.1）， 所有这些操作都依赖它通常的含义。 幂操作可以对任何幂值都正常工作。比如， x^(-0.5) 将计算出 x 平方根的倒数。 取模操作被定义为</p>
<pre><code> a % b == a - math.floor(a/b)*b
</code></pre><p>这就是说，其结果是商相对负无穷圆整后的余数。（译注：负数对正数取模的结果为正数）</p>
<p>2.5.2 - 比较操作符<br>Lua 中的比较操作符有</p>
<pre><code> ==    ~=    &lt;     &gt;     &lt;=    &gt;=
</code></pre><p>这些操作的结果不是 false 就是 true。</p>
<p>等于操作 (==) 首先比较操作数的类型。 如果类型不同，结果就是 false。 否则，继续比较值。 数字和字符串都用常规的方式比较。 对象 （table ，userdata ，thread ，以及函数）以引用的形式比较： 两个对象只有在它们指向同一个东西时才认为相等。 每次你创建一个新对象（一个 table 或是 userdata ，thread 函数）， 它们都各不相同，即不同于上次创建的东西。</p>
<p>你可以改变 Lua 比较 table 和 userdata 的方式，这需要使用 “eq” 这个原方法 （参见 §2.8）。</p>
<p>§2.2.1 中提及的转换规则并不作用于比较操作。 所以， “0”==0 等于 false， 而且 t[0] 和 t[“0”] 描述的是 table 中不同的域。</p>
<p>操作符 ~= 完全等价于 (==) 操作的反值。</p>
<p>大小比较操作以以下方式进行。 如果参数都是数字，那么就直接做数字比较。 否则，如果参数都是字符串，就用字符串比较的方式进行。 再则，Lua 就试着调用 “lt” 或是 “le” 元方法 （参见 §2.8）。</p>
<p>2.5.3 - 逻辑操作符<br>Lua 中的逻辑操作符有 and, or, 以及 not。 和控制结构（参见 §2.4.4）一样， 所有的逻辑操作符把 false 和 nil 都作为假， 而其它的一切都当作真。</p>
<p>取反操作 not 总是返回 false 或 true 中的一个。 与操作符 and 在第一个参数为 false 或 nil 时 返回这第一个参数； 否则，and 返回第二个参数。 或操作符 or 在第一个参数不为 nil 也不为 false 时， 返回这第一个参数，否则返回第二个参数。 and 和 or 都遵循短路规则； 也就是说，第二个操作数只在需要的时候去求值。 这里有一些例子：</p>
<pre><code> 10 or 20            --&gt; 10
 10 or error()       --&gt; 10
 nil or &quot;a&quot;          --&gt; &quot;a&quot;
 nil and 10          --&gt; nil
 false and error()   --&gt; false
 false and nil       --&gt; false
 false or nil        --&gt; nil
 10 and 20           --&gt; 20
</code></pre><p>（在这本手册中， —&gt; 指前面表达式的结果。）</p>
<p>2.5.4 - 连接符<br>Lua 中字符串的连接操作符写作两个点 (‘..’)。 如果两个操作数都是字符串或都是数字，连接操作将以 §2.2.1 中提到的规则把其转换为字符串。 否则，会取调用元方法 “concat” （参见 §2.8）。</p>
<p>2.5.5 - 取长度操作符<br>取长度操作符写作一元操作 #。 字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。</p>
<p>table t 的长度被定义成一个整数下标 n 。 它满足 t[n] 不是 nil 而 t[n+1] 为 nil； 此外，如果 t[1] 为 nil ，n 就可能是零。 对于常规的数组，里面从 1 到 n 放着一些非空的值的时候， 它的长度就精确的为 n，即最后一个值的下标。 如果数组有一个“空洞” （就是说，nil 值被夹在非空值之间）， 那么 #t 可能是指向任何一个是 nil 值的前一个位置的下标 （就是说，任何一个 nil 值都有可能被当成数组的结束）。</p>
<p>2.5.6 - 优先级<br>Lua 中操作符的优先级写在下表中，从低到高优先级排序：</p>
<pre><code> or
 and
 &lt;     &gt;     &lt;=    &gt;=    ~=    ==
 ..
 +     -
 *     /     %
 not   #     - (unary)
 ^
</code></pre><p>通常，你可以用括号来改变运算次序。 连接操作符 (‘..’) 和幂操作 (‘^’) 是从右至左的。 其它所有的操作都是从左至右。</p>
<p>2.5.7 - Table 构造<br>table 构造子是一个构造 table 的表达式。 每次构造子被执行，都会构造出一个新的 table 。 构造子可以被用来构造一个空的 table， 也可以用来构造一个 table 并初始化其中的一些域。 一般的构造子的语法如下</p>
<pre><code>tableconstructor ::= `{´ [fieldlist] `}´
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
fieldsep ::= `,´ | `;´
</code></pre><p>每个形如 [exp1] = exp2 的域向 table 中增加新的一项， 其键值为 exp1 而值为 exp2。 形如 name = exp 的域等价于 [“name”] = exp。 最后，形如 exp 的域等价于 [i] = exp ， 这里的 i 是一个从 1 开始不断增长的数字。 这这个格式中的其它域不会破坏其记数。 举个例子：</p>
<pre><code> a = { [f(1)] = g; &quot;x&quot;, &quot;y&quot;; x = 1, f(x), [30] = 23; 45 }
</code></pre><p>等价于</p>
<pre><code> do
   local t = {}
   t[f(1)] = g
   t[1] = &quot;x&quot;         -- 1st exp
   t[2] = &quot;y&quot;         -- 2nd exp
   t.x = 1            -- t[&quot;x&quot;] = 1
   t[3] = f(x)        -- 3rd exp
   t[30] = 23
   t[4] = 45          -- 4th exp
   a = t
 end
</code></pre><p>如果表单中最后一个域的形式是 exp ， 而且其表达式是一个函数调用或者是一个可变参数， 那么这个表达式所有的返回值将连续的进入列表 （参见 §2.5.8）。 为了避免这一点，你可以用括号把函数调用（或是可变参数）括起来 （参见 §2.5）。</p>
<p>初始化域表可以在最后多一个分割符， 这样设计可以方便由机器生成代码。</p>
<p>2.5.8 - 函数调用<br>Lua 中的函数调用的语法如下：</p>
<pre><code>functioncall ::= prefixexp args
</code></pre><p>函数调用时，第一步，prefixexp 和 args 先被求值。 如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 “call” 就被调用， 第一个参数就是 prefixexp 的值，跟下来的是原来的调用参数 （参见 §2.8）。</p>
<p>这样的形式</p>
<pre><code>functioncall ::= prefixexp `:´ Name args
</code></pre><p>可以用来调用 “方法”。 这是 Lua 支持的一种语法糖。像 v:name(args) 这个样子，被解释成 v.name(v,args)， 这里 v 只会被求值一次。</p>
<p>参数的语法如下：</p>
<pre><code>args ::= `(´ [explist1] `)´
args ::= tableconstructor
args ::= String
</code></pre><p>所有参数的表达式求值都在函数调用之前。 这样的调用形式 f{fields} 是一种语法糖用于表示 f({fields})； 这里指参数列表是一个单一的新创建出来的列表。 而这样的形式 f’string’ （或是 f”string” 亦或是 f[[string]]） 也是一种语法糖，用于表示 f(‘string’)； 这里指参数列表是一个单独的字符串。</p>
<p>因为表达式语法在 Lua 中比较自由， 所以你不能在函数调用的 ‘(‘ 前换行。 这个限制可以避免语言中的一些歧义。 比如你这样写</p>
<pre><code> a = f
 (g).x(a)
</code></pre><p>Lua 将把它当作一个单一语句段， a = f(g).x(a) 。 因此，如果你真的想作为成两个语句段，你必须在它们之间写上一个分号。 如果你真的想调用 f， 你必须从 (g) 前移去换行。</p>
<p>这样一种调用形式：return functioncall 将触发一个尾调用。 Lua 实现了适当的尾部调用（或是适当的尾递归）： 在尾调用中， 被调用的函数重用调用它的函数的堆栈项。 因此，对于程序执行的嵌套尾调用的层数是没有限制的。 然而，尾调用将删除调用它的函数的任何调试信息。 注意，尾调用只发生在特定的语法下， 这时， return 只有单一函数调用作为参数； 这种语法使得调用函数的结果可以精确返回。 因此，下面这些例子都不是尾调用：</p>
<pre><code> return (f(x))        -- 返回值被调整为一个
 return 2 * f(x)
 return x, f(x)       -- 最加若干返回值
 f(x); return         -- 无返回值
 return x or f(x)     -- 返回值被调整为一个
</code></pre><p>2.5.9 - 函数定义<br>函数定义的语法如下：</p>
<pre><code>function ::= function funcbody
funcbody ::= `(´ [parlist1] `)´ block end
</code></pre><p>另外定义了一些语法糖简化函数定义的写法：</p>
<pre><code>stat ::= function funcname funcbody
stat ::= local function Name funcbody
funcname ::= Name {`.´ Name} [`:´ Name]
</code></pre><p>这样的写法：</p>
<pre><code> function f () body end
</code></pre><p>被转换成</p>
<pre><code> f = function () body end
</code></pre><p>这样的写法：</p>
<pre><code> function t.a.b.c.f () body end
</code></pre><p>被转换成</p>
<pre><code> t.a.b.c.f = function () body end
</code></pre><p>这样的写法：</p>
<pre><code> local function f () body end
</code></pre><p>被转换成</p>
<pre><code> local f; f = function () body end
</code></pre><p>注意，并不是转换成</p>
<pre><code> local f = function () body end
</code></pre><p>（这个差别只在函数体内需要引用 f 时才有。）</p>
<p>一个函数定义是一个可执行的表达式， 执行结果是一个类型为 function 的值。 当 Lua 预编译一个 chunk 的时候， chunk 作为一个函数，整个函数体也就被预编译了。 那么，无论何时 Lua 执行了函数定义， 这个函数本身就被实例化了（或者说是关闭了）。 这个函数的实例（或者说是 closure（闭包）） 是表达式的最终值。 相同函数的不同实例有可能引用不同的外部局部变量， 也可能拥有不同的环境表。</p>
<p>形参（函数定义需要的参数）是一些由实参（实际传入参数）的值初始化的局部变量：</p>
<pre><code>parlist1 ::= namelist [`,´ `...´] | `...´
</code></pre><p>当一个函数被调用， 如果函数没有被定义为接收不定长参数，即在形参列表的末尾注明三个点 (‘…’)， 那么实参列表就会被调整到形参列表的长度， 变长参数函数不会调整实参列表； 取而代之的是，它将把所有额外的参数放在一起通过变长参数表达式传递给函数， 其写法依旧是三个点。 这个表达式的值是一串实参值的列表，看起来就跟一个可以返回多个结果的函数一样。 如果一个变长参数表达式放在另一个表达式中使用，或是放在另一串表达式的中间， 那么它的返回值就会被调整为单个值。 若这个表达式放在了一系列表达式的最后一个，就不会做调整了（除非用括号给括了起来）。</p>
<p>我们先做如下定义，然后再来看一个例子：</p>
<pre><code> function f(a, b) end
 function g(a, b, ...) end
 function r() return 1,2,3 end
</code></pre><p>下面看看实参到形参数以及可变长参数的映射关系：</p>
<pre><code> CALL            PARAMETERS

 f(3)             a=3, b=nil
 f(3, 4)          a=3, b=4
 f(3, 4, 5)       a=3, b=4
 f(r(), 10)       a=1, b=10
 f(r())           a=1, b=2

 g(3)             a=3, b=nil, ... --&gt;  (nothing)
 g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
 g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
 g(5, r())        a=5, b=1,   ... --&gt;  2  3
</code></pre><p>结果由 return 来返回（参见 §2.4.4）。 如果执行到函数末尾依旧没有遇到任何 return 语句， 函数就不会返回任何结果。</p>
<p>冒号语法可以用来定义方法， 就是说，函数可以有一个隐式的形参 self。 因此，如下写法：</p>
<pre><code> function t.a.b.c:f (params) body end
</code></pre><p>是这样一种写法的语法糖：</p>
<pre><code> t.a.b.c.f = function (self, params) body end
</code></pre><p>2.6 - 可视规则<br>Lua 是一个有词法作用范围的语言。 变量的作用范围开始于声明它们之后的第一个语句段， 结束于包含这个声明的最内层语句块的结束点。 看下面这些例子：</p>
<pre><code> x = 10                -- 全局变量
 do                    -- 新的语句块
   local x = x         -- 新的一个 &#39;x&#39;, 它的值现在是 10
   print(x)            --&gt; 10
   x = x+1
   do                  -- 另一个语句块
     local x = x+1     -- 又一个 &#39;x&#39;
     print(x)          --&gt; 12
   end
   print(x)            --&gt; 11
 end
 print(x)              --&gt; 10  （取到的是全局的那一个）
</code></pre><p>注意这里，类似 local x = x 这样的声明， 新的 x 正在被声明，但是还没有进入它的作用范围， 所以第二个 x 指向的是外面一层的变量。</p>
<p>因为有这样一个词法作用范围的规则， 所以可以在函数内部自由的定义局部变量并使用它们。 当一个局部变量被更内层的函数中使用的时候， 它被内层函数称作 upvalue（上值），或是 外部局部变量。</p>
<p>注意，每次执行到一个 local 语句都会定义出一个新的局部变量。 看看这样一个例子：</p>
<pre><code> a = {}
 local x = 20
 for i=1,10 do
   local y = 0
   a[i] = function () y=y+1; return x+y end
 end
</code></pre><p>这个循环创建了十个 closure（这指十个匿名函数的实例）。 这些 closure 中的每一个都使用了不同的 y 变量， 而它们又共享了同一份 x。</p>
<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><pre><code>error(message[, level])
</code></pre><ul>
<li>Level = 1[默认]：为调用error位置(文件+行号)</li>
<li>Level = 2：指出哪个调用error的函数的函数</li>
<li>Level = 0：不添加错误位置信息<br>因为 Lua 是一个嵌入式的扩展语言， 所有的 Lua 动作都是从宿主程序的 C 代码调用 Lua 库 （参见 lua_pcall）中的一个函数开始的。 在 Lua 编译或运行的任何时候发生了错误，控制权都会交还给 C ， 而 C 可以来做一些恰当的措施（比如打印出一条错误信息）。<br>Lua 代码可以显式的调用 error 函数来产生一条错误。 如果你需要在 Lua 中捕获发生的错误， 你可以使用 pcall 函数。</li>
</ul>
<h3 id="Metatable"><a href="#Metatable" class="headerlink" title="Metatable"></a>Metatable</h3><p>Lua 中的每个值都可以用一个 metatable。 这个 metatable 就是一个原始的 Lua table ， 它用来定义原始值在特定操作下的行为。 你可以通过在 metatable 中的特定域设一些值来改变拥有这个 metatable 的值 的指定操作之行为。 举例来说，当一个非数字的值作加法操作的时候， Lua 会检查它的 metatable 中 “_<em>add” 域中的是否有一个函数。 如果有这么一个函数的话，Lua 调用这个函数来执行一次加法。<br>我们叫 metatable 中的键名为 事件 (event) ，把其中的值叫作 元方法 (metamethod)。 在上个例子中，事件是 “add” 而元方法就是那个执行加法操作的函数。<br>你可以通过 getmetatable 函数来查询到任何一个值的 metatable。<br>你可以通过 setmetatable 函数来替换掉 table 的 metatable 。 你不能从 Lua 中改变其它任何类型的值的 metatable （使用 debug 库例外）； 要这样做的话必须使用 C API 。<br>每个 table 和 userdata 拥有独立的 metatable （当然多个 table 和 userdata 可以共享一个相同的表作它们的 metatable）； 其它所有类型的值，每种类型都分别共享唯一的一个 metatable。 因此，所有的数字一起只有一个 metatable ，所有的字符串也是，等等。<br>一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为， metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。 对于这些操作，Lua 都将其关联上一个被称作事件的指定健。 当 Lua 需要对一个值发起这些操作中的一个时， 它会去检查值中 metatable 中是否有对应事件。 如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。<br>metatable 可以控制的操作已在下面列出来。 每个操作都用相应的名字区分。 每个操作的键名都是用操作名字加上两个下划线 ‘_</em>‘ 前缀的字符串； 举例来说，”add” 操作的键名就是字符串 “__add”。 这些操作的语义用一个 Lua 函数来描述解释器如何执行更为恰当。<br>这里展示的用 Lua 写的代码仅作解说用； 实际的行为已经硬编码在解释器中，其执行效率要远高于这些模拟代码。 这些用于描述的的代码中用到的函数 （ rawget ， tonumber ，等等。） 都可以在 §5.1 中找到。 特别注意，我们使用这样一个表达式来从给定对象中提取元方法</p>
<pre><code> metatable(obj)[event]
</code></pre><p>这个应该被解读作</p>
<pre><code> rawget(getmetatable(obj) or {}, event)
</code></pre><p>这就是说，访问一个元方法不再会触发任何的元方法， 而且访问一个没有 metatable 的对象也不会失败（而只是简单返回 nil）。</p>
<p>“add”: + 操作。<br>下面这个 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 首先，Lua 尝试第一个操作数。 如果这个东西的类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。</p>
<pre><code> function getbinhandler (op1, op2, event)
   return metatable(op1)[event] or metatable(op2)[event]
 end
</code></pre><p>通过这个函数， op1 + op2 的行为就是</p>
<pre><code> function add_event (op1, op2)
   local o1, o2 = tonumber(op1), tonumber(op2)
   if o1 and o2 then  -- 两个操作数都是数字？
     return o1 + o2   -- 这里的 &#39;+&#39; 是原生的 &#39;add&#39;
   else  -- 至少一个操作数不是数字时
     local h = getbinhandler(op1, op2, &quot;__add&quot;)
     if h then
       -- 以两个操作数来调用处理器
       return h(op1, op2)
     else  -- 没有处理器：缺省行为
       error(···)
     end
   end
 end
&quot;sub&quot;: - 操作。 其行为类似于 &quot;add&quot; 操作。
&quot;mul&quot;: * 操作。 其行为类似于 &quot;add&quot; 操作。
&quot;div&quot;: / 操作。 其行为类似于 &quot;add&quot; 操作。
&quot;mod&quot;: % 操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是这样的 o1 - floor(o1/o2)*o2
&quot;pow&quot;: ^ （幂）操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是调用 pow 函数（通过 C math 库）。
&quot;unm&quot;: 一元 - 操作。
function unm_event (op)
   local o = tonumber(op)
   if o then  -- 操作数是数字？
     return -o  -- 这里的 &#39;-&#39; 是一个原生的 &#39;unm&#39;
   else  -- 操作数不是数字。
     -- 尝试从操作数中得到处理器
     local h = metatable(op).__unm
     if h then
       -- 以操作数为参数调用处理器
       return h(op)
     else  -- 没有处理器：缺省行为
       error(···)
     end
   end
 end
&quot;concat&quot;: .. （连接）操作，
 function concat_event (op1, op2)
   if (type(op1) == &quot;string&quot; or type(op1) == &quot;number&quot;) and
      (type(op2) == &quot;string&quot; or type(op2) == &quot;number&quot;) then
     return op1 .. op2  -- 原生字符串连接
   else
     local h = getbinhandler(op1, op2, &quot;__concat&quot;)
     if h then
       return h(op1, op2)
     else
       error(···)
     end
   end
 end
&quot;len&quot;: # 操作。
 function len_event (op)
   if type(op) == &quot;string&quot; then
     return strlen(op)         -- 原生的取字符串长度
   elseif type(op) == &quot;table&quot; then
     return #op                -- 原生的取 table 长度
   else
     local h = metatable(op).__len
     if h then
       -- 调用操作数的处理器
       return h(op)
     else  -- 没有处理器：缺省行为
       error(···)
     end
   end
 end
</code></pre><p>关于 table 的长度参见 §2.5.5 。</p>
<p>“eq”: == 操作。 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作。 元方法仅仅在参于比较的两个对象类型相同且有对应操作相同的元方法时才起效。<br>     function getcomphandler (op1, op2, event)<br>       if type(op1) ~= type(op2) then return nil end<br>       local mm1 = metatable(op1)[event]<br>       local mm2 = metatable(op2)[event]<br>       if mm1 == mm2 then return mm1 else return nil end<br>     end<br>“eq” 事件按如下方式定义：</p>
<pre><code> function eq_event (op1, op2)
   if type(op1) ~= type(op2) then  -- 不同的类型？
     return false   -- 不同的对象
   end
   if op1 == op2 then   -- 原生的相等比较结果？
     return true   -- 对象相等
   end
   -- 尝试使用元方法
   local h = getcomphandler(op1, op2, &quot;__eq&quot;)
   if h then
     return h(op1, op2)
   else
     return false
   end
 end
</code></pre><p>a ~= b 等价于 not (a == b) 。</p>
<pre><code>&quot;lt&quot;: &lt; 操作。
 function lt_event (op1, op2)
   if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then
     return op1 &lt; op2   -- 数字比较
   elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then
     return op1 &lt; op2   -- 字符串按逐字符比较
   else
     local h = getcomphandler(op1, op2, &quot;__lt&quot;)
     if h then
       return h(op1, op2)
     else
       error(···);
     end
   end
 end
</code></pre><p>a &gt; b 等价于 b &lt; a.</p>
<pre><code>&quot;le&quot;: &lt;= 操作。
 function le_event (op1, op2)
   if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then
     return op1 &lt;= op2   -- 数字比较
   elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then
     return op1 &lt;= op2   -- 字符串按逐字符比较
   else
     local h = getcomphandler(op1, op2, &quot;__le&quot;)
     if h then
       return h(op1, op2)
     else
       h = getcomphandler(op1, op2, &quot;__lt&quot;)
       if h then
         return not h(op2, op1)
       else
         error(···);
       end
     end
   end
 end
</code></pre><p>a &gt;= b 等价于 b &lt;= a 。 注意，如果元方法 “le” 没有提供，Lua 就尝试 “lt” ， 它假定 a &lt;= b 等价于 not (b &lt; a) 。</p>
<p>“index”: 取下标操作用于访问 table[key] 。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gettable_event</span> <span class="params">(table, key)</span></span></span><br><span class="line">    <span class="keyword">local</span> h</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">table</span>) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> v = <span class="built_in">rawget</span>(<span class="built_in">table</span>, key)</span><br><span class="line">        <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> v <span class="keyword">end</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__index</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__index</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">error</span>(···);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(h) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="built_in">table</span>, key)      <span class="comment">-- 调用处理器</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> h[key]          <span class="comment">-- 或是重复上述操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="newindex"><a href="#newindex" class="headerlink" title="newindex"></a>newindex</h3><p>赋值给指定下标 table[key] = value</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">settable_event</span> <span class="params">(table, key, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> h</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">table</span>) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> v = <span class="built_in">rawget</span>(<span class="built_in">table</span>, key)</span><br><span class="line">        <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">            <span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value) </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__newindex</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">            <span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value) </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__newindex</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">error</span>(···)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(h) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="built_in">table</span>, key,value)    <span class="comment">-- 调用处理器</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        h[key] = value             <span class="comment">-- 或是重复上述操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>“call”: 当 Lua 调用一个值时调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function function_event (func, ...)</span><br><span class="line">  if type(func) == &quot;function&quot; then</span><br><span class="line">    return func(...)   -- 原生的调用</span><br><span class="line">  else</span><br><span class="line">    local h = metatable(func).__call</span><br><span class="line">    if h then</span><br><span class="line">      return h(func, ...)</span><br><span class="line">    else</span><br><span class="line">      error(···)</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="2-9-环境"><a href="#2-9-环境" class="headerlink" title="2.9 - 环境"></a>2.9 - 环境</h3><p>类型为 thread ，function ，以及 userdata 的对象，除了 metatable 外还可以用另外一个与之关联的被称作 它们的环境的一个表， 像 metatable 一样，环境也是一个常规的 table ，多个对象可以共享 同一个环境。<br>userdata 的环境在 Lua 中没有意义。 这个东西只是为了在程序员想把一个表关联到一个 userdata 上时提供便利。<br>关联在线程上的环境被称作全局环境。 全局环境被用作它其中的线程以及线程创建的非嵌套函数 （通过 loadfile ， loadstring 或是 load ）的缺省环境。 而且它可以被 C 代码直接访问（参见 §3.3）。<br>关联在 C 函数上的环境可以直接被 C 代码访问（参见 §3.3）。 它们会作为这个 C 函数中创建的其它函数的缺省环境。<br>关联在 Lua 函数上的环境用来接管在函数内对全局变量（参见 §2.3）的所有访问。 它们也会作为这个函数内创建的其它函数的缺省环境。<br>你可以通过调用 setfenv 来改变一个 Lua 函数 或是正在运行中的线程的环境。 而想操控其它对象（userdata、C 函数、其它线程）的环境的话，就必须使用 C API 。</p>
<h3 id="2-10-垃圾收集"><a href="#2-10-垃圾收集" class="headerlink" title="2.10 - 垃圾收集"></a>2.10 - 垃圾收集</h3><p>Lua 提供了一个自动的内存管理。 这就是说你不需要关心创建新对象的分配内存操作，也不需要在这些对象不再需要时的主动释放内存。 Lua 通过运行一个垃圾收集器来自动管理内存，以此一遍又一遍的回收死掉的对象 （这是指 Lua 中不再访问的到的对象）占用的内存。 Lua 中所有对象都被自动管理，包括： table, userdata、 函数、线程、和字符串。<br>Lua 实现了一个增量标记清除的收集器。 它用两个数字来控制垃圾收集周期： garbage-collector pause 和 garbage-collector step multiplier 。<br>garbage-collector pause 控制了收集器在开始一个新的收集周期之前要等待多久。 随着数字的增大就导致收集器工作工作的不那么主动。 小于 1 的值意味着收集器在新的周期开始时不再等待。 当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。<br>step multiplier 控制了收集器相对内存分配的速度。 更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。 小于 1 的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。 缺省值为 2 ，这意味着收集器将以内存分配器的两倍速运行。<br>你可以通过在 C 中调用 lua_gc 或是在 Lua 中调用 collectgarbage 来改变这些数字。 两者都接受百分比数值（因此传入参数 100 意味着实际值 1 ）。 通过这些函数，你也可以直接控制收集器（例如，停止或是重启）。</p>
<h3 id="2-10-1-垃圾收集的元方法"><a href="#2-10-1-垃圾收集的元方法" class="headerlink" title="2.10.1 - 垃圾收集的元方法"></a>2.10.1 - 垃圾收集的元方法</h3><p>使用 C API　， 你可以给 userdata （参见 §2.8）设置一个垃圾收集的元方法。 这个元方法也被称为结束子。 结束子允许你用额外的资源管理器和 Lua 的内存管理器协同工作 （比如关闭文件、网络连接、或是数据库连接，也可以说释放你自己的内存）。<br>一个 userdata 可被回收，若它的 metatable 中有 __gc 这个域　， 垃圾收集器就不立即收回它。 取而代之的是，Lua 把它们放到一个列表中。 最收集结束后，Lua 针对列表中的每个 userdata 执行了下面这个函数的等价操作：</p>
<pre><code>function gc_event (udata)
    local h = metatable(udata).__gc
    if h then
        h(udata)
    end
end
</code></pre><p>在每个垃圾收集周期的结尾，每个在当前周期被收集起来的 userdata 的结束子会以 它们构造时的逆序依次调用。 也就是说，收集列表中，最后一个在程序中被创建的 userdata 的 结束子会被第一个调用。</p>
<p>2.10.2 - Weak Table（弱表）<br>weak table 是一个这样的 table，它其中的元素都被弱引用。 弱引用将被垃圾收集器忽略掉， 换句话说， 如果对一个对象的引用只有弱引用， 垃圾收集器将回收这个对象。</p>
<p>weak table 的键和值都可以是 weak 的。 如果一个 table 只有键是 weak 的，那么将运行收集器回收它们的键， 但是会阻止回收器回收对应的值。 而一个 table 的键和值都是 weak 时，就即允许收集器回收键又允许收回值。 任何情况下，如果键和值中任一个被回收了，整个键值对就会从 table 中拿掉。 table 的 weak 特性可以通过在它的 metatable 中设置 <strong>mode 域来改变。 如果 </strong>mode 域中是一个包含有字符 ‘k’ 的字符串时， table 的键就是 weak 的。 如果 __mode 域中是一个包含有字符 ‘v’ 的字符串时， table 的值就是 weak 的。</p>
<p>在你把一个 table 当作一个 metatable 使用之后， 就不能再修改 __mode 域的值。 否则，受这个 metatable 控制的 table 的 weak 行为就成了未定义的。</p>
<p>2.11 - Coroutine （协同例程）<br>Lua 支持 coroutine ，这个东西也被称为协同式多线程 (collaborative multithreading)　。 Lua 为每个 coroutine 提供一个独立的运行线路。 然而和多线程系统中的线程不同，coroutine 只在显式的调用了 yield 函数时才会挂起。</p>
<p>创建一个 coroutine 需要调用一次 coroutine.create 。 它只接收单个参数，这个参数是 coroutine 的主函数。 create 函数仅仅创建一个新的 coroutine 然后返回它的控制器 （一个类型为 thread 的对象）； 它并不会启动 coroutine 的运行。</p>
<p>当你第一次调用 coroutine.resume 时， 所需传入的第一个参数就是 coroutine.create 的返回值。 这时，coroutine 从主函数的第一行开始运行。 接下来传入 coroutine.resume 的参数将被传进 coroutine 的主函数。 在 coroutine 开始运行后，它讲运行到自身终止或是遇到一个 yields 。</p>
<p>coroutine 可以通过两种方式来终止运行： 一种是正常退出，指它的主函数返回（最后一条指令被运行后，无论有没有显式的返回指令）; 另一种是非正常退出，它发生在未保护的错误发生的时候。 第一种情况中， coroutine.resume 返回 true ， 接下来会跟着 coroutine 主函数的一系列返回值。 第二种发生错误的情况下， coroutine.resume 返回 false ， 紧接着是一条错误信息。</p>
<p>coroutine 中切换出去，可以调用 coroutine.yield。 当 coroutine 切出，与之配合的 coroutine.resume 就立即返回， 甚至在 yield 发生在内层的函数调用中也可以（就是说， 这不限于发生在主函数中，也可以是主函数直接或间接调用的某个函数里）。 在 yield 的情况下，coroutine.resume 也是返回 true， 紧跟着那些被传入 coroutine.yield 的参数。 等到下次你在继续同样的 coroutine ，将从调用 yield 的断点处运行下去。 断点处 yield 的返回值将是 coroutine.resume 传入的参数。</p>
<p>类似 coroutine.create ， coroutine.wrap 这个函数也将创建一个 coroutine ， 但是它并不返回 coroutine 本身，而是返回一个函数取而代之。一旦你调用这个返回函数，就会切入 coroutine 运行。 所有传入这个函数的参数等同于传入 coroutine.resume 的参数。 coroutine.wrap 会返回所有应该由除第一个（错误代码的那个布尔量） 之外的由 coroutine.resume 返回的值。 和 coroutine.resume 不同， coroutine.wrap 不捕获任何错误； 所有的错误都应该由调用者自己传递。</p>
<p>看下面这段代码展示的一个例子：</p>
<pre><code> function foo (a)
   print(&quot;foo&quot;, a)
   return coroutine.yield(2*a)
 end

 co = coroutine.create(function (a,b)
       print(&quot;co-body&quot;, a, b)
       local r = foo(a+1)
       print(&quot;co-body&quot;, r)
       local r, s = coroutine.yield(a+b, a-b)
       print(&quot;co-body&quot;, r, s)
       return b, &quot;end&quot;
 end)

 print(&quot;main&quot;, coroutine.resume(co, 1, 10))
 print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;))
 print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;))
 print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;))
</code></pre><p>当你运行它，将得到如下输出结果：</p>
<pre><code> co-body 1       10
 foo     2

 main    true    4
 co-body r
 main    true    11      -9
 co-body x       y
 main    true    10      end
 main    false   cannot resume dead coroutine
</code></pre><p>3 - 程序接口（API）<br>这个部分描述了 Lua 的 C API ， 也就是宿主程序跟 Lua 通讯用的一组 C 函数。 所有的 API 函数按相关的类型以及常量都声明在头文件 lua.h 中。</p>
<p>虽然我们说的是“函数”，但一部分简单的 API 是以宏的形式提供的。 所有的这些宏都只使用它们的参数一次 （除了第一个参数，也就是 lua 状态机）， 因此你不需担心这些宏的展开会引起一些副作用。</p>
<p>在所有的 C 库中，Lua API 函数都不去检查参数的有效性和坚固性。 然而，你可以在编译 Lua 时加上打开一个宏开关来 开启 luaconf.h 文件中的宏 luai_apicheck 以改变这个行为。</p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>Lua 使用一个虚拟栈来和 C 传递值。 栈上的的每个元素都是一个 Lua 值 （nil，数字，字符串，等等）。</p>
<p>无论何时 Lua 调用 C，被调用的函数都得到一个新的栈， 这个栈独立于 C 函数本身的堆栈，也独立于以前的栈。 （译注：在 C 函数里，用 Lua API 不能访问到 Lua 状态机中本次调用之外的堆栈中的数据） 它里面包含了 Lua 传递给 C 函数的所有参数， 而 C 函数则把要返回的结果也放入堆栈以返回给调用者 （参见 lua_CFunction）。</p>
<p>方便起见，所有针对栈的 API 查询操作都不严格遵循栈的操作规则。 而是可以用一个索引来指向栈上的任何元素： 正的索引指的是栈上的绝对位置（从一开始）； 负的索引则指从栈顶开始的偏移量。 更详细的说明一下，如果堆栈有 n 个元素， 那么索引 1 表示第一个元素（也就是最先被压入堆栈的元素） 而索引 n 则指最后一个元素； 索引 -1 也是指最后一个元素（即栈顶的元素）， 索引 -n 是指第一个元素。 如果索引在 1 到栈顶之间（也就是，1 ≤ abs(index) ≤ top） 我们就说这是个有效的索引。</p>
<h3 id="堆栈尺寸"><a href="#堆栈尺寸" class="headerlink" title="堆栈尺寸"></a>堆栈尺寸</h3><p>当你使用 Lua API 时，就有责任保证其坚固性。 特别需要注意的是，你有责任控制不要堆栈溢出。你可以使用 lua_checkstack 这个函数来扩大可用堆栈的尺寸。<br>无论何时 Lua 调用 C ， 它都只保证 LUA_MINSTACK 这么多的堆栈空间可以使用。 LUA_MINSTACK 一般被定义为 20　，因此，只要你不是不断的把数据压栈，通常你不用关心堆栈大小。<br>所有的查询函数都可以接收一个索引，只要这个索引是任何栈提供的空间中的值。 栈能提供的最大空间是通过 lua_checkstack 来设置的。 这些索引被称作可接受的索引，通常我们把它定义为：</p>
<pre><code> (index &lt; 0 &amp;&amp; abs(index) &lt;= top) || (index &gt; 0 &amp;&amp; index &lt;= stackspace)
</code></pre><p>注意，0 永远都不是一个可接受的索引。（译注：下文中凡提到的索引，没有特别注明的话，都指可接受的索引。）</p>
<h3 id="LUA-GLOBALSINDEX"><a href="#LUA-GLOBALSINDEX" class="headerlink" title="LUA_GLOBALSINDEX"></a>LUA_GLOBALSINDEX</h3><p>除了特别声明外，任何一个函数都可以接受另一种有效的索引，它们被称作“伪索引”。 这个可以帮助 C 代码访问一些并不在栈上的 Lua 值。 伪索引被用来访问线程的环境，函数的环境，注册表，还有 C 函数的 upvalue。<br>线程的环境（也就是全局变量放的地方）通常在伪索引 LUA_GLOBALSINDEX 处。 正在运行的 C 函数的环境则放在伪索引 LUA_ENVIRONINDEX 之处。<br>可以用常规的 table 操作来访问和改变全局变量的值，只需要指定环境表的位置。 举例而言，要访问全局变量的值，这样做：</p>
<pre><code>lua_getfield(L, LUA_GLOBALSINDEX, varname);
</code></pre><h3 id="C-Closure"><a href="#C-Closure" class="headerlink" title="C Closure"></a>C Closure</h3><p>当C函数被创建出来，我们有可能会把一些值关联在一起， 也就是创建一个Cclosure； 这些被关联起来的值被叫做upvalue ，它们可以在函数被调用的时候访问的到。（参见lua_pushcclosure）。<br>无论何时去调用C函数，函数的upvalue都被放在指定的伪索引处。我们可以用<code>lua_upvalueindex</code>这个宏来生成这些伪索引。第一个关联到函数的值放在<code>lua_upvalueindex(1)</code>位置处，依次类推。任何情况下都可以用<code>lua_upvalueindex(n)</code>产生一个upvalue的索引，即使n大于实际的upvalue数量也可以。它都可以产生一个可接受但不一定有效的索引。</p>
<h3 id="LUA-REGISTRYINDEX"><a href="#LUA-REGISTRYINDEX" class="headerlink" title="LUA_REGISTRYINDEX"></a>LUA_REGISTRYINDEX</h3><p>Lua提供了一个注册表，这是一个预定义出来的表，可以用来保存任何C代码想保存的Lua值。这个表可以用伪索引<code>LUA_REGISTRYINDEX</code>来定位。 任何C库都可以在这张表里保存数据，为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名，或者可以取你自己C代码中的一个地址，以 light userdata 的形式做键。<br>注册表里的整数健被用于补充库中实现的引用系统的工作，一般说来不要把它们用于别的用途。</p>
<h3 id="C-中的错误处理"><a href="#C-中的错误处理" class="headerlink" title="C 中的错误处理"></a>C 中的错误处理</h3><p>在内部实现中，Lua 使用了 C 的 longjmp 机制来处理错误。 （如果你使用 C++ 的话，也可以选择换用异常；参见 luaconf.h 文件。） 当 Lua 碰到任何错误（比如内存分配错误、类型错误、语法错误、还有一些运行时错误） 它都会产生一个错误出去； 也就是调用一个 long jump 。 在保护环境下，Lua 使用 setjmp 来设置一个恢复点； 任何发生的错误都会激活最近的一个恢复点。<br>几乎所有的 API 函数都可能产生错误，例如内存分配错误。 但下面的一些函数运行在保护环境中（也就是说它们创建了一个保护环境再在其中运行）， 因此它们不会产生错误出来： lua_newstate, lua_close, lua_load, lua_pcall, and lua_cpcall。</p>
<p>在 C 函数里，你也可以通过调用 lua_error 产生一个错误。</p>
<h3 id="lua-Alloc"><a href="#lua-Alloc" class="headerlink" title="lua_Alloc"></a>lua_Alloc</h3><pre><code>typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
</code></pre><p>Lua 状态机中使用的内存分配器函数的类型。 内存分配函数必须提供一个功能类似于 realloc 但又不完全相同的函数。 它的参数有 ud ，一个由 lua_newstate 传给它的指针； ptr ，一个指向已分配出来或是将被重新分配或是要释放的内存块指针； osize ，内存块原来的尺寸； nsize ，新内存块的尺寸。 如果且只有 osize 是零时，ptr 为 NULL 。 当 nsize 是零，分配器必须返回 NULL； 如果 osize 不是零，分配器应当释放掉 ptr 指向的内存块。 当 nsize 不是零，若分配器不能满足请求时，分配器返回 NULL 。 当 nsize 不是零而 osize 是零时，分配器应该和 malloc 有相同的行为。 当 nsize 和 osize 都不是零时，分配器则应和 realloc 保持一样的行为。 Lua 假设分配器在 osize &gt;= nsize 时永远不会失败。</p>
<p>这里有一个简单的分配器函数的实现。 这个实现被放在补充库中，由 luaL_newstate 提供。</p>
<pre><code>static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) 
{
    (void)ud;  
    (void)osize;  /* not used */
    if (nsize == 0) 
    {
        free(ptr);
        return NULL;
    }
    else
        return realloc(ptr, nsize);
}
</code></pre><p>这段代码假设 free(NULL) 啥也不影响，而且 realloc(NULL, size) 等价于 malloc(size)。 这两点是 ANSI C 保证的行为。</p>
<h3 id="lua-atpanic"><a href="#lua-atpanic" class="headerlink" title="lua_atpanic"></a>lua_atpanic</h3><pre><code>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
</code></pre><p>设置一个新的 panic （恐慌） 函数，并返回前一个。<br>如果在保护环境之外发生了任何错误， Lua 就会调用一个 panic 函数，接着调用 exit(EXIT_FAILURE)， 这样就开始退出宿主程序。 你的 panic 函数可以永远不返回（例如作一次长跳转）来避免程序退出。<br>panic 函数可以从栈顶取到出错信息。</p>
<h3 id="lua-call"><a href="#lua-call" class="headerlink" title="lua_call"></a>lua_call</h3><pre><code>void lua_call(lua_State *L, int nargs, int nresults);
</code></pre><p>调用一个函数。要调用一个函数请遵循以下协议：首先，要调用的函数应该被压入堆栈；接着，把需要传递给这个函数的参数按正序压栈；这是指第一个参数首先压栈。 最后调用一下<code>lua_call</code>；nargs是你压入堆栈的参数个数。当函数调用完毕后，所有的参数以及函数本身都会出栈。而函数的返回值这时则被压入堆栈。返回值的个数将被调整为nresults个， 除非 nresults 被设置成 LUA_MULTRET。 在这种情况下，所有的返回值都被压入堆栈中。 Lua 会保证返回值都放入栈空间中。 函数返回值将按正序压栈（第一个返回值首先压栈）， 因此在调用结束后，最后一个返回值将被放在栈顶。<br>被调用函数内发生的错误将（通过 longjmp）一直上抛。<br>下面的例子中，这行 Lua 代码等价于在宿主程序用 C 代码做一些工作：</p>
<pre><code> a = f(&quot;how&quot;, t.x, 14)
</code></pre><p>这里是 C 里的代码：</p>
<pre><code> lua_getfield(L, LUA_GLOBALSINDEX, &quot;f&quot;);          /* 将调用的函数 */
 lua_pushstring(L, &quot;how&quot;);                          /* 第一个参数 */
 lua_getfield(L, LUA_GLOBALSINDEX, &quot;t&quot;);          /* table 的索引 */
 lua_getfield(L, -1, &quot;x&quot;);         /* 压入 t.x 的值（第 2 个参数）*/
 lua_remove(L, -2);                           /* 从堆栈中移去 &#39;t&#39; */
 lua_pushinteger(L, 14);                           /* 第 3 个参数 */
 lua_call(L, 3, 1); /* 调用 &#39;f&#39;，传入 3 个参数，并索取 1 个返回值 */
 lua_setfield(L, LUA_GLOBALSINDEX, &quot;a&quot;);      /* 设置全局变量 &#39;a&#39; */
</code></pre><p>注意上面这段代码是“平衡”的： 到了最后，堆栈恢复成原由的配置。 </p>
<h3 id="lua-CFunction"><a href="#lua-CFunction" class="headerlink" title="lua_CFunction"></a>lua_CFunction</h3><pre><code>typedef int (*lua_CFunction) (lua_State *L);
</code></pre><p>C 函数的类型。<br>为了正确的和 Lua 通讯，C 函数必须使用下列 定义了参数以及返回值传递方法的协议： C 函数通过 Lua 中的堆栈来接受参数，参数以正序入栈（第一个参数首先入栈）。 因此，当函数开始的时候， lua_gettop(L) 可以返回函数收到的参数个数。 第一个参数（如果有的话）在索引 1 的地方，而最后一个参数在索引 lua_gettop(L) 处。 当需要向 Lua 返回值的时候，C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入）， 然后返回这些返回值的个数。 在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。 和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。</p>
<p>下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和：</p>
<pre><code> static int foo (lua_State *L) {
   int n = lua_gettop(L);    /* 参数的个数 */
   lua_Number sum = 0;
   int i;
   for (i = 1; i &lt;= n; i++) {
     if (!lua_isnumber(L, i)) {
       lua_pushstring(L, &quot;incorrect argument&quot;);
       lua_error(L);
     }
     sum += lua_tonumber(L, i);
   }
   lua_pushnumber(L, sum/n);   /* 第一个返回值 */
   lua_pushnumber(L, sum);     /* 第二个返回值 */
   return 2;                   /* 返回值的个数 */
 }
</code></pre><h3 id="lua-checkstack"><a href="#lua-checkstack" class="headerlink" title="lua_checkstack"></a>lua_checkstack</h3><pre><code>int lua_checkstack (lua_State *L, int extra);
</code></pre><p>确保堆栈上至少有 extra 个空位。 如果不能把堆栈扩展到相应的尺寸，函数返回 false 。 这个函数永远不会缩小堆栈； 如果堆栈已经比需要的大了，那么就放在那里不会产生变化。</p>
<h3 id="lua-close"><a href="#lua-close" class="headerlink" title="lua_close"></a>lua_close</h3><pre><code>void lua_close (lua_State *L);
</code></pre><p>销毁指定 Lua 状态机中的所有对象（如果有垃圾收集相关的元方法的话，会调用它们），并且释放状态机中使用的所有动态内存。 在一些平台上，你可以不必调用这个函数， 因为当宿主程序结束的时候，所有的资源就自然被释放掉了。 另一方面，长期运行的程序，比如一个后台程序或是一个 web 服务器， 当不再需要它们的时候就应该释放掉相关状态机。这样可以避免状态机扩张的过大。</p>
<h3 id="lua-concat"><a href="#lua-concat" class="headerlink" title="lua_concat"></a>lua_concat</h3><pre><code>void lua_concat (lua_State *L, int n);
</code></pre><p>连接栈顶的 n 个值， 然后将这些值出栈，并把结果放在栈顶。如果 n 为 1 ，结果就是一个字符串放在栈上（即，函数什么都不做）； 如果 n 为 0 ，结果是一个空串。 连接依照 Lua 中创建语义完成（参见 §2.5.4 ）。</p>
<h3 id="lua-cpcall"><a href="#lua-cpcall" class="headerlink" title="lua_cpcall"></a>lua_cpcall</h3><pre><code>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
</code></pre><p>以保护模式调用 C 函数 func 。 func 只有能从堆栈上拿到一个参数，就是包含有 ud 的 light userdata。 当有错误时， lua_cpcall 返回和 lua_pcall 相同的错误代码， 并在栈顶留下错误对象； 否则它返回零，并不会修改堆栈。 所有从 func 内返回的值都会被扔掉。</p>
<h3 id="lua-createtable"><a href="#lua-createtable" class="headerlink" title="lua_createtable"></a>lua_createtable</h3><pre><code>void lua_createtable (lua_State *L, int narr, int nrec);
</code></pre><p>创建一个新的空 table 压入堆栈。 这个新 table 将被预分配 narr 个元素的数组空间 以及 nrec 个元素的非数组空间。 当你明确知道表中需要多少个元素时，预分配就非常有用。 如果你不知道，可以使用函数 lua_newtable。</p>
<h3 id="lua-dump"><a href="#lua-dump" class="headerlink" title="lua_dump"></a>lua_dump</h3><pre><code>int lua_dump (lua_State *L, lua_Writer writer, void *data);
</code></pre><p>把函数 dump 成二进制 chunk 。 函数接收栈顶的 Lua 函数做参数，然后生成它的二进制 chunk 。 若被 dump 出来的东西被再次加载，加载的结果就相当于原来的函数。 当它在产生 chunk 的时候，lua_dump 通过调用函数 writer （参见 lua_Writer） 来写入数据，后面的 data 参数会被传入 writer 。<br>最后一次由写入器 (writer) 返回值将作为这个函数的返回值返回； 0 表示没有错误。</p>
<p>这个函数不会把 Lua 返回弹出堆栈。</p>
<h3 id="lua-equal"><a href="#lua-equal" class="headerlink" title="lua_equal"></a>lua_equal</h3><pre><code>int lua_equal (lua_State *L, int index1, int index2);
</code></pre><p>如果依照 Lua 中 == 操作符语义，索引 index1 和 index2 中的值相同的话，返回 1 。 否则返回 0 。 如果任何一个索引无效也会返回 0。</p>
<h3 id="lua-error"><a href="#lua-error" class="headerlink" title="lua_error"></a>lua_error</h3><pre><code>int lua_error (lua_State *L);
</code></pre><p>产生一个 Lua 错误。 错误信息（实际上可以是任何类型的 Lua 值）必须被置入栈顶。 这个函数会做一次长跳转，因此它不会再返回。 （参见 luaL_error）。</p>
<h3 id="lua-gc"><a href="#lua-gc" class="headerlink" title="lua_gc"></a>lua_gc</h3><pre><code>int lua_gc (lua_State *L, int what, int data);
</code></pre><p>控制垃圾收集器。<br>这个函数根据其参数 what 发起几种不同的任务：</p>
<p>LUA_GCSTOP: 停止垃圾收集器。<br>LUA_GCRESTART: 重启垃圾收集器。<br>LUA_GCCOLLECT: 发起一次完整的垃圾收集循环。<br>LUA_GCCOUNT: 返回 Lua 使用的内存总量（以 K 字节为单位）。<br>LUA_GCCOUNTB: 返回当前内存使用量除以 1024 的余数。<br>LUA_GCSTEP: 发起一步增量垃圾收集。 步数由 data 控制（越大的值意味着越多步）， 而其具体含义（具体数字表示了多少）并未标准化。 如果你想控制这个步数，必须实验性的测试 data 的值。 如果这一步结束了一个垃圾收集周期，返回返回 1 。<br>LUA_GCSETPAUSE: 把 data/100 设置为 garbage-collector pause 的新值（参见 §2.10）。 函数返回以前的值。<br>LUA_GCSETSTEPMUL: 把 arg/100 设置成 step multiplier （参见 §2.10）。 函数返回以前的值。</p>
<h3 id="lua-getallocf"><a href="#lua-getallocf" class="headerlink" title="lua_getallocf"></a>lua_getallocf</h3><pre><code>lua_Alloc lua_getallocf (lua_State *L, void **ud);
</code></pre><p>返回给定状态机的内存分配器函数。 如果 ud 不是 NULL ，Lua 把调用 lua_newstate 时传入的那个指针放入 *ud 。</p>
<h3 id="lua-getfenv"><a href="#lua-getfenv" class="headerlink" title="lua_getfenv"></a>lua_getfenv</h3><pre><code>void lua_getfenv (lua_State *L, int index);
</code></pre><p>把索引处值的环境表压入堆栈。</p>
<h3 id="lua-getfield"><a href="#lua-getfield" class="headerlink" title="lua_getfield"></a>lua_getfield</h3><pre><code>void lua_getfield(lua_State *L, int index, const char *k);
</code></pre><p>把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法。</p>
<h3 id="lua-getglobal"><a href="#lua-getglobal" class="headerlink" title="lua_getglobal"></a>lua_getglobal</h3><pre><code>void lua_getglobal(lua_State *L, const char *name);
</code></pre><p>把全局变量name里的值压入堆栈。 这个是用一个宏定义出来的：</p>
<pre><code> #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
</code></pre><h3 id="lua-getmetatable"><a href="#lua-getmetatable" class="headerlink" title="lua_getmetatable"></a>lua_getmetatable</h3><pre><code>int lua_getmetatable (lua_State *L, int index);
</code></pre><p>把给定索引指向的值的元表压入堆栈。 如果索引无效，或是这个值没有元表， 函数将返回 0 并且不会向栈上压任何东西。</p>
<h3 id="lua-gettable"><a href="#lua-gettable" class="headerlink" title="lua_gettable"></a>lua_gettable</h3><pre><code>void lua_gettable (lua_State *L, int index);
</code></pre><p>把t[k] 值压入堆栈， 这里的t是指有效索引 index 指向的值， 而 k 则是栈顶放的值。<br>这个函数会弹出堆栈上的 key （把结果放在栈上相同位置）。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法。</p>
<h3 id="lua-gettop"><a href="#lua-gettop" class="headerlink" title="lua_gettop"></a>lua_gettop</h3><pre><code>int lua_gettop(lua_State *L);
</code></pre><p>返回栈顶元素的索引。 因为索引是从 1 开始编号的， 所以这个结果等于堆栈上的元素个数（因此返回 0 表示堆栈为空）。</p>
<h3 id="lua-insert"><a href="#lua-insert" class="headerlink" title="lua_insert"></a>lua_insert</h3><pre><code>void lua_insert (lua_State *L, int index);
</code></pre><p>把栈顶元素插入指定的有效索引处， 并依次移动这个索引之上的元素。 不要用伪索引来调用这个函数，因为伪索引不是真正指向堆栈上的位置。</p>
<h3 id="lua-Integer"><a href="#lua-Integer" class="headerlink" title="lua_Integer"></a>lua_Integer</h3><pre><code>typedef ptrdiff_t lua_Integer;
</code></pre><p>这个类型被用于 Lua API 接收整数值。<br>缺省时这个被定义为 ptrdiff_t ， 这个东西通常是机器能处理的最大整数类型。</p>
<h3 id="lua-isboolean"><a href="#lua-isboolean" class="headerlink" title="lua_isboolean"></a>lua_isboolean</h3><pre><code>int lua_isboolean (lua_State *L, int index);
</code></pre><p>当给定索引的值类型为 boolean 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-iscfunction"><a href="#lua-iscfunction" class="headerlink" title="lua_iscfunction"></a>lua_iscfunction</h3><pre><code>int lua_iscfunction (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 C 函数时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isfunction"><a href="#lua-isfunction" class="headerlink" title="lua_isfunction"></a>lua_isfunction</h3><pre><code>int lua_isfunction (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个函数（ C 或 Lua 函数均可）时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-islightuserdata"><a href="#lua-islightuserdata" class="headerlink" title="lua_islightuserdata"></a>lua_islightuserdata</h3><pre><code>int lua_islightuserdata (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 light userdata 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isnil"><a href="#lua-isnil" class="headerlink" title="lua_isnil"></a>lua_isnil</h3><pre><code>int lua_isnil (lua_State *L, int index);
</code></pre><p>当给定索引的值是 nil 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isnumber"><a href="#lua-isnumber" class="headerlink" title="lua_isnumber"></a>lua_isnumber</h3><pre><code>int lua_isnumber (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个数字，或是一个可转换为数字的字符串时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isstring"><a href="#lua-isstring" class="headerlink" title="lua_isstring"></a>lua_isstring</h3><pre><code>int lua_isstring (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个字符串或是一个数字（数字总能转换成字符串）时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-istable"><a href="#lua-istable" class="headerlink" title="lua_istable"></a>lua_istable</h3><pre><code>int lua_istable (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 table 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isthread"><a href="#lua-isthread" class="headerlink" title="lua_isthread"></a>lua_isthread</h3><pre><code>int lua_isthread (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 thread 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isuserdata"><a href="#lua-isuserdata" class="headerlink" title="lua_isuserdata"></a>lua_isuserdata</h3><pre><code>int lua_isuserdata (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 userdata （无论是完整的 userdata 还是 light userdata ）时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-lessthan"><a href="#lua-lessthan" class="headerlink" title="lua_lessthan"></a>lua_lessthan</h3><pre><code>int lua_lessthan (lua_State *L, int index1, int index2);
</code></pre><p>如果索引 index1 处的值小于 索引 index2 处的值时，返回 1 ； 否则返回 0 。 其语义遵循 Lua 中的 &lt; 操作符（就是说，有可能调用元方法）。 如果任何一个索引无效，也会返回 0 。</p>
<h3 id="lua-load"><a href="#lua-load" class="headerlink" title="lua_load"></a>lua_load</h3><pre><code>int lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname);
</code></pre><p>加载一个 Lua chunk 。 如果没有错误， lua_load 把一个编译好的 chunk 作为一个 Lua 函数压入堆栈。 否则，压入出错信息。 lua_load 的返回值可以是：</p>
<p>0: 没有错误；<br>LUA_ERRSYNTAX: 在预编译时碰到语法错误；<br>LUA_ERRMEM: 内存分配错误。<br>这个函数仅仅加栽 chunk ；而不会去运行它。</p>
<p>lua_load 会自动检测 chunk 是文本的还是二进制的， 然后做对应的加载操作（参见程序 luac）。<br>lua_load 函数使用一个用户提供的 reader 函数来 读取 chunk （参见 lua_Reader）。 data 参数会被传入读取器函数。<br>chunkname 这个参数可以赋予 chunk 一个名字， 这个名字被用于出错信息和调试信息。</p>
<h3 id="lua-newstate"><a href="#lua-newstate" class="headerlink" title="lua_newstate"></a>lua_newstate</h3><pre><code>lua_State *lua_newstate (lua_Alloc f, void *ud);
</code></pre><p>创建的一个新的独立的状态机。 如果创建不了（因为内存问题）返回 NULL 。 参数 f 是一个分配器函数； Lua 将通过这个函数做状态机内所有的内存分配操作。 第二个参数 ud ，这个指针将在每次调用分配器时被直接传入。</p>
<h3 id="lua-newtable"><a href="#lua-newtable" class="headerlink" title="lua_newtable"></a>lua_newtable</h3><pre><code>void lua_newtable (lua_State *L);
</code></pre><p>创建一个空table，并将之压入堆栈。它等价于<code>lua_createtable(L, 0, 0)</code>。</p>
<h3 id="lua-pushglobaltable"><a href="#lua-pushglobaltable" class="headerlink" title="lua_pushglobaltable"></a>lua_pushglobaltable</h3><p>[-0, +1, –]</p>
<pre><code>void lua_pushglobaltable (lua_State *L);
</code></pre><p>Pushes the global environment onto the stack. </p>
<h3 id="lua-newthread"><a href="#lua-newthread" class="headerlink" title="lua_newthread"></a>lua_newthread</h3><pre><code>lua_State *lua_newthread (lua_State *L);
</code></pre><p>创建一个新线程，并将其压入堆栈， 并返回维护这个线程的 lua_State 指针。 这个函数返回的新状态机共享原有状态机中的所有对象（比如一些 table）， 但是它有独立的执行堆栈。<br>没有显式的函数可以用来关闭或销毁掉一个线程。 线程跟其它 Lua 对象一样是垃圾收集的条目之一。</p>
<h3 id="lua-newuserdata"><a href="#lua-newuserdata" class="headerlink" title="lua_newuserdata"></a>lua_newuserdata</h3><pre><code>void *lua_newuserdata (lua_State *L, size_t size);
</code></pre><p>这个函数分配分配一块指定大小的内存块， 把内存块地址作为一个完整的 userdata 压入堆栈，并返回这个地址。<br>userdata 代表 Lua 中的 C 值。 完整的 userdata 代表一块内存。 它是一个对象（就像 table 那样的对象）： 你必须创建它，它有着自己的元表，而且它在被回收时，可以被监测到。 一个完整的 userdata 只和它自己相等（在等于的原生作用下）。<br>当 Lua 通过 gc 元方法回收一个完整的 userdata 时， Lua 调用这个元方法并把 userdata 标记为已终止。 等到这个 userdata 再次被收集的时候，Lua 会释放掉相关的内存。</p>
<h3 id="lua-next"><a href="#lua-next" class="headerlink" title="lua_next"></a>lua_next</h3><pre><code>int lua_next (lua_State *L, int index);
</code></pre><p>从栈上弹出一个 key（键）， 然后把索引指定的表中 key-value（健值）对压入堆栈 （指定 key 后面的下一 (next) 对）。 如果表中以无更多元素， 那么 lua_next 将返回 0 （什么也不压入堆栈）。<br>典型的遍历方法是这样的：</p>
<pre><code>/* table 放在索引 &#39;t&#39; 处 */
lua_pushnil(L);  /* 第一个 key */
while (lua_next(L, t) != 0) {
    /* 用一下 &#39;key&#39; （在索引 -2 处） 和 &#39;value&#39; （在索引 -1 处） */
    printf(&quot;%s - %s\n&quot;,
    lua_typename(L, lua_type(L, -2)),
    lua_typename(L, lua_type(L, -1)));
    /* 移除 &#39;value&#39; ；保留 &#39;key&#39; 做下一次迭代 */
    lua_pop(L, 1);
}
</code></pre><p>在遍历一张表的时候， 不要直接对 key 调用 lua_tolstring ， 除非你知道这个 key 一定是一个字符串。 调用 lua_tolstring 有可能改变给定索引位置的值； 这会对下一次调用 lua_next 造成影响。</p>
<h3 id="lua-Number"><a href="#lua-Number" class="headerlink" title="lua_Number"></a>lua_Number</h3><pre><code>typedef double lua_Number;
</code></pre><p>Lua 中数字的类型。 确省是 double ，但是你可以在 luaconf.h 中修改它。<br>通过修改配置文件你可以改变 Lua 让它操作其它数字类型（例如：float 或是 long ）。</p>
<h3 id="lua-objlen-amp-luaS-rawlen"><a href="#lua-objlen-amp-luaS-rawlen" class="headerlink" title="lua_objlen &amp; luaS_rawlen"></a>lua_objlen &amp; luaS_rawlen</h3><pre><code>size_t lua_objlen (lua_State *L, int index); -- 5.1
size_t lua_rawlen (lua_State *L, int index); -- 5.3
</code></pre><p>返回指定的索引处的值的长度。 对于 string ，那就是字符串的长度； 对于 table ，是取长度操作符 (‘#’) 的结果； 对于 userdata ，就是为其分配的内存块的尺寸； 对于其它值，为 0 。</p>
<h3 id="lua-pcall"><a href="#lua-pcall" class="headerlink" title="lua_pcall"></a>lua_pcall</h3><pre><code>lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
</code></pre><p>以保护模式调用一个函数。<br>nargs 和 nresults 的含义与 lua_call 中的相同。 如果在调用过程中没有发生错误， lua_pcall 的行为和 lua_call 完全一致。 但是，如果有错误发生的话， lua_pcall 会捕获它， 然后把单一的值（错误信息）压入堆栈，然后返回错误码。 同 lua_call 一样， lua_pcall 总是把函数本身和它的参数从栈上移除。<br>如果 errfunc 是 0 ， 返回在栈顶的错误信息就和原始错误信息完全一致。 否则，errfunc 就被当成是错误处理函数在栈上的索引。 （在当前的实现里，这个索引不能是伪索引。） 在发生运行时错误时， 这个函数会被调用而参数就是错误信息。 错误处理函数的返回值将被 lua_pcall 作为出错信息返回在堆栈上。<br>典型的用法中，错误处理函数被用来在出错信息上加上更多的调试信息，比如栈跟踪信息 (stack traceback) 。 这些信息在 lua_pcall 返回后，因为栈已经展开 (unwound) ， 所以收集不到了。<br>lua_pcall 函数在调用成功时返回 0 ， 否则返回以下（定义在 lua.h 中的）错误代码中的一个：</p>
<p>LUA_ERRRUN: 运行时错误。<br>LUA_ERRMEM: 内存分配错误。 对于这种错，Lua 调用不了错误处理函数。<br>LUA_ERRERR: 在运行错误处理函数时发生的错误。</p>
<h3 id="lua-pop"><a href="#lua-pop" class="headerlink" title="lua_pop"></a>lua_pop</h3><pre><code>void lua_pop (lua_State *L, int n);
</code></pre><p>从堆栈中弹出 n 个元素。</p>
<h3 id="lua-pushboolean"><a href="#lua-pushboolean" class="headerlink" title="lua_pushboolean"></a>lua_pushboolean</h3><pre><code>void lua_pushboolean (lua_State *L, int b);
</code></pre><p>把 b 作为一个 boolean 值压入堆栈。</p>
<h3 id="lua-pushcclosure"><a href="#lua-pushcclosure" class="headerlink" title="lua_pushcclosure"></a>lua_pushcclosure</h3><pre><code>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
</code></pre><p>把一个新的<code>C closure</code>压入堆栈。当创建了一个C函数后，你可以给它关联一些值，这样就是在创建一个<code>C closure</code>；接下来无论函数何时被调用，这些值都可以被这个函数访问到。为了将一些值关联到一个C函数上，首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。接下来调用<code>lua_pushcclosure</code>来创建出closure并把这个C函数压到堆栈上。参数n告之函数有多少个值需要关联到函数上。<code>lua_pushcclosure</code>也会把这些值从栈上弹出。</p>
<h3 id="lua-pushcfunction"><a href="#lua-pushcfunction" class="headerlink" title="lua_pushcfunction"></a>lua_pushcfunction</h3><pre><code>void lua_pushcfunction (lua_State *L, lua_CFunction f);
</code></pre><p>将一个 C 函数压入堆栈。 这个函数接收一个 C 函数指针，并将一个类型为 function 的 Lua 值 压入堆栈。当这个栈顶的值被调用时，将触发对应的 C 函数。<br>注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值 （参见 lua_CFunction）。</p>
<p>lua_pushcfunction 是作为一个宏定义出现的：</p>
<pre><code> #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</code></pre><h3 id="lua-pushfstring"><a href="#lua-pushfstring" class="headerlink" title="lua_pushfstring"></a>lua_pushfstring</h3><pre><code>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
</code></pre><p>把一个格式化过的字符串压入堆栈，然后返回这个字符串的指针。 它和 C 函数 sprintf 比较像，不过有一些重要的区别：<br>摸你需要为结果分配空间： 其结果是一个 Lua 字符串，由 Lua 来关心其内存分配 （同时通过垃圾收集来释放内存）。<br>这个转换非常的受限。 不支持 flag ，宽度，或是指定精度。 它只支持下面这些： ‘%%’ （插入一个 ‘%’）， ‘%s’ （插入一个带零终止符的字符串，没有长度限制）， ‘%f’ （插入一个 lua_Number）， ‘%p’ （插入一个指针或是一个十六进制数）， ‘%d’ （插入一个 int)， ‘%c’ （把一个 int 作为一个字符插入）。</p>
<h3 id="lua-pushinteger"><a href="#lua-pushinteger" class="headerlink" title="lua_pushinteger"></a>lua_pushinteger</h3><pre><code>void lua_pushinteger (lua_State *L, lua_Integer n);
</code></pre><p>把 n 作为一个数字压栈。</p>
<h2 id="lua-pushlightuserdata"><a href="#lua-pushlightuserdata" class="headerlink" title="lua_pushlightuserdata"></a>lua_pushlightuserdata</h2><pre><code>void lua_pushlightuserdata (lua_State *L, void *p);
</code></pre><p>把一个 light userdata 压栈。<br>userdata 在 Lua 中表示一个 C 值。 light userdata 表示一个指针。 它是一个像数字一样的值： 你不需要专门创建它，它也没有独立的 metatable ， 而且也不会被收集（因为从来不需要创建）。 只要表示的 C 地址相同，两个 light userdata 就相等。</p>
<h3 id="lua-pushlstring"><a href="#lua-pushlstring" class="headerlink" title="lua_pushlstring"></a>lua_pushlstring</h3><pre><code>void lua_pushlstring (lua_State *L, const char *s, size_t len);
</code></pre><p>把指针 s 指向的长度为 len 的字符串压栈。 Lua 对这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串内可以保存有零字符。</p>
<h3 id="lua-pushnil"><a href="#lua-pushnil" class="headerlink" title="lua_pushnil"></a>lua_pushnil</h3><pre><code>void lua_pushnil (lua_State *L);
</code></pre><p>把一个 nil 压栈。</p>
<h3 id="lua-pushnumber"><a href="#lua-pushnumber" class="headerlink" title="lua_pushnumber"></a>lua_pushnumber</h3><pre><code>void lua_pushnumber (lua_State *L, lua_Number n);
</code></pre><p>把一个数字 n 压栈。</p>
<h3 id="lua-pushstring"><a href="#lua-pushstring" class="headerlink" title="lua_pushstring"></a>lua_pushstring</h3><pre><code>void lua_pushstring (lua_State *L, const char *s);
</code></pre><p>把指针s指向的以零结尾的字符串压栈。 Lua 这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串中不能包含有零字符；第一个碰到的零字符会认为是字符串的结束。</p>
<h3 id="lua-pushthread"><a href="#lua-pushthread" class="headerlink" title="lua_pushthread"></a>lua_pushthread</h3><pre><code>int lua_pushthread (lua_State *L);
</code></pre><p>把 L 中提供的线程压栈。 如果这个线程是当前状态机的主线程的话，返回 1 。</p>
<h3 id="lua-pushvalue"><a href="#lua-pushvalue" class="headerlink" title="lua_pushvalue"></a>lua_pushvalue</h3><pre><code>void lua_pushvalue(lua_State *L, int index);
</code></pre><p>把堆栈上给定有效处索引处的元素作一个拷贝压栈。</p>
<h3 id="lua-pushvfstring"><a href="#lua-pushvfstring" class="headerlink" title="lua_pushvfstring"></a>lua_pushvfstring</h3><pre><code>const char *lua_pushvfstring (lua_State *L, const char *fmt, va_list argp);
</code></pre><p>等价于 lua_pushfstring， 不过是用 va_list 接收参数，而不是用可变数量的实际参数。</p>
<h3 id="lua-rawequal"><a href="#lua-rawequal" class="headerlink" title="lua_rawequal"></a>lua_rawequal</h3><pre><code>int lua_rawequal (lua_State *L, int index1, int index2);
</code></pre><p>如果两个索引 index1 和 index2 处的值简单地相等 （不调用元方法）则返回 1 。 否则返回 0 。 如果任何一个索引无效也返回 0 。</p>
<h3 id="lua-rawget"><a href="#lua-rawget" class="headerlink" title="lua_rawget"></a>lua_rawget</h3><pre><code>void lua_rawget (lua_State *L, int index);
</code></pre><p>类似于 <code>lua_gettable</code>，但是作一次直接访问（不触发元方法）。</p>
<h3 id="lua-rawgeti"><a href="#lua-rawgeti" class="headerlink" title="lua_rawgeti"></a>lua_rawgeti</h3><pre><code>void lua_rawgeti (lua_State *L, int index, int n);
</code></pre><p>把 t[n] 的值压栈， 这里的 t 是指给定索引 index 处的一个值。这是一个直接访问；就是说，它不会触发元方法。</p>
<h3 id="lua-rawset"><a href="#lua-rawset" class="headerlink" title="lua_rawset"></a>lua_rawset</h3><pre><code>void lua_rawset (lua_State *L, int index);
</code></pre><p>类似于 lua_settable ，但是是作一个直接赋值（不触发元方法）。</p>
<h3 id="lua-rawseti"><a href="#lua-rawseti" class="headerlink" title="lua_rawseti"></a>lua_rawseti</h3><pre><code>void lua_rawseti (lua_State *L, int index, int n);
</code></pre><p>等价于<code>t[n] = v</code>，这里的 t 是指给定索引index 处的一个值， 而 v 是栈顶的值。函数将把这个值弹出栈。 赋值操作是直接的；就是说，不会触发元方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/CSharp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/CSharp/" class="post-title-link" itemprop="url">CSharp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 09:46:52" itemprop="dateCreated datePublished" datetime="2018-04-02T09:46:52+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp/" itemprop="url" rel="index"><span itemprop="name">CSharp</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/04/02/CSharp/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/04/02/CSharp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="internal、sealed"><a href="#internal、sealed" class="headerlink" title="internal、sealed"></a>internal、sealed</h1><p><strong>internal</strong>：本应用程序使用，其它进程无法使用</p>
<p><strong>sealed（密封）</strong>：由它修饰的类、方法、属性将不能被继承或是重写。sealed 必须和override一起使用<br>sealed修饰符表示密封用于类时，表示该类<font color="red"><strong>不能被继承</strong></font>，不能和abstract同时使用，<font color="red"><strong>不能被实例化</strong></font>。密封类不能用作基类、也不能继承，而抽象类总是希望被继承的。</p>
<h1 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h1><p>fixed 语句可防止垃圾回收器重新定位可移动的变量。 fixed 语句仅允许存在于不安全的上下文中。 Fixed 还可用于创建固定大小的缓冲区。</p>
<p>fixed 语句将为托管变量设置一个指针，并在该语句的执行过程中“单边锁定”该变量。 如果没有 fixed，指向可移动的托管变量的指针将几乎没有什么用处，因为垃圾回收可能会不可预见地重新定位变量。 C# 编译器只允许将指针分配给 fixed 语句中的托管变量。</p>
<ol>
<li>不支持持多继承，C#类始终继承一个基类（如果未在声明中指定一个基类，则继承自System.Object)</li>
<li>如果对类没有定义显示构造函数，则编译器将提供默认的构造函数，以初始化这些类的成员字段。但是，如果显式添加了构造函数，就可以有效控制整个构造过程。派生类通过使用:base()语法可以显式调用基类的构造函数</li>
<li>override 具有override关键字修饰符的方法是对基类中同名方法的新实现，基类中的同名方法必须声明为virtual或abstract类型。给基类中的方法添加virtual关键字表示可以重写它的实现。new static 和 virtual关键字不能与override访问修饰符同时使用。</li>
<li>virtual 支持多态，不能与static override同时使用</li>
<li>abstract 一个抽象类包含抽象方法和非抽象方法，抽象方法只存放函数原型，不涉及主体代码，override关键字可在派生类中抽象方法，经override声明重写的方法称为重写基类方法，其签名必须与override方法的签名相同。只是不能被实例化，除此以外具有类的其他特性，重要的是抽象类可以包含抽象方法，这是普通类所不能的。抽象方法只能声明于抽象方法中，且不包含任何实现，派生类必须覆盖它们。</li>
<li>interface 包含未实现的方法声明，派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员，接口包含属性，索引器事件</li>
</ol>
<h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><p>索引器允许类或者结构的实例按照于数组相同的方法进行索引取值，索引器与属性类似，不同的是索引器的访问时带参的</p>
<ul>
<li>索引器的索引值(Index)类型不受限制</li>
<li>索引器允许重载</li>
<li>索引器不是一个变量</li>
</ul>
<h2 id="索引器和属性的不同点"><a href="#索引器和属性的不同点" class="headerlink" title="索引器和属性的不同点"></a>索引器和属性的不同点</h2><ul>
<li>属性以名称来标识，索引器以函数形式标识</li>
<li>索引器可以被重载，属性不可以</li>
<li>索引器不能声明为static，属性可以</li>
</ul>
<h1 id="interface、abstract"><a href="#interface、abstract" class="headerlink" title="interface、abstract"></a>interface、abstract</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>abstract</th>
<th>interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>能否实例化</td>
<td>不能</td>
<td>不能</td>
</tr>
</tbody>
</table>
</div>
<h2 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h2><ul>
<li>类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫抽象类，而接口只是一个行为的规范或规定，</li>
<li>接口基本上不具备类型的任何具体特点，它仅仅承诺了能够调用的方法</li>
<li>抽象类比较细，而接口比较简单</li>
</ul>
<h2 id="抽象类和接口的使用"><a href="#抽象类和接口的使用" class="headerlink" title="抽象类和接口的使用"></a>抽象类和接口的使用</h2><ul>
<li>如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本。</li>
<li>抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能</li>
</ul>
<h1 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h1><p>提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在于非托管代码交互时使用的其他方法</p>
<p>命名空间：System.Runtime.InteropServices<br>程序集：mscorlib</p>
<p>AllocHGlobal(int32); // 通过使用指定的字节数，从进程的非托管内存中分配内存<br>SizeOf(Type)返回非托管类型的大小(以字节为单位)</p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PGExt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">PG_GetComponent</span>(<span class="params"><span class="keyword">this</span> List&lt;Component&gt; components</span>) <span class="keyword">where</span> T : Component</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">        <span class="keyword">int</span> c = components.Count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> p = components[i] <span class="keyword">as</span> T;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">object</span>)p != <span class="literal">null</span>) <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这里会有一个this关键字，做什么用？其实这就是扩展方法！这个扩展方法在静态类中声明，定义一个静态方法，其中第一个参数定义可它的扩展类型，PG_GetComponent方法扩展了List类，因为它的第一个参数定义了List类型，为了区分扩展方法和一般的静态方法，扩展方法还需要给第一个参数使用this关键字。</p>
<p>现在就可以使用带List类型的PG_GetComponent方法了：</p>
<pre><code>var mf = cacheComponents.PG_GetComponent&lt;MeshFilter&gt;();
</code></pre><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile关键字指示一个字段可以由多个同时执行的线程修改。声明volatile的字段不受编译器优化的限制。这样可以确保该字段在任何时间呈现的都是最新的值。<br>volatile修饰符通常用于由多个线程访问但不使用lock语句对访问进行序列化的字段。<br>volatile关键字可应用于以下类型的字段：</p>
<ul>
<li>引用类型</li>
<li>指针类型（在不安全的上下文中）。请注意，虽然指针本身可以是可变的，但是它指向的对象不能是可变的。换句话说，无法声明“指向可变对象的指针”。</li>
<li>类型，如sbyte、byte、short、ushort、int、uint、。</li>
<li>引用类型的泛型类型参数。</li>
<li>IntPtr和UIntPtr</li>
</ul>
<h1 id="事件和委托"><a href="#事件和委托" class="headerlink" title="事件和委托"></a>事件和委托</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Print print; <span class="comment">// 去掉event就是一个委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (print == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> Test();</span><br><span class="line">        obj.print += Print1; <span class="comment">// 事件无法使用=</span></span><br><span class="line">        obj.print += Print2; <span class="comment">// 委托会清掉之前的关联</span></span><br><span class="line">        obj.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件实际上是一个特殊的委托实例，不用事件也没有关系。实际上事件只是削弱了委托的功能，event在编辑器角度保护了程序的安全，因为你只能用+=、-=来注册事件了，而不能使用=为事件关联方法。（在委托中还可以使用=来绑定方法，不过=是一种破坏性代码，不管之前是否已经绑定方法，他都会将其清除）</p>
<p>extern:指示方法在外部实现</p>
<h1 id="堆栈和堆-Heap-amp-Stack"><a href="#堆栈和堆-Heap-amp-Stack" class="headerlink" title="堆栈和堆 Heap &amp; Stack"></a>堆栈和堆 Heap &amp; Stack</h1><p>首先堆栈和堆（托管堆）都在进程的虚拟内存中。（在32位处理器上每个进程的虚拟内存为4GB）<br>栈是内存中完全用于存储局部变量或成员（值类型数据）的高效区域，但其大小有限制。<br>托管堆占内存比栈大得多，当访问速度较慢。托管堆只用于分配内存。<br>在创建值类型数据时，在栈上分配内存；<br>当创建引用型类型数据时，在托管堆上分配并返回对象的引用。注意这个对象的引用，像其他局部变量一样也是保存在栈中，该引用指向的值则位于托管堆中。<br>如果创建一个包含值类型的引用类型，比如数组，其元素的值也是存放在托管堆中的某个地方，由使用该实体的变量引用；而值类型存储在使用它们的地方，有几处在使用，就有几个副本存在。<br>对于引用类型，如果在声明变量的时候没有使用new运算符，运行时不会给它分配托管堆的内存空间，而是在栈上给它分配一个包含null的值的引用。对于值类型，运行时会给它分配栈上的空间，并且调用构造函数来初始化对象的状态。</p>
<h2 id="堆栈stack"><a href="#堆栈stack" class="headerlink" title="堆栈stack"></a>堆栈stack</h2><p>堆栈中存储值类型<br>堆栈实际上是向下填充，即由高内存地址指向低内存地址填充。<br>堆栈的工作方式是先分配内存的变量后后释放（先进后出原则）。<br>堆栈的变量是从下向上释放，这样就保证了堆栈中先进后出的规则不与变量的生命周期起冲突<br>堆栈的性能非常高，但是对于所有的变量来说不太灵活，而且变量的生命周期必须嵌套。<br>通常我们希望使用一种方法分配内存来存储数据，并且方法退出后很长一段时间内数据仍然可以使用。此时就要用到堆（托管堆）</p>
<h2 id="堆（托管堆）heap"><a href="#堆（托管堆）heap" class="headerlink" title="堆（托管堆）heap"></a>堆（托管堆）heap</h2><p><font color="blue">堆（托管堆）存储引用类型。</font><br>引用类型共有四种：类类型、接口类型、数组类型和委托类型。<br>所有引用类型变量所引用的对象，其内存都是托管堆中分配的。<br>严格地说，我们常说的“对象变量”其实是类类型的引用变量。但在实际中人们经常将引用类型的变量简称为“对象变量”，用它来指代所有四种类型的引用变量。<br>此堆非彼堆，.NET中的堆由垃圾收集器自动管理。<br>与堆栈不同，堆是从下往上分配，所以自动的空间都在已用空间的上面。<br>比如创建一个对象：</p>
<pre><code>Customer cus;
cus = new Customer();
</code></pre><p>声明一个Customer的引用cus，在堆栈上给这个引用分配存储空间。这仅仅只是一个引用，不是实际的Customer对象！<br>cus占4个字节的空间，包含了存储Customer的引用地址。<br>接着分配堆上的内存以存储Customer对象的实例，假定Customer对象的实例是32字节，为了在堆上找到一个存储Customer对象的存储位置。<br>.NET运行库在堆中搜索第一个从未使用的，32字节的连续块存储Customer对象的实例。<br>然后把分配给Customer对象实例的地址赋给cus变量。</p>
<p>从这个例子中可以看出，建立对象引用的过程比建立值变量的过程复杂，且不能避免性能的降低！<br>实际上就是.NET运行库中保存堆的状态信息，在堆中添加新数据时，堆栈中的引用变量也要更新。性能上损失很多。<br>有种机制在分配变量内存的时候，不会受到堆栈的限制：把一个引用变量的值赋给一个相同类型的变量，那么这两个变量就引用同一个堆中对象。<br>当一个应用变量出作用域时，它会从堆栈中删除。但引用对象的数据仍然保留在堆中，一直到程序结束或者该数据不被任何变量应用时，垃圾收集器会删除它。</p>
<p>装箱转化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Boxing</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 110;</span><br><span class="line">        object obj = i;</span><br><span class="line">        Console.WriteLine(&quot;i=&#123;0&#125;,obj = &#123;1&#125;&quot;,i,obj);</span><br><span class="line">        obj = 330;</span><br><span class="line">        Console.WriteLine(&quot;i = &#123;0&#125;,obj=&#123;1&#125;&quot;,i,obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义整数类型变量的时候，这个变量占用的内存是内存占中分配的，第二句是装箱操作将变量110存放到了内存堆中，而定义object对象类型的变量Obj则在内存栈中，并指向int类型的数值110，而该数值是赋给变量i的数值副本。<br>内存格局通常分为四个区<br>全局数据区：存放全局变量，静态数据，常量<br>代码区：存放所有的程序代码<br>栈区：存放为运行而分配的局部变量，参数，返回数据，返回地址等。</p>
<p>值类型变量和引用类型变量的内存分配模型也不一样。为了理解清楚这个问题，首先先区分两种不同类型的内存区域：线程堆栈（Thread Stack）和托管堆（Managed Heap）。每个正在运行的程序都对应着一个进程（process），在一个进程内部，可以有一个或多个线程（thread），每个线程都拥有一块“自留地”，称为“线程堆栈”，大小为1M，用于保存自身的一些数据，比如函数中定义的局部变量、函数调用的传参值，这部分内存区域的分配与回收不需要人为干涉。</p>
<p><font color="blue">所有值类型的变量都是在线程堆栈中分配的。</font><br>另一块内存区域成为“堆（heap）”，在.NET托管环境下，堆由CLR进行管理，所以又称为“托管堆（managed heap）”。</p>
<p><font color="red">用new关键字创建的类的对象时，分配给对象的内存单元就位于托管堆中。</font><br>在程序中我们可以随意地使用new 关键字创建多个对象，因此，托管堆中的内存资源是可以动态申请并使用的，当然使用完了必须归还。</p>
<p>对象变量的相互赋值不会导致对象自身被复制，其结果是两个对象变量指向同一对象。另外，由于对象变量是一个局部变量，因为，对象变量本身是位于线程堆栈中的。<br>严格区分<strong>对象变量</strong>和<strong>对象变量所引用的对象</strong>，是面向对象编程的关键之一。</p>
<h2 id="托管堆"><a href="#托管堆" class="headerlink" title="托管堆"></a>托管堆</h2><p>.NET框架包含一个托管堆，所有的.NET语言在分配引用类型对象时都要使用它。像值类型这样的轻量级对象始终分配在栈中，但是所有的<strong>类实例</strong>和<strong>数组</strong>都被生成在一个内存池中，这个内存池就是托管堆。</p>
<p>垃圾收集器算法：</p>
<ul>
<li>将所有的托管内存标记为垃圾</li>
<li>寻找正被使用的内存块，并将他们标记为有效</li>
<li>释放所有没有被使用的内存块</li>
<li>整理堆以减少碎片</li>
</ul>
<h2 id="托管堆优化"><a href="#托管堆优化" class="headerlink" title="托管堆优化"></a>托管堆优化</h2><p>看上去很简单，但是垃圾收集器实际采用的步骤和堆管理系统的其它部分并非微不足道，其中尝尝涉及为提高性能而作的优化设计。举例来说，垃圾收集遍历整个内存池具有很高的开销。然而，研究表明大部分的托管堆上分配的对象只有很短的生存期，因此堆被分为三个段，称作generations。新分配的对象被放在generation 0中。这个generation是最先被回收的-在这个generation中最有可能找到不再使用的内存，由于它的尺寸很小（小到足以放进处理器的L2 cache中），因此在它里面的回收将是最快和最高效的。<br>托管堆的另外一种优化操作与locality of reference规则有关。该规则表明，一起分配的对象经常被一起使用。如果对象们在堆中位置很紧凑的话，高速缓存的性能将会得到提高。由于托管堆的天性，对象们总是被分配在连续的地址上，托管堆总是保持紧凑，结果使得对象们始终彼此靠近，永远不会分得很远。这一点与标准提供的非托管代码形成了鲜明的对比，在标准堆中，堆很容易变成碎片，而且一起分配的对象经常分得很远。<br>还有一种优化是与大对象有关的。通常，大对象具有很长的生存期。当一个大对象在.NET托管堆中产生时，它被分配在堆的一个特殊部分中，这部分堆永远不会被整理。因此移动大对象所带来的开销超过了整理这部分堆所能提高的性能。</p>
<h2 id="关于外部资源（External-Resources）的问题"><a href="#关于外部资源（External-Resources）的问题" class="headerlink" title="关于外部资源（External Resources）的问题"></a>关于外部资源（External Resources）的问题</h2><p>垃圾收集器能够有效地管理从托管堆中释放的资源，但是资源回收操作只有在内存紧张而触发一个回收动作时才执行。那么，累时怎样来管理像数据库连接或者窗口句柄这样有限的资源的呢？等待，直到垃圾回收被触发之后在清理数据库连接或者文件句柄并不是一个好方法，这会严重降低系统的性能。<br>所有拥有外部资源的类，在这些资源已经不再用到的时候，都应当执行Close或者Dispose方法。<br>需要清理外部资源的类还应当实现一个终止操作（finalizer）。在C#中，创建终止操作的首选方式是在析构函数中实现，而在Framework层，终止操作的实现则是通过重载System.Object.Finalize方法。以下两种实现终止操作的方法是等效的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~OverdueBookLocator()</span><br><span class="line">&#123;</span><br><span class="line">    Dispose(false);</span><br><span class="line">&#125;</span><br><span class="line">public void Finalize()</span><br><span class="line">&#123;</span><br><span class="line">    base.Finalize();</span><br><span class="line">    Dispose(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C#中，同时在Finalize方法和析构函数实现终止操作将会导致错误的产生。<br>除非你有足够的理由，否则你不应该创建析构函数或者Finalize方法。终止操作会降低系统的性能，并且增加执行期的内存开销。同时，由于终止操作被执行的方式，你并不能保证何时一个终止操作被执行。</p>
<h2 id="内存分配和垃圾回收的细节"><a href="#内存分配和垃圾回收的细节" class="headerlink" title="内存分配和垃圾回收的细节"></a>内存分配和垃圾回收的细节</h2><p>对GC有了一个总体印象之后，让我们来讨论关于托管堆中的分配与回收工作的细节。托管堆看起来与我们已经熟悉的C++编程中的传统的堆一点都不像。在传统的堆中，数据结构习惯于使用大块的空闲内存。在其中查找特定大小的内存块是一件很耗时的工作，尤其是当内存中充满碎片的时候。与此不同，在托管堆中，内存被组成连续的数组，指针总是巡着已经被使用的内存和未被使用的内存之间的边界移动。当内存被分配的时候，指针只是简单地递增—由此而来的一个好处是，分配操作的效率得到了很大的提升。<br>当对象被分配的时候，它们一开始被generation 0中。当generation 0的大小快要达到它的上限的时候，一个只在generation 0中执行的回收操作被触发。由于generation 0的大小很小，因此这将是一个非常快的GC过程。这个GC过程的结果是将generation 0彻底的刷新了一遍。不再使用的对象被释放，正在使用的对象被整理并移入generation 1中。<br>当generation 1的大小随着generation 0中移入的对象数量的增加而接近它的上限的时候，一个回收动作被触发在generation 0和generation 1中执行GC过程。如同在generation 0中一样，不再使用的对象被释放，正在被使用的对象被整理并移入下一个generation中。大部分GC过程的主要目标是generation 0，因为在generation 0中最优可能存在大量的已不再使用的临时对象。对generation 2的回收过程具有很高的开销，并且此过程只有在generation 0和generation 1的GC过程不能释放足够的内存时才会被触发。如果对generation 2的GC过程仍然不能释放足够的内存，那么系统就会抛出OutOfMemoryException异常。<br>带有终止操作的对象的垃圾收集过程要稍微复杂一些。当一个带有终止操作的对象被标记为垃圾时，它并不会被立即释放。相反，它会被放置一个终止队列（finalizetion queue）中，此队列为这个对象建立一个引用，来避免这个对象被回收。后台线程为队列中的每个对象执行它们各自的终止操作，并且将已经执行过终止操作的对象从终止队列中删除。只有那些已经执行过终止操作的对象才会在下一次垃圾回收过程中被内存中删除。这样做的一个后果是，等待被终止的对象有可能在它被清除之前，被移入更高一级的generation中，从而增加它被清除的延迟时间。<br>需要执行终止操作的对象应当事先IDisposable接口，以便程序通过此接口快速执行终止动作。IDisposable接口包含一个Dispose方法。这个方法被用来释放外部资源并抑制终止操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class OverdueBookLocator:IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    ~OverdueBookLocator()</span><br><span class="line">    &#123;</span><br><span class="line">        InternalDispose(false);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">        InternalDispose(true);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void InternalDispose(bool disposing)</span><br><span class="line">    &#123;</span><br><span class="line">        if (disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            GC.SuppressFinalize(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="栈和托管堆"><a href="#栈和托管堆" class="headerlink" title="栈和托管堆"></a>栈和托管堆</h2><p>通用类型系统（CTS）区分两种基本类型：值类型和引用类型。它们之间的根本区别在于它们在内存中的存储方式。.NET使用两种不同的物理内存来存储数据<font color="orange">栈和托管堆</font><br><img src="/2018/04/02/CSharp/1.png"><br>值类型总是内存中占用一个预定义的字节数（例如，int类型占4个字节，而string类型占用的字节数会根据字符串的长度而不同）。当声明一个值类型变量时，会在栈中分配适当大小的内存（除了引用类型的值类型成员外，如类的int字段）。内存中的这个空间用来存储变量所包含的值。.NET维护一个栈指针，它包含栈中下一个可用的内存空间的地址。当一个变量离开作用域时，栈指针指向下移动被释放变量所占用的字节数。所以它仍指向下一个可用地址。<br>引用变量也利用栈，但这时候栈包含的只是对另一个内存位置的引用，而不是实际值。这个位置是托管堆中的一个地址，和栈一样，他也维护一个指针，包含堆中下一个可用的内存地址。但是，堆不是先入后出的，因为对对象的引用可在我们的程序中传递（例如，作为参数传递给方法调用）。堆中的对象不会在程序的一个预定点离开作用域。为了在不适用在堆中分配的内存时将它释放。.NET定期执行垃圾回收器，垃圾垃圾递归检查应用程序中所有对象的引用。引用不再有效的对象使用的内存无法从程序中访问，该内存就可以回收。</p>
<h2 id="类型层次结构"><a href="#类型层次结构" class="headerlink" title="类型层次结构"></a>类型层次结构</h2><p>CTS定义了一种类型层级结构，该结构不仅仅描述了不同预定义类型，还指出了用户定义类型的层次结构的位置。</p>
<img src="/2018/04/02/CSharp/2.png">
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>可以定义除Char以外的所有整数类型，默认类型是int<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="readonly与const"><a href="#readonly与const" class="headerlink" title="readonly与const"></a>readonly与const</h1><p>readonly是运行时常量，程序运行时进行赋值，赋值完之后无法更改，也被称为只读变量。<br>const表示编译时常量，程序编译时将对常量值进行解析，并将所有常量值引用替换为相应值。</p>
<h1 id="using-语句"><a href="#using-语句" class="headerlink" title="using 语句"></a>using 语句</h1><p>提供可确保正确使用IDisposable对象的方便语法。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Font font1 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">byte</span> charset = font1.GdiCharSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>File和Font是访问非托管资源（本例中为文件句柄和设备上下文）的托管类型的示例。有许多其他类别的非托管资源和封装这些资源的类库类型。所有此类型都必须实现IDisposable接口。<br>IDisposable对象的生存期限于单个方法时，应在using语句中声明并实例化它。using语句按照正确的方式调用对象上的Dispose方法，并（在按照前面所示方式使用它时）会导致在调用Dispose时对象自身处于范围之外。在using块中，对象是只读的并且无法进行修改或重新分配。</p>
<p>using语句可确保调用Dispose，即使using块中发生异常也是如此。通过将对象放入try块中，然后调用finally块中的Dispose，可以实现相同的结果；实际上，这就是编译器转换using语句的方式。前面的代码示例在编译时将扩展到以下代码（请注意，使用额外的大括号为对象创建有限范围）；<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Font font1 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span> charset = font1.GdiCharSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (font1 != <span class="literal">null</span>)</span><br><span class="line">            ((IDsiposable)font1).Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可在using语句中声明一个类型的多个实例，如下面的示例中所示：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Font font3 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>), font4 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use font3 and font4.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在实例化资源对象，然后将变量传递到using语句，但这不是最佳做法。在这种情况下，控件退出using块以后，对象保留在作用域中，但是可能没有访问其未托管资源的劝降。换句话说，它不再是完全初始化的。如果尝试在using块外部使用该对象，则可能导致引发异常。因此，通常最好在using语句中实例化该对象并将其范围限制在using块中。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Font font2 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>);</span><br><span class="line"><span class="keyword">using</span> (font2) <span class="comment">// not recommended</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use font2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// font2 is still in scope</span></span><br><span class="line"><span class="comment">// but the method call throws an exception</span></span><br><span class="line"><span class="keyword">float</span> f = font2.GetHeight();</span><br></pre></td></tr></table></figure></p>
<h1 id="HashTable-HashSet和Dictionary的区别"><a href="#HashTable-HashSet和Dictionary的区别" class="headerlink" title="HashTable HashSet和Dictionary的区别"></a>HashTable HashSet和Dictionary的区别</h1><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>哈希表(HashTable)表示键/值对的集合.在.NET Framework中,HashTable是System.Collections命名空间提供的一个容器,用于处理和表现类似key-value的键值对,其中key通常可用来快速查找,同时key是区分大小写;value用于存储对应于key的值.hashtable中key-value键值对均为object类型,所以hashtable可以支持任何类型的keyvalue键值对,任何非null对象都可以用作键值对.<br>在哈希表添加一个key/键值对:HashTableObject.Add(key,);<br>在哈希表中去除某个key/键值对:HashTableObject.Remove(key);<br>从哈希表中移除所有元素:HashtableObject.Clear();<br>判断哈希表是否包含特定键key:HashtableObject.Contains(key);</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet<t>类主要是设计用来做高性能集运算的,例如对两个集合求交集,并集,差集等.集合中包含一组不重复出现且无特性顺序的元素,HashSet拒绝接受重复的对象.<br>HashSet<t>的一些特性如下:</t></t></p>
<ol>
<li>HashSet<t>中的值不能重复且没有顺序</t></li>
<li>HashSet<t>的容量会按需自动添加</t></li>
</ol>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>Dictionary表示键值的集合.<br><code>Dictionary&lt;string,string&gt;</code>是一个泛型<br>他本身有集合的功能有时候可以把它堪称数组<br>它的结构是这样的:<code>Dictionary&lt;[key],[value]&gt;</code><br>它的特点是存入对象是需要与[key]值一一对应的存入该泛型<br>通过某一个一定的<code>[key]</code>去找对应的值</p>
<h2 id="HashTable和Dictionary的区别"><a href="#HashTable和Dictionary的区别" class="headerlink" title="HashTable和Dictionary的区别"></a>HashTable和Dictionary的区别</h2><ol>
<li>HashTable不支持泛型,而Dictionary支持泛型</li>
<li>HashTable的元素属于Object类型,所以在存储或检索值类型时通常发生装箱和拆箱的操作,所以你可能需要进行类型转换的操作,而且对于int,float这些值类型还需要进行装箱等操作,非常耗时.</li>
<li>单线程程序中推荐使用Dictionary,有泛型优势,且读取速度较快,容量利用更充分.多线程程序中推荐使用Hashtable,默认的hashtable允许单线程写入,多线程读取,对hashtable进一步调用<code>synchronized()</code>方法可以获得完全线程安全的类型,而Dictionary非线程安全,必须人为使用lock语句进行保护,效率搭建.</li>
<li>在通过代码测试的时候发现key是整数型Dictionary的效率比hashtable快,如果key是字符串型,Dictionary的效率没有hashtable快.<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IntMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">    Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dictionary.Add(i,i);</span><br><span class="line">        hashtable.Add(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = dictionary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line">    stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">object</span> <span class="keyword">value</span> = hashtable[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StringMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line">    Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dictionary.Add(i.ToString(),<span class="string">"aaa"</span>);</span><br><span class="line">        hashtable.Add(i.ToString(), <span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> vale = dictionary[i.ToString()];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line">    stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">object</span> <span class="keyword">value</span> = hashtable[i.ToString()];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2018/04/02/CSharp/1.jpg">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/xxsy-sence-merge-render/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/xxsy-sence-merge-render/" class="post-title-link" itemprop="url">xxsy-sence-merge-render</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 08:40:36" itemprop="dateCreated datePublished" datetime="2018-04-02T08:40:36+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/04/02/xxsy-sence-merge-render/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/04/02/xxsy-sence-merge-render/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/xxsy-skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/xxsy-skill/" class="post-title-link" itemprop="url">PJ04</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 08:16:24" itemprop="dateCreated datePublished" datetime="2018-04-02T08:16:24+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/04/02/xxsy-skill/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/04/02/xxsy-skill/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="normal-logic"><a href="#normal-logic" class="headerlink" title="normal_logic"></a>normal_logic</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Index</th>
<th>Type</th>
<th>Data1</th>
<th>Data2</th>
<th>Data3</th>
<th>Data4</th>
<th>Data5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>随机移动</td>
</tr>
<tr>
<td>2</td>
<td>固定线路</td>
</tr>
<tr>
<td>3</td>
<td>跟随逻辑</td>
</tr>
<tr>
<td>4</td>
<td>恐惧逻辑</td>
</tr>
<tr>
<td>5</td>
<td>飞行逻辑</td>
</tr>
<tr>
<td>6</td>
</tr>
<tr>
<td>7</td>
</tr>
<tr>
<td>8</td>
<td>怪物闲聊</td>
<td></td>
<td>talk_list.id</td>
<td>起始延迟时间</td>
<td></td>
<td>间隔时间</td>
</tr>
<tr>
<td>9</td>
<td>宠物跟随</td>
</tr>
<tr>
<td>20</td>
<td>怪物边聊边走</td>
</tr>
</tbody>
</table>
</div>
<h1 id="refresh-table"><a href="#refresh-table" class="headerlink" title="refresh_table"></a>refresh_table</h1><div class="table-container">
<table>
<thead>
<tr>
<th>物体id</th>
<th>刷新方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>cha_list.id</td>
<td>0手动1刷一次2死亡复合3条件</td>
</tr>
</tbody>
</table>
</div>
<h1 id="talk-list"><a href="#talk-list" class="headerlink" title="talk_list"></a>talk_list</h1><div class="table-container">
<table>
<thead>
<tr>
<th>事件类型</th>
<th>事件id</th>
</tr>
</thead>
<tbody>
<tr>
<td>4，驾云/瞬移</td>
<td>trans_cmn.id</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/01/opengl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/01/opengl/" class="post-title-link" itemprop="url">OpenGL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-01 11:24:55" itemprop="dateCreated datePublished" datetime="2018-04-01T11:24:55+08:00">2018-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/04/01/opengl/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/04/01/opengl/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>与读者以前听说的可能不同，OpenGL（对其它3D应用程序接口来说也是如此）3D图形编程并不都是关于着色器的。不管是使用C、C++、C#、JavaScript等编程语言的哪一种，客户端都必须完成相当多的工作，来管理这些着色器，以及向它们馈送（feed）几何图形、变换矩阵和其他各种数据。<br>本书的第一部分是真正的数据——3D图形编程教程，从基本原则开始讲述，当然这些都是基于实时3D图形渲染的行业标准OpenGL的。<br>着色器编程非常令人兴奋，但是作者并不打算将本书写成一本着色器编程数据。实际上，如果没有如何管理场景，设置视点、模型和变换矩阵，以及载入纹理等知识，那么即使懂得如何编写优秀的着色器也难有所成……我想读者一定明白我的意思。<br>为了帮助读者上手，本书提供了一个小型的“存储着色器”库，它们能够完成大多数常规任务。读者甚至可能会发现，对于简单3D渲染来说，这些着色器已经能够满足所有需要了。但是，随着知识的增长，读者可能并不会满足于此。在进入第二部分之前，还未读者准备GLSL“快速开始”，因此读者无需等到完成掌握OpenGL应用程序接口就能开始创造性了。</p>
<h2 id="3D图形技术和术语"><a href="#3D图形技术和术语" class="headerlink" title="3D图形技术和术语"></a>3D图形技术和术语</h2><p>本书的每一章都包含一个或多个实例程序用来演示这一章锁讨论的编程技术。尽管本章有意避免了关于编程细节的讨论，但扔提供了一个示例程序向读者演示最低程度上需要熟悉的技术和术语，以帮助读者充分利用本书。本章的示例程序叫做BLOCK，读者可以从随书提供的示例程序集中的“Chapter 1”文件夹中找到它。<br>将数学和图形数据转换到3D空间图像的操作叫做渲染（Rendering）。当这个术语作为动词使用时，指的是计算机创建三维图像时所经历的过程。它也作为名词使用，指的仅仅是最终的图像作品。</p>
<h3 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h3><p>实际绘制或填充每个定点之间的像素形成线段就叫做光栅化（Rasterization）。我们可以通过隐藏表面消除（Hidden Surface Removal）来进一步澄清3D设计意图。<br>视口：把绘图坐标映射到窗口坐标<br>裁剪区域的高度和宽度很少正好与窗口的宽度和高度（以像素为单位）相匹配。因此，坐标系统必须从逻辑笛卡尔坐标映射到物理屏幕像素坐标。这个映射是通过一种叫做视口（ViewPort）的设置来指定的。视口就是窗口内部用于绘制裁剪区域的客户区域。视口简单地把裁剪区域映射到窗口的一个区域。通常，视口被定义为整个窗口，但这并非严格必须的。例如，我们可能只希望在窗口的下半部分进行绘图。在用GPA抓帧的时候会发现，如果更改屏幕分辨率，就是只绘制到了视口或者窗口的一部分。<br><img src="/2018/04/01/opengl/1.jpg"><br>与此形成对照的是，图1.20所示显示了一个与裁剪区域相匹配的视口。我们所看到的的这个窗口仍然是300*200像素。但是，现在可视区域将占据窗口的左下部分。<br>我们可以使用视口来缩小或放大窗口中的图像，也可以通过把视口设置为大于窗口的用户区域，从而只显示裁剪区域的一部分。<br><img src="/2018/04/01/opengl/2.jpg"><br>顶点——空间中的一个位置</p>
<h1 id="核心模式和立即渲染模式"><a href="#核心模式和立即渲染模式" class="headerlink" title="核心模式和立即渲染模式"></a>核心模式和立即渲染模式</h1><p>早期的OpenGL使用<strong>立即渲染模式</strong>（Immediate mode，也就是<strong>固定渲染管线</strong>），立即渲染模式容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，推出核心模式(Core-profile)，这个模式完全移除了旧的特性。</p>
<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变脸描述OpenGL此刻应当如何运行。绘制3D图形是一项复杂的任务。在接下来的章节，我们讨论许多OpenGL函数。对于一个特定的几何图形，有许多因素可能会影响它的绘制。对象是不是与背景混合？要不要进行正面或背面剔除？当前限制的是什么纹理？这样的问题数不胜数。</p>
<p>我们把这类变量的集合成为管线的状态。状态机是一个抽象的模型，表示一组状态变量的集合。每个状态变量可以有各种不同的值，或者只能可以打开或关闭等。当我们在OpenGL中进行绘图时，如果每次都要指定所有这些变量显示有点不切实际。反之，OpenGL使用了一种状态模型（或称状态机）来追踪所有的OpenGL状态变量。当一个状态值被设置之后，它就一直保持这个状态，直到其他函数对它进行修改为止。许多状态只能简单的打开或关闭。例如，深度测试（参见第3章）就是要么打开、要么关闭。打开深度测试的几何绘图将会被检查以确保在进行渲染之前总会在任何位于它后面的对象前方。在深度测试关闭后进行的几何图形绘制（例如2D覆盖）则会在不进行深度比较的情况下进行绘制。</p>
<p>为了打开这些类型的状态变量，可以使用下面这个OpenGL函数。<br><code>void glEnable(GLenum capability);</code><br>我们可以使用下面这个对应的函数，把这些变量的状态设置为关闭。<br><code>void glDisable(GLenum capability);</code><br>以深度测试为例，可以使用下面这个函数调用深度测试。<br><code>glEnable(GL_DEPTH_TEST);</code><br>也可以使用下面这个函数调用关闭深度测试。<br><code>glDisable(GL_DEPTH_TEST);</code><br>如果希望对一个状态变量进行测试，以判断它是否已被打开，OpenGL还提供了一种方便的机制。<br><code>Glboolean glIsEnabled(GLenum capability);</code><br>但是，并不是所有的状态变量都只是简单地打开或关闭。许多OpenGL函数专门用于设置变量的值，此后这些变量一直保持被设置时的值，直到再次被修改。我们在任何时候都可以查询这些变量的值。OpenGL提供了一组查询函数，可以查询布尔型、整型、单精度浮点型和双精度浮点型变量的值。这4个函数的原型如下所示：</p>
<h1 id="颜色缓冲区"><a href="#颜色缓冲区" class="headerlink" title="颜色缓冲区"></a>颜色缓冲区</h1><p>颜色缓冲区（COLOR_BUFFER）就是帧缓冲区（FRAME_BUFFER），你需要渲染的场景最终每一个像素都要写入该缓冲区，然后由它渲染到屏幕上显示。</p>
<h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><p>深度缓冲区（DEPTH_BUFFER）与帧缓冲区对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们就可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。</p>
<h1 id="模版缓冲区"><a href="#模版缓冲区" class="headerlink" title="模版缓冲区"></a>模版缓冲区</h1><p>模版缓冲区（STENCIL_BUFFER）与深度缓冲大小相同，通过设置模版缓冲每个像素的值，我们可以指定在渲染的时候只渲染某些像素，从而可以达到一些特殊的效果。</p>
<h1 id="Texture-Wrapping"><a href="#Texture-Wrapping" class="headerlink" title="Texture Wrapping"></a>Texture Wrapping</h1><p>通常，纹理坐标的范围在(0,0)到(1,1)之间，但是假如我们制定的坐标在这之外呢？<br>OpenGL会如何做出反应？默认情况下，OpenGL会重复绘制纹理图，不过，OpenGL也提供了更多的选择方案：</p>
<ul>
<li>GL_REPEAT：默认方案，重复纹理图片</li>
<li>GL_MIRRORED_REPEAT：类似于默认方法，不过每次重复的时候进行镜像重复。</li>
<li>GL_CLAMP_TP_EDGE：将坐标限制在0到1之间。超出的坐标会重复绘制边缘的像素，变成一种扩展边缘的图案。</li>
<li>GL_CLAMP_TO_BORDER：超出的坐标将会被绘制成用户指定的边界颜色</li>
</ul>
<h2 id="Mip贴图"><a href="#Mip贴图" class="headerlink" title="Mip贴图"></a>Mip贴图</h2><p>Mip贴图是一种功能强大的纹理技巧，它不仅可以提高渲染性能，而且可以改善场景的显示质量。它使用标准纹理贴图处理两个常见的问题，从而实现上述目标。第一个问题是一种称为闪烁（Scintillation，即锯齿假影）的效果。当屏幕上被渲染物体的表面与它所应用的纹理图像相比显得非常小时，就会出现这种效果。闪烁可以被看成是某种类型的闪光，当纹理 图像的采样区域的移动幅度与它在屏幕上的大小相比显得不成比例时，就会发生这种现象。当照相机或物体处于运动状态时，我们很容易看到闪烁的负面效果。</p>
<p>第二个问题更多地和性能有关，但它的原因和闪烁相同。也就是说，问题的根源在与它必须加载大量的纹理内存并对它们进行过滤处理，但屏幕上实际显示的只是很少的一部分片段。纹理越大，这个问题造成的性能影响也就越为明显。</p>
<p>Mip贴图纹理由一系列图像组成，每个图像大小在每个轴的方向上都缩小一半，或者说是原来图像像素总数的四分之一。图5.11所示显示了这些场景。MipMap并不一样是正方形的，但每个图像的大小都依次减半，知道最后一个图像的大小是1 x 1的纹理单元位置。当其中一个纬度的大小到达1时，接下来的减半处理就只发生在其他纬度上了。使用一组正方形（即各个纬度的大小相等）的MipMap所要求的的内存比不使用MipMap要多出三分之一。<br><img src="/2018/04/01/opengl/3.jpg"><br>MipMap是通过glTexImage函数加载的。现在轮到level参数发挥它的作用了，因为它指定了图像数据用于哪个Mip层。第一层是0，接着是1、2，然后依次类推。如果MipMap未被使用，那么就只有第0层会被加载。在默认情况下，为了使用MipMap，所有的Mip层都必须加载。但是我们可以用GL_TEXTURE_BASE_LEVEL和GL_TEXTURE_MAX_LEVEL纹理参数特别设置需要使用的基层和最大层。例如，如果想指定只加载从第0层至第4层，可以像下面这样调用glTexParameteri函数两次。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_BASE_LEVEL,<span class="number">0</span>);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<p>尽管GL_TEXTURE_BASE_LEVEL和GL_TEXTURE_MAX_LEVEL控制哪些Mip层被加载，但我们仍然可以使用GL_TEXTURE_MIN_LOD和GL_TEXTURE_MAX_LOD参数限制已加载的Mip层的使用范围。</p>
<h2 id="MipMap过滤"><a href="#MipMap过滤" class="headerlink" title="MipMap过滤"></a>MipMap过滤</h2><p>MipMap在两个基本的纹理过滤模式GL_NEAREST和GL_LINEAR尚添加了一个新的变化，这是通过向Mip贴图过滤提供了4中不同变化实现的。表5.5列出了这些变化。<br>表5.5 经过MipMap的纹理过滤</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_NEAREST</td>
<td>在Mip基层上执行最邻近过滤</td>
</tr>
<tr>
<td>GL_LINER</td>
<td>在Mip基层上执行线性过滤</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_NEAREST</td>
<td>选择最邻近Mip层，并执行最邻近过滤</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_LINER</td>
<td>在Mip层之间执行线性插补，并执行最邻近过滤</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_LINEAR</td>
<td>在Mip层之间执行线性插补，并执行线性过滤，又称三线性Mip贴图</td>
</tr>
</tbody>
</table>
</div>
<p>仅仅使用glTexImage函数加载Mip层并不能启用Mip贴图功能。如果纹理过滤设置为GL_LINER或GL_NEAREST，那么就只有纹理贴图基层会被使用，其他所有加载的Mip层都将被忽略。我们必须制定其中一个Mip贴图过滤器，这样才能使用所有已加载的Mip层。这个常量具有GL_FILTER_MIPMAP_SELECTOR的形式，其中FILTER制定了被选择的Mip层将要使用的纹理过滤器，SELECTOR则制定了如何选择Mip层。例如，GL_NEAREST选择最接近匹配的Mip层。<br>应该选择哪种过滤器取决于具体的应用以及希望实现的性能要求。例如，GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象也非常弱，但最邻近过滤在视觉效果上尝尝难以令人满意。GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加载，因为它适用了更高质量的线性过滤器。但是，它需要在不同大小的可用Mip层之间进行快速选择（最邻近过滤）。</p>
<h2 id="各向异性过滤"><a href="#各向异性过滤" class="headerlink" title="各向异性过滤"></a>各向异性过滤</h2><p>各向异性纹理过滤（Anisotropic texture filtering）并不是OpenGL核心规范的一部分，但它是一种得到广泛支持的扩展，可以极大地提高纹理过滤操作的质量。我们在本章前面内容中讲述了纹理贴图，并学习了两种最基本的纹理过滤：最邻近过滤（GL_NEAREST）和线性过滤（GL_LINEAR）。当一个纹理贴图被过滤时，OpenGL使用纹理坐标来判断一个特定的几何片段将落在纹理贴图的什么地方。然后，紧邻这个位置的纹理单元使用GL_NEAREST或GL_LINEAR过滤操作进行采样。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_RGB</td>
<td>按照红、绿、蓝顺序排列的颜色</td>
</tr>
<tr>
<td>GL_RGBA</td>
<td>按照红、绿、Alpha顺序排列的颜色</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/29/Red-Black-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/29/Red-Black-Tree/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-29 16:27:07" itemprop="dateCreated datePublished" datetime="2018-03-29T16:27:07+08:00">2018-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/29/Red-Black-Tree/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/29/Red-Black-Tree/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种自平衡二叉查找树。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>1.节点是红色或黑色。<br>2.根节点是黑色<br>3.每个叶节点（NIL或空节点）是黑色<br>4.每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；<br>5.从任意一个节点到其叶子节点都包含相同数目的黑色节点；</p>
<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>1.本身首先是一棵二叉搜索树<br>2.带有平衡条件：每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1.</p>
<h2 id="节点数"><a href="#节点数" class="headerlink" title="节点数"></a>节点数</h2><h2 id="STL和Linux都使用红黑树作为平衡树的实现"><a href="#STL和Linux都使用红黑树作为平衡树的实现" class="headerlink" title="STL和Linux都使用红黑树作为平衡树的实现"></a>STL和Linux都使用红黑树作为平衡树的实现</h2><p>1.如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的两级O(logN)，而RB-Tree最多只需要3次旋转，只需要O(1)的复杂度。<br>2.其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。<br>3.map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计行能是高于AVL的。</p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.若左子树不空，则左子树所有节点的值均小于或等于它的根节点的值；<br>2.若右子树不空，则右子树所有节点的值均大于或等于它的根节点的值；<br>3.左、右子树也分别为二叉排序树；</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>步骤：若根节点的关键字值等于查找的关键字，成功。<br>否则，若小于根节点的关键字值，递归查左子树。<br>P(n)=O(logn)</p>
<h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><h3 id="前序非递归遍历"><a href="#前序非递归遍历" class="headerlink" title="前序非递归遍历"></a>前序非递归遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_traversal_iteratively</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    TreeNode* last_pop = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* top = s.top();</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;left != <span class="number">0</span> &amp;&amp; top-&gt;left != last_pop &amp;&amp; top-&gt;right != last_pop)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(top-&gt;left);</span><br><span class="line">            <span class="built_in">cout</span> &gt;&gt; top-&gt;left-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (top-&gt;right != <span class="number">0</span> &amp;&amp; top-&gt;right != last_pop &amp;&amp; (top-&gt;left == <span class="number">0</span> || top-&gt;left == last_pop))</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(top-&gt;right);</span><br><span class="line">            <span class="built_in">cout</span> &gt;&gt; top-&gt;right-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            last_pop = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hash-散列函数"><a href="#Hash-散列函数" class="headerlink" title="Hash(散列函数)"></a>Hash(散列函数)</h1><p>给定M，存在函数f(key)，对任意给定给定的关键字key，代入函数厚若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash)表，函数(key)为哈希(Hash)函数。<br>如果key不相同，但是f(k1)=f(k2),这种现象成为碰撞(Collision)</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>1.直接寻址发：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a * key + b,其中a和b为常熟（这种散列函数叫做自身函数）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/24/Objective-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/24/Objective-C/" class="post-title-link" itemprop="url">Objective-C</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-24 16:05:37" itemprop="dateCreated datePublished" datetime="2018-03-24T16:05:37+08:00">2018-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/24/Objective-C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/24/Objective-C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Objective-C-C的超集"><a href="#Objective-C-C的超集" class="headerlink" title="Objective-C: C的超集"></a>Objective-C: C的超集</h1><p>Objective-C是C语言的严格超集—任何C语言不经修改可以直接通过Objective-C编译器</p>
<h1 id="Objective-C代码文件的扩展名"><a href="#Objective-C代码文件的扩展名" class="headerlink" title="Objective-C代码文件的扩展名"></a>Objective-C代码文件的扩展名</h1><p>.h  头文件<br>.m  源代码文件，包含Objective-C和C代码<br>.mm 源代码文件，包含Objective-C、C、C++代码，仅在你的Objective-C代码中确实需要使用C++类或者特性的时候采用这种扩展名</p>
<p>当你需要在源代码中包含头文件的时候，你可以使用标准的#include编译选项，但是Objective-C提供了更好的方法。#import选项和#include选项完全相同，只是它可以确保相同的文件只会被包含一次。Objective-C的例子和文档都倾向于使用#import。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>C++调用方法</p>
<pre><code>obj.method(argument);
</code></pre><p>Objective-C调用方法</p>
<pre><code>[obj method: argument];
</code></pre><p>类声明总是由@interface编译选项开始，由@end选项结束。<br><img src="http://oxcvfpext.bkt.clouddn.com/Objective-C-1.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject: NSObject&#123;</span><br><span class="line">    int memberVar1; // 实体变量</span><br><span class="line">    id </span><br><span class="line">&#125;</span><br><span class="line">+(return_type) class_method; //类方法</span><br><span class="line"></span><br><span class="line">-(return_type) instance_method1; //实例方法</span><br><span class="line">-(void)fbSendInviteByID: (NSDictionary*)info</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>方法前面+/-号代表函数的类型：加号(+)代表类方法(class method),不需要实例就可以调用，与C++的静态函数(static member function)相似。减号(-)即是一般的实例方法(instance method)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)setColorToRed: (float)red Green: ()</span><br></pre></td></tr></table></figure></p>
<h1 id="pragma-mark"><a href="#pragma-mark" class="headerlink" title="pragma mark"></a>pragma mark</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/23/Unity-ILRuntime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/Unity-ILRuntime/" class="post-title-link" itemprop="url">Unity热更新方案-ILRuntime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 18:24:17" itemprop="dateCreated datePublished" datetime="2018-03-23T18:24:17+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/23/Unity-ILRuntime/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/23/Unity-ILRuntime/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ILRuntime的优势同市面上的其他热更方案相比，ILRuntime主要有以下优点：</p>
<ul>
<li>无缝访问C#工程的线程代码，无需额外抽象脚本API</li>
<li>直接使用VS2015进行开发，ILRuntime的解释编译引擎支持.Net 4.6编译的DLL</li>
<li>执行效率是L#的10-20倍</li>
<li>选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右(从脚本调用GameObject之类的接口)</li>
<li>支持跨域集成</li>
<li>完整的泛型支持</li>
<li>拥有Vs2015调试插件，可以实现真机源码级调试(WIP)</li>
</ul>
<p><a href="https://github.com/Ourpalm/ILRuntime" target="_blank" rel="noopener">https://github.com/Ourpalm/ILRuntime</a><br><a href="https://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html" target="_blank" rel="noopener">https://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html</a></p>
<p>如果你希望在Unity中使用ILRuntime,推荐的方式是直接使用ILRuntime源代码，这样ILRuntime可以根据你的发布设置自动进行优化。</p>
<p>你需要将下列源代码目录复制到Unity工程的Assets目录：</p>
<ul>
<li>Mono.Cecil.20</li>
<li>Mono.Cecil.Pdb</li>
<li>ILRuntime</li>
</ul>
<p>需要注意的是，需要删除这些目录里面的bin、obj、Properties子目录，以及.csproj文件。此外由于ILRuntime使用了unsafe代码来优化执行效率，所以你需要在Unity中开启unsafe模式：</p>
<ul>
<li>在Assets目录里建立一个名为smcs.rsp的文本文件</li>
<li>在smcs.rsp文件中假如-unsafe</li>
</ul>
<p>如果你使用的是Unity5.4及以前的版本，并且使用的编译设置是.Net 2.0而不是.Net 2.0 Subset的话，你需要将上述说明中的smcs.rsp文件名改为gmcs.rsp。<br>如果你使用的是Unity5.5以上的版本，你需要将上述说明的smcs.rsp文件名改为mcs.rsp</p>
<h2 id="从Visual-Studio开始"><a href="#从Visual-Studio开始" class="headerlink" title="从Visual Studio开始"></a>从Visual Studio开始</h2><p>如果你希望在VisiualStudio的C#项目中使用ILRuntime，你只需要引用编译好的ILRuntime.dll,Mono.Cecil.20.dll以及Mono.Cecil.Pdb即可。</p>
<h3 id="使用之前"><a href="#使用之前" class="headerlink" title="使用之前"></a>使用之前</h3><p>ILRuntime项目提供了一个测试用例工程ILRuntimeTest,用来验证ILRuntime的正常运行，在运行测试用例前，需要手动生成一下TestCases里面的工程，生成DLL文件。</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">334</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DTWMWSlnxcXcuUgR1H2qlVt9-gzGzoHsz',
      appKey     : 'Ms2yHVyCinQmWnsKtVv7NOHR',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
