<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/25/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/25/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/xxsy-sence-merge-render/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/xxsy-sence-merge-render/" class="post-title-link" itemprop="url">xxsy-sence-merge-render</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 08:40:36" itemprop="dateCreated datePublished" datetime="2018-04-02T08:40:36+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/xxsy-skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/xxsy-skill/" class="post-title-link" itemprop="url">PJ04</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 08:16:24" itemprop="dateCreated datePublished" datetime="2018-04-02T08:16:24+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="normal-logic"><a href="#normal-logic" class="headerlink" title="normal_logic"></a>normal_logic</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Index</th>
<th>Type</th>
<th>Data1</th>
<th>Data2</th>
<th>Data3</th>
<th>Data4</th>
<th>Data5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>随机移动</td>
</tr>
<tr>
<td>2</td>
<td>固定线路</td>
</tr>
<tr>
<td>3</td>
<td>跟随逻辑</td>
</tr>
<tr>
<td>4</td>
<td>恐惧逻辑</td>
</tr>
<tr>
<td>5</td>
<td>飞行逻辑</td>
</tr>
<tr>
<td>6</td>
</tr>
<tr>
<td>7</td>
</tr>
<tr>
<td>8</td>
<td>怪物闲聊</td>
<td></td>
<td>talk_list.id</td>
<td>起始延迟时间</td>
<td></td>
<td>间隔时间</td>
</tr>
<tr>
<td>9</td>
<td>宠物跟随</td>
</tr>
<tr>
<td>20</td>
<td>怪物边聊边走</td>
</tr>
</tbody>
</table>
</div>
<h1 id="refresh-table"><a href="#refresh-table" class="headerlink" title="refresh_table"></a>refresh_table</h1><div class="table-container">
<table>
<thead>
<tr>
<th>物体id</th>
<th>刷新方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>cha_list.id</td>
<td>0手动1刷一次2死亡复合3条件</td>
</tr>
</tbody>
</table>
</div>
<h1 id="talk-list"><a href="#talk-list" class="headerlink" title="talk_list"></a>talk_list</h1><div class="table-container">
<table>
<thead>
<tr>
<th>事件类型</th>
<th>事件id</th>
</tr>
</thead>
<tbody>
<tr>
<td>4，驾云/瞬移</td>
<td>trans_cmn.id</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/01/opengl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/01/opengl/" class="post-title-link" itemprop="url">OpenGL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-01 11:24:55" itemprop="dateCreated datePublished" datetime="2018-04-01T11:24:55+08:00">2018-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>与读者以前听说的可能不同，OpenGL（对其它3D应用程序接口来说也是如此）3D图形编程并不都是关于着色器的。不管是使用C、C++、C#、JavaScript等编程语言的哪一种，客户端都必须完成相当多的工作，来管理这些着色器，以及向它们馈送（feed）几何图形、变换矩阵和其他各种数据。<br>本书的第一部分是真正的数据——3D图形编程教程，从基本原则开始讲述，当然这些都是基于实时3D图形渲染的行业标准OpenGL的。<br>着色器编程非常令人兴奋，但是作者并不打算将本书写成一本着色器编程数据。实际上，如果没有如何管理场景，设置视点、模型和变换矩阵，以及载入纹理等知识，那么即使懂得如何编写优秀的着色器也难有所成……我想读者一定明白我的意思。<br>为了帮助读者上手，本书提供了一个小型的“存储着色器”库，它们能够完成大多数常规任务。读者甚至可能会发现，对于简单3D渲染来说，这些着色器已经能够满足所有需要了。但是，随着知识的增长，读者可能并不会满足于此。在进入第二部分之前，还未读者准备GLSL“快速开始”，因此读者无需等到完成掌握OpenGL应用程序接口就能开始创造性了。</p>
<h2 id="3D图形技术和术语"><a href="#3D图形技术和术语" class="headerlink" title="3D图形技术和术语"></a>3D图形技术和术语</h2><p>本书的每一章都包含一个或多个实例程序用来演示这一章锁讨论的编程技术。尽管本章有意避免了关于编程细节的讨论，但扔提供了一个示例程序向读者演示最低程度上需要熟悉的技术和术语，以帮助读者充分利用本书。本章的示例程序叫做BLOCK，读者可以从随书提供的示例程序集中的“Chapter 1”文件夹中找到它。<br>将数学和图形数据转换到3D空间图像的操作叫做渲染（Rendering）。当这个术语作为动词使用时，指的是计算机创建三维图像时所经历的过程。它也作为名词使用，指的仅仅是最终的图像作品。</p>
<h3 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h3><p>实际绘制或填充每个定点之间的像素形成线段就叫做光栅化（Rasterization）。我们可以通过隐藏表面消除（Hidden Surface Removal）来进一步澄清3D设计意图。<br>视口：把绘图坐标映射到窗口坐标<br>裁剪区域的高度和宽度很少正好与窗口的宽度和高度（以像素为单位）相匹配。因此，坐标系统必须从逻辑笛卡尔坐标映射到物理屏幕像素坐标。这个映射是通过一种叫做视口（ViewPort）的设置来指定的。视口就是窗口内部用于绘制裁剪区域的客户区域。视口简单地把裁剪区域映射到窗口的一个区域。通常，视口被定义为整个窗口，但这并非严格必须的。例如，我们可能只希望在窗口的下半部分进行绘图。在用GPA抓帧的时候会发现，如果更改屏幕分辨率，就是只绘制到了视口或者窗口的一部分。<br><img src="/2018/04/01/opengl/1.jpg"><br>与此形成对照的是，图1.20所示显示了一个与裁剪区域相匹配的视口。我们所看到的的这个窗口仍然是300*200像素。但是，现在可视区域将占据窗口的左下部分。<br>我们可以使用视口来缩小或放大窗口中的图像，也可以通过把视口设置为大于窗口的用户区域，从而只显示裁剪区域的一部分。<br><img src="/2018/04/01/opengl/2.jpg"><br>顶点——空间中的一个位置</p>
<h1 id="核心模式和立即渲染模式"><a href="#核心模式和立即渲染模式" class="headerlink" title="核心模式和立即渲染模式"></a>核心模式和立即渲染模式</h1><p>早期的OpenGL使用<strong>立即渲染模式</strong>（Immediate mode，也就是<strong>固定渲染管线</strong>），立即渲染模式容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，推出核心模式(Core-profile)，这个模式完全移除了旧的特性。</p>
<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变脸描述OpenGL此刻应当如何运行。绘制3D图形是一项复杂的任务。在接下来的章节，我们讨论许多OpenGL函数。对于一个特定的几何图形，有许多因素可能会影响它的绘制。对象是不是与背景混合？要不要进行正面或背面剔除？当前限制的是什么纹理？这样的问题数不胜数。</p>
<p>我们把这类变量的集合成为管线的状态。状态机是一个抽象的模型，表示一组状态变量的集合。每个状态变量可以有各种不同的值，或者只能可以打开或关闭等。当我们在OpenGL中进行绘图时，如果每次都要指定所有这些变量显示有点不切实际。反之，OpenGL使用了一种状态模型（或称状态机）来追踪所有的OpenGL状态变量。当一个状态值被设置之后，它就一直保持这个状态，直到其他函数对它进行修改为止。许多状态只能简单的打开或关闭。例如，深度测试（参见第3章）就是要么打开、要么关闭。打开深度测试的几何绘图将会被检查以确保在进行渲染之前总会在任何位于它后面的对象前方。在深度测试关闭后进行的几何图形绘制（例如2D覆盖）则会在不进行深度比较的情况下进行绘制。</p>
<p>为了打开这些类型的状态变量，可以使用下面这个OpenGL函数。<br><code>void glEnable(GLenum capability);</code><br>我们可以使用下面这个对应的函数，把这些变量的状态设置为关闭。<br><code>void glDisable(GLenum capability);</code><br>以深度测试为例，可以使用下面这个函数调用深度测试。<br><code>glEnable(GL_DEPTH_TEST);</code><br>也可以使用下面这个函数调用关闭深度测试。<br><code>glDisable(GL_DEPTH_TEST);</code><br>如果希望对一个状态变量进行测试，以判断它是否已被打开，OpenGL还提供了一种方便的机制。<br><code>Glboolean glIsEnabled(GLenum capability);</code><br>但是，并不是所有的状态变量都只是简单地打开或关闭。许多OpenGL函数专门用于设置变量的值，此后这些变量一直保持被设置时的值，直到再次被修改。我们在任何时候都可以查询这些变量的值。OpenGL提供了一组查询函数，可以查询布尔型、整型、单精度浮点型和双精度浮点型变量的值。这4个函数的原型如下所示：</p>
<h1 id="颜色缓冲区"><a href="#颜色缓冲区" class="headerlink" title="颜色缓冲区"></a>颜色缓冲区</h1><p>颜色缓冲区（COLOR_BUFFER）就是帧缓冲区（FRAME_BUFFER），你需要渲染的场景最终每一个像素都要写入该缓冲区，然后由它渲染到屏幕上显示。</p>
<h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><p>深度缓冲区（DEPTH_BUFFER）与帧缓冲区对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们就可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。</p>
<h1 id="模版缓冲区"><a href="#模版缓冲区" class="headerlink" title="模版缓冲区"></a>模版缓冲区</h1><p>模版缓冲区（STENCIL_BUFFER）与深度缓冲大小相同，通过设置模版缓冲每个像素的值，我们可以指定在渲染的时候只渲染某些像素，从而可以达到一些特殊的效果。</p>
<h1 id="Texture-Wrapping"><a href="#Texture-Wrapping" class="headerlink" title="Texture Wrapping"></a>Texture Wrapping</h1><p>通常，纹理坐标的范围在(0,0)到(1,1)之间，但是假如我们制定的坐标在这之外呢？<br>OpenGL会如何做出反应？默认情况下，OpenGL会重复绘制纹理图，不过，OpenGL也提供了更多的选择方案：</p>
<ul>
<li>GL_REPEAT：默认方案，重复纹理图片</li>
<li>GL_MIRRORED_REPEAT：类似于默认方法，不过每次重复的时候进行镜像重复。</li>
<li>GL_CLAMP_TP_EDGE：将坐标限制在0到1之间。超出的坐标会重复绘制边缘的像素，变成一种扩展边缘的图案。</li>
<li>GL_CLAMP_TO_BORDER：超出的坐标将会被绘制成用户指定的边界颜色</li>
</ul>
<h2 id="Mip贴图"><a href="#Mip贴图" class="headerlink" title="Mip贴图"></a>Mip贴图</h2><p>Mip贴图是一种功能强大的纹理技巧，它不仅可以提高渲染性能，而且可以改善场景的显示质量。它使用标准纹理贴图处理两个常见的问题，从而实现上述目标。第一个问题是一种称为闪烁（Scintillation，即锯齿假影）的效果。当屏幕上被渲染物体的表面与它所应用的纹理图像相比显得非常小时，就会出现这种效果。闪烁可以被看成是某种类型的闪光，当纹理 图像的采样区域的移动幅度与它在屏幕上的大小相比显得不成比例时，就会发生这种现象。当照相机或物体处于运动状态时，我们很容易看到闪烁的负面效果。</p>
<p>第二个问题更多地和性能有关，但它的原因和闪烁相同。也就是说，问题的根源在与它必须加载大量的纹理内存并对它们进行过滤处理，但屏幕上实际显示的只是很少的一部分片段。纹理越大，这个问题造成的性能影响也就越为明显。</p>
<p>Mip贴图纹理由一系列图像组成，每个图像大小在每个轴的方向上都缩小一半，或者说是原来图像像素总数的四分之一。图5.11所示显示了这些场景。MipMap并不一样是正方形的，但每个图像的大小都依次减半，知道最后一个图像的大小是1 x 1的纹理单元位置。当其中一个纬度的大小到达1时，接下来的减半处理就只发生在其他纬度上了。使用一组正方形（即各个纬度的大小相等）的MipMap所要求的的内存比不使用MipMap要多出三分之一。<br><img src="/2018/04/01/opengl/3.jpg"><br>MipMap是通过glTexImage函数加载的。现在轮到level参数发挥它的作用了，因为它指定了图像数据用于哪个Mip层。第一层是0，接着是1、2，然后依次类推。如果MipMap未被使用，那么就只有第0层会被加载。在默认情况下，为了使用MipMap，所有的Mip层都必须加载。但是我们可以用GL_TEXTURE_BASE_LEVEL和GL_TEXTURE_MAX_LEVEL纹理参数特别设置需要使用的基层和最大层。例如，如果想指定只加载从第0层至第4层，可以像下面这样调用glTexParameteri函数两次。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_BASE_LEVEL,<span class="number">0</span>);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<p>尽管GL_TEXTURE_BASE_LEVEL和GL_TEXTURE_MAX_LEVEL控制哪些Mip层被加载，但我们仍然可以使用GL_TEXTURE_MIN_LOD和GL_TEXTURE_MAX_LOD参数限制已加载的Mip层的使用范围。</p>
<h2 id="MipMap过滤"><a href="#MipMap过滤" class="headerlink" title="MipMap过滤"></a>MipMap过滤</h2><p>MipMap在两个基本的纹理过滤模式GL_NEAREST和GL_LINEAR尚添加了一个新的变化，这是通过向Mip贴图过滤提供了4中不同变化实现的。表5.5列出了这些变化。<br>表5.5 经过MipMap的纹理过滤</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_NEAREST</td>
<td>在Mip基层上执行最邻近过滤</td>
</tr>
<tr>
<td>GL_LINER</td>
<td>在Mip基层上执行线性过滤</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_NEAREST</td>
<td>选择最邻近Mip层，并执行最邻近过滤</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_LINER</td>
<td>在Mip层之间执行线性插补，并执行最邻近过滤</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_LINEAR</td>
<td>在Mip层之间执行线性插补，并执行线性过滤，又称三线性Mip贴图</td>
</tr>
</tbody>
</table>
</div>
<p>仅仅使用glTexImage函数加载Mip层并不能启用Mip贴图功能。如果纹理过滤设置为GL_LINER或GL_NEAREST，那么就只有纹理贴图基层会被使用，其他所有加载的Mip层都将被忽略。我们必须制定其中一个Mip贴图过滤器，这样才能使用所有已加载的Mip层。这个常量具有GL_FILTER_MIPMAP_SELECTOR的形式，其中FILTER制定了被选择的Mip层将要使用的纹理过滤器，SELECTOR则制定了如何选择Mip层。例如，GL_NEAREST选择最接近匹配的Mip层。<br>应该选择哪种过滤器取决于具体的应用以及希望实现的性能要求。例如，GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象也非常弱，但最邻近过滤在视觉效果上尝尝难以令人满意。GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加载，因为它适用了更高质量的线性过滤器。但是，它需要在不同大小的可用Mip层之间进行快速选择（最邻近过滤）。</p>
<h2 id="各向异性过滤"><a href="#各向异性过滤" class="headerlink" title="各向异性过滤"></a>各向异性过滤</h2><p>各向异性纹理过滤（Anisotropic texture filtering）并不是OpenGL核心规范的一部分，但它是一种得到广泛支持的扩展，可以极大地提高纹理过滤操作的质量。我们在本章前面内容中讲述了纹理贴图，并学习了两种最基本的纹理过滤：最邻近过滤（GL_NEAREST）和线性过滤（GL_LINEAR）。当一个纹理贴图被过滤时，OpenGL使用纹理坐标来判断一个特定的几何片段将落在纹理贴图的什么地方。然后，紧邻这个位置的纹理单元使用GL_NEAREST或GL_LINEAR过滤操作进行采样。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_RGB</td>
<td>按照红、绿、蓝顺序排列的颜色</td>
</tr>
<tr>
<td>GL_RGBA</td>
<td>按照红、绿、Alpha顺序排列的颜色</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/29/Red-Black-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/29/Red-Black-Tree/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-29 16:27:07" itemprop="dateCreated datePublished" datetime="2018-03-29T16:27:07+08:00">2018-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种自平衡二叉查找树。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>1.节点是红色或黑色。<br>2.根节点是黑色<br>3.每个叶节点（NIL或空节点）是黑色<br>4.每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；<br>5.从任意一个节点到其叶子节点都包含相同数目的黑色节点；</p>
<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>1.本身首先是一棵二叉搜索树<br>2.带有平衡条件：每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1.</p>
<h2 id="节点数"><a href="#节点数" class="headerlink" title="节点数"></a>节点数</h2><h2 id="STL和Linux都使用红黑树作为平衡树的实现"><a href="#STL和Linux都使用红黑树作为平衡树的实现" class="headerlink" title="STL和Linux都使用红黑树作为平衡树的实现"></a>STL和Linux都使用红黑树作为平衡树的实现</h2><p>1.如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的两级O(logN)，而RB-Tree最多只需要3次旋转，只需要O(1)的复杂度。<br>2.其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。<br>3.map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计行能是高于AVL的。</p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.若左子树不空，则左子树所有节点的值均小于或等于它的根节点的值；<br>2.若右子树不空，则右子树所有节点的值均大于或等于它的根节点的值；<br>3.左、右子树也分别为二叉排序树；</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>步骤：若根节点的关键字值等于查找的关键字，成功。<br>否则，若小于根节点的关键字值，递归查左子树。<br>P(n)=O(logn)</p>
<h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><h3 id="前序非递归遍历"><a href="#前序非递归遍历" class="headerlink" title="前序非递归遍历"></a>前序非递归遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_traversal_iteratively</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    TreeNode* last_pop = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* top = s.top();</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;left != <span class="number">0</span> &amp;&amp; top-&gt;left != last_pop &amp;&amp; top-&gt;right != last_pop)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(top-&gt;left);</span><br><span class="line">            <span class="built_in">cout</span> &gt;&gt; top-&gt;left-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (top-&gt;right != <span class="number">0</span> &amp;&amp; top-&gt;right != last_pop &amp;&amp; (top-&gt;left == <span class="number">0</span> || top-&gt;left == last_pop))</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(top-&gt;right);</span><br><span class="line">            <span class="built_in">cout</span> &gt;&gt; top-&gt;right-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            last_pop = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hash-散列函数"><a href="#Hash-散列函数" class="headerlink" title="Hash(散列函数)"></a>Hash(散列函数)</h1><p>给定M，存在函数f(key)，对任意给定给定的关键字key，代入函数厚若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash)表，函数(key)为哈希(Hash)函数。<br>如果key不相同，但是f(k1)=f(k2),这种现象成为碰撞(Collision)</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>1.直接寻址发：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a * key + b,其中a和b为常熟（这种散列函数叫做自身函数）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/24/Objective-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/24/Objective-C/" class="post-title-link" itemprop="url">Objective-C</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-24 16:05:37" itemprop="dateCreated datePublished" datetime="2018-03-24T16:05:37+08:00">2018-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Objective-C-C的超集"><a href="#Objective-C-C的超集" class="headerlink" title="Objective-C: C的超集"></a>Objective-C: C的超集</h1><p>Objective-C是C语言的严格超集—任何C语言不经修改可以直接通过Objective-C编译器</p>
<h1 id="Objective-C代码文件的扩展名"><a href="#Objective-C代码文件的扩展名" class="headerlink" title="Objective-C代码文件的扩展名"></a>Objective-C代码文件的扩展名</h1><p>.h  头文件<br>.m  源代码文件，包含Objective-C和C代码<br>.mm 源代码文件，包含Objective-C、C、C++代码，仅在你的Objective-C代码中确实需要使用C++类或者特性的时候采用这种扩展名</p>
<p>当你需要在源代码中包含头文件的时候，你可以使用标准的#include编译选项，但是Objective-C提供了更好的方法。#import选项和#include选项完全相同，只是它可以确保相同的文件只会被包含一次。Objective-C的例子和文档都倾向于使用#import。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>C++调用方法</p>
<pre><code>obj.method(argument);
</code></pre><p>Objective-C调用方法</p>
<pre><code>[obj method: argument];
</code></pre><p>类声明总是由@interface编译选项开始，由@end选项结束。<br><img src="http://oxcvfpext.bkt.clouddn.com/Objective-C-1.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject: NSObject&#123;</span><br><span class="line">    int memberVar1; // 实体变量</span><br><span class="line">    id </span><br><span class="line">&#125;</span><br><span class="line">+(return_type) class_method; //类方法</span><br><span class="line"></span><br><span class="line">-(return_type) instance_method1; //实例方法</span><br><span class="line">-(void)fbSendInviteByID: (NSDictionary*)info</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>方法前面+/-号代表函数的类型：加号(+)代表类方法(class method),不需要实例就可以调用，与C++的静态函数(static member function)相似。减号(-)即是一般的实例方法(instance method)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)setColorToRed: (float)red Green: ()</span><br></pre></td></tr></table></figure></p>
<h1 id="pragma-mark"><a href="#pragma-mark" class="headerlink" title="pragma mark"></a>pragma mark</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/23/Unity-ILRuntime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/Unity-ILRuntime/" class="post-title-link" itemprop="url">Unity热更新方案-ILRuntime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 18:24:17" itemprop="dateCreated datePublished" datetime="2018-03-23T18:24:17+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ILRuntime的优势同市面上的其他热更方案相比，ILRuntime主要有以下优点：</p>
<ul>
<li>无缝访问C#工程的线程代码，无需额外抽象脚本API</li>
<li>直接使用VS2015进行开发，ILRuntime的解释编译引擎支持.Net 4.6编译的DLL</li>
<li>执行效率是L#的10-20倍</li>
<li>选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右(从脚本调用GameObject之类的接口)</li>
<li>支持跨域集成</li>
<li>完整的泛型支持</li>
<li>拥有Vs2015调试插件，可以实现真机源码级调试(WIP)</li>
</ul>
<p><a href="https://github.com/Ourpalm/ILRuntime" target="_blank" rel="noopener">https://github.com/Ourpalm/ILRuntime</a><br><a href="https://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html" target="_blank" rel="noopener">https://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html</a></p>
<p>如果你希望在Unity中使用ILRuntime,推荐的方式是直接使用ILRuntime源代码，这样ILRuntime可以根据你的发布设置自动进行优化。</p>
<p>你需要将下列源代码目录复制到Unity工程的Assets目录：</p>
<ul>
<li>Mono.Cecil.20</li>
<li>Mono.Cecil.Pdb</li>
<li>ILRuntime</li>
</ul>
<p>需要注意的是，需要删除这些目录里面的bin、obj、Properties子目录，以及.csproj文件。此外由于ILRuntime使用了unsafe代码来优化执行效率，所以你需要在Unity中开启unsafe模式：</p>
<ul>
<li>在Assets目录里建立一个名为smcs.rsp的文本文件</li>
<li>在smcs.rsp文件中假如-unsafe</li>
</ul>
<p>如果你使用的是Unity5.4及以前的版本，并且使用的编译设置是.Net 2.0而不是.Net 2.0 Subset的话，你需要将上述说明中的smcs.rsp文件名改为gmcs.rsp。<br>如果你使用的是Unity5.5以上的版本，你需要将上述说明的smcs.rsp文件名改为mcs.rsp</p>
<h2 id="从Visual-Studio开始"><a href="#从Visual-Studio开始" class="headerlink" title="从Visual Studio开始"></a>从Visual Studio开始</h2><p>如果你希望在VisiualStudio的C#项目中使用ILRuntime，你只需要引用编译好的ILRuntime.dll,Mono.Cecil.20.dll以及Mono.Cecil.Pdb即可。</p>
<h3 id="使用之前"><a href="#使用之前" class="headerlink" title="使用之前"></a>使用之前</h3><p>ILRuntime项目提供了一个测试用例工程ILRuntimeTest,用来验证ILRuntime的正常运行，在运行测试用例前，需要手动生成一下TestCases里面的工程，生成DLL文件。</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/23/Unity-Skinned-Mesh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/Unity-Skinned-Mesh/" class="post-title-link" itemprop="url">Skinned Mesh原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 11:41:53" itemprop="dateCreated datePublished" datetime="2018-03-23T11:41:53+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、3D模型动画基本原理和分类"><a href="#一、3D模型动画基本原理和分类" class="headerlink" title="一、3D模型动画基本原理和分类"></a>一、3D模型动画基本原理和分类</h1><p>3D模型动画的基本原理是让模型中各定点的位置随时间变化。主要种类由Morph动画，关节动画和骨骼蒙皮动画(Skinned Mesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。</p>
<p>Morph(渐变，变形)动画是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。</p>
<p>关节动画的模型不是一个整体的Mesh，而是分成很多部分(Mesh),通过一个父子层级结构将这些分散的Mesh组织在一起，父Mesh带动其子Mesh运动，各mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。动画帧中设置各子Mesh相对于Mesh的变化（主要是旋转，当然也可以包括移动和缩放），通过子到父，一级级的变化累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。关节动画的问题是，各部分Mesh中的顶点时固定在其Mesh坐标系中的，这样在两个mesh结合处就可能产生裂缝。</p>
<p>第三类就是骨骼蒙皮动画即Skinned Mesh了，骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。</p>
<h1 id="二、Skinned-Mesh-原理和结构分析"><a href="#二、Skinned-Mesh-原理和结构分析" class="headerlink" title="二、Skinned Mesh 原理和结构分析"></a>二、Skinned Mesh 原理和结构分析</h1><p>Skinned Mesh中文一般乘坐骨骼蒙皮动画，这种动画包含骨骼(Bone)和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同：关节动画中时使用多个分散的Mesh,而Skinned Mesh中的Mesh是一个整体，也就是说只有一个mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了，Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图，而是mesh本身，蒙皮是将mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样的关节处的顶点由于同时收到了父子骨骼的拉扯而改变位置就消除了裂缝。</p>
<h2 id="1-理解骨骼和骨骼层次结构-Bone-Hierarchy"><a href="#1-理解骨骼和骨骼层次结构-Bone-Hierarchy" class="headerlink" title="1.理解骨骼和骨骼层次结构(Bone Hierarchy)"></a>1.理解骨骼和骨骼层次结构(Bone Hierarchy)</h2><p>首先要明确一个观念：骨骼决定了模型整体在世界坐标系中的位置和朝向。<br>先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。在渲染静态模型时，由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换就可以进行渲染。而对于骨骼动画，设置模型的位置和朝向，实际实在设置根骨骼的位置和朝向，然后根据骨骼层级结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼堆Mesh中顶点的绑定计算出顶点在世界坐标系中的坐标，从而堆顶点进行渲染，要记住，在骨骼动画中，骨骼才是模型主题，Mesh不过是一层皮，一件衣服。<br>如何理解骨骼？请看第二个管娘：骨骼可理解为一个坐标空间。<br>在一些文章中往往会提到关节和骨骼，那么关节是什么？骨骼有事什么？下图是一个手臂的骨骼层次的实例。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Skinned-Mesh-1.png"><br>骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的远点。关节的位置由它在父骨骼坐标空间中描述，上图中由三块骨骼，分别是手臂，前臂和两个手指。Clavicle(骨锁)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的远点。关节既决定了骨骼空间的位置，旋转和缩放分量决定了骨骼空间的旋转和缩放。我们来看前臂这个骨骼，其原点位置位于上臂上某处的，对于上臂来说，它知道自己的坐标空间某处(即肘关节所在的位置)有一个子空间，那就是前臂，至于前臂里面是啥就不考虑了。当前臂绕肘关节旋转时，实际是前臂坐标空间在旋转，从而其中包含的子空间也在绕肘关节旋转，这个例子中是finger骨骼。和实际生物骨骼不同的是，我们这里的骨骼并没有实质的骨头，所以前臂旋转时，他自己没啥可转的，改变的只是坐标空间的朝向。你可以说上图蓝线在转，但实际蓝线并不存在，蓝线只是画上去表示骨骼之间关系的，真正转的是骨骼空间，我们能看到在转的是wrist joint,也就是两个finger骨骼的坐标空间，因为他们是子空间，会跟随父空间运动，就好比跟着地球转一样。</p>
<p>骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点再其父空间中的位置，绕关节旋转是指骨骼坐标空间(包括所有子空间)自身的旋转。但还有两个可能的疑问，一是骨骼的长度，由于骨骼是坐标空间没有所谓的长度和宽度限制，我们看到的长度一方面是蒙皮后的结果，而另一方面子骨骼的原点(也就是关节)的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。第二个问题，实际上我们的例子中手指没有子骨骼，所以那个端点并不存在，那是为了方便演示画上去的。实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点了。对了，那么手指的长度如何确定？我们看到的长度应该是手指部分的顶点和蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。</p>
<p>经过一段长篇大论，我们终于弄清楚骨骼和骨骼层次结构了，但是为什么要将骨骼组织成层次结构呢？答案是为了做动画方便，设想如果只有一块骨骼，那么让他动起来太简单了，动画每一帧直接指定他的位置即可，如果是n块呢？通过组成一个层次结构，就可以通过父骨骼控制子骨骼的运动，牵一发而动全身，改变某骨骼时并不需要设置其子骨骼的位置，子骨骼的位置会通过计算自动得到，上问已经说过，父子骨骼之间的关系可以理解为，子骨骼位于父骨骼的坐标系中，我们知道物体在坐标系中可以平移变换，以及自身的旋转和缩放。子骨骼在父骨骼的坐标系中也可以做这些变换来改变自己在其父骨骼坐标系中的位置和朝向等，那么如何表示呢？由于4x4矩阵可以同时表示上述三种变换，所以一般描述骨骼在其父骨骼坐标系时使用一个举证，也就是DirectX SkinnedMesh中的FramrTrnsformMatrix。实际上这不是唯一的方法，但应该是公认的方法因为矩阵不光可以同时表示多种变换还可以方便的通过连乘进行变换的组合，这在层次结构中非常方便。在本文的例子-最简单的skinned mesh示例中，我只演示了评议变换，所以只用一个3d坐标就可以表示子骨骼在父骨骼的位置。下面是Bone Class最初的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//这个坐标是定义在父骨骼坐标系中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时增加了一组坐标，存放计算好的世界坐标系。<br>将各个骨骼相关于相对于父骨骼摆放好，就形成了一个骨骼层次结构的初始坐标，所谓初始是指定义骨骼层次时，后来动画改变了骨骼的相对位置，准确的说一般是改变了骨骼自身的旋转而位置保持不变。</p>
<p>假设我们通过某种方法建立了骨骼层次结构，那么每一块骨骼的位置都依赖于其父骨骼的位置，而跟骨骼没有父，他的位置就是整个骨骼体系在世界坐标系中的位置。可以认为root的父就是世界坐标系。但是初始位置时，跟骨骼一般不是世界原点的，比如使用3d max character studio创建的biped骨架时，一般两脚之间时世界原点，而根骨骼-骨盆位于原点上方(+z轴上)。这有什么关系呢，其实也没什么大不了的，只是我们在指定骨骼动画模型整体坐标时，比如设定坐标(0,0,0),则根骨骼-骨盆被置于世界原点，假如xy平面时地面，那么人下个身子到地面下了。我们想让两脚之间算作人的原点，这样设定(0,0,0)的坐标时人就站在地面上了，所以可以在两脚之间设定一个额外的根骨骼放到世界原点上，或者这个骨骼并不需要真实存在，只是在你的骨骼模型结构中保存骨盆骨骼到世界原点的变换矩阵。在微软X文件中，一般有一个Scene_Root节点，这算一个额外的骨骼吧，他的变换矩阵为单位阵，表示他初始位于世界原点，而真正骨骼的跟Bip01,作为Scene_root的子骨骼，其变换矩阵表示相对于root的位置。说这么多其实我只是像解释下，为什么要存在Scenen_Root这种额外的骨骼，以及加深理解骨骼定位骨骼动画模型整体的世界坐标的作用。</p>
<p>有了骨骼类，现在让我们看一下建立骨骼层次的代码，在bone class中增加一个构造函数和两个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bone(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z): m_pSibling(<span class="literal">NULL</span>),m_pFirstChild(<span class="literal">NULL</span>),m_pFather(<span class="literal">NULL</span>),</span><br><span class="line">    m_x(x),m_y(y),m_z(z)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFirstChild</span><span class="params">(Bone *pChild)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_pFirstChild = pChild;</span><br><span class="line">        m_pFirstChild-&gt;m_pFather = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSibling</span><span class="params">(Bone *pSibling)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_pSibling = pSibling;</span><br><span class="line">        m_pSibling-&gt;m_pFather = m_pFather;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我增加了一个成员变量，Bone* m_pFather,这是指向父骨骼的指针，在这个例子中计算骨骼动画时本不需要这个指针，但我为了画一条从父骨骼关节到子骨骼关节的连线，增加了它，因为每个骨骼只有第一子骨骼的指针，绘制父骨骼时从父到子画线就只能画一条，所以记录每个骨骼的父，在胡子hi子骨骼时画这根线。</p>
<p>有了这个函数，就可以创建骨骼层次了，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bone * g_boneRoot;</span><br><span class="line">Bone * g_bone1, *g_bone32, *g_bone22;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildBones</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_boneRoot = <span class="keyword">new</span> Bone(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone1 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone21 = <span class="keyword">new</span> Bone(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone22 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>, <span class="number">0.0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    g_boneRoot-&gt;SetFirstChild(g_bone1);</span><br><span class="line">    gbone1-&gt;SetFirstChild(g_bone21);</span><br><span class="line">    g_bone21-&gt;SetSibling(g_bone22);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是骨骼层次中最核心的部分，更新骨骼！由于动画的作用，某个骨骼的变化(TransformMatrix)变了，这时就要根据新的变化来计算，所以这个过程一般乘坐UpdateBoneMatrix。因为骨骼的变化都是相对父的，要变换顶点必须使用世界变换矩阵，所以这个过程根据更新了某些骨骼的骨骼变换矩阵(TransformMatrix)计算出所有骨骼的世界变换矩阵(CombinedMatrix)。在本文的例子中，骨骼只能平移，甚至我们没有用矩阵，所以当有骨骼变动时要做的只是直接计算骨骼的世界坐标，因此函数命名为ComputeWorldPos,相当于UpdateBoneMatrix后再用顶点相乘CombinedMatrix。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//give father's world pos, compute the bone's world pos</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPos</span><span class="params">(<span class="keyword">float</span> fatherWX, <span class="keyword">float</span> fatherWY, <span class="keyword">float</span> WZ)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_wx = fatherWX + m_x;</span><br><span class="line">        m_wy = fatherWY + m_y;</span><br><span class="line">        m_wz = fatherWZ + m_z;</span><br><span class="line">        <span class="keyword">if</span> (m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">            m_pSibling-&gt;ComputeWorldPos(fatherWX, fatherWY, fatherWZ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pFirstChild != <span class="literal">NULL</span>)</span><br><span class="line">            m_pFirstChild-&gt;ComputreWorldPos(m_wx, m_wy, m_wz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的递归调用使用了微软例子的思想。</p>
<p>有了上述函数，当某骨骼运动时就可以让其子骨骼跟随运动了，但是怎么让骨骼运动呢？这就是动画问题了，我不打算在这个简单的例子中使用关键帧动画，而只是通过程序每帧改变某些骨骼的位置，DEMO中的animateBones就是做这个的，你可以在里面改变不同的骨骼看看效果。在本文下面会对骨骼的关键帧动画做简单的讨论。</p>
<h2 id="2-蒙皮信息和蒙皮过程"><a href="#2-蒙皮信息和蒙皮过程" class="headerlink" title="2.蒙皮信息和蒙皮过程"></a>2.蒙皮信息和蒙皮过程</h2><h3 id="2-1-Skin-info的定义"><a href="#2-1-Skin-info的定义" class="headerlink" title="2-1 Skin info的定义"></a>2-1 Skin info的定义</h3><p>上文曾讨论过，Skinned Mesh中Mesh时作为皮肤使用，蒙在骨骼之上的。为了让普通的Mesh具有蒙皮的功能，必须添加蒙皮信息，即Skin info。我们知道mesh是由顶点构成的，建模时顶点是定义在模型自身坐标系的，即相对于Mesh原点的，而骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标，这就要将顶点和骨骼联系起来，Skin info正是起了这个作用。下面是DEMO中顶点类的定义的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BONE_PER_VERTEX 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//local pos in mesh space</span></span><br><span class="line">    <span class="keyword">float</span> m_wX, m_wY, m_wZ; <span class="comment">// blended vertex pos, in world space</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// skin info</span></span><br><span class="line">    <span class="keyword">int</span> m_boneNum;</span><br><span class="line">    Bone * m_bones[MAX_BONE_PER_VERTEX];</span><br><span class="line">    <span class="keyword">float</span> m_boneWeights[MAX_BONE_PER_VERTEX];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶点的Skin info包含影响该顶点的骨骼数目，只想这些骨骼的指针，这些骨骼作用于该顶点的权重(Skin weight)。由于只是一个简单的例子，这儿没有考虑优化，所以用静态数组存放骨骼指针和权重，且实际引擎中Skin info的定义方式不一定是这样的，但基本原理一致。</p>
<p>MAX_BONE_PER_VERTEX在这儿用来设置可同时影响顶点的最大骨骼数，实际上由于这个DEMO是手工进行Vertex Blending并且没有硬件加速，以及为了确保速度，一般会定义最大骨骼数。另外在本Demo中，Skin info是手工设定的，而实际项目中，一般是在建模软件中生成这些信息并导出。</p>
<p>Skin info 的作用是使用各个骨骼的变换矩阵对顶点进行变换并乘以权重，这样某块骨骼只能对该顶点产生部分影响。各骨骼权重之和应该为1.</p>
<p>Skin info是针对顶点的，然后在使用Skin info前我们必须要使用Bone Offset Matrix对顶点进行变换，下面具体讨论Bone offset Matrix。（写下这句话的时候我感觉不妥，因为实际是先将所有的矩阵相乘最后在用作顶点，这儿是按照理论上的顺序进行讲述吧，请不要与实际情况混肴，其实他们也并不矛盾。而且在我们的DEMO中由于没有使用矩阵，所以变换的顺序和理论顺序是一致的）</p>
<h3 id="2-2-Bone-Offset-Matrix的含义和计算方法"><a href="#2-2-Bone-Offset-Matrix的含义和计算方法" class="headerlink" title="2-2 Bone Offset Matrix的含义和计算方法"></a>2-2 Bone Offset Matrix的含义和计算方法</h3><p>上文已经说过：“骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标”，现在让我们看下顶点受一块骨骼的作用的坐标变换过程：<br>    mesh vertex(defined in mesh space)——&gt;Bone space——&gt;world<br>从这个过程中可以看出，需要首先将模型顶点从模型空间变换到某块骨骼自身的骨骼空间，然后才能利用骨骼的世界变换计算顶点的世界坐标。Bone Offset Matrix的作用正是将模型从顶点空间变换到骨骼空间。那么Bone Offset Matrix如何得到呢？下面具体分析：</p>
<p>Mesh space是建模时使用的空间，mesh中顶点的位置相对于这个空间的原点定义。比如在3dmax中建模时(视xy平面为地面，+z朝上)，可将模型两脚之间的中点作为Mesh空间的原点，并将其放置在世界原点，这样左脚上某一顶点坐标是(10,10,2),右脚上堆成的一点坐标是(-10,10,2)，头顶的坐标是(0,0,170)。由于此时Mesh空间和世界空间重合，上述坐标即在Mesh空间也是世界空间，换句话说，此时实际是以世界空间作为Mesh空间了。在骨骼动画中，在世界中放置的是骨骼而不是Mesh，所以这个区别并不重要。在3d max中添加骨骼的时候，也是将骨骼放入世界空间中，并调整骨骼的相对位置是得和mesh相吻合（即设置骨骼的TransformMatrix),得到股价的初始姿势以及相应的Transform Matrix(按惯例模型做成两臂侧平举直立，骨骼也要适合这个姿态)。由于骨骼的Transform Matrix(作用是将顶点从骨骼空间变换到上层空间)是基于其父骨骼空间的，只有根骨骼的Transform是基于世界空间的，所以要通过自下而上一层层Tranform变换(如果使用行向量右乘矩阵，这个Transform的累计过程就是C=MboneMfatherMgrandpar..Mroot),得到该骨骼在世界空间上的变换矩阵-Combined Transform Matrix,即通过这个矩阵可将该顶点从骨骼空间变换到世界空间。那么这个矩阵的逆矩阵就可以将世界空间中的顶点变换到某块骨骼的骨骼空间。由于Mesh实际上就是定义在世界空间了，所以这个逆矩阵就是Offset Matrix。即OffsetMatrix就是骨骼在初始位置（没有经过任何动画改变）时将bone变换到世界空间的矩阵(CombinedTransformMatrix)的逆矩阵，有一些资料称之为InverseMatrix。在几何流水线中，是通过变换矩阵将顶点变换到上层空间，最终得到世界坐标，逆矩阵则作相反的事，所以Inverse这种提法也符合惯例。那么Offset这种提法从字面上怎么理解呢？Offset即骨骼相对世界原点的偏移，世界原点加上这个偏移就变成骨骼空间的原点，同样定义在世界空间中的点经过这个偏移矩阵的作用也被变换成骨骼空间了。从另一角度理解，在动画中模型中顶点的位置是根据骨骼位置动态计算的，也就是说顶点跟着骨骼动，但首先必须确定顶点和骨骼之间的相对位置（即顶点在该骨骼坐标系中的位置），一个骨骼可能对应很多顶点，如果要保存这个相对位置每个顶点对于每块受控制的骨骼都要保存，这样就要保存太多的矩阵了。。所以只保存mesh空间到骨骼空间的变换（即OffsetMatrix),然后通过这个变换计算每个顶点在该骨骼空间中的坐标，所以OffsetMatrix也反应了mesh和每块骨骼的相对位置，只是这个位置是间接的通过和世界坐标空间的关系表达的，在初始位置将骨骼按照模型的形状摆好的关键之处。</p>
<p>以上的分析是通过mesh space和world space重合得到Offset Matrix的计算方法。那么如果他们不重合呢？那就要先计算顶点从mesh space变换到world space的变换矩阵，并乘上（还是右乘为例）Combined Matrix的Inverse Matrix从而得到Offset Matrix。但是这不是找麻烦吗，因为Mesh的原点在哪里并不重要，为啥不让他们重合呢？</p>
<p>还有一个问题是，既然Offset Matrix可以计算出来，为啥还要在骨骼动画文件中同时提供TransformMatrix和OffsetMatrix呢？实际上文件中确实可以不提供OffsetMatrix,而只在载入时计算，但TransformMatrix不可缺少，动画关键帧数据一般只存储骨骼的旋转和跟骨骼的位置，骨骼见的相对位置还是要靠TransformMatrix提供。在微软的X文件结构中提供了OffsetMatrix,原因是什么呢？我不知道。我猜想一个可能的原因是为了兼容性和灵活性，比如mesh并没有定义在世界坐标系，而是作为一个object放置在3d max中，在导出骨骼动画时不能简单的认为mesh的顶点坐标时相对于世界远点的，还要把这个object的位置考虑进去，于是导出插件要计算OffsetMatrix并保存在x文件中以避免兼容性问题。</p>
<p>关于OffsetMatrix和TransformMatrix含有评议，旋转和缩放的讨论：</p>
<p>首先，OffsetMatrix取决于骨骼的初始位置(即TransformMatrix),由于骨骼动画中我们使用的动画中的位置，初始位置时什么样并不重要，所以可以在初始位置中包含平移，而旋转和缩放在动画中设置(一般也仅仅使用旋转，这也是为啥动画通常中可以用一个四元数表示骨骼的关键帧)。在这种情况下，OffsetMatrix只包含平移即可。因此一些引擎的Bone中不存放Transform矩阵，而只存放骨骼在父骨骼空间的坐标，然后旋转只在动画帧中设置，最基本的骨骼动画即可实现。但也可在Transform和Offset Matrix中包括旋转和缩放，这样可以提供创建动画时的容错性。</p>
<p>在本文的DEMO中，我们也没有使用矩阵保存Bone Offset，而只用了一个坐标保存偏移位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoneOffset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m_offx, m_offy, m_offz;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Bone class中，有一个方法用来计算Bone Offset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BoneOffset m_boneOffset;</span><br><span class="line">    <span class="comment">//called after ComputeWorldPos() when bone loaded but not animated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeBoneOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_boneOffset.m_offx = -m_wx;</span><br><span class="line">        m_boneOffset.m_offy = -m_wy;</span><br><span class="line">        m_boneOffset.m_offz = -m_wz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">            m_pSibing-&gt;ComputeBoneOffset();</span><br><span class="line">        <span class="keyword">if</span> (m_pFirstChild != <span class="literal">NULL</span>)</span><br><span class="line">            m_pFirstChild-&gt;ComputeBoneOffset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在ComputeBoneOffset()中，使用计算好的骨骼的世界坐标来计算bone offset,这儿的计算只是取一个负数，在实际引擎中，如果bone offset是一个矩阵，这儿就应该是求逆矩阵，其实由于旋转矩阵是正交的，只要求出旋转矩阵的转置矩阵。注意由于我们计算Bone offset时是使用计算好的世界坐标，所以在这之前必须在初始位置时对根骨骼调用ComputeWorldPos()以计算出各个骨骼在初始位置时的世界坐标。</p>
<h3 id="2-3-最终：顶点混合-vertex-blending"><a href="#2-3-最终：顶点混合-vertex-blending" class="headerlink" title="2-3 最终：顶点混合(vertex blending)"></a>2-3 最终：顶点混合(vertex blending)</h3><p>现在我们有了Skin info,有了Bone Offset。现在开始做顶点混合，这是骨骼动画的精髓所在，正是这个技术消除了关节处的裂缝。顶点混合后得到了顶点新的世界坐标，对所有的顶点执行vertex blending后，从Mesh的角度看，Mesh deform(变形)了，变成动画需要的形状了。</p>
<p>首先，让我们看看使用单块骨骼对顶点进行作用的过程以下是DEMO中的相关代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputerWorldPosByBone</span><span class="params">(Bone *pBone, <span class="keyword">float</span> &amp;outx, <span class="keyword">float</span> &amp;outY, <span class="keyword">float</span> &amp;outZ)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">//step1: transform vertex from mesh space to bone space</span></span><br><span class="line">        outX = m_x + pBone-&gt;m_boneOffset.m_offx;</span><br><span class="line">        outY = m_y + pBone-&gt;m_boneOffset.m_offy;</span><br><span class="line">        outZ = m_z + pBone-&gt;m_boneOffset.m_offz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step2: transform vertex bone space to world space</span></span><br><span class="line">        outX += pBone-&gt;m_wx;</span><br><span class="line">        outY += pBone-&gt;m_wy;</span><br><span class="line">        outZ += pBone-&gt;m_wz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个函数使用一块骨骼对顶点进行变换，将顶点Mesh坐标系变换到世界坐标系，这儿使用了骨骼的Bone Offset Matrix和Combined Transform Matrix</p>
<p>对于多块骨骼，对每块骨骼执行这个过程并将结果根据权重混合(即vertex blending)就得到顶点最终的世界坐标。进行vertex blending的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlendVertex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">//do the vertex blending,get the vertex's pos in world space</span></span><br><span class="line">        m_wX = <span class="number">0</span>;</span><br><span class="line">        m_wY = <span class="number">0</span>;</span><br><span class="line">        m_wZ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_boneNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> tx, ty, tz;</span><br><span class="line">            ComputeWorldPosByBone(m_bones[i], tx, ty, tz);</span><br><span class="line">            tx *= m_boneWeights[i];</span><br><span class="line">            ty *= m_boneWeights[i];</span><br><span class="line">            tz *= m_boneWeights[i];</span><br><span class="line"></span><br><span class="line">            m_wX += tx;</span><br><span class="line">            m_wY += ty;</span><br><span class="line">            m_wZ += tz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些函数我都放在Vertex类中了，因为只是一个简单DEMO所以没有特别考虑类结构问题，在BlendVertex()中，遍历影响该顶点的所有骨骼，用每块骨骼计算出顶点的世界坐标，然后使用Skin Weight对这些坐标进行加权平均。tx,ty,tz是某块骨骼作用后顶点的世界坐标乘以权重后的值，这些值相加后就是最终的世界坐标了。</p>
<p>现在让我们用一个工时回顾以下Vertex blending的整个过程(使用矩阵变换)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vworld = Vmesh * BoneOffsetMatrix1 * CombindMatrix1 * Weight1</span><br><span class="line">+ Vmesh* BoneOffsetMatrix2 * CombineMatrix2*Wright2</span><br><span class="line">+ ...</span><br><span class="line">+ Vmesh * BoneOffsetMatrixn * CombindMatrixN * WeightN</span><br></pre></td></tr></table></figure>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>从结构上看，SkinnedMesh包括：动画数据，骨骼数据，包括Skin info的Mesh数据，以及Bone Offset Matrix。</p>
<p>从过程上看，载入阶段：载入并建立骨骼层次结构，计算或载入Bone Offset Matrix,载入Mesh数据和Skin info(具体的实现不同的引擎可能都不一样)。运行阶段：根据时间从动画数据中获取骨骼当前时刻的Transfrom Matrix，调用UpdateBoneMatrix计算出各骨骼的CombineMatrix,对于每个顶点根据Skin info进行Vertex Blending计算出顶点的世界坐标，最终进行模型的渲染。</p>
<h1 id="三、关于本文的例子"><a href="#三、关于本文的例子" class="headerlink" title="三、关于本文的例子"></a>三、关于本文的例子</h1><p>这个例子做了尽可能的简化，只包含一个cpp文件，使用OpenGL和GLUT作为渲染器和框架，仅有400多行代码。例子中手工创建了一个骨骼层次和Mesh，手工设置Skin info并自动计算BoneOffset,使用程序控制骨骼平移演示了骨骼层次的运动和骨骼影响下Mesh顶点的运动，例子中甚至没有使用矩阵。本例子仅作理解骨骼动画只用。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Skinned-Mesh-2.png"><br>截图中绿色网格是模型原始形状，蓝色是骨骼，红色是动画时模型形状，DEMO中左数第二个骨骼做上下运动，最下方的骨骼做x方向平移。DEMO没有使用旋转，而实际的骨骼动画中往往没有平移只有旋转的，因为胳膊只能转不能边长，但原理一致。<br>(这个公式使用的是行向量左乘矩阵)<br>由于BoneOffsetMatrix和Combined Matrix都是矩阵，可以先相乘这样就减少了很多计算了，在实际游戏中可以VS进行硬件加速计算。<br>代码的执行过程为，初始化时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">buildBones();<span class="comment">//创建骨骼层次</span></span><br><span class="line">buildMesh();<span class="comment">//创建mesh,设置skin info，计算bone offset </span></span><br><span class="line">```	</span><br><span class="line">每帧运行时：</span><br><span class="line">```C++</span><br><span class="line"><span class="comment">//draw original mesh</span></span><br><span class="line">g_mesh-&gt;DrawStaticMesh(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//move bones</span></span><br><span class="line">animateBones();</span><br><span class="line"></span><br><span class="line"><span class="comment">//update all bone's pos in bone tree</span></span><br><span class="line">g_boneRoot-&gt;ComputeWorldPos(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//update vertex pos by bones,using vertex blending</span></span><br><span class="line">g_mesh-&gt;UpdateVertices();</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw deformed mesh</span></span><br><span class="line">g_mesh-&gt;Draw();</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw bone</span></span><br><span class="line">g_boneRoot-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<p>为保证文本的完整性，下面贴出所有代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simplest Skinned Mesh demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoneOffset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//BoneOffset transform a vertex from mesh space to bone space.</span></span><br><span class="line">    <span class="comment">//In other words, it is the offset from mesh space to a bone's space.</span></span><br><span class="line">    <span class="comment">//For each bone, there is a BoneOffest.</span></span><br><span class="line">    <span class="comment">//If we add the offset to the vertex's pos (in mesh space), we get the vertex's pos in bone space</span></span><br><span class="line">    <span class="comment">//For example: if a vertex's pos in mesh space is (100,0,0), the bone offset is (-20,0,0), so the vertex's pos in bone space is (80,0,0)</span></span><br><span class="line">    <span class="comment">//Actually, BoneOffset is the invert transform of that we place a bone in mesh space, that is (-20,0,0) means the bone is at (20,0,0) in mesh space</span></span><br><span class="line">    <span class="keyword">float</span> m_offx , m_offy , m_offz ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Bone () &#123;&#125;</span><br><span class="line">    Bone ( <span class="keyword">float</span> x , <span class="keyword">float</span> y , <span class="keyword">float</span> z ):m_pSibling (<span class="literal">NULL</span> ),m_pFirstChild (<span class="literal">NULL</span> ),m_pFather (<span class="literal">NULL</span> ),m_x (x ),m_y (y ),m_z (z )&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~Bone () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Bone * m_pSibling ;</span><br><span class="line">    Bone * m_pFirstChild ;</span><br><span class="line">    Bone * m_pFather ; <span class="comment">//only for draw bone</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFirstChild</span> <span class="params">(Bone * pChild )</span> </span>&#123; m_pFirstChild = pChild ; m_pFirstChild -&gt;m_pFather = <span class="keyword">this</span> ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSibling</span> <span class="params">(Bone * pSibling )</span> </span>&#123; m_pSibling = pSibling ; m_pSibling -&gt;m_pFather = m_pFather ; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> m_x , m_y , m_z ; <span class="comment">//pos in its parent's space</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> m_wx , m_wy , m_wz ; <span class="comment">//pos in world space</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//give father's world pos, compute the bone's world pos</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPos</span> <span class="params">( <span class="keyword">float</span> fatherWX , <span class="keyword">float</span> fatherWY , <span class="keyword">float</span> fatherWZ )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       m_wx = fatherWX +m_x ;</span><br><span class="line">       m_wy = fatherWY +m_y ;</span><br><span class="line">       m_wz = fatherWZ +m_z ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;ComputeWorldPos (fatherWX , fatherWY , fatherWZ );</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;ComputeWorldPos (m_wx , m_wy , m_wz );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BoneOffset m_boneOffset ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//called after compute world pos when bone loaded but not animated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeBoneOffset</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       m_boneOffset .m_offx = -m_wx ;</span><br><span class="line">       m_boneOffset .m_offy = -m_wy ;</span><br><span class="line">       m_boneOffset .m_offz = -m_wz ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;ComputeBoneOffset ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;ComputeBoneOffset ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">0</span>,<span class="number">0</span>,<span class="number">1.0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       glVertex3f (m_wx ,m_wy ,m_wz );</span><br><span class="line">       glEnd ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFather !=<span class="literal">NULL</span> )</span><br><span class="line">       &#123;</span><br><span class="line">           glBegin (GL_LINES );</span><br><span class="line">              glVertex3f (m_pFather -&gt;m_wx ,m_pFather -&gt;m_wy ,m_pFather -&gt;m_wz );</span><br><span class="line">              glVertex3f (m_wx ,m_wy ,m_wz );</span><br><span class="line">           glEnd ();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;Draw ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BONE_PER_VERTEX 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Vertex ():m_boneNum (<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPosByBone</span> <span class="params">(Bone * pBone , <span class="keyword">float</span> &amp; outX , <span class="keyword">float</span> &amp; outY , <span class="keyword">float</span> &amp; outZ )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//step1: transform vertex from mesh space to bone space</span></span><br><span class="line">       outX = m_x +pBone -&gt;m_boneOffset .m_offx ;</span><br><span class="line">       outY = m_y +pBone -&gt;m_boneOffset .m_offy ;</span><br><span class="line">       outZ = m_z +pBone -&gt;m_boneOffset .m_offz ;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//step2: transform vertex from bone space to world sapce</span></span><br><span class="line">       outX += pBone -&gt;m_wx ;</span><br><span class="line">       outY += pBone -&gt;m_wy ;</span><br><span class="line">       outZ += pBone -&gt;m_wz ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlendVertex</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//do the vertex blending,get the vertex's pos in world space</span></span><br><span class="line"></span><br><span class="line">       m_wX = <span class="number">0</span>;</span><br><span class="line">       m_wY = <span class="number">0</span>;</span><br><span class="line">       m_wZ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_boneNum ; ++i )        </span><br><span class="line">       &#123;            </span><br><span class="line">       		<span class="keyword">float</span> tx , ty , tz ;            </span><br><span class="line">       		ComputeWorldPosByBone (m_bones [i ], tx , ty , tz );            </span><br><span class="line">       		tx *= m_boneWeights [i ];            </span><br><span class="line">       		ty *= m_boneWeights [i ];            </span><br><span class="line">       		tz *= m_boneWeights [i ];            </span><br><span class="line">       		m_wX += tx ;            </span><br><span class="line">       		m_wY += ty ;            </span><br><span class="line">       		m_wZ += tz ;        </span><br><span class="line">       	&#125;     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">float</span> m_x , m_y , m_z ; </span><br><span class="line">    <span class="comment">//local pos in mesh space     </span></span><br><span class="line">    <span class="keyword">float</span> m_wX , m_wY , m_wZ ; </span><br><span class="line">    <span class="comment">//blended vertex pos, in world space     </span></span><br><span class="line">    <span class="comment">//skin info     </span></span><br><span class="line">    <span class="keyword">int</span> m_boneNum ;     </span><br><span class="line">    Bone * m_bones [MAX_BONE_PER_VERTEX ];     </span><br><span class="line">    <span class="keyword">float</span> m_boneWeights [MAX_BONE_PER_VERTEX ];     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBoneAndWeight</span> <span class="params">( <span class="keyword">int</span> index , Bone * pBone , <span class="keyword">float</span> weight )</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">    	m_bones [index ] = pBone ;        </span><br><span class="line">    	m_boneWeights [index ] = weight ;     </span><br><span class="line">   	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//----------------------------------------------------------- </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkinMesh</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span> :     </span><br><span class="line">    SkinMesh ():m_vertexNum (<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    SkinMesh ( <span class="keyword">int</span> vertexNum ):m_vertexNum (vertexNum )     </span><br><span class="line">    &#123;        </span><br><span class="line">        m_vertexs = <span class="keyword">new</span> Vertex [vertexNum ];     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    ~SkinMesh ()     </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span> (m_vertexNum &gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">delete</span> [] m_vertexs ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateVertices</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">       &#123;</span><br><span class="line">           m_vertexs [i ].BlendVertex ();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawStaticMesh</span> <span class="params">( <span class="keyword">float</span> x , <span class="keyword">float</span> y , <span class="keyword">float</span> z )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">0</span>,<span class="number">1.0</span>,<span class="number">0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z );</span><br><span class="line">       glEnd ();</span><br><span class="line"></span><br><span class="line">       glBegin (GL_LINE_LOOP );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z );</span><br><span class="line">       glEnd ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">1.0</span>,<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ );</span><br><span class="line">       glEnd ();</span><br><span class="line"></span><br><span class="line">       glBegin (GL_LINE_LOOP );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )            glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ );        glEnd ();     &#125;     <span class="keyword">int</span> m_vertexNum ;     Vertex * m_vertexs ; <span class="comment">//array of vertices in mesh &#125;; //-------------------------------------------------------------- Bone * g_boneRoot ; Bone * g_bone1 , *g_bone2 , *g_bone31 , *g_bone32 ; void buildBones () &#123;     g_boneRoot = new Bone (0, 0, 0);     g_bone1 = new Bone (0.2, 0, 0);     g_bone2 = new Bone (0.2, 0, 0);     g_bone31 = new Bone (0.2, 0.1, 0);     g_bone32 = new Bone (0.2, -0.1, 0);     g_boneRoot -&gt;SetFirstChild (g_bone1 );</span></span><br><span class="line">    g_bone1 -&gt;SetFirstChild (g_bone2 );</span><br><span class="line">    g_bone2 -&gt;SetFirstChild (g_bone31 );</span><br><span class="line">    g_bone31 -&gt;SetSibling (g_bone32 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteBones</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> g_boneRoot ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone1 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone2 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone31 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone32 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateBones</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dir =<span class="number">-1</span>, dir2 =<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//animate bones manually</span></span><br><span class="line"></span><br><span class="line">    g_bone1 -&gt;m_y +=<span class="number">0.00001f</span>*dir ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_bone1 -&gt;m_y m_y &gt;<span class="number">0.2</span>)</span><br><span class="line">       dir *=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g_bone32 -&gt;m_x +=<span class="number">0.00001f</span>*dir2 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_bone32 -&gt;m_x m_x &gt;<span class="number">0.2</span>)</span><br><span class="line">       dir2 *=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SkinMesh * g_mesh ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMesh</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> _meshData []=</span><br><span class="line">    &#123; <span class="comment">//x,y,z</span></span><br><span class="line">       <span class="number">-0.1</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.3</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.45</span>,<span class="number">0.06</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.6</span>,<span class="number">0.15</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.65</span>,<span class="number">0.1</span>,<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">0.65</span>,<span class="number">-0.1</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.6</span>,<span class="number">-0.15</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.45</span>,<span class="number">-0.06</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.3</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.1</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">-0.1</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> _skinInfo []=</span><br><span class="line">    &#123; <span class="comment">//bone_num,bone id(0,1,2,31 or 32), bone weight 1~4,</span></span><br><span class="line">       <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">1</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">2</span>,  <span class="number">31</span>, <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">1</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexNum = <span class="keyword">sizeof</span> (_meshData )/( <span class="keyword">sizeof</span> ( <span class="keyword">float</span> )*<span class="number">3</span>);</span><br><span class="line">    g_mesh = <span class="keyword">new</span> SkinMesh (vertexNum );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i m_vertexs [i ].m_x = _meshData [i *<span class="number">3</span>];</span><br><span class="line">       g_mesh -&gt;m_vertexs [i ].m_y = _meshData [i *<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line">       g_mesh -&gt;m_vertexs [i ].m_z = _meshData [i *<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set skin info</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i m_vertexs [i ].m_boneNum = _skinInfo [i *<span class="number">9</span>];</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> j =<span class="number">0</span>; j &lt;g_mesh -&gt;m_vertexs [i ].m_boneNum ; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           Bone * pBone = g_boneRoot ;</span><br><span class="line">           <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">1</span>)</span><br><span class="line">              pBone = g_bone1 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">2</span>)</span><br><span class="line">              pBone = g_bone2 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">31</span>)</span><br><span class="line">              pBone = g_bone31 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">32</span>)</span><br><span class="line">              pBone = g_bone32 ;</span><br><span class="line"></span><br><span class="line">           g_mesh -&gt;m_vertexs [i ].SetBoneAndWeight (j , pBone , _skinInfo [i *<span class="number">9</span>+<span class="number">5</span>+j ]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compute bone offset</span></span><br><span class="line">    g_boneRoot -&gt;ComputeWorldPos (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    g_boneRoot -&gt;ComputeBoneOffset ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> deleteMesh ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> g_mesh ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myInit ()</span><br><span class="line">&#123;</span><br><span class="line">    buildBones ();</span><br><span class="line">    buildMesh ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myQuit ()</span><br><span class="line">&#123;</span><br><span class="line">    deleteBones ();</span><br><span class="line">    deleteMesh ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myReshape ( <span class="keyword">int</span> width , <span class="keyword">int</span> height )</span><br><span class="line">&#123;</span><br><span class="line">    GLfloat h = (GLfloat ) height / (GLfloat ) width ;</span><br><span class="line"></span><br><span class="line">    glViewport (<span class="number">0</span>, <span class="number">0</span>, (GLint ) width , (GLint ) height );</span><br><span class="line">    glMatrixMode (GL_PROJECTION );</span><br><span class="line">    glLoadIdentity ();</span><br><span class="line"><span class="comment">//  glFrustum(-1.0, 1.0, -h, h, 5.0, 60.0);</span></span><br><span class="line">    glFrustum (<span class="number">-1.0</span>, <span class="number">1.0</span>, -h , h , <span class="number">1.0</span>, <span class="number">100.0</span>);</span><br><span class="line">    glMatrixMode (GL_MODELVIEW );</span><br><span class="line">    glLoadIdentity ();</span><br><span class="line">    glTranslatef (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myDisplay ( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    glClear (GL_COLOR_BUFFER_BIT );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw original mesh</span></span><br><span class="line">    g_mesh -&gt;DrawStaticMesh (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//move bones</span></span><br><span class="line">    animateBones ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update all bone's pos in bone tree</span></span><br><span class="line">    g_boneRoot -&gt;ComputeWorldPos (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update vertex pos by bones, using vertex blending</span></span><br><span class="line">    g_mesh -&gt;UpdateVertices ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw deformed mesh</span></span><br><span class="line">    g_mesh -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw bone</span></span><br><span class="line">    g_boneRoot -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    glFlush ();</span><br><span class="line">    glutSwapBuffers ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myIdle ( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    myDisplay ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main ( <span class="keyword">int</span> argc , <span class="keyword">char</span> *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    glutInit (&amp;argc , argv );</span><br><span class="line">    glutInitDisplayMode (GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE );</span><br><span class="line">    glutInitWindowPosition (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    glutInitWindowSize (<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">    glutCreateWindow ( <span class="string">"A simplest skinned mesh DEMO, by happyfirecn@yahoo.com.cn"</span> );</span><br><span class="line"></span><br><span class="line">    glutDisplayFunc (myDisplay );</span><br><span class="line">    glutReshapeFunc (myReshape );</span><br><span class="line">    glutIdleFunc (myIdle );</span><br><span class="line"></span><br><span class="line">    myInit ();</span><br><span class="line">    glutMainLoop ();</span><br><span class="line">    myQuit ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/23/actor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/actor/" class="post-title-link" itemprop="url">Actor模型原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 10:36:48" itemprop="dateCreated datePublished" datetime="2018-03-23T10:36:48+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Actor模型"><a href="#1-Actor模型" class="headerlink" title="1.Actor模型"></a>1.Actor模型</h1><p>在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改（通过消息传递来进行状态修改），所以使用Actors模型进行并发编程可以很好避免这些问题，Actor由状态(state),行为(Behavior)和邮箱(mailBox)三部分组成<br>1.状态(state):Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题<br>2.行为(Behavior):行为指的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态<br>3.邮箱(mailBox):邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送发Actor消息，接收方Actor从邮箱队列中获取消息</p>
<p>Actor的基础就是消息传递</p>
<h1 id="2-使用Actor模型的好处"><a href="#2-使用Actor模型的好处" class="headerlink" title="2.使用Actor模型的好处"></a>2.使用Actor模型的好处</h1><p>1.事件驱动—Actor之间的通信是异步的，即使Actor在发送消息后也无需阻塞或者等待就能够处理其他事件<br>2.强隔离性—Actor中的方法不能由外部部署直接调用，所有的一切都通过消息传递进行的，从而避免了Actor之间的数据共享，想要观察到另一个Actor的状态变化只能通过消息传递进行询问<br>3.位置透明—无论Actor地址实在本地还是在远程机上对于代码来说都是一样的<br>4.轻量性—Actor是非常轻量的计算单机，单个Actor仅占400多字节，只需少量内存就能达到高并发</p>
<h1 id="3-Actor模型原理"><a href="#3-Actor模型原理" class="headerlink" title="3.Actor模型原理"></a>3.Actor模型原理</h1><p>以下通过学生于教师之间的邮件通信来理解akka中的Actor模型</p>
<h2 id="学生-教师的消息传递"><a href="#学生-教师的消息传递" class="headerlink" title="学生-教师的消息传递"></a>学生-教师的消息传递</h2><p>首先只考虑学生单向发送消息给教师（学生—》教师），如下图：<br><img src="http://oxcvfpext.bkt.clouddn.com/actor-1.png"><br>图解：<br>1.学生创建一个ActorSystem<br>2.通过ActorSystem创建ActorRef，将QuoteRequest消息发送到ActorRef(教师代理)<br>3.ActorRef(教师代理)消息传到Dispatcher中<br>4.Dispather依次的将消息发送到TeacherActor邮箱中<br>5.Dispather将邮箱推送到一条线程中<br>6.邮箱取出一条消息并委派给TeacherActor的Receiver方法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/22/thread-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/22/thread-process/" class="post-title-link" itemprop="url">简单介绍多进程和多线程服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-22 20:19:23" itemprop="dateCreated datePublished" datetime="2018-03-22T20:19:23+08:00">2018-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="首先贴下多进程单线程和单进程多线程的特点："><a href="#首先贴下多进程单线程和单进程多线程的特点：" class="headerlink" title="首先贴下多进程单线程和单进程多线程的特点："></a>首先贴下多进程单线程和单进程多线程的特点：</h1><p>多进程：有独立的地址空间，进程之间不共享内存和变量，但可以通过共享内存实现，每个进程只有一个线程，一般用于单机系统开发。<br>多线程：在同一个进程下所有线程可以共享内存和变量。<br>而共同点是，同开辟的进程数/线程数多余系统cpu核数时，无法继续提供应用的性能。<br>而多线程架构的服务器，只要适当将一些任务分出来用新的进程启动，就可以扩展成分布式架构，使用tcp通信即可。当然多进程也可以这么干，通信方式也是使用tcp。<br>而操作系统对于线程的切换是比进程的切换要快。</p>
<h1 id="下面先介绍下多进程单线程服务器架构，以单机系统为例："><a href="#下面先介绍下多进程单线程服务器架构，以单机系统为例：" class="headerlink" title="下面先介绍下多进程单线程服务器架构，以单机系统为例："></a>下面先介绍下多进程单线程服务器架构，以单机系统为例：</h1><p>下贴架构图：<br><img src="http://oxcvfpext.bkt.clouddn.com/thread-process-1.png"><br>一个游戏服大概就有这几个进程。<br>router:作用如其名，路由。每个功能进程启动时，会先连接router,router会给连上来的进程分配一个唯一标识，所有功能进程都是靠这个router进程通信。<br>login:登录服务器，client登录验证在这个进程进行。<br>login:玩家单人逻辑操作处理进程，login会将登录的玩家平台到这些logic上。<br>global_login:全局操作进程，多人玩法的功能，例如战斗匹配，工会等操作会放在这里进行。<br>log:游戏日志输出进程，所有功能进程的日志输出都发到这个进程，log进程会输出到磁盘文件。<br>db:redis作为内存数据库，Mysql作为数据持久化，其它功能进程取数据都会发送请求到db。<br>back:后台进程，集成了一个http服务器。处理http请求，这里可以集成一些第三方服务功能，如gm指令。</p>
<p>以上每个进程都是单线程，所以无需考虑锁的问题。<br>对于每个进程收发数据：<br>    发数据：直接把{target_id:data}发送到router<br>    收数据：帧驱动，如100ms主动向router询问是否有数据，有则取过来处理。<br>单机系统下，如果采用共享内存方式，通信效率将非常高。<br>所以多进程的服务器架构设计起来还是比较简单的。</p>
<h1 id="在介绍下多线程服务器架构，这里我想介绍actor模型。"><a href="#在介绍下多线程服务器架构，这里我想介绍actor模型。" class="headerlink" title="在介绍下多线程服务器架构，这里我想介绍actor模型。"></a>在介绍下多线程服务器架构，这里我想介绍actor模型。</h1><p><img src="http://oxcvfpext.bkt.clouddn.com/thread-process-2.png"><br>一个Actor指的是一个最基本的计算单元。它能接收一个消息并且基于其执行计算。<br>这个理念很像面向对象语言，一个对象接受一条消息（方法调用），然后根据接受的消息做事（调用了哪个方法）。<br>Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。<br>每个Actor都有一个邮箱，用于接受其他actor发送的消息。</p>
<p>这里重点讲一下Actor模型的调度是怎样做的。<br>Actor模型实际上可以有成千上万个，但目前一台通用服务器最多只有24核，当然不可能也开成千上万个线程。</p>
<p>我们可以把Actor简单想象成这样一个类实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetch_msg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> actor_id;</span><br><span class="line">        <span class="built_in">string</span> actor_name;</span><br><span class="line">        <span class="built_in">list</span>&lt;msg&gt; msg_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Actor定义了自己实现的功能(process_1,process_2)<br>当msg_queue邮箱有消息到来的时候，就调用fetch_msg取获取这些消息进程处理。<br>这一步就靠调度线程来做了。</p>
<p>Actor模型的调度实现起码要有：<br>    1.一个位于主线程的Actor队列，如global_queue<actor*> gq,当某个Actor收到消息时，就会被放进这个gp，等待工作线程进行调度。<br>    2.n个工作线程，这个就要根据机器的核数来决定开多少个了，例如只是一台双核的机器，那么开一个就好了，开多了会浪费时间在线程切换上，得不尝试。<br>每个工作线程做的事件很简单，向主线程询问任务，获取任务，处理任务，然后又继续询问，大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    task_list = fetch_task();</span><br><span class="line">    process_task(task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></actor*></p>
<p>所以一个Actor的创建和调度过程如下：<br>1.在主线程创建并放入管理列表<br>2.其他actor往本actor发送消息，消息进入msg_queue,本actor进入global_queue等待调度。<br>3.有工作线程处理完一堆任务了，向主线程询问任务，主线程把本actor分配给这个工作线程。<br>4.该工作线程取出msg，调用actor相应处理函数处理这个消息。</p>
<p>所以可见，actor数目于工作线程数目没有必然的关系，当然理想状态是，每个actor都有自己的处理线程，这里有消息来到时，就可以马上处理，不用等待。</p>
<p>理论上，actor开的越多，业务逻辑就分的越细，每次处理的时间就越短，只要actor的数目超过线程数，就可以最大限度利用多核的优势，cpu的调度就越充分。所以actor模型设计关键在于如何将业务逻辑平摊到更多的actor上，而不是集中，例如上面提到global_logic是多人玩法的业务逻辑，只要一细分，可以分成帮会actor,组队actor,战斗actor等等，这样三个消息同时就有机会被三个cpu处理，而不是固定只有一个。</p>
<p>Actor可以理解成用户级别的进程，于操作系统级别的进程分离，即使开很多Actor，只要工作线程数目设计合理（&lt;=系统cpu核数),就能保证线程能一直在同一个cpu上进行操作，减少线程切换的消耗，这对于cpu核数小的机器非常游泳，而对于像24核的机器，因为开辟的线程数是配置的，所以也很好规划一台机器能部署多少个服。<br>而多线程如果要对某些功能进程扩展，如增加login,增加Logic,就是要增加一个系统线程，一旦进程超过cpu核，就会有时间浪费在切换线程上了，这是一个缺点。<br>而Actor模型本身是优秀的，但是Actor的调度算法会有很多中实现，而且必然涉及到锁的涉及，这就需要设计者的设计功力了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/21/JVM-heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/21/JVM-heap/" class="post-title-link" itemprop="url">JVM的新生代、老年代、MinorGC、MajorGC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-21 17:30:17" itemprop="dateCreated datePublished" datetime="2018-03-21T17:30:17+08:00">2018-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JVM中的堆，一般分为三大部分：新生代、老年代、永久代：<br>一、新生代<br>主要时用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁发MinorGC进行垃圾回收。<br>新生代又分为Eden区、ServivorFrom、ServivorTo三个区。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
