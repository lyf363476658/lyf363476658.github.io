<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/12/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/The-Effects-Framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/The-Effects-Framework/" class="post-title-link" itemprop="url">第十九章 效果架构(The Effects Framework)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:35:43" itemprop="dateCreated datePublished" datetime="2019-04-11T15:35:43+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一个渲染效果一般由以下部分组成：一个顶点和/或像素着色器，一个需要设置的设备状态列表，一个或更多的渲染通道（rendering passes）。此外，有一个能在不同级别的图形硬件上渲染效果的可靠机制通常是值得的（也就是说，有不同的可用的效果版本执行同样的效果或尽可能尝试执行同样的效果）。显然，所有这些必要的任务组合在一起成为一个效果。因此，一个合理的做法是，设法将这些任务封装到一个单元中。<br>Direct3D效果构架提供了这样一个机制：将渲染效果的任务封装到一个效果文件。在效果文件中实现效果有两方面优势。其一，它允许我们不必重编译应用程序就能改变一个效果的执行。这是一种更新效果的过程，不管是修正一个bug，一些简单的加强，或者利用最新的3D硬件特性。第二，它将所有的效果组成部分封装到一个文件。<br>这一章指导你用必要信息和步骤，编写和创建一个效果文件的。我们注意到效果文件象我们的HLSL程序一样可以写在任何ASCII文件中。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>理解一个效果文件的结构和组织</li>
<li>找到HLSL中的一些额外的对象</li>
<li>学习如何在效果文件中指定设备状态</li>
<li>学习如何创建并使用一个效果</li>
<li>通过学习一些例子程序，取得使用效果框架上的一些经验<h1 id="技术与传递（Techniques-and-Passes）"><a href="#技术与传递（Techniques-and-Passes）" class="headerlink" title="技术与传递（Techniques and Passes）"></a>技术与传递（Techniques and Passes）</h1>一个效果文件由一个或多个技术组成。一个技术是用一个特殊的方法渲染一些特效。所以换句话说，一个效果文件提供了渲染相同特效的一个或多个不同的传递。为什么同样的效果需要几个不同实现呢？是的，一些硬件可能不支持一个效果的一种特定实现。因此，必需在不同硬件上实现相同效果的不同版本。<br>注意：例如，我们可能实现一种效果的两个版本，一种用着色器实现而一种用固定管线实现。这样，那些有着色器（shader）支持的显卡用户能够利用着色器实现，而那些不支持着色器的用户仍然可以使用固定管线实现。<br>可以在一个效果文件中实现所有版本的效果，这让我们更完整的封装了所有的效果，也是效果框架的目标之一 ―― 封装（encapsulation）。<br>每种技术包括一次或多次渲染传递（passes）。一次渲染传递（rendering pass）在特定传递（pass）中封装了设备状态、采样器、和/或用于渲染几何体的着色器。<br>注意：一个效果不仅限于可编程管线使用。例如，它可以使用固定功能管线控制设备状态，比如灯光、材质以及纹理。<br>使用多次传递（multiple passes）的理由是，因为对每种特效，是通过使用不同的设备状态、着色器等等，对同样的几何体进行多次渲染来完成的。举例来说，回忆第8章 ，我们不得不在每帧里用不同的设备状态、多次渲染相同的几何体，以达到反射效果。</li>
</ul>
<p>这个例子，是一个用两种技术实现的效果文件的框架，第一种技术包括一次传递而每二种技术包括两次传递:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// effect.txt</span></span><br><span class="line"></span><br><span class="line">technique T0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first and only pass for this technique</span></span><br><span class="line">    pass P0</span><br><span class="line">    &#123;</span><br><span class="line">        [specify pass device states, shaders, samplers, etc.]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">technique T1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first pass</span></span><br><span class="line">    pass P0</span><br><span class="line">    &#123;</span><br><span class="line">        [specify pass device states, shaders, samplers, etc.]</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// second pass</span></span><br><span class="line">    pass P1</span><br><span class="line">    &#123;</span><br><span class="line">        [specify pass device states, shaders, samplers, etc.]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更多HLSL内置对象（-More-HLSL-Intrinsic-Objects）"><a href="#更多HLSL内置对象（-More-HLSL-Intrinsic-Objects）" class="headerlink" title="更多HLSL内置对象（ More HLSL Intrinsic Objects）"></a>更多HLSL内置对象（ More HLSL Intrinsic Objects）</h2><p>这是一些在HLSL中额外的内建对象类型。我们以前没有过早的提及，是因为它们主要用于效果框架。</p>
<h3 id="纹理对象"><a href="#纹理对象" class="headerlink" title="纹理对象"></a>纹理对象</h3><p>   HLSL内建纹理类型描述了一个IDirect3DTexture9对象。通过使用纹理对象我们可以直接地在效果文件中对特定的采样器阶段结合纹理。纹理对象有下面的可以访问的数据成员：</p>
<ul>
<li>type—纹理类型 (例如：2D, 3D)</li>
<li>format—纹理的像素格式</li>
<li>width—纹理的宽度（单位像素）</li>
<li>height—纹理的高度（单位像素）</li>
<li>depth—纹理的深度（如果是3D纹理，单位像素）</li>
</ul>
<p>注意：迄今为止我们仅仅使用纹理来存贮图形数据，但是当你学到更高级的技术，你会发现纹理可用来保存任意表格信息。换句话说，纹理仅是数据表，不是必须包含图形数据。例如，在碰撞映射（bump mapping）时我们用到一种叫做法线图的东东（normal map），就是一种在每个点上包括了法向量的纹理。</p>
<h3 id="采样器对象与采样器状态"><a href="#采样器对象与采样器状态" class="headerlink" title="采样器对象与采样器状态"></a>采样器对象与采样器状态</h3><p>我们在18章讨论了采样器对象，然而，效果框架定义了新的关键字：sampler_state。使用sampler_state关键字，我们能初始化一个采样器对象（即，直接在效果方件中设置采样器对象的纹理和状态）。下面的例子说明了这点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Texture Tex;</span><br><span class="line">sampler SO = sampler_state</span><br><span class="line">&#123;</span><br><span class="line">     Texture = (Tex);  <span class="comment">// 纹理</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 采样器状态</span></span><br><span class="line">     MinFilter = LINEAR;</span><br><span class="line">     MagFilter = LINEAR;</span><br><span class="line">     MipFilter = LINEAR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>这里我们给采样器S0的texture成员关联了纹理 Tex，并给状态成员设置了采样状态。我们直接明了的在效果文件中设置所有信息。
</code></pre><h3 id="顶点与像素着色器对象（Vertex-and-Pixel-Shader-Objects）"><a href="#顶点与像素着色器对象（Vertex-and-Pixel-Shader-Objects）" class="headerlink" title="顶点与像素着色器对象（Vertex and Pixel Shader Objects）"></a>顶点与像素着色器对象（Vertex and Pixel Shader Objects）</h3><p>vertexshader 和 pixelshader是HLSL的内建类型，分别表示顶点着色器和像素着色器。它们在效果文件中表示特定顶点和/或像素着色器，用于一个特定的渲染传递(pass)。vertexshader和/或pixelshader类型在应用程序中用ID3DXEffect::SetVertexShader和ID3DXEffect::SetPixelShader函数分别设置。例如，在效果文件中，让Effect是一个有效的ID3DXEffect对象，让VS是一个有效的IDirect3DVertexShader9对象，以及让VSHandle是一个D3DXHANDLE（是vertexshader 对象的引用）。然后，我们可以通过如下写法初始化VSHandle所引用的顶点着色器：<br>Effect-&gt;SetVertexShader(VSHandle, VS);<br>当在应用程序中设置效果文件中的变量时，多数时候我们使用SetVertexShader 和 SetPixelShader。<br>做为选择，我们可以直接在效果文件中写顶点和/或像素着色器。当使用一种特定的编译语法时，我们可以设置一个着色器变量。下面的例子展示了如何初始化一个pixelshader类型的变量ps。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义入口函数</span></span><br><span class="line"><span class="function">OUTPUT <span class="title">Main</span><span class="params">(INPUT input)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译入口函数</span></span><br><span class="line">pixelshader ps = compile ps_2_0 Main();</span><br></pre></td></tr></table></figure></p>
<p>观察在pixelshader关键字之后的特定的版本名，接下来是着色器入口函数。注意，当用这种方式（style）初始化一个顶点或像素着色器对象时，入口函数必须定义在效果文件中。</p>
<p>最后，我们给一个特定传递关联一个着色器，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义入口函数</span></span><br><span class="line"><span class="function">OUTPUT <span class="title">Main</span><span class="params">(INPUT input)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译入口函数</span></span><br><span class="line">vertexshader vs = compile vs_2_0 Main();</span><br><span class="line"></span><br><span class="line">pass P0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 给这个传递（pass）关联一个着色器（vs）</span></span><br><span class="line">    vertexshader = (vs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者更简洁的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pass P0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置这个传递的顶点着色器，为入口函数" Main()"的顶点着色器</span></span><br><span class="line">    vertexshader = compile vs_2_0 Main();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：这是一个相当有价值的论述，因此你至少要明白，你能用这样的语法来初始化一个vertexshader 和 pixelshader 类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vertexshader vs = <span class="keyword">asm</span> &#123; <span class="comment">/*assembly instructions go here */</span> &#125;;</span><br><span class="line">pixelshader ps = <span class="keyword">asm</span> &#123; <span class="comment">/*assembly instructions go here */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果你用汇编语言来写着色器，你就用这种语法。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>最后，这是一个字符串对象，它的用法是这样地：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> filename = <span class="string">"texName.bmp"</span>;</span><br></pre></td></tr></table></figure></p>
<p>尽管没有任何HLSL的内建函数支持字符串类型，但它可以在应用程序中读取。这样，我们能进一步封装效果使用的数据文件，比如纹理文件名和X文件字。</p>
<h3 id="注解-Annotations"><a href="#注解-Annotations" class="headerlink" title="注解 (Annotations)"></a>注解 (Annotations)</h3><p>除我们已经描述过的语义符之外，注解可以用在变量上。注解在HLSL中是不使用的，但是它们可以被应用程序通过效果框架访问。它们仅仅服务于一个绑定 “note”的变量，这样应用程序就能够访问这个变量了。为注解加入了<annotation>语法。下面一行举例说明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texture tex0 &lt; <span class="built_in">string</span> name = <span class="string">"tiger.bmp"</span>; &gt;;</span><br></pre></td></tr></table></figure></annotation></p>
<p>在这个例子中的注解是<string name="tiger. bmp" ;>。它关联了一个字符串到变量tex0，即保存纹理数据的文件名。很明显，用相应的文件名注解一个纹理是有益的。<br>注解可以使用下面函数被重新得到：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D3DXHANDLE ID3DXEffect::GetAnnotationByName(</span><br><span class="line">     D3DXHANDLE hObject,</span><br><span class="line">     LPCSTR pName</span><br><span class="line">);</span><br></pre></td></tr></table></figure></string></p>
<p>pName是我们要操作的注解的名字，而hObject是注解所在的父块句柄，如一个technique、pass或者结构块。一旦我们有了一个注解的句柄，我们就能通过应用ID3DXEffect::GetParameterDesc得到有关它的信息。查看DirectX SDK文档以得到更多详细的内容。</p>
<h2 id="效果文件的设备状态（-Device-States-in-an-Effect-File）"><a href="#效果文件的设备状态（-Device-States-in-an-Effect-File）" class="headerlink" title="效果文件的设备状态（ Device States in an Effect File）"></a>效果文件的设备状态（ Device States in an Effect File）</h2><p>通常，为了正确执行一个效果，我们必须设置设备的状态，比如渲染状态、纹理状态、材质、灯光和纹理。将全部效果封装进一个文件使它有支持全部效果的能力，效果框架允许我们在效果文件中设置设备状态。设备状态被在渲染的传递部分（pass block）里设置，语法看起来象这样：<br>State= Value;<br>对于完整的状态的列表，在DirectX SDK文档的索引（index）中查找”states”，或者从SDK的目录（Contents）标签下，查找DirectX Graphics\Reference\Effect Reference\Effect Format\States<br>考虑FillMode状态。如果你看了一下刚刚提到的SDK中的内容，值与D3DFILLMODE一样，但没有D3DFILL_前缀。如果我们在SDK文档中查找D3DFILLMODE，我们找到值：D3DFILL_POINT, D3DFILL_WIREFRAME, and D3DFILL_SOLID。因而，对于效果文件我们省略了前缀，并获得下列状态FillMode的有效值：POINT, WIREFRAME, 和 SOLID。例如，你可以在效果文件中这么写-：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FillMode = WIREFRAME;</span><br><span class="line">FillMode = POINT;</span><br><span class="line">FillMode = SOLID;</span><br></pre></td></tr></table></figure></p>
<p>注意：在后面的小节中我们将在例子程序中设置几个设备状态。多数时候能够通过状态的名字猜到它的用途，但如果你想得到更详细的描述，请查看SDK文档。</p>
<h2 id="创建效果"><a href="#创建效果" class="headerlink" title="创建效果"></a>创建效果</h2><pre><code>效果用ID3DXEffect接口表示，我们用下面的D3DX函数创建它：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateEffectFromFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPCSTR pSrcFile,</span></span></span><br><span class="line"><span class="function"><span class="params">     CONST D3DXMACRO* pDefines,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXINCLUDE pInclude,</span></span></span><br><span class="line"><span class="function"><span class="params">     DWORD Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXEFFECTPOOL pPool,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXEFFECT* ppEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXBUFFER *ppCompilationErrors</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pDevice—被创建的ID3DXEffect对象所关联的设备</li>
<li>pSrcFile—我们要编译的包括效果源代码的文本文件的名字（效果文件名）</li>
<li>pDefines—这个参数是可选的，在本书中指定为null</li>
<li>pInclude—ID3DXInclude接口指针。这个接口被设计成由应用程序执行，因而我们可以替换默认行为。通常，默认行为就挺好，我们可以指定null忽略这个参数。</li>
<li>Flags—编译效果文件中的shader的选项标志，指定0为没有标志。有效选项为：<br>o D3DXSHADER_DEBUG—指示编译器写入调试信息<br>o D3DXSHADER_SKIPVALIDATION—指示编译器不做任何代码检测。这只在你正在用到一个已知正常工作的shader时使用。<br>o D3DXSHADER_SKIPOPTIMIZATION—指示编译器不执行任何优化。实际上这只用于调试时，当你不想让编译器对代码做任何更改时。</li>
<li>pPool—可选的ID3DXEffectPool接口指针，用于指定效果参数如何共享其它的效果实例。本例中指定null，表示我们不在参数与效果文件之间共享。</li>
<li>ppEffect—返回一个ID3DXEffect接口指针，表示被创建的效果。</li>
<li>ppCompilationErrors—返回一个包含错误代码字符串和消息的ID3DXBuffer指针。</li>
</ul>
<p>这是一个调用D3DXCreateEffectFromFile的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修建效果</span></span><br><span class="line">ID3DXEffect* Effect = <span class="number">0</span>;</span><br><span class="line">ID3DXBuffer* errorBuffer = <span class="number">0</span>;</span><br><span class="line">hr = D3DXCreateEffectFromFile(</span><br><span class="line">     Device,           <span class="comment">// 关联的设备</span></span><br><span class="line">     <span class="string">"effect.txt"</span>,     <span class="comment">// 效果源文件</span></span><br><span class="line">     <span class="number">0</span>,                <span class="comment">// no preprocessor definitions</span></span><br><span class="line">     <span class="number">0</span>,                <span class="comment">// no ID3DXInclude interface</span></span><br><span class="line">     D3DXSHADER DEBUG, <span class="comment">// 编译标记</span></span><br><span class="line">     <span class="number">0</span>,                <span class="comment">// 不共享参数</span></span><br><span class="line">     &amp;Effect,          <span class="comment">// 返回创建效果的指针</span></span><br><span class="line">     &amp;errorBuffer);    <span class="comment">// 返回的错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出错误信息</span></span><br><span class="line"><span class="keyword">if</span>( errorBuffer )</span><br><span class="line">&#123;</span><br><span class="line">     ::MessageBox(<span class="number">0</span>, (<span class="keyword">char</span>*)errorBuffer-&gt;GetBufferPointer(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">    ::MessageBox(<span class="number">0</span>, <span class="string">"D3DXCreateEffectFromFile() - FAILED"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="设置系数（Setting-Constants）"><a href="#设置系数（Setting-Constants）" class="headerlink" title="设置系数（Setting Constants）"></a>设置系数（Setting Constants）</h2><p>因为对于顶点和像素着色器，我们需要从程序代码中初始化效果文件中的变量。代替使用常量表，就象我们在顶点和像素着色器中做的那样，ID3DXEffect接口中有内建的设置变量的方法。我们这里不会列出所有的设置不同类型变量的方法，因为要完全列出实在是大多了—请查看DirectX SDK文档以获得完整列表。这里是一个删节的列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::SetFloat(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    FLOAT f</span><br><span class="line">);</span><br><span class="line">Sets a floating-point variable in the effect file identified by hParameter to the value f </span><br><span class="line">HRESULT ID3DXEffect::SetMatrix(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    CONST D3DXMATRIX* pMatrix</span><br><span class="line">);</span><br><span class="line">Sets a matrix variable in the effect file identified by hParameter to the value pointed to by pMatrix </span><br><span class="line">HRESULT ID3DXEffect::SetString(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    CONST LPCSTR pString</span><br><span class="line">);</span><br><span class="line">Sets a matrix variable in the effect file identified by hParameter to the value pointed to by pString </span><br><span class="line">HRESULT ID3DXEffect::SetTexture(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    LPDIRECT3DBASETEXTURE9 pTexture</span><br><span class="line">);</span><br><span class="line">Sets a texture variable in the effect file identified by hParameter to the value pointed to by pTexture </span><br><span class="line">HRESULT ID3DXEffect::SetVector(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    CONST D3DXVECTOR4* pVector</span><br><span class="line">);</span><br><span class="line">Sets a <span class="built_in">vector</span> variable in the effect file identified by hParameter to the value pointed to by pVector </span><br><span class="line">HRESULT ID3DXEffect::SetVertexShader(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    LPDIRECT3DVERTEXSHADER9</span><br><span class="line">      pVertexShader</span><br><span class="line">);</span><br><span class="line">Sets a vertex shader variable in the effect file identified by hParameter to the value pointed to by pVertexShader </span><br><span class="line">HRESULT ID3DXEffect::SetPixelShader(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    LPDIRECT3DPIXELSHADER9 pPShader</span><br><span class="line">);</span><br><span class="line">Sets a pixel shader variable in the effect file identified by hParameter to the value pointed to by pPShader</span><br></pre></td></tr></table></figure></p>
<p>我们通过下面的方法得到变量（又叫效果参数effect parameters）句柄：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D3DXHANDLE ID3DXEffect::GetParameterByName(</span><br><span class="line">    D3DXHANDLE hParent, <span class="comment">// scope of variable - parent structure</span></span><br><span class="line">    LPCSTR pName        <span class="comment">// name of variable</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>它的用法与D3DXConstantTable::GetConstantByName方法一样。即每一个参数是一个D3DXHANDLE，它标识我们想得到的在哪个父结构中的变量句柄。对于没有父结构的全局变量，我们指定null。第二个参数是在效果文件中所显示的变量名。<br>做为例子，以下显示如何设置效果文件中的一些变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some data to set</span></span><br><span class="line">D3DXMATRIX M;</span><br><span class="line">D3DXMatrixIdentity(&amp;M);</span><br><span class="line"></span><br><span class="line"><span class="function">D3DXVECTOR4 <span class="title">color</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">IDirect3DTexture9* tex = <span class="number">0</span>;</span><br><span class="line">D3DXCreateTextureFromFile(Device, <span class="string">"shade.bmp"</span>, &amp;tex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get handles to parameters</span></span><br><span class="line">D3DXHANDLE MatrixHandle = Effect-&gt;GetParameterByName(<span class="number">0</span>, <span class="string">"Matrix"</span>);</span><br><span class="line">D3DXHANDLE MtrlHandle   = Effect-&gt;GetParameterByName(<span class="number">0</span>, <span class="string">"Mtrl"</span>);</span><br><span class="line">D3DXHANDLE TexHandle    = Effect-&gt;GetParameterByName(<span class="number">0</span>, <span class="string">"Tex"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set parameters</span></span><br><span class="line">Effect-&gt;SetMatrix(MatrixHandle, &amp;M);</span><br><span class="line">Effect-&gt;SetVector(MtrlHandle, &amp;color);</span><br><span class="line">Effect-&gt;SetTexture(TexHandle, tex);</span><br></pre></td></tr></table></figure></p>
<p>注意：对每一个ID3DXEffect::Set<em>方法都有相应的ID3DXEffect::Get</em>方法用来取得效果文件中的变量值。例如，为得到一个距阵类型的变量，我们可以用这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::GetMatrix(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    D3DXMATRIX* pMatrix</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>要取得所有的方法列表，查看DirectX SDK文档。</p>
<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><pre><code>在这一节和它的小节，我们展示一旦一个效果被创建出来后如何使用它。下面步骤概述了全部过程：
</code></pre><ol>
<li>得到一个在你想使用的效果文件中的技术句柄。</li>
<li>激活想得到的技术。</li>
<li>启动当前活动的技术。</li>
<li>对每个激活技术中的渲染传递，渲染想要的几何体。回想一下，技术可能由几个渲染传递组成，我们必须在每个传递中渲染一次几何体。</li>
<li>结束当前激活的技术。</li>
</ol>
<h3 id="获得效果句柄（-Obtaining-a-Handle-to-an-Effect）"><a href="#获得效果句柄（-Obtaining-a-Handle-to-an-Effect）" class="headerlink" title="获得效果句柄（ Obtaining a Handle to an Effect）"></a>获得效果句柄（ Obtaining a Handle to an Effect）</h3><p>使用技术的第一步是获得一个技术D3DXHANDLE。可以用这个方法得到一个技术句柄：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D3DXHANDLE ID3DXEffect::GetTechniqueByName(</span><br><span class="line">    LPCSTR pName <span class="comment">// Name of the technique.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>注意：实际上，一个效果文件包括几个技术，每一个都被针对一个特定的硬件能力设计。因此，应用程序通常在系统上运行一些能力测试，然后通过这些测试选择最好的技术。看下面小节中的ID3DXEffect::ValidateTechnique。</p>
<h3 id="激活一个效果（-Activating-an-Effect）"><a href="#激活一个效果（-Activating-an-Effect）" class="headerlink" title="激活一个效果（ Activating an Effect）"></a>激活一个效果（ Activating an Effect）</h3><p>一旦得到了想要的技术的句柄，我们必须激活这个技术。这可以通过下面方法实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::SetTechnique(</span><br><span class="line">    D3DXHANDLE hTechnique <span class="comment">// Handle to the technique to set.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>注意：在激活一项技术前你可能想用现有设备验证它。也就是说，你也许想确保硬件支持的特色、配置技术的使用。你可以用下面的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::ValidateTechnique(</span><br><span class="line">    D3DXHANDLE hTechnique <span class="comment">// Handle to the technique to validate.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>回想一个效果文件可能有几个技术，每个偿试用不同的硬件特色执行一个特定效果，希望最少一个技术将在用户系统上执行。对于一个效果，你将遍例每一个技术并用ID3DXEffect::ValidateTechnique运行它，因而你能检测哪个技术是被支持的而哪个不被支持，然后进行适当的动作。</p>
<h3 id="启动效果"><a href="#启动效果" class="headerlink" title="启动效果"></a>启动效果</h3><p>为了使用一个效果渲染几何体，我们必须围绕绘图函数在ID3DXEffect::Begin 和 ID3DXEffect::End技术间调用。这些函数就是分别开启和关闭效果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::Begin(</span><br><span class="line">    UINT* pPasses,</span><br><span class="line">    DWORD Flags</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>pPasses—返回在当前活动的技术中的传递的数量。</li>
<li>Flags—下面标志的任何一个：<br>o Zero (0)—指定效果保存当前设备状态和着色状态，并在效果结束（这时ID3DXEffect::End被调用）后恢复它们。因为效果文件能够改变状态，对于可以保存启动效果前的状态来说，是很有用的。<br>o D3DXFX_DONOTSAVESTATE—指示效果不保存和恢复设备状态（除shader状态外）。<br>o D3DXFX_DONOTSAVESHADERSTATE—指示效果不保存和恢复shader状态。</li>
</ul>
<h3 id="设置当前的渲染传递（Setting-the-Current-Rendering-Pass）"><a href="#设置当前的渲染传递（Setting-the-Current-Rendering-Pass）" class="headerlink" title="设置当前的渲染传递（Setting the Current Rendering Pass）"></a>设置当前的渲染传递（Setting the Current Rendering Pass）</h3><p>在我们用效果渲染任何几何体前，我们必须指定使用的渲染传递。回想一个技术包括一个或多个渲染传递，每一个传递封装了不同的设备状态、采样器、和/或用于这一传递的着色器。渲染传递通过下面方法指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::Pass(</span><br><span class="line">     UINT iPass <span class="comment">// Index identifying the pass.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>一个技术的渲染传递被用标识为0…n-1的索引，共n个传递。因而，我们能用一个简单的循环遍例每一个传递，并用这一传递渲染几何体。19.6.6节有一个例子。</p>
<h3 id="结束效果（Ending-an-Effect）"><a href="#结束效果（Ending-an-Effect）" class="headerlink" title="结束效果（Ending an Effect）"></a>结束效果（Ending an Effect）</h3><p>最后，对于每个传递，我们渲染完几何体后，停止并结束效果时使用ID3DXEffect::End方法：<br>HRESULT ID3DXEffect::End(VOID);</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面的代码片断示例了以上的使用一个效果的必要的五个步骤：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效果文件中</span></span><br><span class="line">technique T0</span><br><span class="line">&#123;</span><br><span class="line">    pass P0</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在应用程序中，取得技术句柄</span></span><br><span class="line">D3DXHANDLE hTech = <span class="number">0</span>;</span><br><span class="line">hTech = Effect-&gt;GetTechniqueByName(<span class="string">"TO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活技术</span></span><br><span class="line">Effect-&gt;SetTechnique(hTech );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动激活的技术</span></span><br><span class="line">UINT numPasses = <span class="number">0</span>;</span><br><span class="line">Effect-&gt;Begin(&amp;numPasses, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍例每个传递</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPasses; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置当前传递</span></span><br><span class="line">    Effect-&gt;Pass(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在传递中渲染几何体</span></span><br><span class="line">    Sphere-&gt;Draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束效果</span></span><br><span class="line">Effect-&gt;End();</span><br></pre></td></tr></table></figure>
<h2 id="例子程序-Lighting-and-Texturing-in-an-Effect-File"><a href="#例子程序-Lighting-and-Texturing-in-an-Effect-File" class="headerlink" title="例子程序: Lighting and Texturing in an Effect File"></a>例子程序: Lighting and Texturing in an Effect File</h2><p>做为热身，让我们创建一个在3D模型中操作灯光和纹理的效果文件。这个例子完全运行于固定功能管线，意味着效果框架不仅限于使用着色器。图19.1展示了使用灯光和纹理例子的屏幕截图。</p>
<p>图19.1: 灯光和纹理例子的屏幕截图. 纹理、材质和灯光状态在效果文件中指定。</p>
<p>以下是效果文件的实现：<br>// File: light tex.txt<br>// Desc: 效果文件控制光的设备状态，和纹理一个3D模型<br>?<br>// 全局变量<br>matrix WorldMatrix;<br>matrix ViewMatrix;<br>matrix ProjMatrix;<br>?<br>texture Tex;<br>?<br>// 过滤器<br>?<br>// Associated the texture ‘Tex’ with the texture stage ‘S0’<br>// corresponds with and also set the sampler states for the sampler<br>// stage ‘S0’ corresponds with.<br>sampler S0 = sampler state<br>{<br>     Texture   = (Tex);<br>     MinFilter = LINEAR;<br>     MagFilter = LINEAR;<br>     MipFilter = LINEAR;<br>};</p>
<p>// Effect<br>technique LightAndTexture<br>{<br>     pass P0<br>     {<br>          // Set misc. render states.?<br>          pixelshader      = null;   // No pixel shader.<br>          vertexshader     = null;   // No vertex shader.<br>          fvf = XYZ | Normal | Tex1; // Flexible vertex format<br>          Lighting         = true;   // Enable lighting.<br>          NormalizeNormals = true;   // Renormalize normals.<br>          SpecularEnable   = false;  // Disable specular highlights.</p>
<pre><code>      // Set transformation states?
      WorldTransform[0]   = (WorldMatrix);
      ViewTransform       = (ViewMatrix);
      ProjectionTransform = (ProjMatrix);

      // Set a light source at light index 0. We fill out all the
      // components for light[0] because the Direct3D
      // documentation recommends filling out all components
      // for best performance.?
      LightType[0]         = Directional;
      LightAmbient[0]      = {0.2f, 0.2f, 0.2f, 1.0f};
      LightDiffuse[0]       = {1.0f, 1.0f, 1.0f, 1.0f};
      LightSpecular[0]     = {0.0f, 0.0f, 0.0f, 1.0f};
      LightDirection[0]     = {1.0f, -1.0f, 1.0f, 0.0f};
      LightPosition[0]      = {0.0f, 0.0f, 0.0f, 0.0f};
      LightFalloff[0]        = 0.0f;
      LightRange[0]        = 0.0f;
      LightTheta[0]        = 0.0f;
      LightPhi[0]          = 0.0f;
      LightAttenuation0[0]  = 1.0f;
      LightAttenuation1[0]  = 0.0f;
      LightAttenuation2[0]  = 0.0f;
</code></pre><p>?<br>          // Finally, enable the light:?<br>          LightEnable[0] = true;<br>?<br>          // Set material components. This is like calling<br>          // IDirect3DDevice9::SetMaterial.?<br>          MaterialAmbient  = {1.0f, 1.0f, 1.0f, 1.0f};<br>          MaterialDiffuse  = {1.0f, 1.0f, 1.0f, 1.0f};<br>          MaterialEmissive = {0.0f, 0.0f, 0.0f, 0.0f};<br>          MaterialPower    = 1.0f;<br>          MaterialSpecular = {1.0f, 1.0f, 1.0f, 1.0f};<br>?<br>          // Hook up the sampler object ‘S0’ to sampler stage 0,<br>          // which is given by Sampler[0].?<br>          Sampler[0] = (S0);<br>     }<br>}</p>
<pre><code>在这个效果文件中我们主要设置设备状态，就象在19.3节所述。例如，我们直接在效果文件中设置一个光源和一个材质。此外，我们指定转换距阵和纹理及采样器状态。这些状态被指定，然后用LightAndTexture方法和渲染传递P0渲染全部几何体，。
</code></pre><p>   注意：考虑到在一个效果文件中涉及到的的变量，你必须把它们装入圆括号中。举例来说，涉及到距阵变量，你必须这样写：(WorldMatrix), (ViewMatrix), and (ProjMatrix)。不使用圆括号是违法的。</p>
<p>   因为大部分必需的和繁琐的工作都在效果文件里做了，比如设置灯光、材质和纹理。应用程序代码就是做一些创建效果和开启效果等简单的事情。例子中有下面一些相关的全局变量：<br>ID3DXEffect* LightTexEffect   = 0;</p>
<p>D3DXHANDLE WorldMatrixHandle  = 0;<br>D3DXHANDLE ViewMatrixHandle   = 0;<br>D3DXHANDLE ProjMatrixHandle   = 0;<br>D3DXHANDLE TexHandle          = 0;</p>
<p>D3DXHANDLE LightTexTechHandle = 0;</p>
<p>　　?这些东西很没劲 ——- 只是一个ID3DXEffect指针和一些句柄。LightTexTechHandle是一个技术的句柄，因此在它的名字中有子字符串“Tech”。</p>
<p>   RestoreDeviceObjects函数执行三个主要步骤：创建效果，获得作为效果参数的我们要用的技术的句柄，并初始化一些效果参数。下面是删节的实现：<br>bool Setup()<br>{<br>    HRESULT hr = 0;<br>　　// …省略了采样器的读取<br>?<br>    // 创建效果<br>    ID3DXBuffer<em> errorBuffer = 0;<br>    hr = D3DXCreateEffectFromFile(<br>        m_pd3dDevice ,<br>        “light_tex.txt”,<br>        0,                // 没有定义预处理器<br>        0,                // 没有ID3DXInclude接口<br>        D3DXSHADER_DEBUG, // 编译标记<br>        0,                // 不共享参数<br>        &amp;m_LightTexEffect,<br>        &amp;errorBuffer);<br>?<br>    // 输出错误信息<br>    if( errorBuffer )<br>    {<br>        ::MessageBox(0, (char</em>)errorBuffer-&gt;GetBufferPointer(), 0, 0);<br>        SAFE_RELEASE(errorBuffer);<br>    }<br>?<br>    if(FAILED(hr))<br>    {<br>        ::MessageBox(0, “D3DXCreateEffectFromFile() - FAILED”, 0, 0);<br>        return false;<br>    }<br>?<br>    // 保存经常访问的参数句柄<br>    m_WorldMatrixHandle  = m_LightTexEffect-&gt;GetParameterByName(0, “WorldMatrix”);<br>    m_ViewMatrixHandle   = m_LightTexEffect-&gt;GetParameterByName(0, “ViewMatrix”);<br>    m_ProjMatrixHandle   = m_LightTexEffect-&gt;GetParameterByName(0, “ProjMatrix”);<br>    m_TexHandle         = m_LightTexEffect-&gt;GetParameterByName(0, “Tex”);?<br>    m_LightTexTechHandle =<br>　　　　m_LightTexEffect-&gt;GetTechniqueByName(“LightAndTexture”);<br>?<br>    // 设置效果参数<br>    // 设置矩阵<br>    D3DXMATRIX W, P;?<br>    D3DXMatrixIdentity(&amp;W);<br>    m_LightTexEffect-&gt;SetMatrix( m_WorldMatrixHandle, &amp;W);?</p>
<pre><code>D3DXMatrixPerspectiveFovLH(
    &amp;P,
    D3DX_PI * 0.25f, // 45 - degree
    (float)800.0f / (float)600.0f,
    1.0f,
    1000.0f);?
m_LightTexEffect-&gt;SetMatrix( m_ProjMatrixHandle, &amp;P);
</code></pre><p>?<br>    // Set texture<br>    IDirect3DTexture9<em> tex = 0;<br>    D3DXCreateTextureFromFile(m_pd3dDevice, “Terrain_3x_diffcol.jpg”, &amp;tex);?<br>    LightTexEffect-&gt;SetTexture(TexHandle, tex);<br>    d3d::Release&lt;IDirect3DTexture9</em>&gt;(tex);<br>?<br>    return true;<br>}</p>
<p>Disply函数很简单，运行步聚在19.6 节中简要说明:<br>bool Display(float timeDelta)<br>{<br>　　if( Device )<br>　　{<br>       // …[Camera update snipped]<br>       // set the new updated view matrix<br>       LightTexEffect-&gt;SetMatrix(ViewMatrixHandle, &amp;V);</p>
<pre><code>   // Activate the technique and render
   Device-&gt;Clear(0, 0, D3DCLEAR TARGET | D3DCLEAR ZBUFFER,
               0xffffffff, 1.0f, 0);
   Device-&gt;BeginScene();

   // set the technique to use
   LightTexEffect-&gt;SetTechnique( LightTexTechHandle );

   UINT numPasses = 0;
   LightTexEffect-&gt;Begin(&amp;numPasses, 0);

   for(int i = 0; i &lt; numPasses; i++)
   {
        LightTexEffect-&gt;Pass(i);

        for(int j = 0; j &lt; Mtrls.size(); j++)
        {
           Mesh-&gt;DrawSubset(j);
        }
   }
   LightTexEffect-&gt;End();

   Device-&gt;EndScene();
   Device-&gt;Present(0, 0, 0, 0);
</code></pre><p>　　}<br>　　<br>　　return true;<br>}</p>
<p>19.8例子程序: Fog Effect<br>    非常遗憾，我们没有用一整章篇幅来介绍Direct3D雾化效果。雾化效果（以下简称雾）提高了场景的真实性，可以用它来模拟逼真的天气状况。另外，雾可以大大减少长剪裁（far-clip）平面视觉效果。<br>    虽然我们不能给它应有的重视，这里我们还是挤出了一个简要的雾化例程。虽然我们不涉及详细的细节，我们还是展示并解释了Direct3D代码，这是很直接的。<br>    Direct3D雾化是固定功能管线的一部份，受渲染状态限制。下面的效果文件设置顶点雾，以达到必要的雾化状态。</p>
<p>   注意：Direct3D也支持像素雾（也叫表格雾table fog），比顶点雾要更精确。<br>// File: fog.txt<br>// Desc: Effect file that handles device states for linear vertex fog.<br>technique Fog<br>{<br>     pass P0<br>     {<br>          // Set misc render states.?<br>          pixelshader      = null;<br>          vertexshader     = null;<br>          fvf              = XYZ | Normal;<br>          Lighting         = true;<br>          NormalizeNormals = true;<br>          SpecularEnable   = false;<br>?<br>          // Fog states?<br>          FogVertexMode = LINEAR;     // Linear fog function.<br>          FogStart      = 50.0f;       // Fog starts 50 units away from viewpoint.<br>          FogEnd        = 300.0f;     // Fog ends 300 units away from viewpoint.<br>?<br>          FogColor      = 0x00CCCCCC; // Gray colored fog.<br>          FogEnable     = true;        // Enable vertex fog.<br>     }<br>}</p>
<p>就象你看到的，线性顶点雾能够通过五个简单的渲染状态控制：<br>*???????? FogVertexMode—使用指定的雾函数用于顶点雾。雾函数指定雾如何根据距离增长，自然界的雾在近视口的地方比较薄并且根据距离增长变得厚起来了。有效的任务类型为LINEAR、EXP、EXP2。这些函数被定义为：</p>
<p>d 是到视口的距离(viewpoint.)</p>
<p>   注意：如果你用EXP或EXP2雾化函数，你不用设置FogStart 和 FogEnd，因为它们在这些雾函数类型中没被用到。代替的你必须设置雾密度（fog density）渲染状态（如，FogDensity = someFloatType）<br><em>???????? FogStart—标记了物体将开始雾化的起始深度。
</em>???????? FogEnd—标记了物体将结束雾化的结束深度。<br>   注意：FogStart 与 FogEnd本质上定义了物体在其中被雾化的深度间隔（从视口）。<br><em>???????? FogColor—一个DWORD 或 D3DCOLOR值，以描述雾的颜色
</em>???????? FogEnable—指定true以开启顶点雾或false以关闭顶点雾</p>
<p>   任何我们用fog.txt效果渲染的几何体将被雾化。通过这种方式，我们可以控制哪一物体得到雾化，而哪些不用雾化。这对只雾化特定区域是很有用的。例如，通常屋外是有雾的，屋里不被雾化。同样的，一定地理部分可能有雾，而另外部分可能没有。图19.2展示了这一小节的调用雾效果的例程的屏幕截图。<br>图19.2: 雾化效果例子程序的屏幕截图，在这个例子中我们使用线性雾函数，而且雾化渲染状态在效果文件中指定。<br>19.9例子程序: Cartoon Effect<br>   到目前为止的2个效果文件的例子，我们没有使用着色器（shader）。因为着色器在特效中的重要部分，我们想展示一个最精简的例子。例程CartoonEffect执行了在17章中讨论的卡通着色器，但是这次应用效果框架。下面是一个删节版的效果文件：<br>// File: tooneffect.txt<br>// 在效果文件中的卡通着色器<br>extern matrix WorldMatrix;<br>extern matrix ViewMatrix;<br>extern matrix ProjMatrix;<br>extern vector Color;<br>extern vector LightDirection;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};<br>extern texture ShadeTex;<br>?<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     float2 uvCoords : TEXCOORD;<br>     vector diffuse  : COLOR;<br>};<br>?<br>// Cartoon Shader Function:<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     …[Implementation omitted for brevity.]<br>}<br>?<br>sampler ShadeSampler = sampler state<br>{<br>     Texture = (ShadeTex);<br>     MinFilter = POINT; // no filtering for cartoon shading<br>     MagFilter = POINT;<br>     MipFilter = NONE;<br>};<br>?<br>technique Toon<br>{<br>     pass P0<br>     {<br>          // Set P0’s vertex shader.<br>          vertexShader = compile vs_1_1 Main();<br>          // Hook up the sampler object to sampler stage 0.<br>          Sampler[0] = (ShadeSampler);<br>     }<br>}</p>
<p>   我们注意到卡通着色器函数被定义在效果文件中，并且我们指定着色器使用一个特定的传递，在传递部分使用语法：vertexShader = compile vs_1_1_Main();。在效果文件中的设备状态象通常一样设置。</p>
<p>19.10 效果编辑（EffectEdit）<br>   在结束这章前，我们想提一下在DirectX SDK中的EffectEdit程序。可以在\DXSDK\Samples\C++\Direct3D\Bin文件夹中找到它。图19.3显示了一个屏幕截图。</p>
<p>图19.3: 一个在DirectX SDK 中的EffectEdit 程序的屏幕截图<br>    这个EffectEdit程序在测试和书写效果文件时是很有用的。我们推荐您在这个工具上花点时间。</p>
<p>19.11摘要<br>略</p>
<p>相关文章：<br>AGP内存<br>AGP（Accelerate Graphical Port），加速图形接口。随着显示芯片的发展，PCI总线日益无法满足其需求。英特尔于1996年7月正式推出了AGP接口，它是一种显示卡专用的局部总线。严格的说，AGP不能称为总线，它与PCI总线不同，因为它是点对点连接，即连接控制芯片和AGP显示卡，但在习惯上我们依然称其为AGP总线。AGP接口是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz。<br>　　AGP总线直接与主板的北桥芯片相连，且通过该接口让显示芯片与系统主内存直接相连，避免了窄带宽的PCI总线形成的系统瓶颈，增加3D图形数据传输速度，同时在显存不足的情况下还可以调用系统主内存。所以它拥有很高的传输速率，这是PCI等总线无法与其相比拟的。<br>　　由于采用了数据读写的流水线操作减少了内存等待时间，数据传输速度有了很大提高；具有133MHz及更高的数据传输频率；地址信号与数据信号分离可提高随机内存访问的速度；采用并行操作允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存；显示带宽也不与其它设备共享，从而进一步提高了系统性能。<br>　　AGP标准在使用32位总线时，有66MHz和133MHz两种工作频率，最高数据传输率为266Mbps和533Mbps，而PCI总线理论上的最大传输率仅为133Mbps。目前最高规格的AGP 8X模式下，数据传输速度达到了2.1GB/s。<br>　　AGP接口的发展经历了AGP1.0(AGP1X、AGP2X)、AGP2.0(AGP Pro、AGP4X)、AGP3.0(AGP8X)等阶段，其传输速度也从最早的AGP1X的266MB/S的带宽发展到了AGP8X的2.1GB/S。<br>AGP 1.0（AGP1X、AGP2X）<br>　 1996年7月AGP 1.0 图形标准问世，分为1X和2X两种模式，数据传输带宽分别达到了266MB/s和533MB/s。这种图形接口规范是在66MHz PCI2.1规范基础上经过扩充和加强而形成的，其工作频率为66MHz，工作电压为3.3v，在一段时间内基本满足了显示设备与系统交换数据的需要。这种规范中的AGP带宽很小，现在已经被淘汰了，只有在前几年的老主板上还见得到。<br>AGP2.0(AGP4X)<br>　　显示芯片的飞速发展，图形卡单位时间内所能处理的数据呈几何级数成倍增长，AGP 1.0 图形标准越来越难以满足技术的进步了，由此AGP 2.0便应运而生了。1998年5月份，AGP 2.0 规范正式发布，工作频率依然是66MHz，但工作电压降低到了1.5v，并且增加了4x模式，这样它的数据传输带宽达到了1066MB/sec，数据传输能力大大地增强了。<br>AGP Pro<br>　　AGP Pro接口与AGP 2.0同时推出，这是一种为了满足显示设备功耗日益加大的现实而研发的图形接口标准，应用该技术的图形接口主要的特点是比AGP 4x略长一些，其加长部分可容纳更多的电源引脚，使得这种接口可以驱动功耗更大（25-110w）或者处理能力更强大的AGP显卡。这种标准其实是专为高端图形工作站而设计的，完全兼容AGP 4x规范，使得AGP 4x的显卡也可以插在这种插槽中正常使用。AGP Pro在原有AGP插槽的两侧进行延伸，提供额外的电能。它是用来增强，而不是取代现有AGP插槽的功能。根据所能提供能量的不同，可以把AGP Pro细分为AGP Pro110和AGP Pro50。在某些高档台式机主板上也能见到AGP Pro插槽，例如华硕的许多主板。<br>AGP 3.0(AGP8X)<br>　　2000年8月，Intel推出AGP3.0规范，工作电压降到0.8V,并增加了8x模式，这样它的数据传输带宽达到了2133MB/sec，数据传输能力相对于AGP 4X成倍增长，能较好的满足当前显示设备的带宽需求。<br>AGP接口的模式传输方式<br>　　不同AGP接口的模式传输方式不同。1X模式的AGP，工作频率达到了PCI总线的两倍—66MHz，传输带宽理论上可达到266MB/s。AGP 2X工作频率同样为66MHz，但是它使用了正负沿（一个时钟周期的上升沿和下降沿）触发的工作方式，在这种触发方式中在一个时钟周期的上升沿和下降沿各传送一次数据，从而使得一个工作周期先后被触发两次，使传输带宽达到了加倍的目的，而这种触发信号的工作频率为133MHz，这样AGP 2X的传输带宽就达到了266MB/s×2（触发次数）＝533MB/s的高度。AGP 4X仍使用了这种信号触发方式，只是利用两个触发信号在每个时钟周期的下降沿分别引起两次触发，从而达到了在一个时钟周期中触发4次的目的，这样在理论上它就可以达到266MB/s×2（单信号触发次数）×2（信号个数）＝1066MB/s的带宽了。在AGP 8X规范中，这种触发模式仍然使用，只是触发信号的工作频率变成266MHz，两个信号触发点也变成了每个时钟周期的上升沿，单信号触发次数为4次，这样它在一个时钟周期所能传输的数据就从AGP4X的4倍变成了8倍，理论传输带宽将可达到266MB/s×4（单信号触发次数）×2（信号个数）＝2133MB/s的高度了。</p>
<p>　　目前常用的AGP接口为AGP4X、AGP PRO、AGP通用及AGP8X接口。需要说明的是由于AGP3.0显卡的额定电压为0.8—1.5V，因此不能把AGP8X的显卡插接到AGP1.0规格的插槽中。这就是说AGP8X规格与旧有的AGP1X/2X模式不兼容。而对于AGP4X系统，AGP8X显卡仍旧在其上工作，但仅会以AGP4X模式工作，无法发挥AGP8X的优势。</p>
<p>Direct3D中实现图元的鼠标拾取<br>索引：<br>　　1、什么是拾取，拾取能做什么？<br>　　2、拾取操作的步骤和实现<br>　　2.1． 变换并获得通过视点和屏幕上点击点的射线矢量（Dir）<br>　　 2.1.1 确定鼠标选取点的屏幕坐标<br>　　 2.1.2 得到Dir在观察坐标空间内的表示<br>　　 2.1.3 转换Dir到世界坐标空间，并得到观察点在世界坐标系中的坐标<br>　　2.2 使用射线矢量对场景中的所有三角形图元求交，获得三角形索引值和重心坐标。<br>　　 2.2.1 D3D扩展函数实现求交<br>　　 2.2.2射线三角面相交的数学算法<br>　　 2.2.3 拾取完成根据获得的中心坐标计算我们关心的常见量<br>　　3、结束及声明<br>　　4、参考文献<br>　　补充：重心坐标的概念<br>　　3D交互图形应用程序中，常常要用鼠标去选择图形，其实现的机制基于鼠标拾取算法。本文主要讲述如何在D3D中实现图元的鼠标拾取。为了讨论简单，本文假定读者理解D3D 坐标变换流程和基本的图形学知识，如果阅读有困难请参考相关资料。<br>1、什么是拾取，拾取能做什么？<br>   首先，拾取操作指当我们在屏幕上用鼠标点击某个图元，应用程序能返回该图元的一个标志和某些相关信息。有图形程序设计经验的人都知道，有这些信息就表示我们有了对该图元的控制权，我们可以删除，可以编辑，可以任意对待该图元，至于你到底想干什么，就是阁下自己的事了^_^。</p>
<p>2、拾取操作的步骤和实现<br>　　拾取算法的思想很简单：得到鼠标点击处的屏幕坐标，通过投影矩阵和观察矩阵把该坐标转换为通过视点和鼠标点击点的一条射入场景的光线，该光线如果与场景模型的三角形相交（本文只处理三角形图元），则获取该相交三角形的信息。本文讲述的方法除可以得到三角形的一个索引号以外还可以得到相交点的重心坐标。<br>从数学角度来看，我们只要得到射线的方向矢量和射线的发射点，我们就具备了判断射线与空间三角面是否相交的条件，本文主要讨论如何获得这些条件，并描述了射线与三角面相交判断算法和D3D的通常实现方法。 </p>
<p>　　根据拾取操作的处理顺序，大概可以依次分为以下几个步骤<br>2.1． 变换并获得通过视点和屏幕上点击点的射线矢量（Dir）<br>详细介绍之前，为了大家方便理解，我们要先简单说一下d3d坐标转换的大概流程，如下图:</p>
<p>　　 所以我们要通过一系列的反变换，得到我们关心的值在世界坐标中的表示。<br>　　2.1.1 确定鼠标选取点的屏幕坐标<br>　　这一步是非常简单的Windows给我们提供了API来完成屏幕坐标的获取，使用GetCursorPos获得鼠标指针位置，然后再利用ScreenToClient转换坐标到客户区坐标系(以窗口视区左上角为坐标原点，单位为像素)，设该坐标为（POINT screenPt）。<br>　　2.1.2 得到Dir在观察坐标空间内的表示<br>　　在观察坐标系中，Dir是一条从观察坐标原点出发的射线，所以我们只需要再确定一个该射线经过的点，就可以得到它在观察坐标系中的表示。假设我们要求的射线上的另外一点为该射线与透视投影平截头体近剪切面的交点，针对最普遍的透视投影而言，透视投影平截头体经投影变换后，变成一个1/2立方体（请允许我这么叫^_^，因为它的大小为一个正方体的一半，x,y方向边长为2，z方向为1）如图：</p>
<p>投影坐标系以近剪切面中心为坐标原点，该立方体从z轴负向看过去与图形程序视区相对应，最终近剪切面（前剪切面）上一点与屏幕坐标之间的对应关系如下图所示：</p>
<p>　　根据比例关系，screenPt与投影空间上的点projPt之间的关系为<br>　　假设图形程序窗口的宽为screenWidth,高为screenHeight,<br>　　projPt.x = (screenPt.x-screenWidth/2)/screenWidth<em>2; （公式1）<br>　　projPt.y = (screenPt.y-screenHeight/2)/screenHeight</em>2; （公式2）<br>　　projPt.z =0;（实际该值可任意取，不影响最终结果。为了处理简单，我们取改值为0，表示该点取在近剪切面上）<br>　　得到projPt后，我们需要做的是把该点坐标从投影空间转换到观察空间(view space),<br>　　根据透视投影的定义，可假设点(projPt.x，projPt.y，projPt.z)<br>　　对应的其次坐标为<br>　　(projPt.x<em>projPt.w，projPt.y</em>projPt.w，projPt.z<em>projPt.w，projPt.w)<br>　　我们可以通过 GetTransform( D3DTS_PROJECTION, &amp;ProjMatrix)函数获得投影矩阵ProjMatrix,则根据观察空间到投影空间的变换关系则：投影坐标 = 观察坐标×投影矩阵<br>　　(projPt.x</em>projPt.w，projPt.y<em>projPt.w，projPt.z</em>projPt.w，projPt.w)<br>　　= (viewPt.x，viewPt.y，viewPt.z, 1)<em>pProjMatrx;<br>　　根据定义和图形学原理<br>　　ProjMatrix = =<br>　　所以,<br>　　(projPt.x</em>projPt.w，projPt.y<em>projPt.w，projPt.z</em>projPt.w，projPt.w)<br>　　= ( viewPt.x<em>ProjMatrix._m11,<br>　　   viewPt.y</em>ProjMatrix._m22,<br>　　   viewPt.z*Q-QZn,<br>       viewPt.z)</p>
<p>　　所以<br>　　projPt.x<em>projPt.w = viewPt.x</em>ProjMatrix._m11<br>　　projPt.y<em>projPt.w = viewPt.y</em>ProjMatrix._m22<br>　　projPt.z<em>projPt.w = viewPt.z</em>Q-QZn （注意projPt.z = 0）<br>　　projPt.w = viewPt.z;<br>　　解得<br>　　viewPt.x = projPt.x<em>Zn/ ProjMatrix._m11;<br>　　viewPt.y = projPt.y</em>Zn/ ProjMatrix._m22;<br>　　viewPt.z = Zn;<br>　　好了，到这里为止我们终于求出了射线与近剪切面交点在观察坐标系中的坐标，现在我们拥有了射线的出发点(0,0,0)和射线方向上另外一点(viewPt.x,viewPt.y,viewPt.z),则该射线的方向矢量在观察空间中的表示可确定为（viewPt.x-0,viewPt.y-0,viewPt.z-0）,化简一下三个分量同除近剪切面z坐标Zn，该方向矢量可写作<br>　　DIRview = (projPt.x/projMatrix._m11,projPt.y/projMatrix._m22,1)<br>　　代入公式1，公式2<br>　　DIRview.x = (2<em>screenPt.x/screenWidth-1)/projMatrix._m11;<br>　　DIRview.y = (2</em>screenPt.y/screenHeight-1)/projMatrix._m22;<br>　　DIRview.z = 1;<br>     其中screenWidth和screenHeight可以通过图像显示的backBuffer的目标表面（D3DSURFACE_DESC）来获得，该表面在程序初始化时由用户创建。</p>
<p>　　2.1.3 转换Dir到世界坐标空间，并得到观察点在世界坐标系中的坐标<br>　　由于最终的运算要在世界坐标空间中进行，所以我们还需要把矢量DIRview从观察空间转换为世界坐标空间中的矢量DIRworld。<br>　　因为<br>　　DIRview = DIRworld<em>ViewMatrix;<br>　　其中ViewMatrix为观察矩阵，在D3D中可以用函数GetTransform( D3DTS_VIEW, &amp;ViewMatrix )得到。<br>　　所以DIRworld = DIRview </em> inverse_ViewMatrix,其中inverse_ViewMatrix为ViewMatrix的逆矩阵。<br>　　观察点在观察坐标系中坐标为OriginView（0，0，0，1），所以其在世界坐标系中的坐标同样可以利用ViewMatrix矩阵，反变换至世界坐标系中，事实上我们可以很简单的判断出,其在世界坐标系中的表示为:<br>　　OriginWorld = (inverse_ViewMatrix._41,<br>　　inverse_ViewMatrix._42,<br>　　inverse_ViewMatrix._43,<br>　　1);<br>　　到这里为止，判断射线与三角面是否相交的条件就完全具备了。<br>2.2 使用射线矢量对场景中的所有三角形图元求交，获得三角形索引值和重心坐标。<br>　　这一步骤地实现由两种途径:<br>　　第一种方法非常简单，利用D3D提供的扩展函数D3DXIntersect可以轻松搞定一切。见2.1<br>　　第二种方法就是我们根据空间解析几何的知识，自己来完成射线三角形的求交算法。一般来讲，应用上用第一种方法就足够了，但是我们如果要深入的话，必须理解相交检测的数学算法，这样才能自由的扩展，面对不同的需求，内容见2.2<br>　　下面分别讲解两种实现途径：<br>　　2.2.1 D3D扩展函数实现求交<br>　　这种方法很简单也很好用，对于应用来说应尽力是用这种方式来实现，毕竟效率比自己写得要高得多。<br>　　实际上其实没什么好讲的，大概讲一下函数D3DXIntersect吧<br>　　D3D SDK该函数声明如下<br>　　HRESULT D3DXIntersect(<br>　　LPD3DXBASEMESH pMesh,<br>　　CONST D3DXVECTOR3 <em>pRayPos,<br>　　CONST D3DXVECTOR3 </em>pRayDir,<br>　　BOOL <em>pHit,<br>　　DWORD </em>pFaceIndex,<br>　　FLOAT <em>pU,<br>　　FLOAT </em>pV,<br>　　FLOAT <em>pDist,<br>　　LPD3DXBUFFER </em>ppAllHits,<br>　　DWORD <em>pCountOfHits<br>　　);<br>　　l pMesh指向一个ID3DXBaseMesh的对象，最简单的方式是从.x文件获得，描述了要进行相交检测的三角面元集合的信息，具体规范参阅direct9 SDK<br>　　l pRayPos 指向射线发出点<br>　　l pRayDir 指向前面我们辛辛苦苦求出的射线方向的向量<br>　　l pHit 当检测到相交图元时，指向一个true,不与任何图元相交则为假<br>　　l pU 用于返回重心坐标U分量<br>　　l pV返回重心坐标V分量<br>　　l pDist 返回射线发出点到相交点的长度<br>　　注意：以上红色字体部分均指最近的一个返回结果（即</em>pDist最小）<br>　　l ppAllHits用于如果存在多个相交三角面返回相交的所有结果<br>　　l pCountOfHits 返回共有多少个三角形与该射线相交<br>　　补充：重心坐标的概念<br>三角形的重心坐标：　　<br>P1，P2，P3为空间三角形的三个顶点矢量， (U,?V)就称为三角形的重心坐标<br>在空间三角形平面上的点可以表示为：　P?=?P1?+?U?<em>?(P2?-?P1)?+?V?</em>?(P3?-?P1)<br>当0?&lt;?U?&lt;?1，0?&lt;?V?&lt;?1，0?&lt;?U?+?V?&lt;?1时，这个点P就在这个三角形的内部<br>                                                                             收集<br>　　<br>　　其中pU和pV用到了重心坐标的概念，下面稍作描述<br>　　一个三角形有三个顶点，在迪卡尔坐标系中假设表示：<br>　　V1(x1,y1,z1),<br>　　V2(x2,y2,z2),<br>　　V3(x3,y3,z3),<br>　　则三角形内任意一点的坐标可以表示为（pV为任意点）：<br>　　pV = V1 + U(V2-V1) + V(V3-V1)<br>　　所以已知三个顶点坐标的情况下，任意一点可用坐标(U,V)来表示，其中 参数U控制V2在结果中占多大的权值，参数V控制V3占多大权值，最终V1占多大权值 = 1 - U - V，这种坐标定义方式就叫重心坐标。<br>　　<br>　　2..2.2射线三角面相交的数学算法<br>　　使用d3d扩展函数，毕竟有时不能满足具体需求，掌握了该方法，我们才能够获得最大的控制自由度，任意修改算法。<br>　　已知条件: 射线源点orginPoint,三角形三个顶点 v1,v2,v3,射线方向 Dir（均以三维坐标向量形式表示）。<br>　　算法目的: 判断射线与三角形是否相交，如果相交求出交点的重心坐标(U,V)和射线原点到交点的距离T。<br>　　我们可先假设射线与三角形相交则交点<br>　　(注以下均为向量运算：<br>dot(X,Y)       点乘；<br>　　cross(X，Y)    叉乘；<br>　　U，V，T      标量(这三个值为X、Y、Z轴坐标))<br>　　<br>　　则：（IntersectPoint为三角形上的交点）<br>　　IntersectPoint = V1 + U×(V2-V1) + V×(V3-V1) ;<br>　　IntersectPoint = originPoint + T×Dir；<br>　　所以：<br>　　orginPoint + T×Dir = V1 + U×(V2-V1) + V×(V3-V1);<br>　　整理得：<br>　　orginPoint - V1 = U×(V2-V1) + V×(V3-V1) - T×Dir;<br>?<br>这是一个简单的线性方程组，若有解则行列式［-Dir, V2-V1, V3-V1］不为0。<br>   根据T,U,V的含义当T&gt;0, 0&lt;U&lt;1,0&lt;V&lt;1,0&lt;U+V&lt;1时该交点在三角形内部，解此方程组即可获得我们关心的值,具体解法不再赘述，克莱姆法则就够了（详细见线性代数）:射线原点到相交点的距离T,和交点的中心坐标(U,V)。<br>下面给出Direct 9 SDK示例程序中的实现代码：<br>IntersectTriangle( const D3DXVECTOR3&amp; orig,<br>??????????????????      const D3DXVECTOR3&amp; dir, D3DXVECTOR3&amp; v0,<br>?????? ????????????     D3DXVECTOR3&amp; v1, D3DXVECTOR3&amp; v2,<br>?????? ????????????     FLOAT<em> t, FLOAT</em> u, FLOAT* v )<br>{<br>??? // 算出两个边的向量<br>??? D3DXVECTOR3 edge1 = v1 - v0;<br>??? D3DXVECTOR3 edge2 = v2 - v0;<br>?<br>   D3DXVECTOR3 pvec;<br>   D3DXVec3Cross( &amp;pvec, &amp;dir, &amp;edge2 );</p>
<p>   // 如果det为0，或接近于零则射线与三角面共面或平行，不相交<br>   //此处det就相当于上面的[-Dir, V2-V1, V3-V1]，<br>??? FLOAT det = D3DXVec3Dot( &amp;edge1, &amp;pvec );<br>?<br>??? D3DXVECTOR3 tvec;<br>??? if( det &gt; 0 )<br>??? {<br>??????? tvec = orig - v0;<br>??? }<br>??? else<br>??? {<br>??????? tvec = v0 - orig;<br>??????? det = -det;<br>??? }<br>?<br>??? if( det &lt; 0.0001f )<br>??????? return FALSE;<br>?<br>??? // 计算u并测试是否合法（在三角形内）<br>??? <em>u = D3DXVec3Dot( &amp;tvec, &amp;pvec );<br>??? if( </em>u &lt; 0.0f || <em>u &gt; det )<br>??????? return FALSE;<br>?<br>??? // Prepare to test V parameter<br>??? D3DXVECTOR3 qvec;<br>??? D3DXVec3Cross( &amp;qvec, &amp;tvec, &amp;edge1 );<br>?<br>??? //计算u并测试是否合法（在三角形内）<br>??? </em>v = D3DXVec3Dot( &amp;dir, &amp;qvec );<br>??? if( <em>v &lt; 0.0f || </em>u + <em>v &gt; det )<br>??????? return FALSE;<br>?<br>??? /</em>计算t,并把t,u,v放缩为合法值（注意前面的t,v,u不同于算法描述中的相应量，乘了一个系数det）,注意：由于该步运算需要使用除法，所以放到最后来进行，避免不必要的运算，提高算法效率<em>/<br>??? </em>t = D3DXVec3Dot( &amp;edge2, &amp;qvec );<br>??? FLOAT fInvDet = 1.0f / det;<br>??? <em>t </em>= fInvDet;<br>??? <em>u </em>= fInvDet;<br>??? <em>v </em>= fInvDet;<br>?<br>??? return TRUE;<br>}</p>
<p>?<br>2.2.3? 拾取完成根据获得的中心坐标计算我们关心的常见量<br>根据重心坐标（U,V）,我们可以很容易的算出各种相关量比如纹理坐标和交点的差值颜色，假设以纹理坐标为例设V1,V2,V3的纹理坐标分别为T1(tu1,tv1),T2(tu2,tv2),T3(tu3,tv3)则交点的坐标为<br>?<br>IntersectPointTexture = T1 + U(T2-T1) + V(T3-T1)</p>
<p>3、结束及声明<br>　　Ok, 到这里为止关于拾取的相关知识就介绍完了，小弟第一次写这种文章，不知道有没有把问题说清楚，希望对大家有所帮助，有任何问题可以给我发email: jzhang1@mail.xidian.edu.cn<br>　　或者到我的网站留言： www.heavysword.com<br>　　声明：<br>　　本文写作的目的是为了广大D3D学习者方便学习服务，文中算法为作者参考相关文献总结，作者无意把这些据为自己的成果，所有权原算法提出者所有（参阅参考文献），文中代码为D3d SDK的示例内容，由笔者进行了必要的解释，代码版权归microsoft所有。<br>4、参考文献<br>　　【1】Microsoft DirectX 9.0 SDK,microsoft<br>　　【2】fast,Minimun Storage Ray/Triangle Intersection,Tomas Moler,Ben Trumbore</p>
<p>?BY</p>
<p>克莱姆（Cramer）法则<br>一、线性方程组<br>　　元线性方程组是指形式为：<br>　　　　　　　　（1）<br>的方程组，其中代表个未知量，是方程的个数，， ; 称为方程组的系数，称为常数项。<br>　　线性方程组的一个解是指由个数组成的有序数组， 当个未知量分别用代入后，式（1）中每个等式都成为恒等式。方程组（1）的解的全体称为它的解集合，如果两个线性方程组有相同的解集合，就称它们是同解方程组。<br>　　为了求解一个线性方程组，必须讨论以下一些问题：<br>　　(1).这个方程组有没有解？<br>　　(2).如果这个方程组有解，有多少个解？<br>　　(3).在方程组有解时,解之间的关系,并求出全部解。<br>　　本节讨论方程的个数与未知量的个数相等(即)的情形。</p>
<p>二、克莱姆法则</p>
<p>　　定理1（克莱姆法则）如果线性方程组<br>　　　　　 ???????????（2）<br>的系数行列式：<br>　　　　<br>那么这个方程组有解，并且解是唯一的，这个解可表示成：<br>　　　　　　　　（3）<br>其中是把中第列换成常数项所得的行列式，即<br>　　　　。<br>　　分析：定理一共有3个结论：方程组有解；解是唯一的；解由公式（3）给出。因此证明的步骤是：<br>　　第一，把 代入方程组，验证它确实是解。这样就证明了方程组有解，并且（3）是一个解，即证明了结论与。<br>　　第二，证明如果是方程组（２）的一个解，那么一定有。这就证明了解的唯一性，即证明了结论。<br>　　证明：先回忆行列式的一个性质，设阶行列式，则有：<br>　<br>接下来证明定理。首先，证明（3）确实是（2）的解。将行列式按第列展开得：<br>　　　　，<br>其中是行列式中元素的代数余子式。现把<br>代入第个方程的左端，得：</p>
<p>这说明将（3）代入第个方程后，得到了一个恒等式，所以（3）是（2）的一个解。<br>　　其次，设是方程组（2）的一个解，那么，将代入（2）后，得到个恒等式：<br>　　　　　　　　　　（4）<br>用系数行列式的第列的代数余子式依次去乘（4）中个恒等式，得到：<br>　　　　<br>将此个等式相加，得：</p>
<p>从而有：。这就是说，如果是方程组（2）的一个解，那么一定有，所以方程组只有一个解。</p>
<p>三、齐次线性方程组<br>　　在线性方程组中，有一种特殊的线性方程组，即常数项全为零的方程组，称为齐次线性方程组。显然，齐次线性方程组总是有解的，因为就是它的解，这个解称为零解；其他的，即不全为零的解（如果还有的话），称为非零解。所以，对于齐次线性方程组，需要讨论的问题，不是有没有解，而是有没有非零解。这个问题与齐次线性方程组解的个数是有密切关系的。如果一个齐次线性方程组只有零解，那么这个方程组就只有唯一解；反之， 如果某个齐次线性方程组有唯一解， 那么由于零解是一个解，所以这个方程组不可能有非零解。<br>　　对于方程个数与未知量个数相同的齐次线性方程组，应用克莱姆法则，有<br>　　推论1? 如果齐次线性方程组<br>　　　　　　　　（5）<br>的系数行列式不等于零，那么（5）只有零解。<br>　　推论2　齐次线性方程组<br>　　　　<br>有非零解的必要条件是它的系数行列式等于零。</p>
<p>四、例子<br>　　例1　解线性方程组<br>　　　　<br>　　解：方程组的系数行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　<br>　<br>所以这个线性方程组的唯一解为：<br>　　　　<br>　　例2　解线性方程组<br>　　　　<br>　　解：方程组的系数行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　　　<br>　　　<br>所以这个线性方和组的唯一解为：<br>　　　　<br>　　例3???????? 已知三次曲线在四个点处的值分别为：，试求其系数。<br>　　解：将三次曲线在4点处的值代入其方程，得到关于的线性方程组：<br>　　　　<br>它的系数行列式是范德蒙行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　　　<br>　　　<br>所以，即所求的三次曲线方程为。<br>　　例4　如果齐次线性方程组<br>　　　　<br>有非零解，那么必须满足什么条件？<br>　　解：由克莱姆法则知，齐次线性方程组有非零解的必要条件是其系数行列式等于零，因此有<br>　　　　<br>又由：，从而必须满足的条件为。<br>　　注　用克莱姆法则求解系数行列式不等于零的元非齐次线性方程组，需要计算个阶行列式，它的计算工作量很大。实际上关于数字系数的线性方程组（包括系数行列式等于零及方程个数和未知量个数不相同的线性方程组）的解法，一般都采用后续章节介绍的方法来求解。克莱姆法则主要是在理论上具有重要的意义，特别是它明确地揭示了方程组的解和系数之间的关系。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Introduction-to-Pixel-Shaders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Introduction-to-Pixel-Shaders/" class="post-title-link" itemprop="url">第十八章 像素着色器入门(Introduction to Pixel Shaders)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:29:49" itemprop="dateCreated datePublished" datetime="2019-04-11T15:29:49+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>   像素着色器是一个执行在图形卡的GPU上的程序，它运行在对每个像素进行光栅化处理时。（不像顶点着色器，Direct3D不会以软件模拟像素着色器的功能。）它实际上替换了固定功能管线的多纹理化阶段（the multitexturing stage），并赋予我们直接操纵单独的像素和访问每个像素的纹理坐标的能力。这种对像素和纹理坐标的直接访问使我们可以达成各种特效，例如：多纹理化（multitexturing）、每像素光照（per pixel lighting）、景深（depth of field）、云状物模拟（cloud simulation）、焰火模拟（fire simulation）、高级阴影技术（sophisticated shadowing technique）。</p>
<p>   图形卡支持的像素着色器的版本可以通过D3DCAPS9结构的PixelShaderVersion成员和D3DPS_VERSION宏进行检查。下列代码片断展示了这点：<br>// If the device’s supported version is less than version 2.0<br>if( caps.PixelShaderVersion &lt; D3DPS_VERSION(2, 0) )<br>     // Then pixel shader version 2.0 is not supported on this device.</p>
<p>目标</p>
<ul>
<li>获得对多纹理化概念的基本理解</li>
<li>学习如何编写、创建并使用像素着色器</li>
<li>学习如何使用像素着色器实现多纹理化效果</li>
</ul>
<p>18.1多纹理化概览<br>   多纹理化（Multitexturing）可能是用像素着色器实现的最简单的技巧了。此外，因为像素着色器替换多纹理化阶段，那么接下来我们应该对多纹理化“是什么”和“做什么”有一个最基本的理解。本节介绍多纹理化的简明概览。</p>
<p>   当我们一开始讨论纹理化（texturing）的时候（第6章），我们忽略了固定功能管线中对多纹理化的讨论，这有两个原因：第一，多纹理化是有一点棘手的过程，我们考虑到这在当时是一个高级话题；此外，固定功能多纹理化阶段被新的和更强有力的像素着色器替换掉了。因此花时间在已经过时的固定功能纹理化阶段上是无意义的。</p>
<p>   多纹理化后面的概念有一点和混合（blending）相关。在第七章中我们了解到：可以将正要被光栅化的像素与之前写入后台缓冲的像素进行混合来达成一种特效。我们延伸这种相同的思想到多纹理化中（multiple texture）。也就是说，我们一次使用几个纹理，然后定义这些纹理如何被混合在一起，以达到一种特殊效果。多纹理化的一个通常的用法是执行光照。作为在顶点处理阶段使用Direct3D的光照模型的替代，我们使用一种叫做“光照图”（light map）的特殊纹理贴图（texture map），它编码（encode）表面是如何被光照的。例如，假设我们希望一盏聚光灯（spotlight）照在一个大木箱上，我们要么可以定义一个D3DLIGHT9结构的聚光灯，要么可以将代表木箱的纹理贴图与代表聚光灯的光照映射混合在一起，如图18.1所示。</p>
<p>图18.1：使用多纹理化渲染一个通过聚光灯照亮的木箱。这里我们通过将相应的纹理像素（texels）相乘来将这两个纹理组合起来。</p>
<p>注意：用第七章里的混合，结果图像依赖于纹理被混合的方式。在固定功能管线的多纹理化阶段，混合方程式被纹理渲染状态（texture render state）控制。用像素着色器，我们 能够以可编程的方式在代码中写出混合函数的简单表达式。这使我们可以用任何我们想要的方式混合纹理。我们将在讨论本章的例子程序时详细讨论纹理混合。</p>
<p>混合多个纹理（本例中是两个）来照亮木箱比起Direct3D的光照来有两个好处：</p>
<ul>
<li>光照是是预先在聚光灯的光照贴图里计算好的。因此，光照不需要在运行时被计算，这节省了处理时间。当然，只有静态对象和静态灯光的光照可以被预先计算。</li>
<li>因为光照图是预先计算好的，我们能够使用比Direct3D的（光照）模型多的多的更加精确的和成熟的光照模型。（更好的光照可以产生更真实的场景。）</li>
</ul>
<p>备注：多纹理化阶段的典型应用是实现静态对象的完全光照引擎（full lighting engine）。例如，我们可以用一个纹理贴图保存对象的颜色，比如木箱的纹理贴图。然后我们可以用一个散射光照贴图（diffuse light map）保存散射表面着色（diffuse surface shade），一个单独的镜面光照贴图保存镜面表面着色，一个雾状物贴图（fog map）保存覆盖在表面的雾状物的总量，还有可以用一个详细贴图（detail map）保存小的、高访问率的表面的细节。当所有这些纹理被组合起来，只需到这些预先计算的纹理中检索，就可以有效的照亮、着色并且增加细节到场景中去。</p>
<p>注意：聚光灯光照贴图在很基础的光照贴图中是一个价值不高（trivial）的例子。一般的的程序通过给定的场景和光源来生成光照贴图。生成光照贴图超越了本书的范围。有兴趣的读者可以参考Alan Watt和Fabio Policarpo在《3D Games: Real-time Rendering and Software Technology》中描述的光照贴图。</p>
<p>18.1.1 允许多个纹理<br>   回忆一下，纹理是用IDirect3DDevice9::SetTexture方法设置，而采样器状态（sampler state）是用IDirect3DDevice9::SetSamplerState方法设置，原型如下：<br>HRESULT IDirect3DDevice9::SetTexture(<br>     DWORD Stage, // specifies the texture stage index<br>     IDirect3DBaseTexture9 *pTexture<br>);</p>
<p>HRESULT IDirect3DDevice9::SetSamplerState(<br>     DWORD Sampler, // specifies the sampler stage index<br>     D3DSAMPLERSTATETYPE Type,<br>     DWORD Value<br>);</p>
<p>注意：一个特定的采样器阶段索引I联合第i个纹理阶段（texture stage）。即第i个采样器阶段指定采样器状态是第i集（set）纹理。</p>
<p>   纹理/采样器阶段索引标识了我们希望设置的纹理/采样器的纹理/采样器阶段。因此，我们可以允许多个纹理并通过使用不同的阶段索引设置其相应的采样器状态。在本书前面的部分中，我们总是指定0，来指示第一个阶段，因为我们一次仅使用一个纹理。所以例如，假设我们要允许三个纹理，我们像这样使用阶段0,1和2：<br>// Set first texture and corresponding sampler states.<br>Device-&gt;SetTexture(0, Tex1);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); </p>
<p>// Set second texture and corresponding sampler states.<br>Device-&gt;SetTexture(1, Tex2);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); </p>
<p>// Set third texture and corresponding sampler states.<br>Device-&gt;SetTexture(2, Tex3);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);<br>这段代码使用Tex1, Tex2和Tex3，并设置每个纹理的过滤模式。</p>
<p>18.1.2 多纹理坐标<br>   回忆一下第六章，对于每个3D三角形，我们应该在纹理上定义一个三角形以映射该3D三角形。我们通过对每个顶点增加纹理坐标完成映射。因此，每三个顶点定义一个三角形，它对应于纹理上的三角形。</p>
<p>   因为我们现在使用多纹理，每三个顶点定义一个三角形，我们需要在每个被使用的纹理上定义一个相应的三角形。我们通过给每个顶点增加额外的一套纹理坐标——每个顶点一套，对应于每个使用的纹理。举个例子，如果我们混合三个纹理到一起，那么每个顶点必须有三套纹理坐标以索引到三个使用的纹理。因此，一个包含三个纹理的多纹理化顶点结构看起来可能像这样：<br>struct MultiTexVertex<br>{<br>     MultiTexVertex(float x, float y, float z,<br>                    float u0, float v0,<br>                    float u1, float v1,<br>                    float u2, float v2)<br>     {<br>          _x =  x;   _y = y; _z = z;<br>          _u0 = u0;  _v0 = v0;<br>          _u1 = u1;  _v1 = v1;<br>          _u2 = u2;  _v2 = v2;<br>     } </p>
<pre><code> float _x, _y, _z;
 float _u0, _v0; // Texture coordinates for texture at stage 0.
 float _u1, _v1; // Texture coordinates for texture at stage 1.
 float _u2, _v2; // Texture coordinates for texture at stage 2. 

 static const DWORD FVF;
</code></pre><p>};<br>const DWORD MultiTexVertex::FVF = D3DFVF_XYZ | D3DFVF_TEX3;</p>
<p>注意，指定自由顶点格式标记D3DFVF_TEX3表明顶点结构包含3套纹理坐标。固定功能管线支持最多8套纹理坐标。如果多于8套，你必须使用顶点声明和可编程顶点管线。</p>
<p>注意：在新版本像素着色器中，我们可以使用一套纹理坐标集来索引多个纹理，并因此消除了对多个纹理坐标的需要。当然这得假设每个纹理阶段使用相同的纹理坐标。如果每个阶段的纹理坐标不同，则我们仍然需要多纹理坐标。</p>
<h1 id="像素着色器输入和输出"><a href="#像素着色器输入和输出" class="headerlink" title="像素着色器输入和输出"></a>像素着色器输入和输出</h1><p>有两样东西要输入到像素着色器：颜色和纹理坐标。两样都是以每像素为单位的。<br>注意：回想一下，顶点颜色是在图元的面（face of primitive）间进行插值的。<br>每个像素的纹理坐标就是简单的 (u , v) ，它指定了纹理的哪个图素被映射到像素上。在输入到像素着色器前，Direct3D根据顶点颜色和顶点纹理坐标，为每个像素计算颜色和纹理坐标。输入到像素着色器的颜色和纹理坐标的数值依赖于顶点着色器输出的颜色和纹理坐标的数值。例如，如果一个顶点着色器输出了两个颜色和三个纹理坐标，那么Direct3D将会为每个像素计算两个颜色和三个纹理坐标并且把它们把它们输入到像素着色器。我们使用带语意的语法（semantic syntax）映射输入颜色和纹理坐标进我们的着色器程序的变量里。用前面的例子，我们可以这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_INPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="built_in">vector</span> c0 : COLOR0;</span><br><span class="line">     <span class="built_in">vector</span> c1 : COLOR1;</span><br><span class="line">     float2 t0 : TEXCOORD0;</span><br><span class="line">     float2 t1 : TEXCOORD1;</span><br><span class="line">     float2 t2 : TEXCOORD2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于输出，像素着色器只输出一个计算过的该像素的颜色值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_OUTPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="built_in">vector</span> finalPixelColor : COLOR0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用像素着色器的步骤"><a href="#使用像素着色器的步骤" class="headerlink" title="使用像素着色器的步骤"></a>使用像素着色器的步骤</h1><p>下面的列表概述了创建和使用像素着色器的必要步骤：</p>
<ol>
<li>编写并编译像素着色器</li>
<li>创建一个IDirect3DPixelShader9接口来代表基于已编译代码的像素着色器</li>
<li>用IDirect3DDevice9::SetPixelShader方法允许该像素着色器</li>
</ol>
<p>当然，用完顶点着色器之后我们必须销毁它。下面几个小节将深入这些步骤。</p>
<p>18.3.1 编写并编译像素着色器<br>   我们用与编译顶点着色器一样的方式编译像素着色器。首先，我们必须编写一个像素着色器程序。本书中，我们用HLSL编写我们的着色器。一旦写好着色器代码，我们就可以用D3DXCompileShaderFromFile函数编译该着色器了，如16.2节所述。回忆一下，这个函数返回一个ID3DXBuffer指针，它包含已编译的着色器代码。</p>
<p>注意：因为我们使用的是像素着色器，所以要记得把编译目标改成像素着色器目标（比如：ps_2_0），而不是顶点着色器目标（比如：vs_2_0）。编译目标通过D3DXCompileShaderFromFile函数的一个参数指定。详见16.2节。<br>18.3.2 创建像素着色器<br>   一旦我们编译了着色器代码，我们就可以获得一个IDirect3DPixelShader的接口指针，它代表一个像素着色器，使用下面的方法：<br>HRESULT IDirect3DDevice9::CreatePixelShader(<br>      CONST DWORD <em>pFunction,<br>      IDirect3DPixelShader9*</em> ppShader<br>);<br>pFunction——已编译着色器代码的指针<br>ppShader——返回一个IDirect3DPixelShader9接口的指针</p>
<p>例如，假设变量shader是一个包含已编译着色器代码的ID3DXBuffer接口指针。那么要获得IDirect3DPixelShader9接口，我们应该写：<br>IDirect3DPixelShader9<em> MultiTexPS = 0;<br>hr = Device-&gt;CreatePixelShader(<br>           (DWORD</em>)shader-&gt;GetBufferPointer(),<br>           &amp;MultiTexPS);<br>注意：重申一遍，D3DXCompileShaderFromFile是一个可以返回已编译着色器代码（shader）的函数。</p>
<p>18.3.3 建立像素着色器<br>   在我们获得一个代表我们的像素着色器的IDirect3DPixelShader9接口的指针之后，我们可以使用下面的方法使用它：<br>HRESULT IDirect3DDevice9::SetPixelShader(<br>      IDirect3DPixelShader9* pShader<br>);<br>   这个方法只接受一个参数，我们通过它传递一个我们希望使用的指向像素着色器的指针。要使用我们在18.3.2节创建的像素着色器，我们应该写：<br>Device-&gt;SetPixelShader(MultiTexPS);</p>
<p>18.3.4 销毁像素着色器<br>   和其它所有Direct3D接口一样，要清除这些接口，我们必须在使用完毕后调用它们的Release方法。继续使用我们在18.3.2节创建的像素着色器，我们写：<br>d3d::Release<idirect3dpixelshader9*>(MultiTexPS);</idirect3dpixelshader9*></p>
<p>18.4 HLSL采样器对象<br>   在像素着色器中使用HLSL的内建函数tex*XXXX给纹理采样。<br>注意：采样时引用纹理上图素的坐标索引和采样器状态来生成像素。<br>   看16.7节详细地解释了这些函数，通常这些函数需要我们做2件事：</p>
<ul>
<li>使用纹理中的索引建立(u, v)纹理坐标。</li>
<li><p>给特定的纹理中编入索引。</p>
<p> 将纹理坐标（u, v）输入到像素着色器，在一个指定的HLSL对象中的像素着色器中，我们想编入索引的纹理是在像素着色器中被定义过的，在HLSL中叫作采样器。（The particular texture that we want to index into is identified in the pixel shader by a special HLSL object called a sampler.），我们可以把采样器对象想象成定义纹理和采样器阶段的对象。例如：假如我们使用3张纹理，这意味着我们需要在像素着色器里能够引用3个阶段中的每个一个。在像素着色器中我们这样写：<br>sampler FirstTex;<br>sampler SecondTex;<br>sampler ThirdTex;<br> Direct3D将给每个采样器对象连接一个唯一的纹理级别(stage)，在应用程序中我们找出与采样器对象相关联的阶段，并设置相应的纹理和采样器状态给该阶段。下列代码将举例说明如何在应用程序中设置纹理并把采样器状态设置为FirstTex：<br>// 创建<br>IDirect3DTexture9* Tex;<br>D3DXCreateTextureFromFile(Device, “tex.bmp”, &amp;Tex);<br>… …<br>// 取得常量FirstTex的句柄<br>FirstTexHandle = MultiTexCT-&gt;GetConstantByName(0, “FirstTex”);</p>
</li>
</ul>
<p>// 取得常量的描述<br>D3DXCONSTANT_DESC FirstTexDesc;<br>UINT count;<br>MultiTexCT-&gt;GetConstantDesc(FirstTexHandle, &amp;FirstTexDesc, &amp;count);<br>… …<br>// 为FirstTex设置纹理和采样器状态. We identify<br>// the stage FirstTex is associated with from the<br>// D3DXCONSTANT_DESC::RegisterIndex member:<br>Device-&gt;SetTexture(FirstTexDesc.RegisterIndex, Tex);</p>
<p>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);<br>   注意：作为选择，替换使用采样器类型，你可以使用更多特殊的、强大的类型，如：sampler1D，sampler2D，sampler3D，和samplerCube类型，这些类型更安全并且它们只使用tex<em> 函数。例如：一个sampler2D对象只使用tex2D</em>函数，同样一个sampler3D对象只使用tex3D*函数。<br>18.5 例子程序：Multitexturing in a Pixel Shader<br>   这章中的例子演示了在像素着色器中使用多纹理，这个例子将纹理一个基于图18.2方格，渲染的目标是一个木箱纹理，一个聚光灯纹理，和一个包含字符串的纹理。这就是例子程序：Pixel Shader。</p>
<p>   图18.2: 混合纹理. 让我们分别取得木箱纹理上、聚光灯纹理和字符串纹理上相关联的像素颜色：b，s和t，然后定义如何将这些颜色混合： c = b × s + t 。<br>   这个例子可以不使用像素着色器来实现，但实现这个程序是简单直接，它允许我们示范如何写，创建，而且使用像素着色器实现一些特效不必使用那些复杂的算法。<br>   虽然在这个例子中一次只使用3张纹理，检查采样器对象的成员以确定每个像素着色器能够使用的版本，这是值得的。换句话说，我们一次能使用多少纹理这依赖  于使用的像素着色器的版本。</p>
<ul>
<li>像素着色器的版本ps_1_1 到 ps_1_3支持4个纹理采样器。</li>
<li>像素着色器的版本ps_1_4支持6个纹理采样器。</li>
<li>像素着色器的版本ps_2_0到 ps_3_0支持16个纹理采样器。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: ps_multitex.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Desc: Pixel shader that does multitexturing.</span></span><br><span class="line"><span class="comment">// Globals</span></span><br><span class="line">sampler BaseTex;</span><br><span class="line">sampler SpotLightTex;</span><br><span class="line">sampler StringTex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Structures</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_INPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     float2 base      : TEXCOORD0;</span><br><span class="line">     float2 spotlight : TEXCOORD1;</span><br><span class="line">     float2 text      : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_OUTPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="built_in">vector</span> diffuse : COLOR0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main</span></span><br><span class="line"><span class="function">PS_OUTPUT <span class="title">Main</span><span class="params">(PS_INPUT input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// zero out members of output</span></span><br><span class="line">     PS_OUTPUT output = (PS_OUTPUT)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// sample appropriate textures</span></span><br><span class="line">     <span class="built_in">vector</span> b = tex2D(BaseTex,      input.base);</span><br><span class="line">     <span class="built_in">vector</span> s = tex2D(SpotLightTex, input.spotlight);</span><br><span class="line">     <span class="built_in">vector</span> t = tex2D(StringTex,    input.text);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// combine texel colors</span></span><br><span class="line">     <span class="built_in">vector</span> c =b *s +t;</span><br><span class="line">     <span class="comment">// increase the intensity of the pixel slightly</span></span><br><span class="line">     c += <span class="number">0.1f</span>;</span><br><span class="line">     <span class="comment">// save the resulting pixel color</span></span><br><span class="line">     output.diffuse = c;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先像素着色器定义了3个sampler对象，要渲染的每个纹理，接下来定义是input和output结构。注意：我们没有将任何的颜色值输入到像素着色器中，这是因为我们使用纹理自己的颜色和光照；即BaseTex保存表面的颜色，SpotLightTex是光照图。像素着色器输出只一个简颜色值，指定了我们计算过的这个特定像素的颜色。<br>Main函数使用tex2D函数采样3  个纹理，即它取得每个纹理的图素，计算映射到的像素，这通常依赖于指定的纹理坐标和采样器对象。然后我们混合图素的颜色用公式：c = b * s + t。接下来我们让全部的像素变亮一个bit，给每个部分增加0.1f。最后我们保存结果像素颜色并返回它。<br>现在我们看到了的像素着色器的代码，现在我们改变并考虑应用程序的代码。应用程序有下列相应的全局变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IDirect3DPixelShader9* MultiTexPS = <span class="number">0</span>;</span><br><span class="line">ID3DXConstantTable* MultiTexCT    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">IDirect3DVertexBuffer9* QuadVB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">IDirect3DTexture9* BaseTex      = <span class="number">0</span>;</span><br><span class="line">IDirect3DTexture9* SpotLightTex = <span class="number">0</span>;</span><br><span class="line">IDirect3DTexture9* StringTex    = <span class="number">0</span>;</span><br><span class="line">D3DXHANDLE BaseTexHandle      = <span class="number">0</span>;</span><br><span class="line">D3DXHANDLE SpotLightTexHandle = <span class="number">0</span>;</span><br><span class="line">D3DXHANDLE StringTexHandle    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">D3DXCONSTANT_DESC BaseTexDesc;</span><br><span class="line">D3DXCONSTANT_DESC SpotLightTexDesc;</span><br><span class="line">D3DXCONSTANT_DESC StringTexDesc;</span><br></pre></td></tr></table></figure></p>
<p>多纹理顶点结构的例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MultiTexVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     MultiTexVertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z,</span><br><span class="line">                    <span class="keyword">float</span> u0, <span class="keyword">float</span> v0,</span><br><span class="line">                    <span class="keyword">float</span> u1, <span class="keyword">float</span> v1,</span><br><span class="line">                    <span class="keyword">float</span> u2, <span class="keyword">float</span> v2)</span><br><span class="line">     &#123;</span><br><span class="line">          _x =  x;   _y =  y; _z = z;</span><br><span class="line">          _u0 = u0;  _v0 = v0;</span><br><span class="line">          _u1 = u1;  _v1 = v1;</span><br><span class="line">          _u2 = u2,  _v2 = v2;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">float</span> _x,  _y,  _z;</span><br><span class="line">     <span class="keyword">float</span> _u0,  _v0;</span><br><span class="line">     <span class="keyword">float</span> _u1,  _v1;</span><br><span class="line">     <span class="keyword">float</span> _u2,  _v2;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> DWORD MultiTexVertex::FVF = D3DFVF_XYZ | D3DFVF_TEX3;</span><br></pre></td></tr></table></figure></p>
<p>它包含3个纹理坐标系统。</p>
<p>Setup函数执行下列功能：</p>
<ul>
<li>填充方形的顶点缓存</li>
<li>编译着像素色器</li>
<li>创建像素色器</li>
<li>读取纹理</li>
<li>设置投影矩阵，不使用光照</li>
<li>取得采样器(sampler)对象的句柄</li>
<li>取得采样器对象的描述<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HRESULT hr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create quad geometry.</span></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">         <span class="number">6</span> * <span class="keyword">sizeof</span>(MultiTexVertex),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        MultiTexVertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;QuadVB,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    MultiTexVertex*v =<span class="number">0</span>;</span><br><span class="line">    QuadVB-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = MultiTexVertex(<span class="number">-10.0f</span>, <span class="number">-10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">1</span>] = MultiTexVertex(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">2</span>] = MultiTexVertex( <span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">3</span>] = MultiTexVertex(<span class="number">-10.0f</span>, <span class="number">-10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">4</span>] = MultiTexVertex( <span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">5</span>] = MultiTexVertex( <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    QuadVB-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compile shader</span></span><br><span class="line">    ID3DXBuffer* shader      = <span class="number">0</span>;</span><br><span class="line">    ID3DXBuffer* errorBuffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hr = D3DXCompileShaderFromFile(</span><br><span class="line">         <span class="string">"ps_multitex.txt"</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="string">"Main"</span>, <span class="comment">// entry point function name</span></span><br><span class="line">        <span class="string">"ps_1_1"</span>,</span><br><span class="line">        D3DXSHADER_DEBUG,</span><br><span class="line">        &amp;shader,</span><br><span class="line">        &amp;errorBuffer,</span><br><span class="line">        &amp;MultiTexCT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output any error messages</span></span><br><span class="line">    <span class="keyword">if</span>( errorBuffer )</span><br><span class="line">    &#123;</span><br><span class="line">        ::MessageBox(<span class="number">0</span>, (<span class="keyword">char</span>*)errorBuffer-&gt;GetBufferPointer(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        ::MessageBox(<span class="number">0</span>, <span class="string">"D3DXCompileShaderFromFile() - FAILED"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create Pixel Shader</span></span><br><span class="line">    hr = Device-&gt;CreatePixelShader((DWORD*)shader-&gt;GetBufferPointer(),&amp;MultiTexPS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        ::MessageBox(<span class="number">0</span>, <span class="string">"CreateVertexShader - FAILED"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d3d::Release&lt;ID3DXBuffer*&gt;(shader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load textures.</span></span><br><span class="line">    D3DXCreateTextureFromFile(Device, <span class="string">"crate.bmp"</span>, &amp;BaseTex);</span><br><span class="line">    D3DXCreateTextureFromFile(Device, <span class="string">"spotlight.bmp"</span>, &amp;SpotLightTex);</span><br><span class="line">    D3DXCreateTextureFromFile(Device, <span class="string">"text.bmp"</span>, &amp;StringTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set projection matrix</span></span><br><span class="line">    D3DXMATRIX P;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(&amp;P, D3DX_PI * <span class="number">0.25f</span>, (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height, <span class="number">1.0f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable lighting.</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_LIGHTING, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get handles</span></span><br><span class="line">    BaseTexHandle      = MultiTexCT-&gt;GetConstantByName(<span class="number">0</span>, <span class="string">"BaseTex"</span>);</span><br><span class="line">    SpotLightTexHandle = MultiTexCT-&gt;GetConstantByName(<span class="number">0</span>, <span class="string">"SpotLightTex"</span>);</span><br><span class="line">    StringTexHandle    = MultiTexCT-&gt;GetConstantByName(<span class="number">0</span>, <span class="string">"StringTex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set constant descriptions:</span></span><br><span class="line">    UINT count;</span><br><span class="line"></span><br><span class="line">    MultiTexCT-&gt;GetConstantDesc(BaseTexHandle, &amp;BaseTexDesc, &amp;count);</span><br><span class="line">    MultiTexCT-&gt;GetConstantDesc(SpotLightTexHandle, &amp;SpotLightTexDesc, &amp;count);</span><br><span class="line">    MultiTexCT-&gt;GetConstantDesc(StringTexHandle,&amp;StringTexDesc, &amp;count);</span><br><span class="line"></span><br><span class="line">    MultiTexCT-&gt;SetDefaults(Device);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Display函数设置像素着色器，使用2个纹理，并且在渲染方格前设置他们对应的采样器状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...camera update code snipped</span></span><br><span class="line">        <span class="comment">// Render</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,</span><br><span class="line">                   <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the pixel shader</span></span><br><span class="line">        Device-&gt;SetPixelShader(MultiTexPS);</span><br><span class="line">     Device-&gt;SetFVF(MultiTexVertex::FVF);</span><br><span class="line">     Device-&gt;SetStreamSource(<span class="number">0</span>, QuadVB, <span class="number">0</span>, <span class="keyword">sizeof</span>(MultiTexVertex));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// base tex</span></span><br><span class="line">     Device-&gt;SetTexture(BaseTexDesc.RegisterIndex, BaseTex);</span><br><span class="line">     Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// spotlight tex</span></span><br><span class="line">     Device-&gt;SetTexture(SpotLightTexDesc.RegisterIndex, SpotLightTex);</span><br><span class="line">     Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// string tex</span></span><br><span class="line">     Device-&gt;SetTexture(     StringTexDesc.RegisterIndex, StringTex);</span><br><span class="line">     Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// draw the quad</span></span><br><span class="line">     Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     Device-&gt;EndScene();</span><br><span class="line">     Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然我们必须想着在Cleanup函数中释放我们自己分配的接口。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d3d::Release&lt;IDirect3DVertexBuffer9*&gt;(QuadVB);</span><br><span class="line">    d3d::Release&lt;IDirect3DTexture9*&gt;(BaseTex);</span><br><span class="line">    d3d::Release&lt;IDirect3DTexture9*&gt;(SpotLightTex);</span><br><span class="line">    d3d::Release&lt;IDirect3DTexture9*&gt;(StringTex);</span><br><span class="line"></span><br><span class="line">    d3d::Release&lt;IDirect3DPixelShader9*&gt;(MultiTexPS);</span><br><span class="line">    d3d::Release&lt;ID3DXConstantTable*&gt;(MultiTexCT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>像素着色器取代了固定功能管线的多纹理级别（stage），而且，像素着色器给我们更改单独像素的能力，以任何方式选择和访问纹理数据。因而，使我们能实现很多使用固定功能管线所不能完成的特殊效果。</li>
<li>多纹理是一次使用几个纹理，并渲染它们一起创造出一个想要的结果的一个过程。多纹理代表性的用法是用它为静态几何图形实现光引擎。</li>
<li>HLSL内建的采样器（sampler）对象，标识特定的纹理/采样器级别（stage）。A采样器常用于从像素着色器中引用一个纹理/采样器级别。</li>
</ul>
<p>注意：一旦你懂得了如何去实现顶点和像素着色器，你需要的一些特效的创意，可以用它们去实现。得到特效创意最好的方法是，学习现有的用顶点和像素着色器实现的特效。《Direct3D ShaderX: Vertex and Pixel Shader Tips》和《Tricks edited by Wolfgang Engel》这2本书是众多出版物中最好的，像Nvidia和ATI的开发站点：<a href="http://developer.nvidia.com/" target="_blank" rel="noopener">http://developer.nvidia.com/</a> 和 <a href="http://ati.com/developer/index.html。另外我们推荐CG方面：由Randima" target="_blank" rel="noopener">http://ati.com/developer/index.html。另外我们推荐CG方面：由Randima</a> Fernando 和 Mark J. Kilgard写的《The Cg Tutorial by Randima Fernando》，这本书对于使用Cg的3D图形编程是一本相当好的指南，它基本上和Direct3D’s HLSL相同。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Introduction-to-Vertex-Shaders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Introduction-to-Vertex-Shaders/" class="post-title-link" itemprop="url">Introduction-to-Vertex-Shaders</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:28:59" itemprop="dateCreated datePublished" datetime="2019-04-11T15:28:59+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>第十七章 顶点着色器入门(Introduction to Vertex Shaders)<br>概览<br>   顶点着色器（vertex shader）是一个在图形卡的GPU上执行的程序，它替换了固定功能管线（fixed function pipeline）中的变换（transformation）和光照（lighting）阶段。（这不是百分之百的正确，因为顶点着色器可以被Direct3D运行时（Direct3D runtime）以软件模拟，如果硬件不支持顶点着色器的话）。图16.1说明了管线中顶点着色器替换的部件。</p>
<p>图16.1：顶点着色器替换固定功能管线的光照和变形阶段</p>
<p>   从图16.1，我们知道，顶点以局部坐标输入到顶点着色器，并且必须输出齐次剪裁空间的有颜色的顶点。（为了保持简单，本书中我们没有深入研究投影变换的细节。但是经投影矩阵变换顶点后的空间称作齐次剪裁空间（homogeneous clip space）。因此，要把一个顶点从局部空间变换到齐次坐标空间，我们必须应用下列变换序列：世界变换（world transformation），视图变换（view transformation）和投影变换（projection transformation），它们分别由世界矩阵，视图矩阵和投影矩阵来完成。）对于点元（point primitive），顶点着色器也被用于操作每个顶点的顶点大小。</p>
<p>   由于顶点着色器是我们（在HLSL中）写的一个自定义程序，因此我们在图形效果方面获得了我们能够达到的极大的自由性。我们不再受限于Direct3D的固定光照算法。此外，应用程序操纵顶点位置的能力也有了多样性，例如：cloth simulation，粒子系统的点大小操纵，还有顶点混合/morphing。此外，我们的顶点数据结构更自由了，并且可以在可编程管线中包含比在固定功能管线中多得多的数据。</p>
<p>   顶点着色器仍然是相对新的特性，并且许多图形卡不支持它们，特别是随DirectX 9发布的较新版本的顶点着色器。通过检查D3DCAPS9结构的VertexShaderVersion成员，可以测试顶点着色器的版本。下列代码段展示了这一点：<br>// If the device’s supported version is less than version 2.0<br>if( caps.VertexShaderVersion &lt; D3DVS VERSION(2, 0) )<br>     // Then vertex shader version 2.0 is not supported on this device.</p>
<p>我们看到D3D_VERSION的两个参数分别接收主和次版本号。现在，D3DXCompileShaderFromFile函数支持顶点着色器版本1.1和2.0。</p>
<p>目标</p>
<ul>
<li>学习如何在可编程管线中定义顶点结构的分量</li>
<li>了解顶点分量的不同用法</li>
<li>学习如何创建、设置和销毁一个顶点着色器</li>
<li>学习如何使用顶点着色器实现卡通动画渲染效果</li>
</ul>
<p>17.1顶点声明<br>   到现在为止，我们已经使用自由顶点格式（flexible vertex format，FVF）来描述顶点结构中的各分量。但是，在可编程管线中，顶点数据包含的数据比用FVF所能表达的多很多。因此，我们通常使用更具表达性并且更强大的顶点声明（vertex declaration）。</p>
<p>注意：如果FVF能够描述我们的顶点格式 我们仍然可以在可编程管线中使用它。不管用何种方法，只是为了方便，同样FVF会在内部被转换为一个顶点声明。</p>
<p>17.1.1 描述顶点声明<br>   我们将一个顶点声明描述为一个D3DVERTEXELEMENT9结构的数组。D3DVERTEXELEMENT9数组中的每个成员描述了一个顶点的分量。所以，如果你的顶点结构有三个分量（例如：位置、法线、颜色），那么其相应的顶点声明将描述3个D3DVERTEXELEMENT9结构的数组。这个D3DVERTEXELEMENT9结构定义如下：<br>typedef struct _D3DVERTEXELEMENT9 {<br>     BYTE Stream;<br>     BYTE Offset;<br>     BYTE Type;<br>     BYTE Method;<br>     BYTE Usage;<br>     BYTE UsageIndex;<br>} D3DVERTEXELEMENT9;</p>
<ul>
<li>Stream——指定关联到顶点分量的流</li>
<li>Offset——偏移，按字节，相对于顶点结构成员的顶点分量的开始。例如，如果顶点结构是：<br>struct Vertex<br>{<br>   D3DXVECTOR3 pos;<br>   D3DXVECTOR3 normal;<br>};<br>……pos分量的偏移是0，因为它是第一个分量；normal分量的偏移是12，因为sizeof(pos) == 12。换句话说，normal分量以Vertex的第12个字节为开始。</li>
<li>Type——指定数据类型。它可以是D3DDECLTYPE枚举类型的任意成员；完整列表请参见文档。常用类型如下：</li>
<li>D3DDECLTYPE_FLOAT1——浮点数值</li>
<li>D3DDECLTYPE_FLOAT2——2D浮点向量</li>
<li>D3DDECLTYPE_FLOAT3——3D浮点向量</li>
<li>D3DDECLTYPE_FLOAT4——4D浮点向量</li>
<li><p>D3DDECLTYPE_D3DCOLOR—D3DCOLOR类型，它扩展为RGBA浮点颜色向量(r g b a)，其每一分量都是归一化到区间[0, 1]了的。</p>
</li>
<li><p>Method——指定网格化方法。我们认为这个参数是高级的，因此我们使用默认值，标识为D3DDECLMETHOD_DEFAULT.。</p>
</li>
<li><p>Usage——指定已计划的对顶点分量的使用。例如，它是否准备用于一个位置向量、法线向量、纹理坐标等？有效的用途标识符（usage identifier）是D3DDECLUSAGE枚举类型的：<br>typedef enum _D3DDECLUSAGE {<br>   D3DDECLUSAGE_POSITION     = 0,  // Position.<br>   D3DDECLUSAGE_BLENDWEIGHTS = 1,  // Blending weights.<br>   D3DDECLUSAGE_BLENDINDICES = 2,  // Blending indices.<br>   D3DDECLUSAGE_NORMAL       = 3,  // Normal vector.<br>   D3DDECLUSAGE_PSIZE        = 4,  // Vertex point size.<br>   D3DDECLUSAGE_TEXCOORD     = 5,  // Texture coordinates.<br>   D3DDECLUSAGE_TANGENT      = 6,  // Tangent vector.<br>   D3DDECLUSAGE_BINORMAL     = 7,  // Binormal vector.<br>   D3DDECLUSAGE_TESSFACTOR   = 8,  // Tessellation factor.<br>   D3DDECLUSAGE_POSITIONT    = 9,  // Transformed position.<br>   D3DDECLUSAGE_COLOR        = 10, // Color.<br>   D3DDECLUSAGE_FOG          = 11, // Fog blend value.<br>   D3DDECLUSAGE_DEPTH        = 12, // Depth value.<br>   D3DDECLUSAGE_SAMPLE       = 13  // Sampler data.<br>} D3DDECLUSAGE;</p>
<p> D3DDECLUSAGE_PSIZE类型用于指定一个顶点的点的大小。它用于点精灵，因此我们可以基于每个顶点控制其大小。一个D3DDECLUSAGE_POSITION成员的顶点声明意味着这个顶点已经被变换，它通知图形卡不要把这个顶点送到顶点处理阶段（变形和光照）。</p>
</li>
</ul>
<p>注意：这些中的少数用途类型（usage type）未在本书中提及，例如BLENDWEIGHTS, BLENDINDICES, TANGENT, BINORMAL, 和TESSFACTOR</p>
<ul>
<li>UsageIndex——用于标识多个相同用途的顶点分量。这个用途索引是位于区间[0, 15]间的一个整数。例如，假设我们有三个用途为D3DDECLUSAGE_NORMAL的顶点分量。我们可以为第一个指定用途索引为0，为第二个指定用途索引为1，并且为第三个指定用途索引为2。按这种方式，我们可以通过其用途索引标识每个特定的法线。</li>
</ul>
<p>顶点描述声明的例子：假设我们想要描述的顶点格式由位置向量和三个法线向量组成。顶点声明可以指定如下：<br>D3DVERTEXELEMENT9 decl[] =<br>{<br>{0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_POSITION, 0},<br>　<br>{0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 0},<br>　<br>{0, 24, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 1},<br>　<br>{0, 36, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 2},</p>
<p>D3DDECL_END()<br>};<br>D3DDECL_END宏用于初始化D3DVERTEXELEMENT9数组的最后一个顶点元素。同样的，注意法线向量的用途索引标签。</p>
<p>17.1.2 创建顶点声明<br>一旦你描述了一个顶点声明为D3DVERTEXELEMENT9数组，我们就可以使用下面的方法获得一个IDirect3DVertexDeclaration9接口指针：<br>HRESULT IDirect3DDevice9::CreateVertexDeclaration(<br>     CONST D3DVERTEXELEMENT9<em> pVertexElements,<br>     IDirect3DVertexDeclaration9*</em> ppDecl<br>);</p>
<ul>
<li>pVertexElements——D3DVERTEXELEMENT9结构数组，它描述我们想要创建的顶点声明。</li>
<li>ppDecl——用于返回创建的IDirect3DVertexDeclaration9接口指针<br>例子调用，其中decl是一个D3DVERTEXELEMENT9数组：<br>IDirect3DVertexDeclaration9* _decl = 0;<br>hr = _device-&gt;CreateVertexDeclaration(decl, &amp;_decl);</li>
</ul>
<p>17.1.3 使用一个顶点声明<br>   回忆一下：自由顶点格式是一个方便的特性并且在内部转换成了顶点声明。因此，当直接使用顶点声明，我们不再需要调用：Device-&gt;SetFVF( fvf );<br>相反，我们调用：Device-&gt;SetVertexDeclaration( _decl );<br>其中，_decl是一个IDirect3DVertexDeclaration9接口指针。<br>17.2顶点数据用途<br>考虑这个顶点声明：<br>D3DVERTEXELEMENT9 decl[] =<br>{<br>{0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_POSITION, 0},</p>
<p>{0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL,   0},</p>
<p>{0, 24, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL,   1},</p>
<p>{0, 36, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>  D3DDECLUSAGE_NORMAL,   2},</p>
<p>D3DDECL_END()<br>};</p>
<p>   我们需要一种方式，来定义一个顶点声明的元素到顶点着色器的Input结构的数据成员的映射。我们在Input结构中通过指定每个数据成员的语义（: usage-type [usage-index]）定义这个映射。语义通过元素的用途类型和用途索引标识顶点声明中的一个元素。由数据成员的语义标识的顶点元素是得以映射到数据成员的元素。例如，对应于前面的顶点声明的输入结构是：<br>struct VS_INPUT<br>{<br>     vector position    : POSITION;<br>     vector normal     : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};</p>
<p>注意：如果我们遗漏了用途索引，就意味着用途索引为零。例如，POSITION和POSITION0是同一样东西。</p>
<p>   这里decl中的元素0，由用途POSITION和用途索引0标识，它映射到position。decl中的元素1，由用途NORMAL和用途索引0标识，它映射到normal。decl中的元素2，由NORMAL和用途索引1标识，它映射到faceNormal1。decl中的元素3，由用途NORMAL和用途索引2标识，它映射到faceNormal2。</p>
<p>受支持的顶点着色器输入用途（input usage）是：</p>
<ul>
<li>POSITION [n]——位置</li>
<li>BLENDWEIGHTS [n]——混合权重</li>
<li>BLENDINDICES [n]——混合索引</li>
<li>NORMAL [n]——法线向量</li>
<li>PSIZE[n]——顶点大小</li>
<li>DIFFUSE [n]——散射颜色</li>
<li>SPECULAR [n]——镜面颜色</li>
<li>TEXCOORD [n]——纹理坐标<br>其中，n是一个位于区间[0, 15]的可选整数。</li>
</ul>
<p>注意：再重复一遍，这些用途类型中的少数未在本书中提及，如：BLENDWEIGHTS, TANGENT, BINORMAL, BLENDINDICES, 和TESSFACTOR。</p>
<p>   此外，对于输出结构，我们必须指定每个成员是用来做什么的。例如，数据成员应该被作为位置向量、颜色、纹理坐标等对待吗？图形卡没主意，除非你强制的告诉它。这也需要通过语法的语义来完成：<br>struct VS_OUTPUT<br>{<br>     vector position  : POSITION;<br>     vector diffuse   : COLOR0;<br>     vector specular  : COLOR1;<br>};</p>
<p>受支持的顶点着色器输出用途是：</p>
<ul>
<li>POSITION—位置</li>
<li>PSIZE—顶点大小</li>
<li>FOG—雾混合值</li>
<li>COLOR [n]—顶点颜色。注意：可以有多个顶点颜色被输出，并且这些颜色可以被混合在一起以产生最终的颜色。</li>
<li>TEXCOORD [n]—顶点纹理坐标。注意：多个顶点纹理坐标可以被输出。<br>其中，n是一个位于区间[0, 15]的可选整数。</li>
</ul>
<p>17.3使用顶点着色器的步骤<br>下面的列表概括了创建和使用顶点着色器的必须步骤：</p>
<ol>
<li>编写并编译顶点着色器</li>
<li>创建一个IDirect3DVertexShader9接口以引用已编译的着色器代码上的顶点着色器。</li>
<li>用IDirect3DDevice9:: SetVertexShader方法使用这个顶点着色器。</li>
</ol>
<p>当然，在我们做完这些之后，我们还得销毁这个顶点着色器。下面的各小节将更详细的迈入这些步骤。</p>
<p>17.3.1 编写并编译顶点着色器<br>   首先，我们必须编写一个顶点着色器程序。在本书中的HLSL一章中，我们已经编写了我们的着色器（译者注：参见我翻译的译文第一章中各节）。一旦着色器代码写好之后，我们就使用D3DXCompileShaderFromFile函数编译这个着色器，如16.2.2节所述。回忆一下，这个函数返回一个ID3DXBuffer指针，它包含已编译的着色器代码。</p>
<p>17.3.2 创建顶点着色器<br>   一旦我们拥有了编译好的着色器代码，我们就能够获得一个IDirect3DVertexShader9接口的指针，它代表一个顶点着色器——通过使用下面的方法：<br>HRESULT IDirect3DDevice9::CreateVertexShader(<br>     const DWORD <em>pFunction,<br>     IDirect3DVertexShader9*</em> ppShader<br>);<br>pFunction——已编译着色器代码的指针<br>ppShader——返回一个IDirect3DVertexShader9接口的指针</p>
<p>例如，假设变量shader是一个包含已编译的，着色器代码的ID3DXBuffer指针。然后要获得一个IDirect3DVertexShader9接口，我们可以写：<br>IDirect3DVertexShader9<em> ToonShader = 0;<br>hr = Device-&gt;CreateVertexShader(<br>           (DWORD</em>)shader-&gt;GetBufferPointer(),<br>           &amp;ToonShader);<br>注意：重申一遍，D3DXCompileShaderFromFile是一个函数，它将返回已编译着色器的代码（shader）。</p>
<p>17.3.3 建立顶点着色器<br>   在我们获得了一个代表我们的顶点着色器的IDirect3DVertexShader9接口的指针之后，我们就能够使用下面的方法使用它：<br>HRESULT IDirect3DDevice9::SetVertexShader(<br>     IDirect3DVertexShader9* pShader<br>);<br>这个方法仅接受一个参数，我们在其中传递一个想要使用的顶点着色器的指针。要使用这个我们在17.3.2节创建的着色器，我们可以写：Device-&gt;SetVertexShader(ToonShader);</p>
<p>17.3.4 销毁顶点着色器<br>   和所有的Direc3D接口一样，要清除他们，我们就必须在用完它们之后调用其的Release方法。仍然以我们在17.3.2节创建的顶点着色器为例，我们写：<br>d3d::Release<idirect3dvertexshader9*>(ToonShader);</idirect3dvertexshader9*></p>
<p>17.4样例应用程序：散射光照<br>   作为创建并使用顶点着色器的热身，我们写一个顶点着色器，它用一个方向（平行）光对每个顶点进行标准的散射光照。简而言之，散射光照根据顶点法线和光线向量（它的点朝向光源方向）的角度计算顶点接收到的光线的数量。角度越小，则顶点接收到的光线就越多；而角度越大，则顶点接收到的光线就越少。如果角度大于等于90度，顶点就接收不到光线了。</p>
<p>我们以检阅着色器代码作为开始：<br>// File: diffuse.txt<br>// Desc: Vertex shader that does diffuse lighting.<br>// Global variables we use to hold the view matrix, projection matrix,<br>// ambient material, diffuse material, and the light vector that<br>// describes the direction to the light source. These variables are<br>// initialized from the application.</p>
<p>matrix ViewMatrix;<br>matrix ViewProjMatrix;<br>vector AmbientMtrl;<br>vector DiffuseMtrl;<br>vector LightDirection;</p>
<p>// 环境光强度，漫射光强度<br>// 这些变量定义在着色器代码中<br>vector DiffuseLightIntensity = {0.0f, 0.0f, 1.0f, 1.0f};<br>vector AmbientLightIntensity = {0.0f, 0.0f, 0.2f, 1.0f};</p>
<p>// Input and Output structures.<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};</p>
<p>//Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     // zero out all members of the output instance.<br>     VS_OUTPUT output = (VS_OUTPUT)0;</p>
<pre><code> // 变换位置到齐次坐标空间，保存到output.position成员中
 output.position = mul(input.position, ViewProjMatrix);

 // 变换光和法线到视图空间，设置w分量为0，是因为变换的向量不是点 
 LightDirection.w = 0.0f;
 input.normal.w  = 0.0f;
 LightDirection   = mul(LightDirection, ViewMatrix);
 input.normal    = mul(input.normal, ViewMatrix);

 // 计算光与法线夹角的余弦
 float s = dot(LightDirection, input.normal); 

 // 回忆一下，如果法线和光的夹角大于90度，则表面接收不到光。
 if( s &lt; 0.0f )
     s = 0.0f;

 // 环境光反射是执行一个叉积（环境材质向量与环境光强度向量），
 // 漫射光反射是执行一个叉积（漫射材质向量与漫射光强度向量，
 // 更进一步讲，我们测量着色器的颜色，基于顶点从光源处接收到多少光
 //环境光和漫射光综合起来，决定一个顶点的最终颜色
 output.diffuse = (AmbientMtrl * AmbientLightIntensity) +
                  ((DiffuseMtrl * DiffuseLightIntensity) * s);
 return output;
</code></pre><p>}</p>
<p>   既然我们已经看到了实际的顶点着色器的代码，那么就让我们改变方式来看看应用程序的代码。这个应用程序有下列相关的全局变量：<br>IDirect3DVertexShader9<em> DiffuseShader = 0;<br>ID3DXConstantTable</em> DiffuseConstTable = 0;<br>ID3DXMesh* Teapot               = 0;<br>D3DXHANDLE ViewMatrixHandle     = 0;<br>D3DXHANDLE ViewProjMatrixHandle = 0;<br>D3DXHANDLE AmbientMtrlHandle    = 0;<br>D3DXHANDLE DiffuseMtrlHandle    = 0;<br>D3DXHANDLE LightDirHandle       = 0;<br>D3DXMATRIX Proj;<br>   有代表顶点着色器及其常量表的变量，有茶壶网格的变量，接着是一组D3DXHANDLE，其名字描述了他们引用的变量：</p>
<p>Setup函数执行下列任务：</p>
<ul>
<li>创建茶壶网格</li>
<li>编译顶点着色器</li>
<li>根据已编译代码创建顶点着色器</li>
<li>通过常量表获取着色器程序中的几个变量的句柄</li>
<li>通过常量表初始化着色器的这几个变量</li>
</ul>
<p>注意：对于本应用程序，我们的顶点结构不需要任何自由顶点格式没有的额外的分量。因此，在本例中，我们使用一个自由顶点格式来代替顶点声明。回想一下，自由顶点格式描述最终在内部被转换为一个顶点声明。<br>bool Setup()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> // Create geometry:
 D3DXCreateTeapot(Device, &amp;Teapot, 0); 

 // Compile shader
 ID3DXBuffer* shader      = 0;
 ID3DXBuffer* errorBuffer = 0;

 hr = D3DXCompileShaderFromFile(
      &quot;diffuse.txt&quot;,
      0,
      0,
      &quot;Main&quot;, // entry point function name
      &quot;vs_1_1&quot;,
      D3DXSHADER_DEBUG,
      &amp;shader,
      &amp;errorBuffer,
      &amp;DiffuseConstTable);

 // output any error messages
 if( errorBuffer )
 {
    ::MessageBox(0, (char*)errorBuffer-&gt;GetBufferPointer(), 0, 0);
    d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);
 }

 if(FAILED(hr))
 {
    ::MessageBox(0, &quot;D3DXCompileShaderFromFile() - FAILED&quot;, 0, 0);
    return false;
 }

 // Create shader
 hr = Device-&gt;CreateVertexShader(
      (DWORD*)shader-&gt;GetBufferPointer(),
      &amp;DiffuseShader);

  if(FAILED(hr))
 {
    ::MessageBox(0, &quot;CreateVertexShader - FAILED&quot;, 0, 0);
    return false;
 }

 d3d::Release&lt;ID3DXBuffer*&gt;(shader);

 // Get Handles
 LightDirHandle    = DiffuseConstTable-&gt;GetConstantByName(0, &quot;LightDirection&quot;);
 ViewMatrixHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;ViewMatrix&quot;);
 ViewProjMatrixHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;ViewProjMatrix&quot;);
 AmbientMtrlHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;AmbientMtrl&quot;);
 DiffuseMtrlHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;DiffuseMtrl&quot;);


 // Set shader constants:
 // Light direction:
 D3DXVECTOR4 directionToLight(-0.57f, 0.57f, -0.57f, 0.0f);
 DiffuseConstTable-&gt;SetVector(Device, LightDirHandle,  &amp;directionToLight); 

 // Materials:
 D3DXVECTOR4 ambientMtrl(0.0f, 0.0f, 1.0f, 1.0f);
 D3DXVECTOR4 diffuseMtrl(0.0f, 0.0f, 1.0f, 1.0f);
 DiffuseConstTable-&gt;SetVector(Device,AmbientMtrlHandle,&amp;ambientMtrl);
 DiffuseConstTable-&gt;SetVector(Device,DiffuseMtrlHandle,&amp;diffuseMtrl);

 DiffuseConstTable-&gt;SetDefaults(Device);

 // Compute projection matrix.
 D3DXMatrixPerspectiveFovLH(
   &amp;Proj, D3DX PI * 0.25f,
   (float)Width / (float)Height, 1.0f, 1000.0f);

 return true;
</code></pre><p>}</p>
<p>   Display函数非常简单。它检测用户输入（译者注：这里指的是用户输入的传入着色器程序的变量），并相应的更新视图矩阵。但是，因为我们在着色器中执行这个视图矩阵变换，所以我们还必须更新着色器中的视图矩阵变量。我们用常量表完成这件事情。<br>bool Display(float timeDelta)<br>{<br>     if( Device )<br>     {<br>          // Update view matrix code snipped…<br>          D3DXMATRIX V;<br>          D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;target, &amp;up);<br>          DiffuseConstTable-&gt;SetMatrix(Device, ViewMatrixHandle, &amp;V);<br>          D3DXMATRIX ViewProj =V *Proj;</p>
<pre><code>      DiffuseConstTable-&gt;SetMatrix(Device, ViewProjMatrixHandle,
                                  &amp;ViewProj);

      // Render
      Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                    0xffffffff, 1.0f, 0);
      Device-&gt;BeginScene();
      Device-&gt;SetVertexShader(DiffuseShader);
      Teapot-&gt;DrawSubset(0);
      Device-&gt;EndScene();
      Device-&gt;Present(0, 0, 0, 0);
 }
 return true;
</code></pre><p>}</p>
<p>同样注意，就在DrawSubset调用之前，我们允许了这个我们希望使用的顶点着色器。<br>清理也需要被完成；我们简单的释放了这个已分配的接口：<br>void Cleanup()<br>{<br>     d3d::Release<id3dxmesh*>(Teapot);<br>     d3d::Release<idirect3dvertexshader9*>(DiffuseShader);<br>     d3d::Release<id3dxconstanttable*>(DiffuseConstTable);<br>}</id3dxconstanttable*></idirect3dvertexshader9*></id3dxmesh*></p>
<p>17.5 卡通渲染<br>   作为第二个顶点着色器的例子，让我们编写两个顶点着色器，它们以卡通风格的绘画方式对网格着色（shade）并画轮廓（outline）。图17.2展示了这一点：</p>
<p>图17.2：（a）使用卡通着色法着色的对象（注意着色间的尖锐过渡）。（b）增强卡通效果，轮廓边（silhouette edge）被勾出。（c）使用标准散射光照着色的对象</p>
<p>注意：卡通渲染是一种特定类型的非写实渲染（non-photorealistic rendering），有时被称作风格化渲染（stylistic rendering）。</p>
<p>   虽然卡通渲染不适用于所有游戏，例如激烈的第一人称射击游戏，但是它仍然可以增强一些希望表现卡通感觉类型游戏的气氛。此外，卡通渲染是漂亮的，并易于实现。让我们好好的演示一个顶点着色器。</p>
<p>我们将卡通渲染分为两步：</p>
<ol>
<li>卡通绘画的特点是：在一个顶点到下一个顶点的强烈转换时，有少量的阴影强度级别；我们看一下这个卡通阴影（cartoon shading）。在图17.2（a）中，我们看到网络着色使用了三种阴影强度（亮、中、暗），而且其间的过渡是不平滑的——不像图17.2（c），其明暗过渡是平滑的。</li>
<li>卡通绘图的主要特点是：在其外框上勾画轮廓，如图17.2（b）所示。<br>这两个步骤都需要其各自的顶点着色器。</li>
</ol>
<p>17.5.1 卡通着色<br>   要实现卡通着色，我们采用Lander在2000年3月发表在Game Developer Magazine的文章“Shades of Disney: Opaquing a 3D World”中所描述的方法。它像这样工作：我们创建一个带强度级别的灰度纹理，它包含我们需要的不同的着色强度。图17.3显示了我们在样例程序中使用的这个纹理。</p>
<p>图 17.3：用来保存着色强度的着色纹理。注意观察不连续的着色间过渡和纹理着色强度必须从左到右增加。<br>   然后在顶点着色器中，我们执行标准散射点积运算（standard diffuse calculation dot product）来确定顶点法线N和光线向量L之间角度的余弦，用以确定顶点接收到多少光线：s=L·N</p>
<p>   如果s＜0，就表示光线向量和顶点法线之间的角度大于90度，也就表示该表面接收不到光线。因此，如果s＜0，我们就让s＝0。所以s ∈ [0, 1]。</p>
<p>   现在，在通常的散射光照模型中，我们使用s来标记颜色向量。这样，顶点颜色的明暗取决于接收到的光照的数量：diffuseColor = s(r, g, b, a)<br>   但是，这将会导致从亮到暗之间平滑的着色。这是与我们期望的卡通着色相反的。我们想要一种在几个不同着色器间突然转换颜色的效果（对卡通渲染来说，在2至4种着色器工作起来还是挺不错的）。</p>
<p>   不使用s来标记颜色向量，我们将使用s作为早先提到的强度纹理的u纹理坐标——如图17.3。<br>注意：标量（scalar）s必定是一个有效的纹理坐标，因为s ∈ [0, 1]，这是通常的纹理坐标区间。</p>
<p>   按这种方式，顶点不会被平滑着色，而是间断的。例如，强度纹理可能被分成3种着色，如图17.4所示：</p>
<p>图17.4：那么，s ∈ [0, 0.33]的值使用shader0着色，s ∈ [ 0.33，0.66]的值使用shader1着色，s ∈ [0.66,1]的值使用shader2着色。当然，从这些着色的一种到另一种的过渡是不平滑的，这就赋予了我们期望的效果。</p>
<p>注意：我们还为卡通着色关闭了纹理过滤，因为这种过滤会试图使着色过渡变平滑。这对于我们要求的不连续过渡是多余的。</p>
<p>17.5.2 卡通着色的顶点着色器代码<br>   我们现在介绍卡通着色的顶点着色器。这个着色器的主要任务只是根据s=L·N计算并设置纹理坐标。注意观察输出结构，我们已经增加了一个数据成员来存储已被计算过的纹理坐标。同时还需注意，我们仍然输出顶点颜色，虽然我们不修改它，不过当颜色被与强度纹理组合起来的时候，它呈现为被着色的。<br>// File: toon.txt<br>// Desc: Vertex shader that lights geometry so it appears to be<br>// drawn in a cartoon style.</p>
<p>// Globals<br>extern matrix WorldViewMatrix;<br>extern matrix WorldViewProjMatrix;<br>extern vector Color;<br>extern vector LightDirection;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};</p>
<p>// Structures<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     float2 uvCoords : TEXCOORD;<br>     vector diffuse  : COLOR;<br>};</p>
<p>// Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>      // zero out each member in output<br>　　　VS_OUTPUT output = (VS_OUTPUT)0;<br>　　　<br>      // transform vertex position to homogenous clip space<br>　　　output.position = mul(input.position, WorldViewProjMatrix);<br>　　　<br>      // Transform lights and normals to view space.  Set w<br>      // components to zero since we’re transforming vectors.<br>      // Assume there are no scalings in the world<br>      // matrix as well.<br>      LightDirection.w = 0.0f;<br>      input.normal.w   = 0.0f;<br>      LightDirection   = mul(LightDirection, WorldViewMatrix);<br>      input.normal     = mul(input.normal, WorldViewMatrix);</p>
<pre><code>  // Compute the 1D texture coordinate for toon rendering.
</code></pre><p>　　　float u = dot(LightDirection, input.normal);<br>　　　<br>      // Clamp to zero if u is negative because u<br>      // negative implies the angle between the light<br>      // and normal is greater than 90 degrees.  And<br>      // if that is true then the surface receives no light.<br>      if(u &lt; 0.0f)<br>         u = 0.0f;</p>
<pre><code>  // Set other tex coord to middle.
  float v = 0.5f;
  output.uvCoords.x = u;
  output.uvCoords.y = v;

  // save color
</code></pre><p>　　　output.diffuse = Color;<br>　　　<br>      return output;<br>}</p>
<p>两点注解：</p>
<ul>
<li>我们假设世界矩阵没有执行任何缩放。因为如果它执行，它就会弄乱乘以它的顶点的长度和方向。</li>
<li>我们总是设置v纹理坐标为纹理的中点。这意味着我们仅使用纹理中一条单一的线，那就是说我们可以使用1D强度纹理来代替2D的那个纹理。不管怎样，1D和2D纹理都能工作。本例中，我们使用了2D纹理而不是1D纹理，这是没有什么特别的原因的。</li>
</ul>
<p>17.5.3轮廓勾勒<br>要完成卡通效果，我们还需要勾勒（outline）轮廓边（silhouette edge）。这比卡通着色稍微复杂一点。</p>
<p>17.5.3.1 边的表示法<br>我们将一个网格的一条边表示为一个四元组（构建自2个三角形）——参见图17.5。</p>
<p>图 17.5：表示边的四元组</p>
<p>   我们选择四元组有两个原因：我们可以通过调整四元组的维容易的改变边的厚度，并且我们可以渲染退化的四元组来隐藏某些边，也即非轮廓边。在Direct3D中，我们从两个三角形来构建一个四元组。退化四元组（degenerate quad）是从两个退化三角形构建而来的四元组。退化三角形（degenerate triangle）是一个面积为零的三角形，或者换句话说，是一个三点位于一线上的三角形。如果我们传入一个退化三角形到渲染管线，则该三角形显示为空。这是很有用的，因为如果我们希望隐藏特定三角形，我们可以简单的退化它而不需要实际的从三角形列表（顶点缓冲）移除它。回想一下，我们只需要显示轮廓边——而不是网格的每一条边。</p>
<p>   当我们首先创建一条边的时候，我们指定其四个顶点，并使其退化，这意味着边将会被隐藏（渲染时不显示）。</p>
<p>图17.6：由两个三角形共用边描述的退化四元组</p>
<p>   注意图17.6中的两个顶点v0和v1，我们设置其顶点法线向量为零向量。然后当我们将边的顶点送入顶点着色器的时候，顶点着色器将会检测顶点是否位于轮廓边上；如果是，则顶点着色器将按顶点法线的方向偏移顶点位置的标量。观察法线向量为零的顶点，它不会被偏移。</p>
<p>因此，我们最终以一个非退化四元组（non-degenerate quad）来表示轮廓边，如图17.7所示。</p>
<p>图17.7：位于轮廓边上的顶点v2和v3被按照其各自的顶点法线n2和n3进行偏移。观察顶点v0和v1仍然保持在其固定位置，因为其顶点法线等于零向量，因此对于它们来说没有偏移发生。按这种方式，四元组成功的重新生成来表示轮廓边。</p>
<p>备注：如果我们没有设置顶点v0和v1的顶点法线为零向量，那么那些顶点就同样会被偏移。但是如果偏移描述轮廓边的所有四个顶点，那么我们仅是平移了该退化四元组。通过保持顶点v0和v1固定并仅仅偏移顶点v2和v3，我们重新生成了四元组。</p>
<p>17.5.3.2 轮廓边测试<br>   若两个三角面face0和face1在视图方向上与两个不同方向的面共享同一条边，则该边为轮廓边。也就是说，如果一个面是前面（front facing）而另一个面是后面（back facing），那么这条边就是一条轮廓边。图17.8给出了一个轮廓边和一个非轮廓边的例子。</p>
<p>图17.8：在（a）中，由v0 和v1定义的共享边的一个面是前面，而共享边另一个面是背面，因此该边是轮廓边。在（b）中，由v0 和v1定义的这两个共享边面都是前面，因此该边不是轮廓边。</p>
<p>   接下来，为了检测一个顶点是否在轮廓边上，我们必须以每个顶点为基础了解face0 和 face1的法线向量。我们的边的顶点数据结构反映如下：<br>struct VS_INPUT<br>{<br>     vector position    : POSITION;<br>     vector normal      : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};</p>
<p>   前两个分量很直接，但让我们看看两个额外的法线向量，它们是faceNormal1和faceNormal2。这些向量描述了两个三角面的面法线，共享边的顶点位于这两个面的共享边上，这两个面是face0和face1。</p>
<p>   实际检测顶点是否在共享边上的数学如下。假设我们在视图空间中，令v为一原点指向检测顶点的向量——图17.8，令n0为face0的面法线且n1为face0的面法线，若下面的不等式为真，则顶点位于轮廓边上：<br>（1）（v·n0）（v·n1）＜0</p>
<p>   若两点积符号相异，则不等式为真，使得不等式左边为负。回想一下点积的性质：两个点积的符号相异，这意味着一个三角面是前面而另一个是后面。</p>
<p>   现在，考虑一条边只有一个三角形共享它的情况，如图17.9，其法线将会被存储在faceNormal1中。</p>
<p>图 17.9：顶点v0和v1定义的边只有一个三角面共享它</p>
<p>   我们定义这种边总为轮廓边。要确保顶点着色器将这种边作为轮廓边处理，我们要让faceNormal2 = -faceNormal1。因此，反向的面法线和不等式（1）为真，表示该边为一轮廓边。</p>
<p>17.5.3.3 边的生成<br>   生成网格的边是微不足道的；我们简单的遍历网格的每个三角面并为三角面上每条边计算一个四元组（退化的，如图17.6所示）。<br>注意：每个三角面有三条边，因为每个三角形有三条边。</p>
<p>   对于每条边上的顶点，我们同样需要知道共享边的两个三角面。一个面是边所在的三角形。例如，如果要计算第1个面的一条边，那么第1个面共享该边。共享该边的另一个面可以使用网格的邻接信息找到。<br>17.5.4 轮廓边顶点着色器代码<br>   我们现在呈现渲染轮廓边的顶点着色器代码。这个着色器的主要任务就是确定传入的顶点是否在轮廓边上。如果是，顶点着色器就以一定的值，按顶点法线的方向偏移顶点。<br>// File: outline.txt<br>// Desc: Vertex shader renders silhouette edges.</p>
<p>// Globals</p>
<p>extern matrix WorldViewMatrix;<br>extern matrix ProjMatrix;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};</p>
<p>// Structures<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};<br>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse : COLOR;<br>};</p>
<p>// Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>      // zero out each member in output<br>      VS_OUTPUT output = (VS_OUTPUT)0; </p>
<pre><code>  // transform position to view space
  input.position = mul(input.position, WorldViewMatrix); 

  // Compute a vector in the direction of the vertex
  // from the eye. Recall the eye is at the origin
</code></pre><p>　　　// in view space - eye is just camera position.<br>      vector eyeToVertex = input.position; </p>
<pre><code>  // transform normals to view space.  Set w
  // components to zero since we&#39;re transforming vectors.
  // Assume there are no scalings in the world
  // matrix as well.
  input.normal.w      = 0.0f;
  input.faceNormal1.w = 0.0f;
  input.faceNormal2.w = 0.0f;
  input.normal      = mul(input.normal,      WorldViewMatrix);
  input.faceNormal1 = mul(input.faceNormal1, WorldViewMatrix);
  input.faceNormal2 = mul(input.faceNormal2, WorldViewMatrix); 

  // compute the cosine of the angles between
  // the eyeToVertex vector and the face normals.
  float dot0 = dot(eyeToVertex, input.faceNormal1);
  float dot1 = dot(eyeToVertex, input.faceNormal2);

  // if cosines are different signs (positive/negative)
  // then we are on a silhouette edge. Do the signs
  // differ?
  if( (dot0 * dot1) &lt; 0.0f )
  {
       // yes, then this vertex is on a silhouette edge,
       // offset the vertex position by some scalar in the
       // direction of the vertex normal.
       input.position += 0.1f * input.normal;
  }

  // transform to homogeneous clip space
  output.position = mul(input.position, ProjMatrix);

  // set outline color
  output.diffuse = Black; 

  return output;
</code></pre><p>}</p>
<p>17.6 摘要</p>
<ul>
<li>使用顶点着色器，我们可以替换固定功能管线的变换和光照阶段。通过用我们自己的程序（顶点着色器）替换此固定处理，我们可以在图形效果方面获得我们能够达到的极大的自由性。</li>
<li>顶点声明用于描述顶点格式。它们和自由顶点格式相似，但是更加自由并允许我们描述FVF不能描述的顶点格式。注意，如果顶点可以用FVF描述，我们仍然可以使用它们；不管怎样，在内部它们被转换为顶点声明。</li>
<li>对于输入，用途语义指定了顶点分量如何被从顶点声明映射到HLSL程序中的变量。对于输出，用途语义指定了顶点分量是用来做什么的（例如：位置、颜色、纹理坐标，等等）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Intorduction-to-the-High-Level-Shading-Language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Intorduction-to-the-High-Level-Shading-Language/" class="post-title-link" itemprop="url">高级着色器语言入门(Introduction to the High-Level Shading Language)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:27:51" itemprop="dateCreated datePublished" datetime="2019-04-11T15:27:51+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>   在这一章里我们描述高级着色器语言（High-Level Shading Language ，简称HLSL），在下三章里我们用它去编写顶点和像素着色器。简单的说，在我们写的程序里顶点和像素是很小的对象，它们由GPU来执行，是固定功能管线的一部分。用我们自己写的着色器程序替换一部分固定功能管线，在绘制效果上我们获得很大的灵活性。我们不再局限于预定义的”固定”操作。<br>   为了编写着色器程序，我们需要一种语言。 在DirectX 8.x,中，着色器是用低级着色器汇编语言编写的。幸运的是，我们不必再用汇编语言来写着色器了，DirectX 9支持一种高级着色器语言来xyna写。用HLSL在汇编语言来写着色器程序与使用高级语言有同样的优势，像C++，它超越了汇编语言，即：</p>
<ul>
<li>增加生产力—用高级语言比用低级语言写程序更快、更容易。 我们可以花费更多的时间关注于算法而不是代码。</li>
<li>增加可读性—用高级语言写的程序更易读，这意味着用高级语言编程更易于调试和维护。</li>
<li>大多数情况下，编译器产生的汇编代码比手写有效率。</li>
<li>使用HLSL 编译器，我们可以编译我们的代码到任何可用shader版本，使用汇编语言我们将不得不为每个需要的版本移植代码。</li>
</ul>
<p>HLSL 同C和C++语法很类似, 所以缩短了学习曲线。<br>   最后，如果你的显卡不支持顶点和像素着色器的话，为了执行着色器的例子程序你将需要转换REF设备。使用REF设备意味着着色器例子运行的会很慢，但它至少能显示结果，让我们去检查是否代码可以被执行。</p>
<p>提示：顶点shaders可以用软件来模拟 ―― D3DCREATE_SOFTWARE_VERTEX-PROCESSING。16.1 </p>
<p>目标</p>
<ul>
<li>学习如何定、编译一个HLSL 着色器程序。</li>
<li>学习如何将程序中的数据传送到着色器程序。</li>
<li><p>熟悉语法、类型，和HLSL的内建函数。</p>
<h1 id="编写HLSL着色器"><a href="#编写HLSL着色器" class="headerlink" title="编写HLSL着色器"></a>编写HLSL着色器</h1><p>我们可以在程序源文件中用字符串直接编写HLSL着色器代码，然而更方便、更模块化的方法是把它与程序代码分离出来。因此，我们在记事本中编写着色器并保存成一般的ASCII文本文件，然后可以用D3DXCompileShaderFromFile函数(section 16.2.2)来编译它们。<br>作为介绍，下面是用HLSL编写的一个简单的顶点着色器，用记事本生成并保存成文本文件“Transform.txt”。全部工程都在标题为Transform的目录下，顶点着色器用组合视图和投影矩阵转换顶点，并设置顶点漫射光为蓝色。</p>
<p> 注意：这是一个顶点着色器的例子，不必关心顶点着色器做了什么，这是下一章包含的内容，现在的目标是熟悉HLSL编程的语法和格式。<br>// File: transform.txt<br>// Author: Frank D. Luna (C) All Rights Reserved<br>// System: AMD Athlon 1800+ XP, 512 DDR, Geforce 3, Windows XP,<br>// MSVC++ 7.0</p>
</li>
</ul>
<p>// Desc: 顶点着色器用组合视图和投影矩阵转换顶点，并设置顶点漫射光为蓝色.</p>
<p>//全局变量<br>//用来保存视图和投影的组合矩阵，在程序中初始化变量<br>matrix ViewProjMatrix;</p>
<p>// 初始化颜色变量（蓝色）<br>vector Blue = {0.0f, 0.0f, 1.0f, 1.0f};</p>
<p>// 结构<br>// Input结构用来描述输入到着色器的顶点，这个Input顶点只包含一个位置成员<br>struct VS_INPUT<br>{<br>     vector position  : POSITION;<br>};</p>
<p>//Output结构用来描述从着色器输出的顶点，这个Output顶点包含位置和颜色成员<br>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};</p>
<p>//主入口点，这个main函数接收一个Input顶点的拷贝作为参数，返回一个Output顶点的拷贝<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     // 将output结构所有成员初始化<br>     VS_OUTPUT output = (VS_OUTPUT)0;<br>     // 将位置变换到投影空间<br>     output.position  = mul(input.position, ViewProjMatrix);<br>     // 设置顶点颜色<br>     output.diffuse = Blue;<br>     //Output the projected and colored vertex.<br>     return output;<br>}</p>
<p>16.1.1 全局变量<br>首先是2个全局变量：<br>matrix ViewProjMatrix;<br>vector Blue = {0.0f, 0.0f, 1.0f, 1.0f};<br>   第1个变量ViewProjMatrix是矩阵类型，它是一个在HLSL 内创建的4×4的矩阵类型。这个变量保存视图与投影的组合矩阵，它描述两者的变换。使用这种方法我们只要做一个向量和矩阵的乘法（而不是二个）。注意，在着色器源代码的任何地方都没有初始化这个变量，因为它是我们在应用程序的源代码里设置的，而不是在着色器中。从应用程序向着色器程序通讯是常用的操作，例子在16.2.1节。<br>   第二个变量Blue是built-in（内建）类型的4D向量，我们简单的将它初始化成蓝色，它是个RGBA的颜色向量。</p>
<p>16.1.2 输入和输出结构<br>   在全局变量定义之后，定义2个特殊的结构，我们调用输入和输出结构。对于顶点着色器而言，这些结构定义了顶点的数据，分别是：<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};<br>注意：给像素着色器的结构定义输入和输出像素数据。</p>
<p>   在例子中，INPUT 顶点着色器只包含位置成员（POSITION），OUTPUT顶点着色器包含位置和颜色成员（POSITION and COLOR）。<br>   特殊的冒号是一种语义，用于是声明变量。这与vertex结构中的自由顶点格式（FVF）相似。例如，在VS_INPUT中有成员：vector position : POSITION;<br>   “: COLOR”是说顶点的漫射光是用VS_OUTPUT结构的COLOR成员来说明的。在下一章中对于顶点和像素着色器中向量的标识符用法，我们将会有更多的讨论。<br>   注意：从底层来说，着色器变量的语义和语法同硬件寄存器是相关联的。即，input变量与input寄存器关联，output变量与output寄存器关联。例如，VS_INPUT中的position成员与顶点input的position寄存器相关联。同样，diffuse与顶点的output 的color寄存器关联。</p>
<p>16.1.3 函数的入口点<br>   在C++程序中，每个HLSL程序有一个入口点。在我们的着色器例子中，我们调用入口点函数main。然而名字不是强制的。入口点函数名可以是任何有效的函数名，入口点函数必须有一个input结构参数，它通过input顶点进入着色器。入口点函数必须返回一个output结构实例，在着色器中使用output操作顶点。<br>VS_OUTPUT Main(VS_INPUT input)<br>{</p>
<p>   注意：实际上，使用input、output结构不是强制的。例如，有时你将会看到使用类似下面的语法，特别是在像素着色器中：<br>float4 Main(in float2 base : TEXCOORD0,<br>            in float2 spot : TEXCOORD1,<br>            in float2 text : TEXCOORD2) : COLOR<br>{<br>…<br>}</p>
<p>   例子中，输入到着色器中的参数是3个纹理坐标。着色器输出（返回）一个颜色，COLOR语句在函数的声明以后。这种定义是类似于：<br>struct INPUT<br>{<br>     float2 base : TEXCOORD0;<br>     float2 spot : TEXCOORD1;<br>     float2 text : TEXCOORD2;<br>};</p>
<p>struct OUTPUT<br>{<br>     float4 c : COLOR;<br>};</p>
<p>OUTPUT Main(INPUT input)<br>{<br>…<br>}</p>
<p>   输入点函数负责根据给定的input顶点计算output顶点。例子中的着色器简单的变换input顶点到视图空间和投影空间，设置顶点颜色为蓝色，并返回结果顶点。首先我们定义VS_OUTPUT的实例并初始化所有成员为0。<br>VS_OUTPUT output = (VS_OUTPUT)0; // zero out all members<br>   然后着色器变换input顶点位置用ViewProjMatrix变量，使用mul 函数。它是一个built-in（内建）函数，实现向量与矩阵相乘，或矩阵与矩阵相乘。我们保存结果变换的向量（在output实例的position成员中）。<br>// 变换后为投影空间的位置<br>output.position = mul(input.position, ViewProjMatrix);<br>   然后设置output的成员diffuse的颜色为蓝色：<br>// 设置顶点颜色<br>output.diffuse = Blue;<br>   最后返回结果向量：<br>return output;<br>}<br>16.2 编译HLSL 着色器<br>16.2.1 常量表<br>   每个着色器有一个常量表，用来保存它的变量。D3DX库通过ID3DXConstantTable接口，提供给应用程序访问着色器的常量表。通过这个接口我们能够在应用程序中设置着色器源代码中的变量。<br>   我们现在描述一个被节选了的ID3DXConstantTable接口的方法列表的实现，全部的列表请查阅Direct3D文档。<br>16.2.1.1 取得常量句柄<br>   为了在应用程序中设置着色器中的一个特定变量，需要有一种方法去引用它，我们能够在应用程序中用D3DXHANDLE引用一个在着色器中的变量，下面的方法返回一个着色器中的变量的D3DXHANDLE，使用时，需要传递一个变量的名字作为参数：<br>D3DXHANDLE ID3DXConstantTable::GetConstantByName(<br>     D3DXHANDLE hConstant, // scope of constant<br>     LPCSTR pName          // name of constant<br>);</p>
<ul>
<li>Hconstant——我们要取得的父结构中变量句柄的D3DXHANDLE标识。例如，如果我们想获得一个特定数据结构中单一数据成员的句柄，我们可以传递结构实例的句柄。如果我们获得一个顶级变量的句柄，给这个参数设为0。</li>
<li>PName——我们想获得的句柄的着色器代码中的变量的名字。</li>
</ul>
<p>例如，如果在着色器中变量的名字为ViewProjMatrix，并且这是顶级变量，我们这么写：<br>// 取得着色器中ViewProjMatrix变量的句柄<br>D3DXHANDLE h0;<br>h0 = ConstTable-&gt;GetConstantByName(0, “ViewProjMatrix”);</p>
<p>16.2.1.2 设置常量<br>   一旦应用程序有了一个D3DXHANDLE，要引用着色器代码中的具体变量，我们可以在应用程序中使用ID3DXConstantTable::SetXXX方法设置变量。如果我们想设置一个向量数组类型的变量，方法名是SetVectorArray。<br>   ID3DXConstantTable::SetXXX的一般语法是：<br>HRESULT ID3DXConstantTable::SetXXX(<br>     LPDIRECT3DDEVICE9 pDevice,<br>     D3DXHANDLE hConstant,<br>     XXX value<br>);</p>
<ul>
<li>PDevice：常量表所关联的设备的指针。</li>
<li>HConstant：我们正在设置的变量句柄的引用。</li>
<li><p>Value：我们要把变量设置成的值，XXX是我们设置的要替换的变量类型名，对于有些类型（bool, int, float），传递变量值的COPY，另外一些类型（vectors, matrices, structures），传递值的指针。</p>
<p> 下面列表描述了我们能用ID3DXConstantTable接口设置的类型列表。这里假定我们有一个有效的设备，和一个有效句柄。<br>SetBool—Used to set a Boolean value. Sample call:<br>bool b = true;<br>ConstTable-&gt;SetBool(Device, handle, b);</p>
</li>
</ul>
<p>SetBoolArray—Used to set a Boolean array. Sample call:<br>bool b[3] = {true, false, true};<br>ConstTable-&gt;SetBoolArray(Device, handle, b, 3);</p>
<p>SetFloat—Used to set a float. Sample call:<br>float f = 3.14f;<br>ConstTable-&gt;SetFloat(Device, handle, f);</p>
<p>SetFloatArray—Used to set a float array. Sample call:<br>float f[2] = {1.0f, 2.0f};<br>ConstTable-&gt;SetFloatArray(Device, handle, f, 2);</p>
<p>SetInt—Used to set an integer. Sample call:<br>int x = 4;<br>ConstTable-&gt;SetInt(Device, handle, x);</p>
<p>SetIntArray—Used to set an integer array. Sample call:<br>int x[4] = {1, 2, 3, 4};<br>ConstTable-&gt;SetIntArray(Device, handle, x, 4);</p>
<p>SetMatrix—Used to set a 4 × 4 matrix. Sample call:<br>D3DXMATRIX M(…);<br>ConstTable-&gt;SetMatrix(Device, handle, &amp;M);</p>
<p>SetMatrixArray—Used to set a 4 × 4 matrix array. Sample call:<br>D3DXMATRIX M[4];<br>// …Initialize matrices<br>ConstTable-&gt;SetMatrixArray(Device, handle, M, 4);</p>
<p>SetMatrixPointerArray—Used to set an array of 4 × 4 matrix pointers. Sample call:<br>D3DXMATRIX* M[4];<br>// …Allocate and initialize matrix pointers<br>ConstTable-&gt;SetMatrixPointerArray(Device, handle, M, 4);</p>
<p>SetMatrixTranspose—Used to set a transposed 4 × 4 matrix. Sample call:<br>D3DXMATRIX M(…);<br>D3DXMatrixTranspose(&amp;M, &amp;M);<br>ConstTable-&gt;SetMatrixTranspose(Device, handle, &amp;M);</p>
<p>SetMatrixTransposeArray—Used to set an array of 4 × 4 transposed matrices. Sample call:<br>D3DXMATRIX M[4];<br>// …Initialize matrices and transpose them.<br>ConstTable-&gt;SetMatrixTransposeArray(Device, handle, M, 4);</p>
<p>SetMatrixTransposePointerArray—Used to set an array of pointers to 4 × 4 transposed matrices. Sample call:<br>D3DXMATRIX* M[4];<br>// …Allocate,initialize matrix pointers and transpose them.<br>ConstTable-&gt;SetMatrixTransposePointerArray(Device, handle, M, 4);</p>
<p>SetVector—Used to set a variable of type D3DXVECTOR4. Sample call:<br>D3DXVECTOR4 v(1.0f, 2.0f, 3.0f, 4.0f);<br>ConstTable-&gt;SetVector(Device, handle, &amp;v);</p>
<p>SetVectorArray—Used to set a variable that is a vector array. Sample call:<br>D3DXVECTOR4 v[3];<br>// …Initialize vectors<br>ConstTable-&gt;SetVectorArray(Device, handle, v, 3);</p>
<p>SetValue—Used to set an arbitrarily sized type, such as a structure. In the sample call, we use SetValue to set a D3DXMATRIX:<br>D3DXMATRIX M(…);<br>ConstTable-&gt;SetValue(Device, handle, (void*)&amp;M, sizeof(M));</p>
<p>16.2.1.3 设置常量默认值<br>   下一个方法就是设置常量的默认值，这些默认值在声明时初始化。这个方法应该在应用程序建立（setup）期间被一次性调用（called once）。<br>   HRESULT ID3DXConstantTable::SetDefaults(<br>        LPDIRECT3DDEVICE9 pDevice<br>   );<br>   pDevice——关联到常量表的设备的指针。</p>
<p>16.2.2 编译HLSL着色器<br>   我们可以编译一个着色器——用我们已保存的着色器的文本文件——使用下列函数：<br>   HRESULT D3DXCompileShaderFromFile(<br>        LPCSTR               pSrcFile,<br>        CONST D3DXMACRO<em>     pDefines,<br>        LPD3DXINCLUDE        pInclude,<br>        LPCSTR               pFunctionName,<br>        LPCSTR               pTarget,<br>        DWORD                Flags,<br>        LPD3DXBUFFER</em>        ppShader,<br>        LPD3DXBUFFER<em>        ppErrorMsgs,<br>        LPD3DXCONSTANTTABLE</em> ppConstantTable<br>   );</p>
<ul>
<li>pSrcFile——要编译的包含着色器源代码的文本文件的文件名</li>
<li>pDefines——参数可选，本书中指定为空。</li>
<li>pInclude——ID3DXInclude接口指针。这个接口被设计成由应用程序实现，所以我们可以重载默认include的行为。通常，默认行为就可以了，而且我们可以通过将其指定为空忽略此参数。</li>
<li>pFunctionName——指定入口点函数名的字符串。例如，如果着色器的入口点函数叫做Main，我们可以给此参数传递“Main”。</li>
<li><p>pTarget——指定要编译成的HLSL着色器源文件的版本的字符串。有效的顶点着色器版本是：vs_1_1, vs_2_0, vs_2_sw。有效的像素着色器版本是2.0，我们可以给此参数传递vs_2_0。</p>
<p> 备注：有编译不同版本着色器的能力，是HLSL与汇编语言比的主要优势。用HLSL我们只需为需要的目标简单的重新编译，便可快速移植着色器到不同的版本。使用汇编，我们可能需要手动移植代码。</p>
</li>
<li>Flags——可选的编译标记，指定为0标识没有标记。有效的选项是：</li>
<li>D3DXSHADER_DEBUG——通知编译器写入调试信息</li>
<li>D3DXSHADER_SKIPVALIDATION——通知编译器不要做任何代码检查。此项仅用于你已知着色器能够工作时</li>
<li>D3DXSHADER_SKIPOPTIMIZATION——通知编译器不要执行任何代码优化。实践中，这个选项应该仅用于调试，因为这种情况下你不希望编译器以任何方式修改代码。</li>
<li>ppShader——返回已编译的着色器代码的ID3DXBuffer指针。这个已编译过的着色器代码将作为另一个实际创建顶点/像素着色器函数的参数</li>
<li>ppErrorMsgs——返回包含错误码和错误消息字符串的ID3DXBuffer指针</li>
<li><p>ppConstantTable——返回包含此着色器常量表数据的ID3DXConstantTable指针</p>
<p> 这里是一个调用D3DXCompileShaderFromFile的例子：<br> // Compile shader</p>
<p> ID3DXConstantTable<em> TransformConstantTable = 0;<br> ID3DXBuffer</em> shader      = 0;<br> ID3DXBuffer* errorBuffer = 0;</p>
<p> hr = D3DXCompileShaderFromFile(</p>
<pre><code>  &quot;transform.txt&quot;,      // shader filename
  0,
  0,
  &quot;Main&quot;,               // entry point function name
  &quot;vs 2 0&quot;,             // shader version to compile to
  D3DXSHADER_DEBUG,     // debug compile
  &amp;shader,
  &amp;errorBuffer,
  &amp;TransformConstantTable);
</code></pre><p> // output any error messages<br> if( errorBuffer )<br> {</p>
<pre><code>  ::MessageBox(0, (char*)errorBuffer-&gt;GetBufferPointer(), 0, 0);
  d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);
</code></pre><p> }</p>
<p> if (FAILED (hr))<br> {</p>
<pre><code>  ::MessageBox(0, &quot;D3DXCreateEffectFromFile() - FAILED&quot;, 0, 0);
  return false;
</code></pre><p> }</p>
</li>
</ul>
<p>16.3 变量类型<br>   注意：除了下列各小节中描述的类型外，HLSL还有一些内建的对象类型（如：纹理对象）。但是，由于这些对象类型主要用于效果框架，我们将对其延迟到第19章讨论。</p>
<p>16.3.1 数值类型<br>HLSL支持下列数值类型（scalar type）：</p>
<ul>
<li>bool—True or false value. Note that HLSL provides the true and false keywords.</li>
<li>int—32-bit signed integer</li>
<li>half—16-bit floating-point number</li>
<li>float—32-bit floating-point number</li>
<li>double—64-bit floating-point number<br> 注意：一些平台不支持int, half, and double类型，这时我们使用 float类型模拟。</li>
</ul>
<p>16.3.2 向量类型<br>HLSL有下列内建的向量类型（vector type）：</p>
<ul>
<li>vector——各分量为float类型的4D向量</li>
<li><p>vector<t, n>——一个n维向量，其每个分量都为T类型。n维必须在1到4之间。这里是一个2D double向量的例子：<br>vector<double, 2> vec2;</double,></t,></p>
<p> 我们可以使用数组下标的语法访问向量的一个分量。例如，要设置向量vec的第i个分量，我们可以写成：<br>vec[i] = 2.0f;</p>
<p> 此外，我们可以像访问结构的成员一样访问向量vec的一个分量，使用已定义的分量名x，y，z，w，r，g，b和a。<br>vec.x = vec.r = 1.0f;<br>vec.y = vec.g = 2.0f;<br>vec.z = vec.b = 3.0f;</p>
</li>
</ul>
<p>vec.w = vec.a = 4.0f;</p>
<p>   名称为r，g，b和a的分量分别对应x，y，z和w的分量。当使用向量来表示颜色时，RGBA符号是更适合的，因为它加强了向量所表示的颜色。</p>
<p>   作为选择，我们可以使用其它一些预定义类型，分别用来代表2D，3D和4D向量的类型：<br>float2 vec2;<br>float3 vec3;<br>float4 vec4;</p>
<p>   考虑向量u = (ux, uy, uz, uw)，假设我们要拷贝u的所有分量到一个像v = (ux, uy, uy, uw)这样的向量v。最直接的方法可能是逐个从u往v拷贝每个分量。但不管怎样，HLSL提供了一种特殊的语法做这些无序的拷贝，它叫做“鸡尾酒”（swizzles）：<br>vector u = {l.0f, 2.0f, 3.0f, 4.0f};<br>vector v = {0.0f, 0.0f, 5.0f, 6.0f};<br>v = u.xyyw; // v = {1.0f, 2.0f, 2.0f, 4.0f}</p>
<p>拷贝数组时，我们不必拷贝每个分量。例如，我们可以仅拷贝x和y分量，代码段举例如下：<br>vector u = {1.0f, 2.0f, 3.0f, 4.0f};<br>vector v = {0.0f, 0.0f, 5.0f, 6.0f};<br>v.xy = u; // v = {l.0f, 2.0f, 5.0f, 6.0f}</p>
<p>16.3.3 矩阵类型<br>HLSL有下列内建矩阵类型：</p>
<ul>
<li>matrix——一个4×4矩阵，其各项类型为float</li>
<li>matrix<t, m, n>——一个m×n矩阵，其每个成员为类型T。矩阵维数m和n必须在1至4之间。</t,></li>
</ul>
<p>这里是一个2×2整型矩阵的例子：<br>matrix<int, 2 2,> m2x2;</int,></p>
<p>作为选择，我们可以定义一个m×n矩阵，其m和n在1至4之间，使用下列语法：<br>floatmxn matmxn;<br>实例：<br>float2x2 mat2x2;<br>float3x3 mat3x3;<br>float4x4 mat4x4;<br>float2x4 mat2x4;<br>注意：类型不必是float类型——我们可以使用其它类型。举例来说，我们可以用整型，写成这样：<br>int2x2 i2x2;<br>int2x2 i3x3;<br>int2x2 i2x4;</p>
<p>我们可以用二维数组的下标语法访问矩阵中的项。例如，要设置矩阵M的第i，j个项，我们可以写成：<br>M[i] [j] = value;</p>
<p>此外，我们可以像访问结构的成员那样访问矩阵M的项。下列条目已定义：<br>以1为基数的：<br>M._11 = M._12 = M._13 = M._14 = 0.0f;<br>M._21 = M._22 = M._23 = M._24 = 0.0f;<br>M._31 = M._32 = M._33 = M._34 = 0.0f;<br>M._41 = M._42 = M._43 = M._44 = 0.0f;</p>
<p>以0为基数的：<br>M._m00 = M._m01 = M._m02 = M._m03 = 0.0f;<br>M._m10 = M._m11 = M._m12 = M._m13 = 0.0f;<br>M._m20 = M._m21 = M._m22 = M._m23 = 0.0f;<br>M._m30 = M._m31 = M._m32 = M._m33 = 0.0f;</p>
<p>有时，我们想要访问矩阵中一个特定的行。我们可以用一维数组的下标语法来做。例如，要引用矩阵M中第i行的向量，我们可以写：<br>vector ithRow = M[i]; // get the ith row vector in M</p>
<p>注意：可以使用两种语法在HLSL中初始化变量：<br>vector u = {0.6f, 0.3f, 1.0f, 1.0f};<br>vector v = {1.0f, 5.0f, 0.2f, 1.0f};</p>
<p>也可以，等价的，使用构造风格的语法：<br>vector u = vector(0.6f, 0.3f, 1.0f, 1.0f);<br>vector v = vector(1.0f, 5.0f, 0.2f, 1.0f);</p>
<p>其它一些例子:<br>float2x2 f2x2 = float2x2(1.0f, 2.0f, 3.0f, 4.0f);<br>int2x2 m = {1, 2, 3, 4};<br>int n = int(5);<br>int a = {5};<br>float3 x = float3(0, 0, 0);</p>
<p>16.3.4 数组<br>我们可以用类似C++的语法声明特定类型的一个数组。例如：<br>float  M[4][4];<br>half   p[4];<br>vector v[12];</p>
<p>16.3.5 结构<br>结构的定义和在C++里一样。但是，HLSL里的结构不能有成员函数。这是一个HLSL里的结构的例子：<br>struct MyStruct<br>{<br>     matrix T;<br>     vector n;<br>     float  f;<br>     int    x;<br>     bool   b;<br>};<br>MyStruct s; // instantiate<br>s.f = 5.0f; // member access</p>
<p>16.3.6 typedef关键字<br>   HLSL的typedef关键字功能和C++里的完全一样。例如，我们可以给类型vector<float, 3>用下面的语法命名：<br>typedef vector<float, 3> point;<br>然后，不用写成：<br>vector<float, 3> myPoint;<br>……我们只需这样写：<br>point myPoint;</float,></float,></float,></p>
<p>这里是另外两个例子，它展示了如何对常量和数组类型使用typedef关键字：<br>typedef const float CFLOAT;<br>typedef float point2[2];</p>
<p>1.3.7 变量前缀<br>下列关键字可以做变量声明的前缀：</p>
<ul>
<li><p>static——如果带static关键字前缀，那它是全局变量。就表示它不是暴露于着色器之外的。换句话说，它是着色器局部的。如果一个局部变量以static关键字为前缀，它就和C++中static局部变量有相同的行为。也就是说，该变量在函数首次执行时被一次性初始化，然后在所有函数调用中维持其值。如果变量没有被初始化，它就自动初始化为0。static int x = 5;</p>
</li>
<li><p>uniform——如果变量以uniform关键字为前缀，就意味着此变量在着色器外面被初始化，比如被C++应用程序初始化，然后再输入进着色器。</p>
</li>
<li><p>extern——如果变量以extern关键字为前缀，就意味着该变量可在着色器外被访问，比如被C++应用程序。仅全局变量可以以extern关键字为前缀。不是static的全局变量默认就是extern。</p>
</li>
<li><p>shared——如果变量以shared关键字为前缀，就提示效果框架（参见19章）：变量将在多个效果间被共享。仅全局变量可以以shared为前缀。</p>
</li>
<li><p>volatile——如果变量以volatile关键字为前缀，就提示效果框架（参见19章）：变量将被时常修改。仅全局变量可以以volatile为前缀。</p>
</li>
<li><p>const——HLSL中的const关键字和C++里的意思一样。也就是说，如果变量以const为前缀，那此变量就是常量，并且不能被改变。const float pi = 3.14f;<br>16.4关键字、语句和强制转换<br>16.4.1 关键字<br>为便于参考，这里给出一个HLSL定义的关键字列表：<br>asm        bool        compile       const          decl         do<br>double      else        extern         false          float         for<br>half        if           in            inline         inout         int<br>matrix      out         pass           pixelshader    return        sampler<br>shared      static       string          struct         technique     texture<br>true        typedef     uniform        vector         vertexshader   void<br>volatile     while</p>
</li>
</ul>
<p>下面的集合显示了被保留并且未使用但是将来可能成为关键字的标识符：<br>auto            break        case           catch         char          class<br>const_cast       continue      default         delete        dynamic cast   enum<br>explicit         friend         goto           long         mutable       namespace<br>new            operator       private         protected     public         register<br>reinterpret_cast   short         signed          sizeof        static_cast     switch<br>template         this          throw          try           typename     union<br>unsigned         using        virtual </p>
<p>16.4.2 基本程序流程<br>HLSL支持很多与C++相似的选择、重复、和一般程序流程语句。这些语句的语法和C++极为相似。<br>return语句：<br>return (expression);<br>if和if…else语句：<br>if( condition )<br>{<br>     statement(s);<br>}</p>
<p>if( condition )<br>{<br>     statement(s);<br>}<br>else<br>{<br>     statement(s);<br>}</p>
<p>for语句：<br>for(initial; condition; increment)<br>{<br>     statement(s);<br>}</p>
<p>while语句：<br>while( condition )<br>{<br>     statement(s);<br>}</p>
<p>do…while语句：<br>do<br>{<br>     statement(s);<br>}while( condition );</p>
<p>16.4.3 强制转换（casting）<br>   HLSL支持一种非常自由的强制转换设计。HLSL中强制转换的语法和C程序语言中的一样。例如要把float转换到matrix，我们写：<br>float f = 5.0f;<br>matrix m = (matrix)f;</p>
<p>   从本书的例子中，你就能推断出这个转换语法的意思。但是，如果想要得到更详细的受支持的转换的信息，那么在DirectX SDK里，Content（内容）标签页下，看DirectX Graphics\Reference\Shader Reference\High Level Shading Language\Type就可以了。</p>
<p>16.5 操作符<br>   HLSL支持很多类似C++的操作符。除了很少一些底下注释的例外以外，他们的用法和C++里的完全一样。下表列出了HLSL的操作符：<br>[]<br>?<br>&gt;<br>&lt;<br>&lt; =</p>
<blockquote>
<p>=<br>! =<br>= =<br>!<br>&amp;&amp;<br>?<br>?:<br>+</p>
<ul>
<li>=<br>-</li>
</ul>
<ul>
<li>=<br><em>
</em>=<br>/<br>/=<br>%<br>%=</li>
</ul>
<h2 id><a href="#" class="headerlink" title="+ +"></a>+ +</h2><p>=<br>()<br>‘</p>
</blockquote>
<p>   虽然操作符的行为和C++很相似，但是也有一些差异。第一，求模%运算符对整型和浮点型都起作用。为了使用求模操作符，左边的值和右边的值都必须有相同的正负号（如：左边和右边必须都是正或者负）。</p>
<p>   第二，要注意HLSL操作是以每个分量为基础的。这是由于实际上向量和矩阵是语言内建的，并且这些类型是由若干个分量组成。通过将这些操作施加在分量级别之上，我们可以像使用数值类型一样完成诸如向量/矩阵的加法，减法和相等测试这些操作（），见下例：</p>
<p>注意：操作符的行为正如对数值操作一样（也就是说，按一般C++的方式）。<br>vector u = {1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 2.0f, 1.0f, 0.0f};<br>// adds corresponding components<br>vector sum = u + v; // sum = (-3.0f, 2.0f, -2.0f, 1.0f)</p>
<p>增量一个向量就是增量其每个分量：<br>// before increment: sum = (-3.0f, 2.0f, -2.0f, 1.0f)<br>sum++; // after increment: sum = (-2.0f, 3.0f, -1.0f, 2.0f)</p>
<p>向量相乘也是按分量的：<br>vector u = {1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 2.0f, 1.0f, 0.0f};</p>
<p>// multiply corresponding components<br>vector sum = u * v; // product = (-4.0f, 0.0f, -3.0f, 0.0f)</p>
<p>比较操作也是按分量进行的，并且返回一个每个分量都为bool类型的向量或者数组。作为结果的“bool”向量包含了每个分量比较的结果。例如：<br>vector u = { 1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 0.0f, 1.0f, 1.0f};<br>vector b = (u == v); // b = (false, true, false, true)</p>
<p>最后，我们以讨论二元操作的变量提升（promotion）作为结束：</p>
<ul>
<li>对于二元操作，如果（操作符的）左边和右边维数不同，则维数较少的一边提升（强制转换）到具有和维数较大的一边相同的维数。例如，如果x的类型为float，而y的类型为float3，在表达式(x + y)中变量x被提升到float3，并且计算出来的表达式的值的类型也为float3。提升使用已定义的转换完成。注意，若转换未定义则提升也是未定义的。例如，我们不能转换float2到float3，因为没有定义这个转换。</li>
<li>对于二元操作，如果左边和右边类型不同，那么较低精度的类型（the lower type resolution）被提升（强制转换）到具有同类型的较高精度的类型（the higher type resolution）。例如，如果x类型为int，y类型为half，则表达式(x + y)中的变量x被提升到half，并且计算出来的表达式的值的类型也为half。</li>
</ul>
<p>16.6 用户定义函数<br>HLSL中的函数有下例属性：</p>
<ul>
<li>函数使用类似C++的语法</li>
<li>参数总是按值传递</li>
<li>递归不被支持</li>
<li>函数总是inline的</li>
</ul>
<p>此外，函数还加上了一些用于其上的额外的关键字。例如，考虑一个写在HLSL中的下面这个函数：<br>bool foo(in const bool b,   // input bool<br>         out int r1,        // output int<br>         inout float r2)    // input/output float<br>{<br>     if( b )               // test input value<br>     {<br>          r1 = 5;          // output a value through r1<br>     }<br>     else<br>     {<br>          r1 = 1;          // output a value through r1<br>     }</p>
<pre><code> // since r2 is inout we can use it as an input
 // value and also output a value through it
 r2 = r2 * r2 * r2;

 return true;
</code></pre><p>}</p>
<p>函数几乎和C++函数是一样的，除了in，out和inout关键字：</p>
<ul>
<li>in——指定型参（argument，特指传递给实参的变量）应该在函数开始前被拷贝给实参。传入参数不必强制指定，因为实参默认是in的。例如，下面两段是等价的：<br>float square(in float x)<br>{<br>   return x * x;<br>}</li>
</ul>
<p>也可以不强制指定in：<br>float square(float x)<br>{<br>     return x * x;<br>}</p>
<ul>
<li><p>out——指定实参应该在函数返回时被拷贝给型参。这样可以通过参数返回值。out关键字是必须的，因为HLSL不允许传递一个引用或一个指针。我们要注意：如果实参标记为out，在函数开始前，型参就不拷贝给实参。换句话说，out实参仅可以被用于输出数据——它不能用于输入。<br>void square(in float x, out float y)<br>{<br>   y = x * x;<br>}<br>这里，我们输入了要被乘方的数x，并且通过参数y返回了x的乘方。</p>
</li>
<li><p>inout——这是一个指示实参既用于输入又用于输出的快捷方法。如果要使用实参同时用作输入和输出，就指定inout。<br>void square(inout float x)<br>{<br>   x = x * x;<br>}<br>这里，我们输入了要被乘方的数x，同时又通过x返回了的x的乘方。</p>
</li>
</ul>
<p>16.7内建函数<br>   HLSL有一个丰富的内建函数的集合，它们对3D图形来说非常有用。下表是一个删减了的列表。在下两章中，我们会使用这些函数中的一些进行实践。而现在，熟悉它们就够了。</p>
<p>注意：要得到更多的参考，可以参看DirectX文档中内建HLSL函数的完整列表，在Content页下，然后到DirectX Graphics\Reference\Shader Reference\High Level Shader Language\Intrinsic Functions。</p>
<p>译者注：以下表格中，//<variable>//表示变量variable的模（例如向量的绝对值）。<br>函数<br>描述<br>abs(x)<br>返回 |x|<br>ceil(x)<br>返回 ≥ x 的最小整数<br>clamp(x, a, b)<br>clamp(x, a, b)<br>clamp(x, a, b)<br>clamp(x, a, b)<br>cross(u, v)<br>返回 u × v（叉积）<br>degrees(x)<br>转换 x 从弧度到角度<br>determinant(M)<br>返回矩阵M的行列式det(M)<br>distance(u, v)<br>返回u点和v点之间的距离||v - u||<br>dot(u, v)<br>返回 u · v（点积）<br>floor(x)<br>返回 ≤ x 的最大整数<br>length(v)<br>返回 ||v||<br>lerp(u, v, t)<br>在u和v之间线性插值，根据参数 t ? [0, 1 ]<br>log(x)<br>返回 ln(x)<br>log10(x)<br>返回 log10(x)<br>log2(x)<br>返回 log2(x)<br>max(x, y)<br>如果x ≥ y，则返回 x；否则返回 y<br>min(x, y)<br>如果 x ≤ y，返回x；否则返回 y<br>mul(M, N)<br>返回矩阵乘积 MN. 注意：矩阵乘积必须是已定义的. 如果M是一个向量，它被作为一个行向量，则向量－矩阵（vector-matrix）乘法是已定义的。类似的,如果N 是一个向量，他被作为一个列向量，则矩阵－向量（matrix-vector）乘法是已定义的<br>normalize(v)<br>返回 v/∥v∥<br>pow(b, n)<br>返回 bn<br>radians(x)<br>转换 x 从 角度 到 弧度<br>reflect(v, n)<br>给定向量v和表面法线n，计算其反射向量<br>refract(v,n, eta)<br>给定向量v、表面法线n和两种材质的两个索引的比率eta，计算其折射向量. 翻看一下物理书中Snell的规则或者在互联网上搜索一下关于refraction（反射）的信息<br>rsqrt(x)<br>返回x的平方根的倒数<br>saturate(x)<br>返回clamp(x, 0.0, 1.0)<br>sin(x)<br>返回x的正弦,其中x单位为弧度<br>返回x的正弦,其中x单位为弧度<br>返回x的正弦和余弦，其中x单位为弧度<br>sqrt(x)<br>返回x的平方根<br>tan(x)<br>返回x的正切,其中 x 单位为弧度<br>transpose(M)<br>返回MT的转置</variable></p>
<p>   大多数函数已经重载以使其可以对所有内建类型有意义。例如，abs对所有数值类型有意义，所以它为所有这些数值类型进行了重载。又例如，叉积的叉乘仅对3D向量有意义，所以它对所有类型的3D向量（比如：int，float，double的3D向量）进行了重载。另一方面，线性插值——lerp，对于数值、2D、3D和4D向量有意义，因此重载了这些类型。</p>
<p>注意：如果你传递进去一个非数值类型到一个（要求）数值类型的函数，也就是一个仅能对数值类型进行操作的函数（比如：cos(x)），那么这个函数会对传进去的每个分量进行操作。例如，你写：<br>floats v = float3 (0.0f, 0.0f, 0.0f);<br>v = cos(v);</p>
<p>那么函数将会对每个分量进行操作：v=(cos(x),cos(y),cos(z))。<br>下例展示了这些固有的函数可能被调用的方式：<br>float x = sin(1.0f);       // sine of 1.0f radian.<br>float y = sqrt(4.0f);      // square root of 4.</p>
<p>vector u = {1.0f, 2.0f, -3.0f, 0.0f};<br>vector v = {3.0f, -1.0f, 0.0f, 2.0f};<br>float  s = dot(u, v);      // compute dot product of u and v.</p>
<p>float3 i = {1.0f, 0.0f, 0.0f};<br>float3 j = {0.0f, 1.0f, 0.0f};<br>float3 k = cross(i, j);    // compute cross product of i and j.</p>
<p>matrix<float, 2 2,> M = {1.0f, 2.0f, 3.0f, 4.0f};<br>matrix<float, 2 2,> T = transpose(M); // compute transpose</float,></float,></p>
<p>16.8 摘要</p>
<ul>
<li>我们在ASCII文本文件中编写了HLSL程序，并且在我们的应用程序中使用D3DXCompileShaderFromFile函数编译了它们。</li>
<li>ID3DXConstantTable接口允许我们在应用程序中对着色器程序中的变量进行设置。这种通信是必须的，因为被着色器使用的变量可以按一帧一帧的变化而改变。例如，如果应用程序中的视图矩阵发生了改变，我们需要使用新的视图矩阵更新着色器的视图矩阵变量。我们可以用ID3DXConstantTable完成这种更新。</li>
<li>对于每个着色器，我们必须定义一个输入和一个输出结构，这些结构分别描述了着色器中输入和输出数据的格式。</li>
<li>每个着色器有一个入口点函数，它有一个输入结构参数用于传递数据进着色器。此外，每个着色器返回一个输出结构的实例，它用于从着色器输出数据。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Picking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Picking/" class="post-title-link" itemprop="url">第十五章 选取(Picking)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:26:08" itemprop="dateCreated datePublished" datetime="2019-04-11T15:26:08+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>概览(OVERVIEW)<br>   如果用户点击了屏幕上的点 s = (x, y)。 从图15.1 我们能看到用户选取了茶壶。 无论如何，应用程序无法根据给定的s点就立即确定茶壶是被选取。所以，我们必须拿出计算这个动作技巧来，叫做选取技巧。</p>
<p>   图15.1 用户正在选择茶壶</p>
<p>   我们知道一些知识：关于茶壶和它的关联点s，茶壶投影在围绕s点的区域，更准确的说是：它投影到投影窗口上围绕p点的区域，与它对应的屏幕点是s。因为这个问题依赖于3D物体与它的投影之间的关系，我们看图15.2就可以了解。</p>
<p>图15.2放射线穿过点p点将会相交于围绕p点投影的对象。 注意：在投影窗口上的点 p与荧屏上被按下了点s相关联。</p>
<p>   图15.2我们看到如果我们发射一条选取射线，从原点发出，经过点p，会与围绕p点投影的对象相交，即茶壶。所以一旦我们计算选取射线，我们可以遍例场景中的每个对象并测试，看射线是否与它相交。与射线相交的对象即是用户选择的对象，在这个例子中用户选取的对象是茶壶。<br>   上面的例子讲解了点s与茶壶的关系。通常我们任意点击屏幕上的点，我们遍例场景中的每个对象，如果对象与射线相交，那么这个对象就是用户选取的对象。例如，图15.1中，如果用户没有点击5个对象中的一个，而是点击了白色的背景区域，射线将不能相交任何对象。因此，结论是：如果射线没有与场景中的任何对象相交，则用户没有点击任何一个对象，其它的我们不关心。<br>   “选取”适用于所有种类的游戏和3D程序。例如，玩家通过用鼠标点击来影响3D世界中的不同对象，玩家可能点击向敌人射击，或点击拾取物品。好的程序会适当做出反应，程序需要知道哪个对象被选取（是敌人还是物品），和在3D空间中的位置（开枪会击中哪？或玩家将要移动到哪去拾取物品？）。选取回答了我们这些问题。</p>
<p>目标<br>学习如何计算选取算法并了解它是如何工作的，我们将选取分解成四步：<br>1) 给一个屏幕点s，找出它在投影窗口上相交的点，即p。<br>2) 计算射线，它是从原点出发并经过点p。<br>3) 转换射线与模型到同一空间。<br>4) 测试与射线相交的对象，相交的对象即是屏幕上点击的对象。<br>15.1 屏幕到投影窗口的转换<br>首先，转换屏幕点到投影窗口，视口变换矩阵是：</p>
<p>根据屏幕上的点s = (sx, sy)，通过视口转换，得到在投影窗口上的点p = (px, py, pz)：</p>
<p>回忆一下2D图形部分：视口转换后z轴是不用保存的，而被保存在z缓存中。<br>给出屏幕点s，我们要找到点p，使用下列公式：</p>
<p>假定视口成员x和y都是0，通常我们能进一步得到：</p>
<p>因为前面的定义，投影窗口就是z=1的平面，所以pz = 1。</p>
<p>可是我们还什么都没做，投影矩阵缩放投影窗口上的点，来模拟不同的视角。为了返回缩放前的点值，我们必须用与缩放相反的操作来转换点。P是投影矩阵，因为P00 和 P11转换距阵缩放点的x和y坐标，我们得到：</p>
<p>15.2 计算射线<br>   回忆一下，射线能够描述参数方程：p(t) = p0 + tu。其中p0是射线的起点，用来描述它的位置，u是向量，用来描述它的方向。<br>   如图15.2，我们知道射线的起点总是视图空间的原点，所以p0 = (0, 0, 0)，如果p是射线穿过投影窗口上的点，方向向量u给出：u = p - p0 = (px, py, 1) - (0, 0, 0) = p。<br>   下面的方法用来计算选取射线（从屏幕空间点击的点所对应的视图空间的点x、y坐标）：<br>d3d::Ray CalcPickingRay(int x, int y)<br>{<br>     float px = 0.0f;<br>     float py = 0.0f;</p>
<pre><code> D3DVIEWPORT9 vp;
 Device-&gt;GetViewport(&amp;vp);
 D3DXMATRIX proj;
 Device-&gt;GetTransform(D3DTS_PROJECTION, &amp;proj);

 px = ((( 2.0f*x) / vp.Width)  - 1.0f) / proj(0, 0);
 py = (((-2.0f*y) / vp.Height) + 1.0f) / proj(1, 1);

 d3d::Ray ray;
 ray._origin    = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
 ray._direction = D3DXVECTOR3(px, py, 1.0f);

 return ray;
</code></pre><p>}<br>where Ray is defined as:<br>struct Ray<br>{<br>     D3DXVECTOR3 _origin;<br>     D3DXVECTOR3 _direction;<br>};<br>   我们更新d3dUtility.h文件，在d3d命名空间中加入选取射线Ray。</p>
<p>15.3 变换射线<br>   上一节讲到，选取射线的计算被描述在视图空间，为了完成射线的相交的测试，射线和对象必须在同一个坐标系统。通常转换射线到世界空间（甚至对象在本地空间）要好于将所有对象转换到视图空间。<br>   我们能够将一个变换矩阵转换为一条原点为p0，方向为u的射线r(t) = p0 + tu，注意：原点转换为一个点，方向转换为一个向量，在本章的选取例子中，下列函数转换一条射线：<br>void TransformRay(d3d::Ray<em> ray, D3DXMATRIX</em> T)<br>{<br>      // transform the ray’s origin, w = 1.<br>      D3DXVec3TransformCoord(<br>           &amp;ray-&gt;_origin,<br>           &amp;ray-&gt;_origin,<br>           T);</p>
<pre><code>  // transform the ray&#39;s direction, w = 0.
  D3DXVec3TransformNormal(
       &amp;ray-&gt;_direction,
       &amp;ray-&gt;_direction,
       T);

  // normalize the direction
  D3DXVec3Normalize(&amp;ray-&gt;_direction, &amp;ray-&gt;_direction);
</code></pre><p>}<br>   D3DXVec3TransformCoord和D3DXVec3TransformNormal接受一个Ray类型参数（包含二个3D向量成员）。 D3DXVec3TransformCoord函数中，射线的原点（_origin）向量的第四部分w = 1。相反，函数D3DXVec3TransformNormal中，射线的方向（_direction）向量的第四部分w = 0。<br>   这样，当我们向世界空间转换时，能够用D3DXVec3TransformCoord转换一个点，用D3DXVec3TransformNormal转换一个向量。</p>
<p>15.4 射线－对象 交点<br>   我们将射线和对象转换到同一坐标系统后，准备测试哪个对象与射线相交。因为我们将对象描述为三角形组成的网络，下面详细说明这种方法。遍例场景中每个对象的三角形列表并测试，如果射线相交于一个三角形，它就与三角形所在的对象相交。<br>   然而，通过遍例场景中的每个三角形来实现射线相交在计算上会增加时间，一种比较快的方法，虽然准确性会差一点。它将每个对象围成一个近似的球形（边界球），这样我们就能通过遍例每个边界球来测试射线相交。用边界球来描述相交的对象。<br>   注意：射线可能相交多个对象，然而离照相机近的对象会被选取。因为近距离对象遮挡了后面的对象。<br>   给出一个边界球的圆心c和半径r，使用下列恒等式能够测试点p是否在边界球上：<br>   ||p-c||-r = 0<br>   如果恒等式满足，则点p在边界球上。如图15.3</p>
<p>   图15.3 向量p到c的长度表示为：||p - c||，如果等于半径则表示点p在边界球上。注意：我们使用边界球是为了方便，但这将扩展出三个种情况。<br>   假定射线p(t) = p0 + tu相交于边界球，我们将射线代入球的恒等式中，使参数t满足了球的恒等式，给出了满足相交点的参数。</p>
<p>将射线p(t) = p0 + tu代入球的恒等式：<br>||p(t) - c|| - r = 0   —&gt;   ||p0 + tu - c|| - r = 0</p>
<p>通过以上推导，我们得到二次方程：<br>At2 + Bt + C = 0</p>
<p>其中A = u · u, B = 2(u · (p0 - c))，而C = (p0 - c) . (p0 - c) – r 2。<br>如果u是标准化的，那么A = 1。<br>因为u是标准化的，我们解t0 和 t1：</p>
<p>   图15.4显示可能返回的t0 和 t1，并显示了一些返回值的几何意义：</p>
<p>   图15.4 (a)射线从球边上擦过；(b)射线在球前；(c)射线在球的内部；(d)射线相交于球；(e)射线是球的切线。<br>   下列方法射线通过并与边界球相交，返回true；射线错过边界球，返回false。<br> bool PickApp::raySphereIntersectionTest(Ray<em> ray,<br>                                        BoundingSphere</em> sphere)<br>{<br>     D3DXVECTOR3 v = ray-&gt;_origin - sphere-&gt;_center;<br>     float b = 2.0f <em> D3DXVec3Dot(&amp;ray-&gt;_direction, &amp;v);<br>     float c = D3DXVec3Dot(&amp;v, &amp;v) - (sphere-&gt;_radius </em> sphere-&gt;<br>                                      _radius);</p>
<pre><code> // find the discriminant
 float discriminant = (b * b) - (4.0f * c);

 // test for imaginary number
 if( discriminant &lt; 0.0f )
      return false;

 discriminant = sqrtf(discriminant);

 float s0 = (-b + discriminant) / 2.0f;
 float s1 = (-b - discriminant) / 2.0f;

 // if a solution is &gt;= 0, then we intersected the sphere
 if( s0 &gt;= 0.0f || s1 &gt;= 0.0f )
      return true;

 return false;
</code></pre><p>}<br>   当然，我们已经准备了一个边界球，为了便于理解我们再次显示它的定义：<br>bool PickApp::raySphereIntersectionTest(Ray<em> ray,<br>                                        BoundingSphere</em> sphere)<br>{<br>struct BoundingSphere<br>{<br>     BoundingSphere();</p>
<pre><code> D3DXVECTOR3 _center;
 float       _radius;
</code></pre><p>};</p>
<p>15.5 例子程序：选取<br>图15.5显示了本章例子程序的屏幕截图，茶壶绕着屏幕移动，你可以用鼠标试着点击它。如果你点击到茶壶的边界球上，一个消息框将弹出，表示你点中了。我们通过测试WM_LBUTTONDOWN消息来处理鼠标点击事件：<br>case WM_LBUTTONDOWN:</p>
<p>// compute the ray in view space given the clicked screen point<br>d3d::Ray ray = CalcPickingRay(LOWORD(lParam), HIWORD(lParam));</p>
<p>// transform the ray to world space<br>D3DXMATRIX view;<br>Device-&gt;GetTransform(D3DTS_VIEW, &amp;view);</p>
<p>D3DXMATRIX viewInverse;<br>D3DXMatrixInverse(&amp;viewInverse, 0, &amp;view);</p>
<p>TransformRay(&amp;ray, &amp;viewInverse);</p>
<p>// test for a hit<br>if( RaySphereIntTest(&amp;ray, &amp;BSphere) )<br>     ::MessageBox(0, “Hit!”, “HIT”, 0);</p>
<p>break;</p>
<p>图15.5 这章例子程序的屏幕截图</p>
<p>15.6 摘要</p>
<ul>
<li>选取技巧通过鼠标点击，来确定与3D对象对应的屏幕上显示的2D投影对象。</li>
<li>选取线是一个射线，源自视图空间的原点，穿过投影窗口上的点关联到屏幕上点击的点。</li>
<li>我们能够变换一个射线r(t) = p0 + tu，通过变换原点p0和通过矩阵变换得到方向u。注意：原点变换自一个（w=1）的点，方向是（w=0）的向量。</li>
<li>测试射线与对象相交，我们能测试射线是否相交于组成对象的三角形，或测试射线是否相交于围绕对象的一个体积，比如边界球。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Particle-System/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Particle-System/" class="post-title-link" itemprop="url">第十四章 粒子系统(Particle Systems)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:24:20" itemprop="dateCreated datePublished" datetime="2019-04-11T15:24:20+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>   许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。<br>目标：</p>
<ul>
<li>学习我们给定的粒子属性，如何描述D3D中的粒子。</li>
<li>设计一个灵活的粒子基系统的基类，包括一般的粒子系统都有的属性和方法。</li>
<li>模拟3个具体的粒子系统，雪、爆炸、粒子枪。<br>14.1 粒子和点精灵（Point Sprite）<br> 粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案。可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0,以前，因为点元方法的局限性而完全不使用他们。代替的方法是，程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。<br> Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。</li>
</ul>
<p>14.1.1 结构的格式<br>   我们使用下面的顶点结构来描述粒子的位置和颜色：<br>struct Particle<br>{<br>     D3DXVECTOR3 _position;<br>     D3DCOLOR    _color;<br>     static const DWORD FVF;<br>};<br>const DWORD Particle::FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;<br>   这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标，我们在下一节讨论给点精灵赋予纹理。<br>   增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是：用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：<br>strict Particle<br>{<br>     D3DXVECTOR3 _position;<br>     D3DCOLOR    _color;<br>     float       _size;<br>     static const DWORD FVF;<br>};<br>const DWORD Particle::FVF = D3DFVF XYZ | D3DFVF DIFFUSE |<br>  D3DFVF_PSIZE;<br>   注意：通过vertex shader，能够获取每个粒子的大小，即使你的硬件不支持D3DFVFCAPS_PSIZE。Vertex shaders的内容在本书的第IV部分。</p>
<p>14.1.2点精灵（Point Sprite）渲染状态<br>   点精灵的行为大部分由渲染状态（render states）来控制，现在让我们来看一下这些渲染状态：<br>D3DRS_POINTSPRITEENABLE—A Boolean value. The default value is false.<br>True表示将当前的纹理全部映射到点精灵上。<br>False 表示用指定的纹理坐标映射到点精灵的点（图素）上。<br>_device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);</p>
<p>D3DRS_POINTSCALEENABLE—A Boolean value. The default value is false.<br>True表示用视图空间单位来解释点的大小。视图空间单位的3D空间点在照相机中，点精灵将会自动缩放，这取决到它有多远, 像其他对象一样，离照相机近的粒子比离照相机远的粒子要小。<br>False 表示点的大小将用屏幕空间单位来解释。屏幕空间单位是屏幕上的像素单位。. 因此如果你指定false, 例如, 设置点精灵的尺寸为3, 则点精灵在屏幕区域中的尺寸为3×3像素。.<br>_device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);</p>
<p>D3DRS_POINTSIZE—表示点精灵的尺寸. 这个值可以任意指定视图空间或屏幕空间的点精灵的尺寸, 取决于D3DRS_POINTSCALEENABLE 状态如何设置. 下面的代码段设置点的尺寸为2.5个单位。:<br>_device-&gt;SetRenderState( D3DRS_POINTSIZE, d3d::FtoDw(2.5f) );</p>
<p>d3d::FtoDw 是我们新加进 d3dUtility.h/cpp 文件中的一个函数，它将float型转换为 DWORD型。 我们必须这么做是因为所有的IDirect3DDevice9::SetRenderState 都要一个 DWORD 型的值而不是float型。<br>DWORD d3d::FtoDw(float f)<br>{<br>     return <em>((DWORD</em>)&amp;f);<br>}</p>
<p>D3DRS_POINTSIZE_MIN—表示点精灵的最小尺寸。例子，将设置最小值为0.2：<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE_MIN, d3d::FtoDw(0.2f));</p>
<p>D3DRS_POINTSIZE_MAX—表示点精灵的最大尺寸。例子，将设置最大值为5.0:<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE_MAX, d3d::FtoDw(5.0f));</p>
<p>D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C—这3个常量表示如何根据距离控制点精灵的尺寸—这个距离是点精灵到照相机的距离。</p>
<p>D3D用以下的公式去计算点精灵的最终尺寸，这取决于距离和这3个常量。</p>
<p>其中：<br>FinalSize：距离计算后，点精灵的最后尺寸。<br>ViewportHeight：视口的高度。<br>Size：分别为D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, and D3DRS_POINTSCALE_C值。<br>D：在视图空间中点精灵与照相机的距离。因为照相机被放置在视图空间中的原点，这个值是：，也是点精灵所在的位置。</p>
<p>   下面代码设置点精灵的距离常量，因此远处的点精灵将变小。<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_A, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_B, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_C, d3d::FtoDw(1.0f));</p>
<p>14.1.3 粒子和他们的属性<br>    一个粒子系统是由除了位置、颜色以外的更多的属性组成，例如，一个粒子有某些速度。然而，这些额外的属性对于渲染粒子来说不是必须的。因此，我们在单独的结构中保存渲染粒子所必须的数据和属性。当我们创建、显示或更新粒子时，我们使用属性来工作。当我们准备渲染时，我们从Particle（粒子）结构中COPY位置和颜色。<br>   对于我们模拟的具体粒子系统，粒子的属性也是不同的。因此我们能够归纳一些通用的属性，一面的结构例子中包含一些通用的属性，大多数系统用不上这么多，一些系统需要的属性这里可能还没有。<br>struct Attribute<br>{<br>     D3DXVECTOR3 _position;<br>     D3DXVECTOR3 _velocity;<br>     D3DXVECTOR3 _acceleration;<br>     float       _lifeTime;<br>     float       _age;<br>     D3DXCOLOR   _color;<br>     D3DXCOLOR   _colorFade;<br>     bool        _isAlive;<br>};<br>_position—粒子在世界空间中的位置<br>_velocity—粒子的速度，每秒多少个单位。<br>_acceleration—粒子的加速度, 每秒多少个单位。<br>_lifeTime—粒子的生命周期. 例如,当一个时间段后，我们可以杀死一个激光柱的粒子.<br>_age—粒子的当前年龄。<br>_color—粒子的颜色。<br>_colorFade—粒子随时间的变化而褪去的颜色。<br>_isAlive—True 表示粒子活着;false 表示粒子死了。 </p>
<p>14.2 粒子系统的组成<br>   粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。<br>   虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的Psystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下Psystem类：<br>class PSystem<br>{<br>public:<br>     PSystem();<br>     virtual ~PSystem();</p>
<pre><code> virtual bool init(IDirect3DDevice9* device, char* texFileName);
 virtual void reset();
 virtual void resetParticle(Attribute* attribute) = 0;
 virtual void addParticle();
 virtual void update(float timeDelta) = 0;

 virtual void preRender();
 virtual void render();
 virtual void postRender();

 bool isEmpty();
 bool isDead();
</code></pre><p>protected:<br>     virtual void removeDeadParticles();</p>
<p>protected:<br>     IDirect3DDevice9<em>       _device;<br>     D3DXVECTOR3             _origin;<br>     d3d::BoundingBox        _boundingBox;<br>     float                   _emitRate;<br>     float                   _size;<br>     IDirect3DTexture9</em>      _tex;<br>     IDirect3DVertexBuffer9* _vb;<br>     std::list<attribute>    _particles;<br>     int                     _maxParticles;</attribute></p>
<pre><code> DWORD _vbSize;
 DWORD _vbOffset;
 DWORD _vbBatchSize;
</code></pre><p>};</p>
<p>   一些数据成员：</p>
<ul>
<li>_origin—粒子系统的原点， 这是粒子系统产生时的位置。</li>
<li>_boundingBox—创建粒子系统使用的边界盒，用于限制粒子的活动范围。例如，假如我们让雪系统只落在一个围绕高山的峰顶的体积内； 我们会定义一个包括这个体积的边界盒, 出界的粒子将会被杀死。</li>
<li>_emitRate—新增加到系统中的粒子的速度。 通常的标准是每秒。</li>
<li>_size—系统中所有粒子的尺寸。</li>
<li>_particles—系统中粒子属性的一个列表。 我们用这个列表创建，释放及更新粒子。 当我们准备画粒子时, 我们COPY列表节点的一部分到顶点缓存并画粒子。 当我们COPY另外一批时绘制这批粒子，然后重复这一过程直到绘制完所有粒子。 这有点太简单了，我们将在section 14.2.1节详细的解释绘制的过程。</li>
<li>_maxParticles—在给定的时间内，系统中允许的粒子最大数。例如, 如果创建粒子的速度比释放快的话, 随着时间的增长粒子的数量将会是巨大的，这个成员将避免出现这样的问题。</li>
<li>_vbSize—在给定的时间内顶点缓存中能够保存的粒子的数量，这个值与实际的粒子系统中的粒子数量无关。<br>注意：member _vbOffset和_vbBatchSize数据成员在渲染粒子系统时使用，我们在稍后的section 14.2.1节讨论。</li>
</ul>
<p>方法：</p>
<ul>
<li>PSystem/ ~PSystem—用来初始化默认值的构造器/用来释放设备接口的析构器 (vertex buffer, texture)。</li>
<li>init—这个方法做与设备无关的初始化工作, 比如创建用来保存点精灵的顶点缓存或创建纹理。 顶点缓存的创建包括一些标记，现在我们都已经讨论过了，但还没有用:<br>hr = device-&gt;CreateVertexBuffer(<br>   _vbSize * sizeof(Particle),<br>   D3DUSAGE DYNAMIC | D3DUSAGE POINTS | D3DUSAGE WRITEONLY,<br>   Particle::FVF,<br>   D3DPOOL_DEFAULT,<br>   &amp;_vb,<br>   0) ;</li>
<li>o 注意： 我们使用动态的顶点缓存（D3DUSAGE DYNAMIC）。 因为我们需要在每帧中更新我们的粒子,意思是我们将会去存取顶点缓存的内存，回想一下，访问一个静态的顶点缓存慢得不可接受， 所以我们使用动态的顶点缓存。<br>o 查看我们用过的 D3DUSAGE_POINTS 标记,它说明顶点缓存将保存点精灵。<br>o 顶点缓存的尺寸是由_vbSize预先确定的，而且与系统中粒子的数量无关。 也就是说, _vbSize 将小于等于系统中粒子的数量。 这是因为渲染粒子系统是一批一批的，不是一次渲染全部。 我们将在section 14.2.1节中解释渲染过程。<br>o 我们使用默认的内存池(pool)代替通常使用的托管内存池，因为动态顶点缓存不能用在托管内存池中。</li>
<li>reset—这个方法重新设置系统中每个粒子的属性:<br>void PSystem::reset()<br>{<br>   std::list<attribute>::iterator i;<br>   for(i = _particles.begin(); i != _particles.end(); i++)<br>   {<pre><code>    resetParticle( &amp;(*i) );
</code></pre>   }<br>}</attribute></li>
<li>resetParticle—这个方法重新设置粒子的属性。如何重设粒子的属性，这依赖于具体粒子系统的特性。因此我们定义这个方法为虚拟的，等待子类去实现。</li>
<li>addParticle—这个方法用来在系统中增加一个粒子。在增加它到粒子列表之前，使用resetParticle 方法先初始化粒子:<br>void PSystem::addParticle()<br>{<br>   Attribute attribute;<br>   resetParticle(&amp;attribute);<br>   _particles.push_back(attribute);<br>}<br>void PSystem::addParticle()</li>
<li>update—这个方法更新系统中所有的粒子。因为这个的方法的执行取决于具体粒子系统的特性, 因此我们定义这个方法为抽象的，等待子类去实现。</li>
<li>render—这个方法用来显示系统中所有的粒子。 执行起来很复杂，我们将在14.2.1 节讨论。</li>
<li><p>preRender—用它来初始化渲染状态， 在渲染前设置。 因为系统与系统之间是不同的,所以我们定义它为虚拟的。 默认将执行下列代码:<br>void PSystem::preRender()<br>{<br>_device-&gt;SetRenderState(D3DRS_LIGHTING, false);<br>_device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE, d3d::FtoDw( size));<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE MIN, d3d::FtoDw(0.0f));</p>
<p>// control the size of the particle relative to distance<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE A, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE B, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE C, d3d::FtoDw(1.0f));</p>
<p>// use alpha from texture<br><em>device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA</em><br>   TEXTURE);<br><em>device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP</em><br>   SELECTARG1);</p>
<p>_device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);<br>_device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>}</p>
</li>
<li>注意：我们使用alpha混合渲染，以便设置纹理的alpha通道，来设置纹理像素的透明度。 用它产生多种效果；一种特殊的情况是：获得象纹理那样的非矩形的粒子。例如， 获得一个圆形“雪球形”的粒子, 我们使用一个简单的带有alpha通道的纹理， 它看上去是背景为黑色的带有白色圆形的样子。因此，显示出来时只是一个白圆，这比白色的矩形纹理要好。</li>
<li><p>postRender—用它去保存所有渲染状态，它是一个特殊的粒子系统可能有的设置。因为系统与系统间是不同的,所以我们定义它为虚拟的。默认将执行下列代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PSystem::postRender()</span><br><span class="line">&#123;</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_LIGHTING,          <span class="literal">true</span>);</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, <span class="literal">false</span>);</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE,  <span class="literal">false</span>);</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE,  <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>isEmpty—如果为True 则在当前的系统中没有粒子， 否则为false.</p>
</li>
<li>isDead—如果为True 则系统中的所有粒子都是死的，否则为false。 注意： 系统中所有粒子状态为idDead时并不意味着isEmpty. 空意思着系统中没有粒子。 Dead的意思是系统中有粒子，但都是死的。.</li>
<li>removeDeadParticles—搜索属_particle性表，从表中杀死并删除粒子。<br>14.2.1 绘制粒子系统<br> 因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下:</li>
<li><p>创建一个足够大的顶点缓存保存最大数量的粒子。</p>
<pre><code>   每一帧里执行：
</code></pre><p>A. 更新所有粒子。<br>B. COPY所有活着的粒子到顶点缓存。<br>C. 绘制顶点缓存。<br> 这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，并且我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。</p>
<p>  更好的办法（SDK中点精灵例程中用到的方法）就象这样：<br> 提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。</p>
<p> 创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。</p>
</li>
</ul>
<ul>
<li>然后创建一个全局变量 i = 0 ，用来记录片段。<pre><code>   每一帧里执行:
</code></pre>A. 更新所有粒子。<br>B. 直到所有粒子渲染完毕。:</li>
</ul>
<ol>
<li>如果顶点缓存没有满：<br>a 用D3DLOCK_NOOVERWRITE标记锁定缓存片段i<br>b COPY 500个粒子到片段i</li>
<li><p>如果顶点缓存满了：<br>a 从起始的地方开始顶点缓冲: i=0<br>b 用D3DLOCK_NOOVERWRITE标记锁定缓存段i<br>c COPY 500个粒子到片段i </p>
</li>
<li><p>渲染片段i. </p>
</li>
<li><p>下一片段： i+ +<br>备注：顶点缓存是动态的， 因此我们能利用动态锁定标记D3DLOCK_NOOVERWRITE 和 D3DLOCK_DISCARD。这两个标记允许我们锁定顶点缓存的某一部分。当顶点缓存中的其他部分被渲染时，它是不能渲染的。例如，假如我们正在使用D3DLOCK_NOOVERWRITE标记渲染片段0时， 当渲染片段0的时候我们能锁定并填充片段1。这样可以防止渲染的延迟。</p>
<p>这个方法更有效率。首先，我们减少顶点缓存的尺寸；然后， CPU与显卡在协调的工作。也就是说，当我们绘制一小批粒子时(graphics card work)，同时拷贝另一小批粒子到顶点缓存 (CPU work)。这个动作是连续执行的，直到所有的粒子都被渲染完毕，就像你了解的一样， 显卡在全部顶点缓存被填充的时候是不用处于空闲状态的。<br>我们现在将注意力转向这一个渲染方案的实现，为了方便使用这个粒子系统的渲染方案, 我们使用 PSystem 类中的下列数据成员:</p>
</li>
</ol>
<ul>
<li>_vbSize—在给定时间内我们的顶点缓存能够保存的粒子数量。这个值与实际的粒子系统中的粒子数无关。</li>
<li>_vbOffset—这个变量是在顶点缓存中的偏移，在顶点缓存里我们将用它开始COPY下一批粒子，例如，如果第一批在缓存中是0到499，偏移到第二批COPY的开始处将是500。</li>
<li>_vbBatchSize—定义一批缓存中的粒子数量。</li>
<li>我们现在介绍渲染方法的代码：<br>void PSystem::render()<br>{<br>if( !_particles.empty() )<br>{<br>   // set render states<br>   preRender();<br>   _device-&gt;SetTexture(0, _tex);<br>   _device-&gt;SetFVF(Particle::FVF);<br>   _device-&gt;SetStreamSource(0, _vb, 0, sizeof(Particle));</li>
</ul>
<p>// start at beginning if we’re at the end of the vb<br>     if(_vbOffset &gt;= _vbSize)<br>          _vbOffset = 0;</p>
<pre><code> Particle*v =0;

 _vb-&gt;Lock(
      _vbOffset    * sizeof( Particle ),
      _vbBatchSize * sizeof( Particle ),
      (void**)&amp;v,
      _vbOffset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);

 DWORD numParticlesInBatch = 0;

 //
 // Until all particles have been rendered.
 //
 std::list&lt;Attribute&gt;::iterator i;
 for(i = _particles.begin(); i != _particles.end(); i++)
 {
      if( i-&gt;_isAlive )
      {
           //
           // Copy a batch of the living particles to the
           // next vertex buffer segment
           //
           v-&gt;_position = i-&gt;_position;
           v-&gt;_color = (D3DCOLOR)i-&gt;_color;
           v++; // next element;

           numParticlesInBatch++; //increase batch counter

           // is this batch full?
           if(numParticlesInBatch == _vbBatchSize)
           {
                //
                // Draw the last batch of particles that was
                // copied to the vertex buffer.
                //
                _vb-&gt;Unlock();
                _device-&gt;DrawPrimitive(
                     D3DPT_POINTLIST,
                     _vbOffset,
                     _vbBatchSize);

           //
           // While that batch is drawing, start filling the
           // next batch with particles.
           //

           // move the offset to the start of the next batch
           _vbOffset += _vbBatchSize;

           // don&#39;t offset into memory thats outside the vb&#39;s
           // range. If we&#39;re at the end, start at the beginning.
           if(_vbOffset &gt;= _vbSize)
                _vbOffset = 0;

           _vb-&gt;Lock(
                _vbOffset    * sizeof( Particle ),
                _vbBatchSize * sizeof( Particle ),
                (void**)&amp;v,
                _vbOffset ? D3DLOCK_NOOVERWRITE :
                   D3DLOCK_DISCARD);

           numParticlesInBatch = 0; // reset for new batch
      }//end if
   }//end if
 }//end for

 _vb-&gt;Unlock();

 // it&#39;s possible that the LAST batch being filled never
 // got rendered because the condition
 // (numParticlesInBatch == _vbBatchSize) would not have
 // been satisfied.  We draw the last partially filled batch now.

 if( numParticlesInBatch )
 {
       _device-&gt;DrawPrimitive(
            D3DPT_POINTLIST,
            _vbOffset,
            numParticlesInBatch);
 }

 // next block
 _vbOffset += _vbBatchSize;

 postRender();
 }//end if
</code></pre><p>}// end render()</p>
<p>14.2.2 随机<br>   这有一个随机的粒子系统。例如，如果我们模拟雪花，不能让所有雪花以完全相同的方式落下。我们要让它们按相似的方式落下而不是完全相同的方式。为了使粒子系统的随机功能更简单，我们增加了下列两个函数到d3dUtility.h/cpp文件。<br>   第一个函数在[lowBound, highBound]区间内随机的返回一个Float类型值：<br>float d3d::GetRandomFloat(float lowBound, float highBound)<br>{<br>     if( lowBound &gt;= highBound ) // bad input<br>          return lowBound;</p>
<pre><code> // get random float in [0, 1] interval
 float f = (rand() % 10000) * 0.0001f;

 // return float in [lowBound, highBound] interval.
 return (f * (highBound - lowBound)) + lowBound;
</code></pre><p>}<br>   第二个函数在边界盒的范围内，输出一个随机的向量。<br>void d3d::GetRandomVector(<br>       D3DXVECTOR3<em> out,<br>       D3DXVECTOR3</em> min,<br>       D3DXVECTOR3* max)<br>{<br>       out-&gt;x = GetRandomFloat(min-&gt;x, max-&gt;x);<br>       out-&gt;y = GetRandomFloat(min-&gt;y, max-&gt;y);<br>       out-&gt;z = GetRandomFloat(min-&gt;z, max-&gt;z);<br>}</p>
<p>   注意：记得用srand()去seed随机数生成器。<br>14.3 具体的粒子系统：雪、火、粒子枪<br>现在让我们用Psystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到Psystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。这些系统的名字基本上概括了他们的模型。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。<br>注意：照例，用全部的工程代码来说明这些系统，你能够在本章找到这些文件。</p>
<p>14.3.1 例子程序：雪</p>
<p>图14.2 雪系统例子的屏幕截图</p>
<p>雪系统类定义如下：<br>class Snow : public PSystem<br>{<br>public:<br>     Snow(d3d::BoundingBox<em> boundingBox, int numParticles);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta);<br>};<br>备注：因为父类做了大部分的工作，所以雪系统的接口非常简单。事实上，我们在这一节中实现的这三个粒子系统，接口简单并相对容易实现。<br>   构造器提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造器的实现：<br>Snow::Snow(d3d::BoundingBox<em> boundingBox, int numParticles)<br>{<br>     _boundingBox   = </em>boundingBox;<br>     _size          = 0.8f;<br>     _vbSize        = 2048;<br>     _vbOffset      = 0;<br>     _vbBatchSize   = 512;<br>     for(int i = 0; i &lt; numParticles; i++)<br>          addParticle();<br>}<br>   同样注意：我们指定顶点缓存的尺寸，每一批的尺寸和开始的偏移。<br>   ResetParticle方法创建一个雪花，在x、z轴随机的位置并在边界盒的范围内。设置y轴高度为边界盒的顶部。如果给雪花一个速度，以便让雪花下落时稍稍向左倾斜。雪花是白色的。<br>void Snow::resetParticle(Attribute* attribute)<br>{<br>     attribute-&gt;_isAlive = true;</p>
<pre><code> // get random x, z coordinate for the position of the snowflake.
 d3d::GetRandomVector(
      &amp;attribute-&gt;_position,
      &amp;_boundingBox._min,
      &amp;_boundingBox._max);

 // no randomness for height (y-coordinate). Snowflake
 // always starts at the top of bounding box.
 attribute-&gt;_position.y = _boundingBox._max.y;

 // snowflakes fall downward and slightly to the left
 attribute-&gt;_velocity.x = d3d::GetRandomFloat(0.0f, 1.0f)*-3.0f;
 attribute-&gt;_velocity.y = d3d::GetRandomFloat(0.0f, 1.0f)*-10.0f;
 attribute-&gt;_velocity.z = 0.0f;

 // white snowflake
 attribute-&gt;_color = d3d::WHITE;
</code></pre><p>}<br>   Update方法更新粒子和粒子间的位置，并且测试粒子是否在系统的边界盒之外，如果它已经跳出边界盒，就再重新创建。<br>void Snow::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;<br>     for(i = _particles.begin(); i != _particles.end(); i++)<br>     {<br>          i-&gt;_position += i-&gt;_velocity * timeDelta;</attribute></p>
<pre><code>      // is the point outside bounds?
      if( _boundingBox.isPointInside( i-&gt;_position ) == false )
      {
           // nope so kill it, but we want to recycle dead
           // particles, so respawn it instead.
           resetParticle( &amp;(*i) );
      }
 }
</code></pre><p>}</p>
<p>14.3.2 例子程序：火</p>
<p>图14.3 火粒子系统例子的屏幕截图<br>火系统类定义如下：<br>class Firework : public PSystem<br>{<br>public:<br>     Firework(D3DXVECTOR3<em> origin, int numParticles);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta); void preRender();<br>     void postRender();<br>};<br>   构造器需要提供一个点作为粒子系统中的原点，和系统中的粒子数，原点是火焰爆发的那个点。<br>ResetParticle方法在原点位置初始化粒子系统，并在边界球内创建一个随机的速度，粒子系统中的每个例子有一个随机的颜色，我们定义粒子只能存活2秒。<br>void Firework::resetParticle(Attribute* attribute)<br>{<br>     attribute-&gt;_isAlive = true;<br>     attribute-&gt;_position = _origin;</p>
<pre><code> D3DXVECTOR3 min = D3DXVECTOR3(-1.0f, -1.0f, -1.0f);
 D3DXVECTOR3 max = D3DXVECTOR3( 1.0f,  1.0f,  1.0f);

 d3d::GetRandomVector(
      &amp;attribute-&gt;_velocity,
      &amp;min,
      &amp;max);
 // normalize to make spherical
 D3DXVec3Normalize(
      &amp;attribute-&gt;_velocity,
      &amp;attribute-&gt;_velocity);

 attribute-&gt;_velocity *= 100.0f;

 attribute-&gt;_color = D3DXCOLOR(
      d3d::GetRandomFloat(0.0f, 1.0f),
      d3d::GetRandomFloat(0.0f, 1.0f),
      d3d::GetRandomFloat(0.0f, 1.0f),
      1.0f);

 attribute-&gt;_age      = 0.0f;
 attribute-&gt;_lifeTime = 2.0f; // lives for 2 seconds
</code></pre><p>}</p>
<p>   Update方法更新每个粒子的位置，并在粒子超出自己的生活周期时杀死它。注意：这个系统不能移除死掉的粒子，这么做是因为我们想产生一个新的火焰的时候，我们只要简单的重新设置已经存在的死了的火焰系统就可以了。这样为我们不必频繁的去产生和释放粒子。<br>void Firework::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;</attribute></p>
<pre><code> for(i = _particles.begin(); i != _particles.end(); i++)
 {
      // only update living particles
      if( i-&gt;_isAlive )
      {
           i-&gt;_position += i-&gt;_velocity * timeDelta;

           i-&gt;_age += timeDelta;

           if(i-&gt;_age &gt; i-&gt;_lifeTime) // kill
                i-&gt;_isAlive = false;
      }
 }
</code></pre><p>}<br>当渲染时，火系统使用不同的方法渲染像素。进一步讲，它不写深度缓存，我们可以简单的改变混合像素，通过重写PSystem::preRender方法和PSystem::postRender方法，下面是重写的实现：<br>void Firework::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;<br>void Firework::preRender()<br>{<br>     PSystem::preRender();</attribute></p>
<pre><code> _device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
 _device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
 // read, but don&#39;t write particles to z-buffer
 _device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, false);
</code></pre><p>}</p>
<p>void Firework::postRender()<br>{<br>     PSystem::postRender();</p>
<pre><code> _device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, true);
</code></pre><p>}<br>注意：这两个方法调用父类版本，这样，我们仍能重新使用父类的一些功能，做一些小的改变就变成了火焰系统。<br>14.3.3 例子程序：粒子枪</p>
<p>图14.4 激光枪系统的截图<br>下面是粒子枪系统的定义：<br>class ParticleGun : public PSystem<br>{<br>public:<br>     ParticleGun(Camera<em> camera);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta);</p>
<p>private:<br>     Camera<em> _camera;<br>};<br>   构造器需要提供一个照相机的位置点，这是因为系统需要知道照相机的位置及朝向，以决定在哪创建一个粒子。<br>   ResetParticle方法设置粒子的位置为当前照相机的位置，并且设置方向上的速度，在照像机视角的100个单位。这样，子弹将射向我们正在看的方向，粒子颜色为绿色。<br>void ParticleGun::resetParticle(Attribute</em> attribute)<br>{<br>     attribute-&gt;_isAlive  = true;</p>
<pre><code> D3DXVECTOR3 cameraPos;
 _camera-&gt;getPosition(&amp;cameraPos);

 D3DXVECTOR3 cameraDir;
 _camera-&gt;getLook(&amp;cameraDir);

 // change to camera position
 attribute-&gt;_position = cameraPos;
 attribute-&gt;_position.y -= 1.0f; // slightly below camera so it&#39;s
                                 // like we&#39;re carrying gun

 // travels in the direction the camera is looking
 attribute-&gt;_velocity = cameraDir * 100.0f;

 // green
 attribute-&gt;_color = D3DXCOLOR(0.0f, 1.0f, 0.0f, 1.0f);

 attribute-&gt;_age      = 0.0f;
 attribute-&gt;_lifeTime = 1.0f; // lives for 1 seconds
</code></pre><p>}</p>
<p>   Update方法更新粒子的位置，并且杀死超过其生命周期的粒子，然后，我们搜索粒子列表删除已经死了的粒子。<br>{<br>     std::list<attribute>::iterator i;</attribute></p>
<pre><code> for(i = _particles.begin(); i != _particles.end(); i++)
 {
      i-&gt;_position += i-&gt;_velocity * timeDelta;

      i-&gt;_age += timeDelta;

      if(i-&gt;_age &gt; i-&gt;_lifeTime) // kill
           i-&gt;_isAlive = false;
 }
 removeDeadParticles();
</code></pre><p>}</p>
<p>14.4 摘要</p>
<ul>
<li>用点精灵来显示一个粒子是方便且灵活的，它可能改变粒子尺寸、给粒子赋予纹理。此外，能够使用简单的顶点（vertex）来描述它们。</li>
<li>粒子系统维护一个粒子的集合，并负责创建、释放、更新和显示粒子。</li>
<li>还有一些其他粒子系统的概念，是你能够实现的：烟，火箭的轨迹，喷泉/河水车效果，火，光，爆炸，和雨。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Basic-Terrain-Rendering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Basic-Terrain-Rendering/" class="post-title-link" itemprop="url">第十三章 地形渲染基础(Basic Terrain Rendering)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:21:54" itemprop="dateCreated datePublished" datetime="2019-04-11T15:21:54+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实际上，地形网格不比三角形网格复杂，图13.1.(a)所示，网络的每个顶点指定了高度，格子模型用这种方式显示从山脉到河流的平滑过渡。图13.1 (b)，模拟自然地形。当然，我们可以用漂亮的纹理表现沙石地，绿色的山丘。图13.1.(c)雪山效果。</p>
<p>图 13.1: (a) 三角网格. (b) 平滑高度过渡的三角网格. (c) 光和纹理，我们在这一章节中写的例子的一个屏幕截图。<br>   这一章的内容是实现一个Terrain（地形）类。这个类的功能很强。我们的意思是，它只是储存整个地形的顶点/索引数据，然后渲染它。因为如果游戏需要一个小的地形，那么它能够在现代图形卡支持的硬件顶点处理下工作。然而实际上，游戏需要大量的地形，你必须对细节做某种（级别）程度的捡选，因为模型需要大量的几何数据，这样大的地形对于再强大的处理方法也是无法处理的。</p>
<p>目标 </p>
<ul>
<li>学习怎样生成地形的高度信息，它能使山丘、河流等地带的平滑的过度，模拟自然界的地形。</li>
<li>了解怎样生成地形的顶点和三角形数据。</li>
<li>学习使用地形的纹理和光照.</li>
<li>找到控制地形上照相机位置的方法，以便模拟在地形上走动。</li>
</ul>
<p>13.1 Heightmaps（高度图）<br>   我们使用高度图去描述地形上的山丘、河流。高度图是一个数组，数组中的每个成员指定地形顶点描述中的高度信息。我们经常把高度图想像成一个矩阵，因为每个元素都一一对应于每个地形网格中的顶点。<br>   当我们保存高度图到磁盘上时，我们通常为高度图的每个元素分配1个byte的内存，所以高度的范围是0..255，0..255的范围对于地形的高度之间保持平滑过渡是足够用的。但为了在我们的程序中匹配3D世界中的物体，可能需要的范围在0..255以外。例如，我们在3D世界中的测量单位是英尺，那么0..255的范围对于表现任何有趣的东西是不够的。因此，当我们读取数据进应用程序时，给每个高度元素分配一个整型数（或浮点型），它允许我们很好的缩放0..255范围之外的任何大小的物品。<br>   高度图图形表示法这一是灰度图(grayscale map)。较黑的值表示地形中较低的地方，较白的值表现地形中较高的地方。</p>
<pre><code> 图13.2: 高度图的灰度图表示
</code></pre><p>13.1.1 创建高度图（Heightmap）<br>   高度图不是用程序生成就是用图像编辑器生成，比如：Adobe Photoshop。使用图像编辑器大概是最容易的方法了。当你想生成地形时，可以交互式的可视化的创建。你可以利用图像编辑器的功能，比如：过滤器，创建一个有趣的高度图，图13.3显示了一个用Adobe Photoshop图像编辑器的工具创建的金字塔形的高度图。注意：当创建图像时我们指定一个灰度图类型。</p>
<pre><code> 图13.3 一幅用Adobe Photoshop创建的灰度图
 一但你画完了你的高度图，你必须将它保存为一个8bit的RAW文件。RAW文件只图像的逐个字节。我们的应用程序可以非常容易的读这样的图像。你的软件可能告诉你保存的RAW文件是有文件头的还是没有文件头的。
 注意：用RAW格式保存高度信息不是必须的；你可以用符合你需要的任何格式。RAW格式是我们能使用的的格式之一。我决定使用RAW格式是因为很多流行的图像编辑器支持导出这种格式，而且应用程序读取RAW文件的数据非常简单。这章中有使用8-bit RAW文件的例子。
</code></pre><p>13.1.2 读取RAW文件<br>   RAW文件与一段连续的bit内存块没什么分别。我们能用很简单的方法读取这段内存块，注意：变量_heightmap是Terrain类的一个成员，定义如下 ：<br>std::vector<int> _heightmap;<br>bool Terrain::readRawFile(std::string fileName)<br>{<br>     // A height for each vertex<br>     std::vector<byte> in(  numVertices );<br>     std::ifstream inFile(fileName.c_str(), std::ios_base::binary);<br>     if( inFile == 0 )<br>          return false;<br>     inFile.read(<br>          (char*)&amp;in[0], // buffer<br>          in.size());// number of bytes to read into buffer<br>     inFile.close();</byte></int></p>
<pre><code> // copy BYTE vector to int vector
 _heightmap.resize( _numVertices );
 for(int i = 0; i &lt; in.size(); i++)
      _heightmap[i] = in[i];

 return true;
</code></pre><p>}<br>我们COPY一个bytes向量到一个整形向量，这样做我们能够缩放 [0,255]以外的高度。这个方法唯一限制是：RAW文件必须读入至少与地形的顶点数一样多的高度信息。因此，如果你读取一个256x256 的RAW文件，你的地形也必须包含256x256个顶点。</p>
<p>13.1.3 访问与修改Heightmap<br>     Terrain类提供以下2个方法访问和修改Heightmap的入口。<br>int Terrain::getHeightmapEntry(int row, int col)<br>{<br>      return _heightmap[row * _numVertsPerRow + col];<br>}</p>
<p>void Terrain::setHeightmapEntry(int row, int col, int value)<br>{<br>     _heightmap[row * _numVertsPerRow + col] = value;<br>}<br>   这些方法允许我们以行和列来访问入口，并且隐藏方法。当使用它去描述矩阵时，我们必须将一个线性数组编入索引。<br>（These methods allow us to refer to an entry by row and column and hide the way we must index a linear array when using it to describe a matrix）</p>
<p>13.2 生成地形几何数据<br>   图13.4显示Terrain类的一些属性、词汇和我们提到的一些关键点。我们定义地形的大小，指定每行、每列顶点的数量，和单元的间隔。传递这些值到Terrain类的构造器中。另外，也传递地形所关联的设备，一个包含高度图数据的字符串文件名，一个用来缩放高度图成员的高度缩放值。</p>
<pre><code>     图13.4：三角形网络的属性，延着方格线上的点是地形的顶点。
</code></pre><p>class Terrain<br>{<br>public:<br>     Terrain(<br>          IDirect3DDevice9* device,<br>          std::string heightmapFileName,<br>          int numVertsPerRow,<br>          int numVertsPerCol,<br>          int cellSpacing,    // space between cells<br>          float heightScale); // value to scale heights by</p>
<pre><code> ... methods snipped
</code></pre><p>private:<br>     …device/vertex buffer etc snipped</p>
<pre><code> int _numVertsPerRow;
 int _numVertsPerCol;
 int _cellSpacing;

 int _numCellsPerRow;
 int _numCellsPerCol;
 int _width;
 int _depth;
 int _numVertices;
 int _numTriangles;

 float _heightScale;
</code></pre><p>};<br>Terrain类定义的全部的源代码，实在是太多了，无法在这里全部包含进来。根据传递给构造器的值，我们能够计算Terrain类的其他变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_numCellsPerRow  = _numVertsPerRow - <span class="number">1</span>;</span><br><span class="line">_numCellsPerCol  = _numVertsPerCol - <span class="number">1</span>;</span><br><span class="line">_width           = _numCellsPerRow * _cellSpacing;</span><br><span class="line">_depth           = _numCellsPerCol * _cellSpacing;</span><br><span class="line">_numVertices     = _numVertsPerRow * _numVertsPerCol;</span><br><span class="line">_numTriangles    = _numCellsPerRow * _numCellsPerCol * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>Terrain类定义的顶点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TerrainVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     TerrainVertex()&#123;&#125;</span><br><span class="line">     TerrainVertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> u, <span class="keyword">float</span> v)</span><br><span class="line">     &#123;</span><br><span class="line">          _x = x; _y = y; _z = z; _u = u; _v = v;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">     <span class="keyword">float</span> _u, _v;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>   注意：TerrainVertex是Terrain类内部的一个嵌套类（译者：看样子是结构啊？），之所以这么做，是因为它在Terrain类外部基本没有什么用处。<br>13.2.1 计算顶点<br>   在图13.4中，计算三角形网格上的顶点，我们只是在开始产生顶点的地方，一行一行的生成顶点数据，直到结束为止。单元格的顶点与顶点之间有一块空白区域，这会让我们取得x、z坐标，但y坐标是什么呢？得到y坐标很容易，当读取高度图数据结构时会找到对应的入口。<br>   注意：这个操作使用一个巨大的顶点缓存去保存所有地形上的所有顶点。这可能会引起硬件局限性的问题。例如：一个原始计数界限的最大值和3D设备设定的最大的顶点索引界限。检查MaxPrimitiveCount和D3DCAPS9结构的MaxVertexlndex成员，查看你的设备的限定值，在13.7节讨论，使用顶点缓存时存在问题和解决方法。<br>   计算纹理坐标，看图13.5，给我们一个简单的设定，允许我们用(u, v)纹理坐标去对应地形顶点坐标。</p>
<p>   图13.5：地形顶点与纹理顶点之间一一对应。<br>   u = j uCoordIncrementSize<br>   v = i vCoordIncrementSize<br>   And where:</p>
<p>   最后，用代码生成顶点：<br>bool Terrain::computeVertices()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> hr = _device-&gt;CreateVertexBuffer(
      _numVertices * sizeof(TerrainVertex),
      D3DUSAGE_WRITEONLY,
      TerrainVertex::FVF,
      D3DPOOL_MANAGED,
      &amp;_vb,
      0);

 if(FAILED(hr))
      return false;

 // 对应第一个生成的顶点坐标
 int startX = -_width / 2;
 int startZ =  _depth / 2;

 // 对应最后一个生成的顶点坐标
 int endX =  _width / 2;
 int endZ = -_depth / 2;

 // compute the increment size of the texture coordinates
 // from one vertex to the next.
 float uCoordIncrementSize = 1.0f / (float)_numCellsPerRow;
 float vCoordIncrementSize = 1.0f / (float)_numCellsPerCol;

 TerrainVertex* v = 0;
 _vb-&gt;Lock(0, 0, (void**)&amp;v, 0);

 int i = 0;
 for(int z = startZ; z &gt;= endZ; z -= _cellSpacing)
 {
      int j = 0;
      for(int x = startX; x &lt;= endX; x += _cellSpacing)
      {
           // compute the correct index into the vertex buffer
           // and heightmap based on where we are in the nested
           // loop.
           int index = i * _numVertsPerRow + j;

           v[index] = TerrainVertex(
                (float)x,
                (float)_heightmap[index],
                (float)z,
                (float)j * uCoordIncrementSize,
                (float)i * vCoordIncrementSize);

           j++; // next column
      }
      i++; // next row
 }

 _vb-&gt;Unlock();

 return true;
</code></pre><p>}</p>
<p>13.2.2 计算索引-定义三角形<br>   计算三角形网格的索引，只需要循环访问每一个格子，从左上到右下，如图13.4，并且计算组成格子的2个三角形。</p>
<p>这里的技巧是：提取出计算第ij格子的2个三角形的公式。用图13.6去推导公式，找到第ij的格子：</p>
<p>?ABC = {i · numVertsPerRow + j i·numVertsPerRow + j + 1 (i + 1). numVertsPerRow + j}<br>?CBD = {(i + 1) numVertsPerRow + j i·numVertsPerRow + j + 1 (i·l) numVertsPerRow + j + 1} </p>
<p>图13.6 方格的顶点</p>
<p>代码生成索引：<br>bool Terrain::computeIndices()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> hr = _device-&gt;CreateIndexBuffer(
      _numTriangles * 3 * sizeof(WORD), // 每个三角形有3个索引
      D3DUSAGE_WRITEONLY,
      D3DFMT_INDEX16,
      D3DPOOL_MANAGED,
      &amp;_ib,
      0);

 if(FAILED(hr))
      return false;

 WORD* indices = 0;
 _ib-&gt;Lock(0, 0, (void**)&amp;indices, 0);

 // 将组成一个方格的2个三角形的一组6个索引的开始位置编入索引
 int baseIndex = 0;

 // 从头到尾计算每一个格子中的三角形
 for(int i = 0; i &lt; _numCellsPerCol; i++) //行循环
 {
      for(int j = 0; j &lt; _numCellsPerRow; j++) //列循环
      {
           indices[baseIndex]     =   i   * _numVertsPerRow + j;
           indices[baseIndex + 1] =   i   * _numVertsPerRow +
                                                 j + 1;
           indices[baseIndex + 2] = (i+1) * _numVertsPerRow + j;

           indices[baseIndex + 3] = (i+1) * _numVertsPerRow + j;
           indices[baseIndex + 4] =   i   * _numVertsPerRow +
                                                 j + 1;
           indices[baseIndex + 5] = (i+1) * _numVertsPerRow +
                                                 j + 1;

           // next quad
           baseIndex += 6;
      }
 }
 _ib-&gt;Unlock();

 return true;
</code></pre><p>};</p>
<h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>Terrain类提供2个方法去处理地形的纹理。最简单的方法是简单地读取一个已经制作好的纹理文件并使用它，下面的方法使用Terrain类实现将一个文件读取纹理到_tex成员中，然后指向一个IDirect3DTexture9接口的指针。关键是，在地形渲染之前先用Terrain: :draw方法设置_tex。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Terrain::loadTexture(<span class="built_in">std</span>::<span class="built_in">string</span> fileName)</span><br><span class="line">&#123;</span><br><span class="line">     HRESULT hr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     hr = D3DXCreateTextureFromFile(</span><br><span class="line">          _device,</span><br><span class="line">          fileName.c_str(),</span><br><span class="line">          &amp;_tex);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>13.3.1 程序上的处理方法<br>   一个可选择的方法是用程序计算地形的纹理，就是说，我们创建一个空纹理，根据定义的参数用代码计算每一个部分的颜色，在例子中，参数是地形的高度。<br>   我们用Terrain::genTexture方法用程序去生成纹理，首先用D3DXCreateTexture方法创建一个空的纹理，锁定高度级别（top level，纹理图的一个成员，有多个级别），不断的循环每一个texel（图素）并给它上色，texel的颜色取决于与方格对应的高度（近似高度）。我们的想法是：地形中较低的地方是沙滩色，中间的地方像是绿色的小山丘，较高的地方颜色好像雪山。我们定义的高度是方格中左上角的近似高度。<br>   一旦每个texel都有了颜色，我们想让每一个texel变暗或是变亮，这基于光打在格子中对应的texel上的角度，由Terrain::lightTerrain方法实现。（Once we have a color for each texel, we want to darken or brighten each texel based on the angle at which sunlight (modeled by a directional light) strikes the cell to which the texel corresponds. This is done in the Terrain::lightTerrain method）<br>   Terrain::genTexture方法通过计算lower mipmap级别的texels来得出结论，它是通过D3DXFilterTexture函数实现。用代码生成纹理：<br>bool Terrain::genTexture(D3DXVECTOR3* directionToLight)<br>{<br>     // Method fills the top surface of a texture procedurally. Then<br>     // lights the top surface. Finally, it fills the other mipmap<br>     // surfaces based on the top surface data using<br>     // D3DXFilterTexture.</p>
<pre><code> HRESULT hr = 0;

 // texel for each quad cell
 int texWidth  = _numCellsPerRow;
 int texHeight = _numCellsPerCol;

 // create an empty texture
 hr = D3DXCreateTexture(
      _device,
      texWidth, texHeight,  // dimensions
      0,                    // create a complete mipmap chain
      0,                    // usage - none
      D3DFMT_X8R8G8B8,      // 32-bit XRGB format
      D3DPOOL_MANAGED,      // memory pool
      &amp;_tex);

 if(FAILED(hr))
      return false;

 D3DSURFACE DESC textureDesc;
 _tex-&gt;GetLevelDesc(0 /*level*/, &amp;textureDesc);

 // make sure we got the requested format because our code
 // that fills the texture is hard coded to a 32-bit pixel depth.
 if( textureDesc.Format != D3DFMT_X8R8G8B8 )
      return false;

 D3DLOCKED_RECT lockedRect;
 _tex-&gt;LockRect(0/*lock top surface*/, &amp;lockedRect,
       0 /* lock entire tex*/, 0/*flags*/);

 // fill the texture
 DWORD* imageData = (DWORD*)lockedRect.pBits;
 for(int i = 0; i &lt; texHeight; i++)
 {
      for(int j = 0; j &lt; texWidth; j++)
      {
      D3DXCOLOR c;

      // get height of upper-left vertex of quad.
      float height = (float)getHeightmapEntry(i, j)/_heightScale;

      // set the color of the texel based on the height
      // of the quad it corresponds to.
      if( (height) &lt; 42.5f )       c = d3d::BEACH SAND;
      else if( (height) &lt; 85.0f )  c = d3d::LIGHT YELLOW GREEN;
      else if( (height) &lt; 127.5f ) c = d3d::PUREGREEN;
      else if( (height) &lt; 170.0f ) c = d3d::DARK YELLOW GREEN;
      else if( (height) &lt; 212.5f ) c = d3d::DARKBROWN;
      else                         c = d3d::WHITE;

      // fill locked data, note we divide the pitch by four
      // because the pitch is given in bytes and there are
      // 4 bytes per DWORD.
      imageData[i * lockedRect.Pitch / 4 + j] = (D3DCOLOR)c;
      }
 }

 _tex-&gt;UnlockRect(0);

 // light the terrain
 if(!lightTerrain(directionToLight))
 {
       ::MessageBox(0, &quot;lightTerrain() - FAILED&quot;, 0, 0);
       return false;
 }

 // fill mipmaps
 hr = D3DXFilterTexture(
      _tex,// texture to fill mipmap levels
      0,   // default palette
       0,   // use top level as source for lower levels
       D3DX_DEFAULT); // default filter

 if (FAILED (hr))
 {
       ::MessageBox(0, &quot;D3DXFilterTexture() - FAILED&quot;, 0, 0);
       return false;
 }

 return true;
</code></pre><p>}</p>
<p>注意：颜色常量BEACH_SAND等定义在d3dUtility.h.文件中。</p>
<p>13.4 光照<br>   Terrain::genTexture方法会调用Terrain::lightTerrain，顾名思义，光照使地形更接近于现实。当我们已经计算完地形纹理以后，我们只需要计算阴影系数（shade factor），使一个定义了光源的地形区域变亮或变暗。在这一节中，我们检验这样一个技巧，你会惊讶于为什么我们照亮地图却没有让Direct3D来做。我们自己来计算有三个好处：</p>
<ul>
<li>内存中不必保存顶点法线。</li>
<li>因为纹理是静态的，所以不能随意的移动光源。虽然我们可以重新计算光源，但因此采用Direct3D实时的照亮地形是很耗时的。</li>
<li>我们获得了一些数学上的经验，熟悉了一些基本的光照概念，并且是用Direct3D函数实践的。</li>
</ul>
<p>13.4.1概览(OVERVIEW)<br>   光照是计算地形阴影（shade）的一个最基本的技巧之一，一般认为的光是漫射光（diffuse lighting），我们定义一个平行光源，指定光的方向，延着光线的相反方向是散发平行光的光源。因此，如果我们想让光线从空中笔直落下，那么lightRaysDirection = (0, -1, 0)，按相反的方向：directionToLight = (0, 1, 0)。注意：创建光照向量要使用单位向量。<br>   注意：虽然指定方向的光是从光源发射出来的，这么说更直接一点，指定方向的光在计算上要比漫谢光更合得来。<br>   对于地形中的每个方格，我们计算光的向量与方格的面法线之间的角度。<br>   在图13.7中我们看到，当角度变得比较大时，方格的面离光源越来越远，接收的光越少。反过来说，角度变小，方格的面则离光源越来越近，相应的会接收更多的光。注意：一旦光向量与法线角度大于90度，表面就接收不到光。</p>
<p>   图13.7 光向量与平面法线的关系，我们能够创建一个阴影（shading） 标量，用0..1之间的范围来表示表面能接收到光的多少。使用阴影标量，角度大则标量接近于0。当颜色与一个阴影标量接近0的值相乘时，得到的结果是：颜色变暗。相反，乘以一个阴影标量的值接近1的值时，颜色则接近于原始亮度。</p>
<p>13.4.2 计算方格的阴影（Shade）<br>   光源的方向是一个单位向量，为了计算光源方向与面法线间的夹角，首先需要找到面法线，这是叉积的一小部分应用，但首先必须在方格里找到二个共面的非0并且不平行的向量。看图 13.8有两个这样的向量：</p>
<p>   图13.8: 计算在同一方格中的共面的二个向量</p>
<p>u = (cellSpacing, by - ay, 0)<br>v = (0, cy, -ay, -cellSpacing) </p>
<p>关于u和v，方格的法线N = u × v，当然要把N标准化：</p>
<p>找到光线与法线的夹角，回忆一下点积，是二个3维空间中的单位向量组成的夹角的余弦。</p>
<p>   它的标量是在-1..1的范围，因为-1..0的sin值符合夹角角度且大于90度，在图13.7中接受不到光照，如果它在-1..0之间那么夹角是0度。<br>float cosine = D3DXVec3Dot(&amp;n, directionToLight);</p>
<p>if(cosine &lt; 0.0f)<br>     cosine = 0.0f;</p>
<p>   现在s的夹角大于90度，s的阴影标量将在0..1之间。因为光线与法线的角度从0增加到90度时，s的值将从1到降到0。这是我们想要的结果，具体讲解请看13.4.1节。<br>   给指定的格子计算阴影系数用Terrain::computeShade方法，它需要参数：行和列来确定方格，还有平行方向光的光源。<br>float Terrain::computeShade(int cellRow, int cellCol,<br>                            D3DXVECTOR3* directionToLight)<br>{<br>     // 取得方格中三个顶点的高度（从高度图中）<br>     float heightA = getHeightmapEntry(cellRow,   cellCol);<br>     float heightB = getHeightmapEntry(cellRow,   cellCol+1);<br>     float heightC = getHeightmapEntry(cellRow+1, cellCol);</p>
<pre><code> // 创建方格中的二个顶点
 D3DXVECTOR3 u( cellSpacing, heightB - heightA, 0.0f);
 D3DXVECTOR3 v(0.0f, heightC - heightA, - cellSpacing);

 //用方格中的二个向量的叉积找到面法线
 D3DXVECTOR3 n;
 D3DXVec3Cross(&amp;n, &amp;u, &amp;v);
 D3DXVec3Normalize(&amp;n, &amp;n);

 float cosine = D3DXVec3Dot(&amp;n, directionToLight);

 if(cosine &lt; 0.0f)
      cosine = 0.0f;

 return cosine;
</code></pre><p>}</p>
<p>13.4.3 地形阴影（Shading）<br>   一旦知道了如何给指定的方格加阴影，我们就能给地形上所有的方格加阴影。只要遍例每一个方格，计算方格的阴影值，并测量方格对应的texel颜色。光照少则方格会变暗。下面一段代码展示了Terrain::lightTerrain方法的重要部分：</p>
<p>DWORD<em> imageData = (DWORD</em>)lockedRect.pBits;<br>for(int i = 0; i &lt; textureDesc.Height; i++)<br>{<br>     for(int j = 0; j &lt; textureDesc.Width; j++)<br>     {<br>          int index = i * lockedRect.Pitch / 4 + j;</p>
<pre><code>      // get current color of cell
      D3DXCOLOR c( imageData[index] );

      // shade current cell
      c *= computeShade(i, j, lightDirection);;

      // save shaded color
      imageData[index] = (D3DCOLOR)c;
 }
</code></pre><p>}</p>
<p>13.5 在地形上“行走”<br>   构造了一个地形以后，我们想要有移动照相机的能力，以便模拟在地形上行走的效果。我们需要调整照相机的高度，这依赖于地形部分的知识，好的，我们继续往下看。我们首先需要找到照相机所在的方格的位置，并给出x轴和z轴坐标，Terrain::getHeight函数能做到这些，它能提供x轴、y轴坐标参数，返回照相机需要被设置在地形上的高度值，现在看实现部分。<br>float Terrain::getHeight(float x, float z)<br>{<br>     // Translate on xz-plane by the transformation that takes<br>     // the terrain START point to the origin.<br>     x = ((float) width / 2.0f) + x;<br>     z = ((float) depth / 2.0f) - z;</p>
<pre><code> // Scale down by the transformation that makes the
 // cellspacing equal to one. This is given by
 // 1 / cellspacing since cellspacing * 1 / cellspacing = 1.
 x /= (float) cellSpacing;
 z /= (float)_cellSpacing;
</code></pre><p>   我们首先转换地形的起始点为原点，然后，我们按反方向去测量空间变量（we scale by the inverse of the cell spacing variable），设置单元空间间隔为1。我们切换到一个新的参考框架，z轴正方向是向下的。当然，没有代码转换参考框架，但现在我们知道+z是向下的。图13.9显示了这些步骤：</p>
<p>图13.9：地形网格在转换前的第一个点，转换后为原点。单元格的空间为1，转换z轴。<br>我们看到我们转换的坐标系统与矩阵的行和列相对应，也就是说左上为原点，列数的增加向右，行数的增加向下。因此，在图13.9中我们知道了单元格的空间是1，通过以下的方法我们马上就能得到单元格行和列：<br>float col = ::floorf(x);<br>float row = ::floorf(z);</p>
<p>换句话说，在x轴部分列是整数，z轴部分行也是整数。回忆floor(t)函数，。<br>现在我们将取得方格的四个顶点的高度。<br>        //  A   B<br>        //  <em>—</em><br>        //  | / |<br>        //  <em>—</em><br>        //  C   D<br>float A = getHeightmapEntry(row,   col);<br>float B = getHeightmapEntry(row,   col+1);<br>float C = getHeightmapEntry(row+1, col);<br>float D = getHeightmapEntry(row+1, col+1);</p>
<p>   现在我们知道了方格的四个顶点的高度，我们需要找到照相机所在的位置的方格的高度，因为一个方格可能同时向几个方向倾斜，这可能会稍微难一点，见图 13.10:</p>
<p>图13.10: 照相机所在的位置的方格的高度<br>   为了找到高度，我们需要知道我们在方格中的哪个三角形里。方格是由二个三角形渲染成的，找到我们所在的三角形，我们要取得我们所在的方格并且转换它，它的左上点是原点。<br>   自从用行和列来描述我们所在的方格左上顶点的位置以来，我们必须转换列x轴与行z轴，转换x、z坐标：<br>   float dx = x - col;<br>   float dz = z - row;</p>
<p>图13.11: 我们所在的方格在转换前与转换后，左上顶点变成了原点。<br>   .现在解释当我们在方格中的上三角形时如何找到高度，这和在下三角形是相似的。马上你会看到这两种情况的代码。在上三角形时，构造2个向量：u = (cellSpacing, B -A, 0) and v = (0, C - A, - cellSpacing)，三角形的边上并且在矢量q = (qx, A, qz)终点点开始的地方，如图13.12(a)。</p>
<p>   图13.12 (a) 计算三角形的邻边和对边这两个向量。 (b)使用线性差值创建高度<br>   注意：我们只关心改变的高度值，我们只修改y值，忽视其他部分，因此，Height=sum A + dxuy + dzvy<br>   以下是Terrian::getHeight函数的实现代码：<br>   （Note that since we are only concerned about the interpolated height value, we can just interpolate the y-components and ignore the other components. Thus, the height is obtained by the sum A + dxuy + dzvy.）<br>if(dz &lt; 1.0f - dx) // upper triangle ABC<br>     {<br>          float uy = B - A; // A-&gt;B<br>          float vy = C - A; // A-&gt;C</p>
<pre><code>      height = A + d3d::Lerp(0.0f, uy, dx) +
                   d3d::Lerp(0.0f, vy, dz) ;
 }
 else // lower triangle DCB
 {
      float uy = C - D; // D-&gt;C
      float vy = B - D; // D-&gt;B

      height = D + d3d::Lerp(0.0f, uy, 1.0f - dx) +
                   d3d::Lerp(0.0f, vy, 1.0f - dz);
 }    return height;
</code></pre><p>}</p>
<p>   Lerp函数是一个沿着一维直线的基本线性插值算法，实现如下：<br>float d3d::Lerp(float a, float b, float t)<br>{<br>     return a - (a<em>t) + (b</em>t);<br>}</p>
<p>13.6 例子程序: Terrain<br>   这章的例子是用一个包含高度信息的RAW文件创建一个地形，纹理和光源。用方向键在地形上行走。注意，下列函数中不相关的代码被省略了，被省略的代码用(…)表示，依赖你的硬件，这个例子可能运行得很慢，请偿试运行一个小地形。<br>   首先，增加全局变量：地形、照相机、每秒帧数。<br>Terrain<em> TheTerrain = 0;<br>Camera   TheCamera(Camera::LANDOBJECT);<br>FPSCounter</em> FPS = 0;</p>
<p>   下面是框架函数：<br>bool Setup()<br>{<br>     D3DXVECTOR3 lightDirection(0.0f, -1.0f, 0.0f);<br>     TheTerrain = new Terrain(Device, “coastMountain256.raw”,<br>                              256, 256, 10, 1.0f);<br>     TheTerrain-&gt;genTexture();<br>     TheTerrain-&gt;lightTerrain(&amp;directionToLight);<br>     …</p>
<pre><code> return true;
</code></pre><p>}</p>
<p>void Cleanup()<br>{<br>     d3d::Delete<terrain*>(TheTerrain);<br>     d3d::Delete<fpscounter*>(FPS);<br>}</fpscounter*></terrain*></p>
<p>bool Display(float timeDelta)<br>{<br>     if( Device )<br>     {<br>          // Update the scene:<br>          …[snipped input checking]</p>
<pre><code>      // Walking on the terrain: Adjust camera&#39;s height so we
      // are standing 5 units above the cell point we are
      // standing on.
      D3DXVECTOR3 pos;
      TheCamera.getPosition(&amp;pos);

      float height = TheTerrain-&gt;getHeight( pos.x, pos.z );

      pos.y = height + 5.0f;

      TheCamera.setPosition(&amp;pos);

      D3DXMATRIX V;
      TheCamera.getViewMatrix(&amp;V);
      Device-&gt;SetTransform(D3DTS VIEW, &amp;V);

      // Draw the scene:
      Device-&gt;Clear(0, 0, D3DCLEAR TARGET | D3DCLEAR ZBUFFER,
                    0xff000000, 1.0f, 0);
      Device-&gt;BeginScene();

      D3DXMATRIX I;
      D3DXMatrixIdentity(&amp;I);

      if( TheTerrain )
          TheTerrain-&gt;draw(&amp;I, false);

      if( FPS )
          FPS-&gt;render(0xffffffff, timeDelta);

      Device-&gt;EndScene();
      Device-&gt;Present(0, 0, 0, 0);
 }
 return true;
</code></pre><p>}</p>
<p>13.7 一些改进<br>   Terrain读取顶点数据到一个很大的缓存，在多重的顶点缓存中划分地形结构，在速度和可测量性方面都十分有利。为我们提出一个问题：顶点缓存最大支持多大？回答是，这依赖于你的硬件。所以你必须先检测。<br>   将地图划分为许多小的顶点缓存是重要的练习，然后将类似矩阵的数据结构编入索引，并且管理数据，这不需要引入新的概念。我们不必详细讨论它。简单的说，你基本上站在地形中一个我们叫做“blocks”的矩阵上,每个block是地形的一个矩形区域。另外，每个block区域（在它自己的顶点索引缓存中）的下方包含地形中的几何信息，为了画它在地形中的位置。<br>   另外，你可以读取地形到一个很大的ID3DXMesh接口。使用D3D函数D3DXSplitMesh划分地形为许多小的Mesh, 以下是D3DXSplitMesh函数原型：<br>void D3DXSplitMesh(<br>    const LPD3DXMESH pMeshIn,<br>    const DWORD <em>pAdjacencyIn,<br>    const DWORD MaxSize,<br>    const DWORD Options,<br>    DWORD </em>pMeshesOut,<br>    LPD3DXBUFFER <em>ppMeshArrayOut,<br>    LPD3DXBUFFER </em>ppAdjacencyArrayOut,<br>    LPD3DXBUFFER <em>ppFaceRemapArrayOut,<br>    LPD3DXBUFFER </em>ppVertRemapArrayOut<br>);<br>       这个函数将一个源Mesh划分多个小的Mesh,，pMeshIn参数是一个指针，指向想划分的Mesh，pAdjacencyIn指向一个邻接数组，MaxSize参数指定作为结果返回的最大顶点数，为返回的Meshe使用指定的创建标记，pMeshesOut参数返回ppMeshArrayOut数组中的Mesh数量，最后3个参数是可选的（可以指定为null），返回邻接信息的数组。<br>13.8 摘要</p>
<ul>
<li>我们能用三角形网格和不同的高度值来模拟地形，创建山丘、河流。</li>
<li>Heightmap数据包含地形顶点的高度值。</li>
<li>我们能通过程序使用磁盘上的图像文件生成地形上的纹理。</li>
<li>我们能照亮地形，通过计算阴影系数来使每个格子变亮或变暗，阴影系数是由光照在格子上的角度决定的。</li>
<li>使照相机在地形上走动，我们需要找到我们站立的三角形。我们计算三角形上的邻边和对边这两个向量，高度是通过…（线性插值在这些向量中每个使用x、z对应的单位向量，以左高顶点为原点为参数。）找到的。<br>（The height is then found by linearly interpolating on each of these vectors using the x- and z-coordinates in a normalized cell with an upper-left vertex at the origin as parameters.）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Building-a-Flexible-Camera-Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Building-a-Flexible-Camera-Class/" class="post-title-link" itemprop="url">第十一章 网格模型II(Building a Flexible Camera Class)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:17:21" itemprop="dateCreated datePublished" datetime="2019-04-11T15:17:21+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ID3DXBuffer"><a href="#ID3DXBuffer" class="headerlink" title="ID3DXBuffer"></a>ID3DXBuffer</h1><p>　　对ID3DXBuffer接口的一些参考是在上一章，这里我们不会详细讲解。在D3DX库中到处都能看见这个接口，因此大概介绍一下该接口还是很有必要的。<br>　　ID3DXBuffer接口是一个很普通的数据结构， D3DX用它将数据存储到邻接内存块中。它只有两个方法：</p>
<ul>
<li>LPVOID GetBufferPointer()——返回一个指向开始数据的指针。</li>
<li>DWORD GetBufferSize()——返回在缓存中的字节大小。<br> 为了保持结构特性，它使用一个空指针。也就是说它让我们知道被存储的数据的类型。例如，D3DXLoadMeshFromX使用一个ID3DXBuffer来返回mesh的邻接信息。因为邻接信息是被存储在DWORD数组中的，所以当我们希望使用缓存中的邻接信息时，我们不得不将缓存转换为DWORD数组。<br>　　例如：<br>DWORD<em> info =(DWORD</em>)adjacencyInfo-&gt;GetBufferPointer();<br>D3DXMATERIAL<em> mtrls = (D3DXMATERIAL</em>)mtrlBuffer-&gt;GetBufferPointer();<br>　　因为ID3DXBuffer是一个COM对象，当你使用完以后就必须释放它以防止内存泄漏：<br>adjacencyInfo-&gt;Release();<br>mtrlBuffer-&gt;Release();<br>　　我们能够使用下面的方法来创建一个空的ID3DXBuffer：<br>HRESULT D3DXCreateBuffer(<br>  DWORD NumBytes, // Size of the buffer, in bytes.<br>  LPD3DXBUFFER <em>ppBuffer // Returns the created buffer.<br>);<br>　　下面的例子是创建一个能包含4个整数的缓存：<br>ID3DXBuffer</em> buffer = 0;<br>D3DXCreateBuffer( 4 <em> sizeof(int), &amp;buffer );<br>11.2 X文件<br> 迄今为止，我们已经使用过了简单的几何物体，如球体，圆柱体，立方体等，它们都是用D3DXCreate</em>函数来创建的。假如你想通过手工指定顶点来创建你自己的3D物体，你能，不用怀疑，不过这是非常枯燥乏味的事情。为了减轻建造3D物体数据的工作，专门的应用程序已经被开发出来了，我们把它们叫做3D建模工具。它们允许我们在一个虚拟的拥有丰富工具的交互环境下建造复杂的真实的mesh，在这建造这些模型都是非常容易的。例如在游戏开发中常用到的有3DSMax（www.discreet.com）,LightWave 3D（www.newtek.com）,以及Maya（www.aliaswavefront.com）。<br> 这些工具，当然能够输出创建好的mesh数据到文件中。因此，我们也能够写一个文件来提取在我们的3D应用程序中要用到的mesh数据。这的确是一种可行的解决办法。不过，还存在一个更方便的解决方案。它是一种叫做X文件的特殊mesh文件格式（扩展名为.X）。很多3D建模软件都能输出这种格式，当然这里存在一个将其他流行的mesh文件转换为X文件的过程。是什么使X文件这么便利呢？因为它是DirectX定义的格式，并且D3DX库很容易地支持X文件。D3DX库提供了读和写X文件的函数。因此，如果我们使用这种格式就避免了还要自己写程序文件来读/写模型文件了。<br> 注意：你能够下载DirectX9 SDK Extra——你能从MSDN（www.msdn.microsoft.com）上得到一些已经开发好的针对3DMax,LightWave,Maya软件导出.X文件的Direct3D工具包。<br>11.2.1读取X文件<br> 我们使用下面的函数来读取存储在X文件中的mesh数据。注意这个方法创建一个ID3DXMesh对象，且从X文件中读取几何信息数据填入其中。<br>HRESULT D3DXLoadMeshFromX(<br>  LPCSTR pFilename,<br>  DWORD Options,<br>  LPDIRECT3DDEVICE9 pDevice,<br>  LPD3DXBUFFER <em>ppAdjacency,<br>  LPD3DXBUFFER </em>ppMaterials,<br>  LPD3DXBUFFER<em> ppEffectInstances,<br>  PDWORD pNumMaterials,<br>  LPD3DXMESH </em>ppMesh<br>);</li>
<li>pFilename — 读取的X文件的文件名。</li>
<li>Options — 用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</li>
<li>D3DXMESH_32BIT — mesh使用32位索引。</li>
<li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li>
<li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li>
<li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li>
<li>pDevice — 与复制mesh有关的设备。</li>
<li>ppAdjacency — 返回一个ID3DXBuffer包含一个DWORD数组，描述mesh的邻接信息。</li>
<li>ppMaterials — 返回一个ID3DXBuffer包含一个D3DXMATERIAL结构的数组，存储了mesh的材质数据。我们在下一节介绍mesh材质。</li>
<li>ppEffectInstances — 返回一个ID3DXBuffer包含一个D3DXEFFECTINSTANCE结构的数组。我们现在通过指定0值来忽略这个参数。</li>
<li>pNumMaterials — 返回mesh的材质数。</li>
<li>ppMesh — 返回填充了X文件几何信息的ID3DXMesh对象。<br>11.2.2 X文件的材质<br>　　D3DXLoadMeshFromX的第七个参数返回的是mesh包含的材质数，第五个参数返回的是包含着材质数据的一个D3DXMATERIAL结构数组。D3DXMATERIAL结构的定义如下：<br>typedef struct D3DXMATERIAL {<br>  D3DMATERIAL9 MatD3D;<br>  LPSTR pTextureFilename;<br>} D3DXMATERIAL;<br>　　这是一个简单的结构；它包含一个基本的D3DMATERAIL9结构和一个用来指定与之相关联的纹理文件名的一个以null结束的字符串指针。一个X文件是不能插入纹理数据的；它只能插入文件名。因此，在使用D3DXLoadMeshFromX读取一个X文件以后，我们还必须从纹理文件中读取纹理数据。我们将在下一节中说明怎样具体实现。<br>　　D3DXLoadMeshFromX函数读取X文件数据以便在返回的D3DXMATERIAL数组中的第i项与第i个子集相对应。因此，子集是使用0，1，2，…，n-1标记的，n是子集和材质的数目。这也就允许使用简单的循环来渲染mesh了。<br>11.2.3 实例程序：X文件<br>　　我们现在演示本章中的第一个实例（X文件）的相关代码。该例子调用一个叫做bigship1.x的x文件，你可以在DirectX SDK下的media文件夹下找到它。完整原代码可以在相应的文件中找到。图11.1是该实例的一个截图。</li>
</ul>
<p>图11.1<br>　　该实例使用下面的全局变量：<br>ID3DXMesh<em>                      Mesh = 0;<br>std::vector<d3dmaterial9>       Mtrls(0);<br>std::vector&lt;IDirect3DTexture9</d3dmaterial9></em>&gt; Textures(0);<br>   这里有一个ID3DXMesh对象，它被用来存储从X文件中读取的mesh数据。也有一个材质vector和纹理vector,我们用它们来分别存储mesh的材质和纹理。<br>　　我们首先在Setup函数中操作。首先，我们读取X文件：<br>bool Setup()<br>{<br>    HRESULT hr = 0;<br>    //<br>    // Load the XFile data.<br>    //<br>    ID3DXBuffer<em> adjBuffer  = 0;<br>    ID3DXBuffer</em> mtrlBuffer = 0;<br>    DWORD        numMtrls   = 0;<br>    hr = D3DXLoadMeshFromX(<br>        “bigship1.x”,<br>        D3DXMESH_MANAGED,<br>        Device,<br>        &amp;adjBuffer,<br>        &amp;mtrlBuffer,<br>        0,<br>        &amp;numMtrls,<br>        &amp;Mesh);<br>    if(FAILED(hr))<br>    {<br>        ::MessageBox(0, “D3DXLoadMeshFromX() - FAILED”, 0, 0);<br>        return false;<br>     }<br>　　读取完X文件数据以后，我们必须遍历D3DXMATERIAL数组来读取mesh中所使用的所有纹理：<br>    //<br>    // Extract the materials, and load textures.<br>    //<br>    if( mtrlBuffer != 0 &amp;&amp; numMtrls != 0 )<br>    {<br>        D3DXMATERIAL<em> mtrls = (D3DXMATERIAL</em>)mtrlBuffer-&gt;GetBufferPointer();<br>        for(int i = 0; i &lt; numMtrls; i++)<br>        {<br>            // the MatD3D property doesn’t have an ambient value set<br>            // when its loaded, so set it now:<br>            mtrls[i].MatD3D.Ambient = mtrls[i].MatD3D.Diffuse;<br>            // save the ith material<br>            Mtrls.push_back( mtrls[i].MatD3D );<br>            // check if the ith material has an associative texture<br>            if( mtrls[i].pTextureFilename != 0 )<br>            {<br>                // yes, load the texture for the ith subset<br>                IDirect3DTexture9<em> tex = 0;<br>                D3DXCreateTextureFromFile(<br>                    Device,<br>                    mtrls[i].pTextureFilename,<br>                    &amp;tex);<br>                // save the loaded texture<br>                Textures.push_back( tex );<br>            }<br>            else<br>            {<br>                // no texture for the ith subset<br>                Textures.push_back( 0 );<br>            }<br>        }<br>    }<br>　　d3d::Release&lt;ID3DXBuffer</em>&gt;(mtrlBuffer); // done w/ buffer<br>    .<br>    . // Snipped irrelevant code to this chapter (e.g., setting up lights,<br>    . // view and projection matrices, etc.)<br>    .<br>    return true;<br>} // end Setup()<br>　　在Display函数中我们让mesh在每一帧中都旋转一个小角度。我们使用简单的循环，Mesh便能够被渲染了：<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        //<br>        // Update: Rotate the mesh.<br>        //</p>
<pre><code>    static float y = 0.0f;
    D3DXMATRIX yRot;
    D3DXMatrixRotationY(&amp;yRot, y);
    y += timeDelta;

    if( y &gt;= 6.28f )
        y = 0.0f;

    D3DXMATRIX World = yRot;

    Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);

    //
    // Render
    //

    Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
    Device-&gt;BeginScene();

    for(int i = 0; i &lt; Mtrls.size(); i++)
    {
        Device-&gt;SetMaterial( &amp;Mtrls[i] );
        Device-&gt;SetTexture(0, Textures[i]);
        Mesh-&gt;DrawSubset(i);
    }   

    Device-&gt;EndScene();
    Device-&gt;Present(0, 0, 0, 0);
}
return true;
</code></pre><p>}<br>11.2.4 产生顶点法线<br>   一个X文件不包含顶点法线数据，这是很有可能的。假如是这种情况，那么手动计算顶点法线以便我们能够使用灯光这是很有必要的。在第5章中我们简要的介绍了一下怎么做。然而，现在我们知道了ID3DXMesh接口和它的父接口ID3DXBaseMesh，我们能够使用下面的函数来产生任何mesh的顶点法线：<br>HRESULT D3DXComputeNormals(<br>    LPD3DXBASEMESH pMesh, // Mesh to compute normals of.<br>    const DWORD <em>pAdjacency // Input adjacency info.<br>);<br>   这个函数通过使用平均法线的方法来产生顶点法线。假如有邻接信息，那么重复的顶点是被忽略的。假如没有邻接信息，那么重复的顶点也会被重复计算。了解这些是很重要的，我们检查pMash必须有一个包含D3DFVF_NORMAL标记的顶点格式。<br>   注意假如X文件不包含顶点法线数据，那么通过D3DXLoadMeshFromX创建的ID3DXMesh对象在它的顶点格式中没有指定的D3DFVF_NORMAL标记。因此，在我们能够使用D3DXComputeNormals之前，我们必须复制mesh并且为其指定包含D3DFVF_NORMAL的顶点格式。下面就是相应的代码：<br>// does the mesh have a D3DFVF_NORMAL in its vertex format?<br>if ( !(pMesh-&gt;GetFVF() &amp; D3DFVF_NORMAL) )<br>{<br>    // no, so clone a new mesh and add D3DFVF_NORMAL to its format:<br>    ID3DXMesh</em> pTempMesh = 0;<br>    pMesh-&gt;CloneMeshFVF(<br>        D3DXMESH_MANAGED,<br>        pMesh-&gt;GetFVF() | D3DFVF_NORMAL, // add it here<br>        Device,<br>        &amp;pTempMesh );</p>
<pre><code>// compute the normals:
D3DXComputeNormals( pTempMesh, 0 );

pMesh-&gt;Release(); // get rid of the old mesh
pMesh = pTempMesh; // save the new mesh with normals
</code></pre><p>}<br>11.3渐进网格（Progressive Meshes）<br>   渐进网格，它通过ID3DXPMesh接口来表现，允许我们通过简化边缩减转换（edge collapse transformations，ECT）来简化mesh。每执行一次ECT就移除一个顶点和一或2个面。因为每个ECT是可逆的（它的逆过程叫顶点分裂），我们能够逆转简化过程并且恢复mesh为它的原始状态。当然，我们不可能得到比原始情况还要精细的网格。我们仅仅只能简化然后恢复简化操作。图11.2显示了同一个mesh的三种不同精细级别（levels of detail，LOD）：高，中，低。</p>
<p>图11.2<br>   渐进网格和mipmaps纹理非常相似。当使用纹理时，我们已经注意到在一个小或远的图元上使用高分辨率的纹理简直就是浪费。对于mesh也是同样的道理；一个小或远的mesh不需要太多三角形，多了也是浪费。因此，我们不会花费渲染高三角形模型的时间来渲染一个只需要表现小的低三角形模型。<br>   我们可以使用渐进网格来根据模型距离摄象机的距离来调整模型的LOD。也就是说，当距离减少时，我们增加mesh的细节，当距离增加时我们减少mesh的细节。<br>   注意我们还没有讨论渐进网格是怎样被实现的；这里我们只讲解怎样使用ID3DXPMesh接口。对此感兴趣的读者可以到渐进网格的原始页面Hoppe上查看。Hoppe的网址：<a href="http://research.microsoft.com/~hoppe/。" target="_blank" rel="noopener">http://research.microsoft.com/~hoppe/。</a><br>11.3.1 产生一个渐进网格<br>   我们能够使用下面的函数来创建一个ID3DXPMesh对象：<br>HRESULT D3DXGeneratePMesh(<br>    LPD3DXMESH pMesh,<br>    CONST DWORD <em>pAdjacency,<br>    CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,<br>    CONST FLOAT </em>pVertexWeights,<br>    DWORD MinValue,<br>    DWORD Options,<br>    LPD3DXPMESH *ppPMesh<br>);</p>
<ul>
<li>pMesh— 输入原始mesh，它包含了我们想要生成的渐进网格的mesh数据。</li>
<li>pAdjacency — 指向一个包含pMesh邻接信息的DWORD数组。</li>
<li>pVertexAttributeWeights — 指向一个D3DXATTRIBUTEWEIGHTS数组，它的大小是pMesh-&gt;GetNumVertices（）。它的第i项与pMesh中的第i个顶点相对应并且指定的是它的品质权重。品质权重被用来确定一个顶点被删除的可能性大小。你能够将此参数设置为null，对于每个顶点一个默认的顶点品质权重将被设置。在11.3.2节中有关于顶点品质权重和D3DXATTRIBUTEWEIGHTS结构的更多信息。</li>
<li>pVertexWeights — 指向一个float数组，它的大小是pMesh-&gt;GetNumVertices（），它的第i项与pMesh中的第i个顶点相对应并且指定的是它的顶点权重。顶点权重越高被删除的可能性越小。你能够将此参数设置为null，对于每个顶点一个默认的顶点品质权重1.0将被设置。</li>
<li>MinValue — 我们想要简化到的最小顶点或面数。注意该值是必须的，而且与顶点/品质权重有关，最终可能达不到该值。</li>
<li>Options — 只能取D3DXMESHSIMP枚举类型中的一个值：</li>
<li>D3DXMESHSIMP_VERTEX — 指定在上一个参数MinValue中提到的数为顶点数。</li>
<li>D3DXMESHSIMP_FACE —指定在上一个参数MinValue中提到的数为面数。</li>
<li><p>ppPMesh — 返回生成好的渐进网格。<br>11.3.2 顶点品质权重<br>typedef struct _D3DXATTRIBUTEWEIGHTS {<br>  FLOAT Position;<br>  FLOAT Boundary;<br>  FLOAT Normal;<br>  FLOAT Diffuse;<br>  FLOAT Specular;<br>  FLOAT Texcoord[8];<br>  FLOAT Tangent;<br>  FLOAT Binormal;<br>} D3DXATTRIBUTEWEIGHTS;<br>　　顶点权重结构允许我们为每个顶点属性指定一个权值。0.0表示该属性没有权重。顶点属性的权重越高在简化过程中被移除的可能性越小。默认的权值如下：<br>D3DXATTRIBUTEWEIGHTS AttributeWeights;<br>AttributeWeights.Position = 1.0;<br>AttributeWeights.Boundary = 1.0;<br>AttributeWeights.Normal = 1.0;<br>AttributeWeights.Diffuse = 0.0;<br>AttributeWeights.Specular = 0.0;<br>AttributeWeights.Tex[8] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};<br>　　默认的权值是被推荐的，除非你的应用程序有一个重要的理由而不使用它。<br>11.3.3 ID3DXPMesh方法<br> ID3DXPMesh接口是继承自ID3DXBaseMesh接口。因此它拥有以前所学习过的ID3DXMesh的所有函数，下面是一些额外的方法：<br>DWORD GetMaxFaces(VOID)——返回渐进网格能够被设置的最大面数。<br>DWORD GetMaxVertices(VOID)——返回渐进网格能够被设置的最大顶点数。<br>DWORD GetMinFaces(VOID)——返回渐进网格能够被设置的最小面数。<br>DWORD GetMinVertices(VOID)——返回渐进网格能够被设置的最小顶点数。<br>HRESULT SetNumFaces(DWORD Faces)——这个方法允许我们设置面的个数，以便让mesh简化/复杂化。例如，假设mesh目前有50个面，我们现在想将它简化到30个面；我们将写成：<br>pmesh-&gt;SetNumFaces(30);<br> 注意调整后的面数可能并不是我们设定的面数。假如面数小于了GetMinFaces（），那么面数将为GetMinFaces（）。同样的，假如面数大于了GetMaxFaces（），那么面数将为GetMaxFaces（）。<br>HRESULT SetNumVertices(DWORD Vertices)——这个方法允许我们设置顶点的个数，以便让mesh简化/复杂化。例如，假设mesh目前有20个顶点，我们现在想将它增加到40个；我们将写成：<br>pmesh-&gt;SetNumVertices(40);<br> 注意调整后的顶点数可能并不是我们设定的数。假如顶点数小于了GetMinVertices（），那么顶点数将为GetMinVertices（）。同样的，假如顶点数大于了GetMaxVertices（），那么顶点数将为GetMaxVertices（）。<br>HRESULT TrimByFaces(<br>DWORD NewFacesMin,<br>DWORD NewFacesMax,<br>DWORD <em>rgiFaceRemap, // Face remap info.<br>DWORD </em>rgiVertRemap // Vertex remap info.<br>);<br> 这个方法允许我们设置新的最小和最大面数，分别通过NewFacesMin和NewFacesMax指定。注意新的最小和最大值必须在现有最小和最大面数之间；也就是说，必须在[GetMinFaces（），GetMaxFaces（）]之中。该函数也返回面和顶点的重影射信息。重影射信息参见10.4节。<br>HRESULT TrimByVertices(<br>DWORD NewVerticesMin,<br>DWORD NewVerticesMax,<br>DWORD <em>rgiFaceRemap, // Face remap info.<br>DWORD </em>rgiVertRemap // Vertex remap info.<br>);<br> 这个方法允许我们设置新的最小和最大顶点数，分别通过NewVerticesMin和NewVerticesMax指定。注意新的最小和最大值必须在现有最小和最大顶点数之间；也就是说，必须在[GetMinVertices（），GetMaxVertices（）]之中。该函数也返回面和顶点的重影射信息。重影射信息参见10.4节。<br>11.3.4实例程序：渐进网格<br> 渐进网格例子与X文件例子很相似，除了实际上我们创建和渲染的是一个渐进网格，通过ID3DXPMesh接口来表现。我们允许用户通过键盘输入进行交互式地改变渐进网格。你能通过按A键来增加mesh的面数，按S键来减少mesh的面数。<br> 在这个例子中使用的全局变量和X文件例子中的是一样的，不过我们增加了一个用来存储渐进网格的变量：<br>ID3DXMesh<em>                      SourceMesh = 0;<br>ID3DXPMesh</em>                     PMesh      = 0; // progressive mesh<br>std::vector<d3dmaterial9>       Mtrls(0);<br>std::vector<idirect3dtexture9*> Textures(0);<br> 回想一下，为了得到一个渐进网格我们必须输入一个包含了数据信息的源mesh。因此，我们首先读取一个X文件数据到ID3DXMesh对象SourceMesh之中，然后再产生渐进网格：<br>bool Setup()<br>{<br>  HRESULT hr = 0;<br>  // …Load XFile data into SourceMesh snipped.<br>  //<br>　　// …Extracting materials and textures snipped.<br> 因为这一部分代码和X文件例子中的是完全一样的，在这里我们就把它省略了。一但有了源mesh，我们就能够象下面一样来生成渐进网格了：<br>  //<br>  // Generate the progressive mesh.<br>  //<br>  hr = D3DXGeneratePMesh(</idirect3dtexture9*></d3dmaterial9></p>
<pre><code>  SourceMesh,
  (DWORD*)adjBuffer-&gt;GetBufferPointer(), // adjacency
  0,                  // default vertex attribute weights
  0,                  // default vertex weights
  1,                  // simplify as low as possible
  D3DXMESHSIMP_FACE,  // simplify by face count
  &amp;PMesh);
</code></pre><p>  d3d::Release<id3dxmesh*>(SourceMesh);  // done w/ source mesh<br>  d3d::Release<id3dxbuffer*>(adjBuffer); // done w/ buffer</id3dxbuffer*></id3dxmesh*></p>
<p>  if(FAILED(hr))<br>  {</p>
<pre><code>  ::MessageBox(0, &quot;D3DXGeneratePMesh() - FAILED&quot;, 0, 0);
  return false;
</code></pre><p>   }<br>　　注意，因为顶点/品质权值的缘故，很难将Mesh简化到只有一个面，但是，如果将其指定为1，则可以将Mesh简化到最低。<br>　　在这一点上，渐进网格已经被产生了，但是假如你现在就渲染它，它将以最简化的方式来渲染。以为我们想开始渲染最高精度的mesh，所以我们设置它为：<br>  // set to original detail<br>  DWORD maxFaces = PMesh-&gt;GetMaxFaces();<br>   PMesh-&gt;SetNumFaces(maxFaces);<br> 在Display函数中，我们测试A键和S键并将结果输入。<br>bool Display(float timeDelta)<br>{<br>  if( Device )<br>  {</p>
<pre><code>  //
  // Update: Mesh resolution.
  //

  // Get the current number of faces the pmesh has.
  int numFaces = PMesh-&gt;GetNumFaces();

  // Add a face, note the SetNumFaces() will  automatically
  // clamp the specified value if it goes out of bounds.
  if( ::GetAsyncKeyState(&#39;A&#39;) &amp; 0x8000f )
  {
      // Sometimes we must add more than one face to invert
      // an edge collapse transformation
      PMesh-&gt;SetNumFaces( numFaces + 1 );
      if( PMesh-&gt;GetNumFaces() == numFaces )
          PMesh-&gt;SetNumFaces( numFaces + 2 );
  }

  // Remove a face, note the SetNumFaces() will  automatically
  // clamp the specified value if it goes out of bounds.
  if( ::GetAsyncKeyState(&#39;S&#39;) &amp; 0x8000f )
</code></pre><p>　　　　　　　　PMesh-&gt;SetNumFaces( numFaces - 1 );<br> 这是很简单的，但是要注意当增加面时我们有时必须增加两个面来完成ECT。<br>　　最后，我们就能象渲染ID3DXMesh对象一样来渲染ID3DXPMesh对象。另外，为了更加直观的观察网格的三角形数的变化情况，使用黄色材质在线框模式（Wireframe Mode）下渲染Mesh的三角形。</p>
<pre><code>  Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
  Device-&gt;BeginScene();
  for(int i = 0; i &lt; Mtrls.size(); i++)
  {
      // draw pmesh
      Device-&gt;SetMaterial( &amp;Mtrls[i] );
      Device-&gt;SetTexture(0, Textures[i]);
      PMesh-&gt;DrawSubset(i);
      // draw wireframe outline
      Device-&gt;SetMaterial(&amp;d3d::YELLOW_MTRL);
      Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
      PMesh-&gt;DrawSubset(i);
      Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
  }   
  Device-&gt;EndScene();
  Device-&gt;Present(0, 0, 0, 0);
</code></pre><p>  }<br>  return true;<br>}<br>　　<br>图11.3<br>11.4 界线容积（Bounding Volumes）<br>　　有时我们需要计算mesh的界线容积（边界范围）。常用的有两种类型：立方体和球。也有使用其它方法的，如圆柱体，椭球体，菱形体，胶囊形。图11.4演示了对同一个mesh分别使用立方体和球体类型。这一节我们只讨论立方体和球体两种边界形式。<br>　　<br>　　图11.4<br>　　边界盒/球常常被用来加速可见性测试，碰撞检测等。例如，假如一个mesh的边界盒/球不可见，那么我们就说mesh不可见。一个盒/球可见性测试是比分别测试mesh中的每个三角形要廉价的多。对于一个碰撞检测例子，如果一枚导弹点火起飞，我们需要检测它是否击中了同一场景中的目标。由于这些物体都是由大量三角形构成，我们可以依次检测每个对象的每个三角形，来测试导弹（可以用射线数学模型）是否碰撞到了这些三角形。这个方法需要进行多次的射线/三角形交点的运算。一个更好的方法是使用边界盒或边界球，计算射线与场景中的每个对象的边界盒/边界球的交点。如果射线与对象的边界范围相交，可以认为该对象被击中了。这是一个公平的近似方法，如果需要更高的精度，可以用边界范围法先去除那些明显不会相撞的对象，然后用更精确地方法检测很可能相撞的对象。如果边界范围检测发现相撞，则该对象就很有可能相撞。<br>　　D3DX库提供了计算mesh的边界盒和边界球的函数。这些函数使用顶点数组作为输入计算边界盒/球。这些函数本来就是设计的很灵活的，它们可以使用各种顶点格式：<br>HRESULT D3DXComputeBoundingSphere(<br>  LPD3DXVECTOR3 pFirstPosition,<br>  DWORD NumVertices,<br>  DWORD dwStride,<br>  D3DXVECTOR3<em> pCenter,<br>  FLOAT</em> pRadius<br>);</p>
</li>
<li>pFirstPosition——指向在顶点数组中第一个顶点的向量，描述顶点位置。</li>
<li>NumVertices——在顶点数组中的的顶点数。</li>
<li>dwStride——每个顶点的字节大小。这是很需要的，因为顶点结构可能有一些额外信息如法向量和纹理坐标，这些信息对计算边界又没有用，函数需要知道应该跳过多少字节来得到下一个顶点的位置。</li>
<li>pCenter——返回边界球的中心。</li>
<li>pRadius——返回边界球的半径。<br>HRESULT D3DXComputeBoundingBox(<br>  LPD3DXVECTOR3 pFirstPosition,<br>  DWORD NumVertices,<br>  DWORD dwStride,<br>  D3DXVECTOR3<em> pMin,<br>  D3DXVECTOR3</em> pMax<br>);<br>前三个参数和D3DXComputeBoundingSphere的前三个参数是完全一样的。最后两个参数分别用来返回边界盒的最小和最大点。<br>11.4.1一些新的特殊常量<br>让我来介绍两个常量，它们在本书中是经常要用到的。我们把它们添加到d3d名称空间中：<br>namespace d3d<br>{<br>  …<br>  const float INFINITY = FLT_MAX;<br>  const float EPSILON = 0.001f;<br>常量INFINITY是用来表示一个浮点数所能存储的最大数。因为我们找不到一个比FLT_MAX还要大的浮点数，我们可以将它视为无穷大。常量EPSILON是一个很小的值，我们这样定义它，凡是比它小的数就视为0。这也是很有必要的，因为得到的浮点是不精确的，一个被读作0的数可能有一点点小偏差。因此，让它和0比较相等肯定会失败。我们因此可以通过把该值与0的差值与EPSILON比较来确定是否相等：<br>bool Equals(float lhs, float rhs)<br>{<br>  // if lhs == rhs their difference should be zero<br>  return fabs(lhs - rhs) &lt; EPSILON ? true : false;<br>}<br>11.4.2界线容积类型<br> 为了更容易的使用边界盒和边界球，我们将它们分别封装到两个类中。现在在d3d名称空间中定义类：<br>struct BoundingBox<br>{<br>  BoundingBox();<br>  bool isPointInside(D3DXVECTOR3&amp; p);<br>  D3DXVECTOR3 _min;<br>  D3DXVECTOR3 _max;<br>};<br>struct BoundingSphere<br>{<br>  BoundingSphere();<br>  D3DXVECTOR3 _center;<br>  float _radius;<br>};<br>d3d::BoundingBox::BoundingBox()<br>{<br>  // infinite small bounding box<br>  _min.x = d3d::INFINITY;<br>  _min.y = d3d::INFINITY;<br>  _min.z = d3d::INFINITY;<br>  _max.x = -d3d::INFINITY;<br>  _max.y = -d3d::INFINITY;<br>  _max.z = -d3d::INFINITY;<br>}<br>bool d3d::BoundingBox::isPointInside(D3DXVECTOR3&amp; p)<br>{<br>  // is the point inside the bounding box?<br>  if(p.x &gt;= _min.x &amp;&amp; p.y &gt;= _min.y &amp;&amp; p.z &gt;= _min.z &amp;&amp;<pre><code>  p.x &lt;= _max.x &amp;&amp; p.y &lt;= _max.y &amp;&amp; p.z &lt;= _max.z)
</code></pre>  {<pre><code>  return true;
</code></pre>  }<br>  else<br>  {<pre><code>  return false;
</code></pre>  }<br>}<br>d3d::BoundingSphere::BoundingSphere()<br>{<br>  _radius = 0.0f;<br>}<br>11.4.3实例程序：界线容积<br>　　在这一章中被叫做界线容积的实例程序主要是演示使用D3DXComputeBoundingSphere和D3DXComputeBoundingBox。程序读取一个X文件并且计算该mesh的边界球。它创建两个ID3DXMesh对象，一个用来作为边界球模型一个用来作为边界盒模型。X文件生成的mesh被渲染，其中的边界球或边界盒不可见（如图11.5）。你能够通过敲空格键来再边界球和边界盒之间切换。</li>
</ul>
<p>图11.5<br>　　这个例子是非常简单的，我们列出你要学习的代码。我们实现的两个函数是用来计算网格的边界球和边界盒的：<br>bool ComputeBoundingSphere(<br>        ID3DXMesh<em> mesh, // mesh to compute bounding sphere for<br>        d3d::BoundingSphere</em> sphere) // return bounding sphere<br>{<br>    HRESULT hr = 0;</p>
<pre><code>BYTE* v = 0;
mesh-&gt;LockVertexBuffer(0, (void**)&amp;v);

hr = D3DXComputeBoundingSphere(
        (D3DXVECTOR3*)v,
        mesh-&gt;GetNumVertices(),
        D3DXGetFVFVertexSize(mesh-&gt;GetFVF()),
        &amp;sphere-&gt;_center,
        &amp;sphere-&gt;_radius);

mesh-&gt;UnlockVertexBuffer();

if( FAILED(hr) )
    return false;
return true;
</code></pre><p>}</p>
<p>bool ComputeBoundingBox(<br>        ID3DXMesh<em> mesh, // mesh to compute bounding box for<br>        d3d::BoundingBox</em> box) // return bounding box<br>{<br>    HRESULT hr = 0;</p>
<pre><code>BYTE* v = 0;
mesh-&gt;LockVertexBuffer(0, (void**)&amp;v);

hr = D3DXComputeBoundingBox(
        (D3DXVECTOR3*)v,
        mesh-&gt;GetNumVertices(),
        D3DXGetFVFVertexSize(mesh-&gt;GetFVF()),
        &amp;box-&gt;_min,
        &amp;box-&gt;_max);

mesh-&gt;UnlockVertexBuffer();

if( FAILED(hr) )
    return false;
return true;
</code></pre><p>}<br>　　注意，类型转换(D3DXVECTOR3*)v假定顶点位置成员是被存储在我们所使用的顶点结构的开始位置。同样要注意我们能够使用D3DXGetFVFVertexSize函数来得到顶点结构的大小。<br>11.5 摘要(略)</p>
<p>第十二章 创建灵活的摄像机类(Building a Flexible Camera Class)<br>　　迄今，我们已经使用过D3DXMatrixLookAtLH函数来计算视图空间变换矩阵。这个函数对于在固定位置布置和对准摄像机是非常好用的，不过它的用户接口对于要响应用户输入来实现摄像机移动就不那么好用了。这就激发我们用我们自己的方法来解决。在这一章我们展示了怎样实现一个Camera类，它使我们能够比D3DXMatrixLookAtLH函数更好地操作摄像机，并且可以用来作为飞行模拟摄像机和第一人称视角摄像机。<br>目标</p>
<ul>
<li>学习怎样实现一个灵活的摄像机类，它可以用作飞行模拟摄像机和第一人称视角摄像机。<br>12.1 摄像机设计<br>　　我们定义一个相对于世界坐标系的位置和摄像机的方向，这里使用四个摄像机向量：right vector ,  up vector, look vector 以及 position vector, 如图12.1所示。这些向量用来为摄像机定义一个坐标系来描述在世界坐标中的对应关系。因为 right ，up 和 look 向量定义了摄像机在世界中的方向，我们有时把它们三个向量一起称为方向向量（orientation vectors）。方向向量必须被标准化。假如彼此互相垂直且都是单位长度，那么我们就称它们是正交标准化向量。我们做这些限制是因为等一会儿我们要将方向向量插入到一个行矩阵中。因为行向量是正交标准化的，所以该矩阵也就是直交矩阵。回忆一下，直交矩阵有一个特性就是它的逆矩阵等于它的转置矩阵。这在等一下的12.2.1.2节中是很有用的。</li>
</ul>
<p>图12.1<br>　　有了这四个向量来描述摄像机，我们的摄像机就能够按照下面六种方式变化了：</p>
<ul>
<li>围绕right向量旋转（pitch倾斜）</li>
<li>围绕up向量旋转（yaw 偏航）</li>
<li>围绕look向量旋转（roll 滚转）</li>
<li>沿着right向量平移（strafe）</li>
<li>沿着up向量飞行（fly）</li>
<li>沿着look向量移动（move）<br>通过这六种操作，我们能够沿着三个轴移动以及饶着三个轴旋转，这给了我们一个六度的自由。下面的Camera类定义了我们要的描述数据以及想要的方法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> CameraType &#123; LANDOBJECT, AIRCRAFT &#125;;</span><br><span class="line">    Camera();</span><br><span class="line">    Camera(CameraType cameraType);</span><br><span class="line">    ~Camera();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">strafe</span><span class="params">(<span class="keyword">float</span> units)</span></span>; <span class="comment">// left/right</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">float</span> units)</span></span>;    <span class="comment">// up/down</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">float</span> units)</span></span>;   <span class="comment">// forward/backward   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pitch</span><span class="params">(<span class="keyword">float</span> angle)</span></span>; <span class="comment">// rotate on right vector</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">yaw</span><span class="params">(<span class="keyword">float</span> angle)</span></span>;   <span class="comment">// rotate on up vector</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">roll</span><span class="params">(<span class="keyword">float</span> angle)</span></span>;  <span class="comment">// rotate on look vector</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getViewMatrix</span><span class="params">(D3DXMATRIX* V)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCameraType</span><span class="params">(CameraType cameraType)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPosition</span><span class="params">(D3DXVECTOR3* pos)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(D3DXVECTOR3* pos)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRight</span><span class="params">(D3DXVECTOR3* right)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUp</span><span class="params">(D3DXVECTOR3* up)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getLook</span><span class="params">(D3DXVECTOR3* look)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CameraType  _cameraType;</span><br><span class="line">    D3DXVECTOR3 _right;</span><br><span class="line">    D3DXVECTOR3 _up;</span><br><span class="line">    D3DXVECTOR3 _look;</span><br><span class="line">    D3DXVECTOR3 _pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在类中我们定义了一个还没有讨论的CameraType枚举类型。目前，我们的摄像机支持两种摄像机模式，LANDOBJECT模式和AIRCRAFT模式。AIRCRAFT模式允许我们在空间中完全自由的移动。不过，在有些游戏中，比如第一人称设计游戏，人是不能飞的；因此我们必须限制它在某些轴上的运动。指定为LANDOBJECT模式的摄像机就限制了这些，你可以在下一部分看见。<br>12.2 执行详细资料<br>12.2.1计算视图矩阵<br>　　我们现在演示怎样根据摄像机向量来计算视图矩阵变换的。让 p = (px, py, pz), r = (rx, ry, rz), u = (ux, uy, uz) 以及 d = (dx, dy, dz) 分别表示 position, right, up 以及 look 向量。<br>　　回忆第二章我们所说的，视图空间变换是指在世界坐标系中进行几何变换以便将照相机平移变换到坐标系的源点并把它的方向旋转至朝向Z轴的正方向（如图12.2）。</p>
<p>图12.2<br>因此，我们希望有一个象这样的变换矩阵V ：</p>
<ul>
<li>pV = (0, 0, 0)—矩阵V能将摄像机移动到原点。</li>
<li>rV = (1, 0, 0)—矩阵V能将摄像机的right向量与世界坐标系中的x轴对齐。</li>
<li>uV = (0, 1, 0)—矩阵V能将摄像机的up向量与世界坐标系中的y轴对齐。</li>
<li>dV = (0, 0, 1)—矩阵V能将摄像机的look向量与世界坐标系中的z轴对齐。<br>我们能将变换任务分为两个部分：1）平移部分，将摄像机的位置移动到原点；2）旋转部分，将摄像机的方向向量与世界坐标系的轴对齐。<br>12.2.1.1 第一部分：平移<br>　　平移只需要利用 –p 就可简单地将 p 移动到原点，因为 p–p=0。因此我们能够用下面的矩阵来描述视图变换中的平移部分：<br>　　<br>12.2.1.2 第二部分：旋转<br>　　矫正摄像机的三个方向向量使其与世界坐标系的轴对齐需要更多的工作。我们需要一个3<em>3的旋转矩阵A ，它能将right，up和look分别与x-，y-以及z轴对齐。这个矩阵将满足如下三个等式：<br>　　<br>注意：我们在这里使用3</em>3矩阵来工作是因为现在不需要额外的信息来表现旋转。等一下我们将它增加到常用的4<em>4矩阵。<br>　　因为这三个等式都有一个相同系数矩阵A ，所以我们能够把它们合在一起。我们把它们从新写到一起来：<br>　　<br>　　求A有很多方法，但是我们知道A是B逆矩阵因为BA = BB-1 = I。因为B 是一个直交矩阵（它的行向量是正交标准化的），我们知道它的逆矩阵就是它的转置矩阵。因此，将方向向量和世界坐标系中的坐标轴对齐的变换如下：<br>　　<br>12.2.1.3 将两部分合并<br>　　最后，将A增加为4</em>4矩阵，同时将平移部分合并到旋转部分形成的视图变换矩阵V：</li>
</ul>
<p>我们在Camera::getViewMatrix方法中建立这个矩阵：<br>void Camera::getViewMatrix(D3DXMATRIX* V)<br>{<br>    // Keep camera’s axes orthogonal to eachother<br>    D3DXVec3Normalize(&amp;_look, &amp;_look);<br>    D3DXVec3Cross(&amp;_up, &amp;_look, &amp;_right);<br>    D3DXVec3Normalize(&amp;_up, &amp;_up);<br>    D3DXVec3Cross(&amp;_right, &amp;_up, &amp;_look);<br>    D3DXVec3Normalize(&amp;_right, &amp;_right);</p>
<pre><code>// Build the view matrix:
float x = -D3DXVec3Dot(&amp;_right, &amp;_pos);
float y = -D3DXVec3Dot(&amp;_up, &amp;_pos);
float z = -D3DXVec3Dot(&amp;_look, &amp;_pos);

(*V)(0,0) = _right.x; (*V)(0, 1) = _up.x; (*V)(0, 2) = _look.x; (*V)(0, 3) = 0.0f;
(*V)(1,0) = _right.y; (*V)(1, 1) = _up.y; (*V)(1, 2) = _look.y; (*V)(1, 3) = 0.0f;
(*V)(2,0) = _right.z; (*V)(2, 1) = _up.z; (*V)(2, 2) = _look.z; (*V)(2, 3) = 0.0f;
(*V)(3,0) = x;        (*V)(3, 1) = y;     (*V)(3, 2) = z;       (*V)(3, 3) = 1.0f;
</code></pre><p>}<br>你可能想知道方法中前面几行代码是干什么的。在几次旋转后，摄像机的方向向量可能变的不相互垂直了。因此，每当该函数被调用时，我们根据look向量从新计算up和right向量，使它们保持相互垂直。新的up向量是这样计算的up = look × right。 接着新的right向量是这样计算的right = up × look。<br>12.2.2围绕任意轴旋转<br>为了实现我们的摄像机旋转方法，我们需要能够绕着任意轴旋转。D3DX库提供下面的函数来解决这个问题：<br>D3DXMATRIX <em>D3DXMatrixRotationAxis(<br>    D3DXMATRIX </em>pOut, // returns rotation matrix<br>    CONST D3DXVECTOR3 *pV, // axis to rotate around<br>    FLOAT Angle // angle, in radians, to rotate<br>);<br>　　<br>　　图12.3<br>例如，假如我们想绕向量（0.707, 0.707, 0）轴旋转π/2角度。我们可以这样写：<br>D3DXMATRIX R;<br>D3DXVECTOR3 axis(0.707f, 0.707f, 0.0f);<br>D3DXMatrixRotationAxis(&amp;R, &amp;axis, D3DX_PI / 2.0f);<br>D3DXMatrixRotationAxis的变换矩阵的来源你可以在Eric Lengyel的 Mathematics for 3D Game Programming &amp;Computer Graphics中找到。<br>12.2.3 Pitch、Yaw和Roll<br>因为方向向量描述了摄像机相对于世界坐标系的方向，我们必须考虑在使用倾斜（pitch）、偏航（yaw）和滚转（roll）时及时更新方向向量。这其实也是非常简单的。图12.4，12.5，12.6分别显示了摄像机的倾斜、偏航和滚转操作。</p>
<p>图12.4</p>
<p>图12.5</p>
<p>图12.6<br>当倾斜（pitch）时，我们需要将up和look向量绕着right向量旋转一定角度。同样的，当偏航（yaw）时，我们需要将look和right向量绕着up向量旋转一定角度。最后，当滚转（roll）时，我们需要将up和right向量绕着look向量旋转一定角度。<br>　　我们现在明白了为什么D3DXMatrixRotationAxis函数是非常必要的，因为这三个向量中的任何一个都可能围绕世界坐标系中的任意轴旋转。<br>　　对于倾斜（pitch）、偏航（yaw）和滚转（roll）的执行我们已经讨论了。然而，对于LANDOBJECT模式就有一些限制。我们在偏航（yaw）方法中只围绕y轴旋转，我们完全屏蔽滚转（roll）。当然你可以根据你的程序需要来改变Camera类。我们这里只是一个示例而已。<br>倾斜（pitch）、偏航（yaw）和滚转（roll）方法代码的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Camera::pitch(<span class="keyword">float</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    D3DXMATRIX T;</span><br><span class="line">    D3DXMatrixRotationAxis(&amp;T, &amp;_right, angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate _up and _look around _right vector</span></span><br><span class="line">    D3DXVec3TransformCoord(&amp;_up,&amp;_up, &amp;T);</span><br><span class="line">    D3DXVec3TransformCoord(&amp;_look,&amp;_look, &amp;T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Camera::yaw(<span class="keyword">float</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    D3DXMATRIX T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate around world y (0, 1, 0) always for land object</span></span><br><span class="line">    <span class="keyword">if</span>( _cameraType == LANDOBJECT )</span><br><span class="line">        D3DXMatrixRotationY(&amp;T, angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate around own up vector for aircraft</span></span><br><span class="line">    <span class="keyword">if</span>( _cameraType == AIRCRAFT )</span><br><span class="line">        D3DXMatrixRotationAxis(&amp;T, &amp;_up, angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate _right and _look around _up or y-axis</span></span><br><span class="line">    D3DXVec3TransformCoord(&amp;_right,&amp;_right, &amp;T);</span><br><span class="line">    D3DXVec3TransformCoord(&amp;_look,&amp;_look, &amp;T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Camera::roll(<span class="keyword">float</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// only roll for aircraft type</span></span><br><span class="line">    <span class="keyword">if</span>( _cameraType == AIRCRAFT )</span><br><span class="line">    &#123;</span><br><span class="line">        D3DXMATRIX T;</span><br><span class="line">        D3DXMatrixRotationAxis(&amp;T, &amp;_look,  angle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rotate _up and _right around _look vector</span></span><br><span class="line">        D3DXVec3TransformCoord(&amp;_right,&amp;_right, &amp;T);</span><br><span class="line">        D3DXVec3TransformCoord(&amp;_up,&amp;_up, &amp;T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>12.2.4 Walking、Strafing和Flying<br>当提到walking时，我们的意思是在我们观察的方向上移动位置（也就是说，沿着look向量）。Strafing是说在我们观察方向的左右移动，也就是沿着right向量移动。最后，我们说flying就是沿着up向量移动。为了沿着这些轴移动，我们只需要简单地加一个向量就可以了（如图12.7）。</p>
<p>图12.7<br>就象旋转一样，我们需要对移动作一些限制。例如，LANDOBJECT不允许飞起来。因此我们把移动限制在xz平面。然而，因为LANDOBJECT能够允许爬楼梯和登山，所以，我们设置Camera::setPosition方法，它允许你手动设置你的摄像机位置来达到你的高度和位置。<br>    移动（walk）、平移（strafe）和飞行（fly）方法代码的具体实现如下：<br>void Camera::walk(float units)<br>{<br>    // move only on xz plane for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos += D3DXVECTOR3(_look.x, 0.0f, _look.z) <em> units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _look </em> units;<br>}<br>void Camera::strafe(float units)<br>{<br>    // move only on xz plane for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos += D3DXVECTOR3(_right.x, 0.0f, _right.z) <em> units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _right </em> units;<br>}<br>void Camera::fly(float units)<br>{<br>    // move only on y-axis for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos.y += units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _up * units;<br>}<br>12.3实例程序：摄像机<br>　　这一章的实例程序是创建和渲染一个如图12.8所示的场景。你能够通过键盘输入在场景中自由地飞行。下面是相应键盘设置：</p>
<ul>
<li>W/S—向前/向后移动</li>
<li>A/D—向左/向右平移</li>
<li>R/F—向上/向下飞行</li>
<li>Up/Down方向键—倾斜</li>
<li>Left/Right方向键—偏航</li>
<li>N/M—滚转</li>
</ul>
<p>图12.8<br>　　例子的执行是非常简单的，因为所有工作都包含在摄像机类中了，这些我们都已经讨论过了。我们在Display函数中获得键盘的输入。记住，我们在全局域中实例化了一个摄像机类对象TheCamera。同样注意我们使用时间变化量来控制移动摄像机；这可以排除帧速度的影响而稳定地移动。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Update: Update the camera.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'W'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.walk(<span class="number">4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'S'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.walk(<span class="number">-4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'A'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.strafe(<span class="number">-4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'D'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.strafe(<span class="number">4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'R'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.fly(<span class="number">4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'F'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.fly(<span class="number">-4.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_UP) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.pitch(<span class="number">1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_DOWN) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.pitch(<span class="number">-1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_LEFT) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.yaw(<span class="number">-1.0f</span> * timeDelta);           </span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(VK_RIGHT) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.yaw(<span class="number">1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'N'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.roll(<span class="number">1.0f</span> * timeDelta);</span><br><span class="line">        <span class="keyword">if</span>( ::GetAsyncKeyState(<span class="string">'M'</span>) &amp; <span class="number">0x8000f</span> )</span><br><span class="line">            TheCamera.roll(<span class="number">-1.0f</span> * timeDelta);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the view matrix representing the cameras </span></span><br><span class="line">        <span class="comment">// new position/orientation.</span></span><br><span class="line">        D3DXMATRIX V;</span><br><span class="line">        TheCamera.getViewMatrix(&amp;V);</span><br><span class="line">        Device-&gt;SetTransform(D3DTS_VIEW, &amp;V);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Render</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, <span class="number">0x00000000</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line">        d3d::DrawBasicScene(Device, <span class="number">1.0f</span>);</span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：我们已经用一个新的函数DrawBasicScene更新了d3d名称空间。这个函数绘制了如图12.8的场景。我们已经将其添加进了d3d名称空间，这是因为对于建立一个基本的场景它是一个非常方便的函数。以后的例子我们就可以集中精力在例子代码中而不需要关注这些不相关的绘制场景的代码了。它是在d3dUtility.h中被声明的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function references "desert.bmp" internally.  This file must</span></span><br><span class="line"><span class="comment">// be in the working directory.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DrawBasicScene</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IDirect3DDevice9* device,<span class="comment">// Pass in 0 for cleanup.</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> scale)</span></span>;            <span class="comment">// uniform scale</span></span><br></pre></td></tr></table></figure></p>
<p>如果该函数不能任何东西也就是什么都显示不出来，你就需要看看相应的代码了。你可以在本章的代码中找到它。注意这个函数需要调用一张desert.bmp图片用作纹理。当然该文件也可以在同一个文件夹下找到。<br>12.4 摘要<br>   我们以四个向量来描述在世界坐标系中照相机的位置和方向：right、up、look、position向量，藉由这个描述, 我们能轻易的实现一个自由的六角度照相机，为游戏中的模拟飞行器、第一人称视角的游戏玩家提供了一个灵活的照相机接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Meshes-Part-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Meshes-Part-I/" class="post-title-link" itemprop="url">第十章 网格模型I(Meshes Part I)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:14:46" itemprop="dateCreated datePublished" datetime="2019-04-11T15:14:46+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="几何信息"><a href="#几何信息" class="headerlink" title="几何信息"></a>几何信息</h1><p>ID3DXBaseMesh接口包含一个用来存储网格顶点的顶点缓存和一个用来定义这些顶点怎样连接在一起组成网格三角形的索引缓存。我们能够通过使用下面的方法来得到这些缓存的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXMesh::GetVertexBuffer(LPDIRECT3DVERTEXBUFFER9* ppVB);</span><br><span class="line">HRESULT ID3DXMesh::GetIndexBuffer(LPDIRECT3DINDEXBUFFER9* ppIB);</span><br></pre></td></tr></table></figure></p>
<p>这里有一些使用这些方法的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDirect3DVertexBuffer9* vb = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;GetVertexBuffer( &amp;vb );</span><br><span class="line">IDirect3DIndexBuffer9* ib = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;GetIndexBuffer( &amp;ib );</span><br></pre></td></tr></table></figure></p>
<p>假如想锁定这些缓存来读写数据，那么我们能够使用下面的方法。注意这些方法锁定整个顶点/索引缓存。<br>HRESULT ID3DXMesh::LockVertexBuffer(DWORD Flags, BYTE<strong> ppData);<br>HRESULT ID3DXMesh::LockIndexBuffer(DWORD Flags, BYTE</strong> ppData);<br>Flags参数描述怎样锁定它。这些Flags参数在第三章中我们介绍过。ppData是函数返回的指向锁定内存的指针的地址。<br>　　当然在你锁定以后一定要记得解锁：<br>HRESULT ID3DXMesh::UnlockVertexBuffer();<br>HRESULT ID3DXMesh::UnlockIndexBuffer();<br>　　下面是另外一些与mesh几何结构有关的ID3DXMesh接口方法：</p>
<ul>
<li>DWORD GetFVF() — 返回顶点的格式</li>
<li>DWORD GetNumVertices() — 返回顶点缓存中的顶点数</li>
<li>DWORD GetNumBytesPerVertex() — 返回一个顶点所占的字节数</li>
<li>DWORD GetNumFaces() — 返回在mesh中的面（三角形）数<br>10.2 子集和属性缓存<br>　　一个mesh由一个或数个子集组成。一个子集（subset）是在mesh中的使用相同属性渲染的一组三角形。这里的属性是指材质，纹理和渲染状态。图10.1显示了一座房子mesh可能被分成的几个子集。<br>　　<br>图10.1<br>我们通过给每个子集指定一个唯一非负整数来标识子集。这个值可以是存储在一个DWORD中的任意数值。例如，在图10.1中我们用0，1，2和3来标识子集。<br>　　在mesh中的每个三角形都与一个属性ID相关联，表示该三角形属于该子集。例如，图10.1中组成地板的三角形具有属性ID0，它表示这些三角形属于子集0。同样，组成墙的三角形具有属性ID1，它表示这些三角形属于子集1。<br>　　三角形的属性ID存储在mesh的属性缓存中，它是一个DWORD数组。因为每个面对应属性缓存中的一项，所以属性缓存中的项目数等于mesh中的面的个数。属性缓存中的项目和索引缓存中定义的三角形一一对应。即，属性缓存中的第i项和索引缓存中的第i个三角形相对应。三角形i由下面三个索引缓存中的索引项定义：<br>　　A = i <em> 3<br>　　B = i </em> 3 + 1<br>　　C = i * 3 + 2<br>图10.2显示了这个对应关系：</li>
</ul>
<p>图10.2<br>　　我们可以锁定属性缓存，就象下面的代码片段：<br>DWORD* buffer = 0;<br>Mesh-&gt;LockAttributeBuffer(lockingFlags, &amp;buffer);<br>// Read or write to attribute buffer…<br>Mesh-&gt;UnlockAttributeBuffer();<br>10.3 绘制<br>　　ID3DXMesh接口提供了DrawSubset（DWORD AttribId）方法来绘制AttribId指示的子集中的各个三角形。例如，要绘制子集0中的所有三角形，我们将这样写：<br>Mesh-&gt;DrawSubset(0);<br>　　为了绘制整个mesh，我们必须绘制mesh的所有子集。这是非常方便的用0，1，2，…，n-1来标识子集，这里的n是子集的总数。且有一个相对应的材质和纹理数组，即子集i与材质和纹理数组的第i项对应。这就使我们能够简单的用循环来渲染mesh：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numSubsets; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Device-&gt;SetMaterial( mtrls[i] );</span><br><span class="line">    Device-&gt;SetTexture( <span class="number">0</span>, textures[i] );</span><br><span class="line">    Mesh-&gt;DrawSubset(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10.4 优化<br>　　Mesh的顶点和索引能够被重组以便能更有效的渲染mesh。当我们这样做时，我们说我们优化了一个mesh。我们可以使用下面的方法来进行优化：<br>HRESULT ID3DXMesh::OptimizeInplace(<br>    DWORD Flags,<br>    CONST DWORD<em> pAdjacencyIn,<br>    DWORD</em> pAdjacencyOut,<br>    DWORD<em> pFaceRemap,<br>    LPD3DXBUFFER</em> ppVertexRemap<br>);</p>
<ul>
<li>Flags — 表示执行什么类型的优化方法。它可以是下面的一个或几个的组合：</li>
<li>D3DXMESHOPT_COMPACT — 从mesh中移除没有用的顶点和索引项。</li>
<li>D3DXMESHOPT_ATTRSORT — 根据属性给三角形排序并调整属性表，这将使DrawSubset执行更有效（参见10.5节）。</li>
<li>D3DXMESHOPT_VERTEXCACHE — 增加顶点缓存的命中率。</li>
<li>D3DXMESHOPT_STRIPREORDER — 重组顶点索引使三角带尽可能的长。</li>
<li>D3DXMESHOPT_IGNOREVERTS — 只优化索引信息；忽略顶点信息。<br>注意：D3DXMESHOPT_VERTEXCACHE和D3DXMESHOPT_STRIPREORDER不能同时使用。</li>
<li>pAdjacencyIn — 指向没有优化的mesh的邻接数组。</li>
<li>pAdjacencyOut — 指向一个DWORD数组，它被用来填充优化好了的mesh邻接信息。该数组必须有ID3DXMesh::GetNumFaces() * 3个元素。如果不需要该信息，可以将其设置为0。</li>
<li>pFaceRemap —指向一个DWORD数组，它被用来填充面重影射信息。该数组必须不小于ID3DXMesh::GetNumFaces()。当一个mesh被优化时，由索引缓存定义的面可能被移动；也就是说，在pFaceRemap中的第i项表示第i个原始面被移动到的面索引值。如果不需要该信息，可以将其设置为0。</li>
<li>ppVertexRemap — 指向ID3DXBuffer指针的地址（参见11.1节），它被用来填充顶点重影射信息。这个缓存应该包含ID3DXMesh::GetNumVertices()个顶点。当一个mesh被优化后，顶点可能被移动。顶点重影射信息用来说明原来的顶点被移动到新位置；也就是说，在ppVertexRemap中的第i项表示原来的第i个顶点的新位置。如果不需要该信息，可以将其设置为0。<br>　　例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the adjacency info of the non-optimized mesh.</span></span><br><span class="line">DWORD adjacencyInfo[Mesh-&gt;GetNumFaces() * <span class="number">3</span>];</span><br><span class="line">Mesh-&gt;GenerateAdjacency(<span class="number">0.0f</span>, adjacencyInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array to hold optimized adjacency info.</span></span><br><span class="line">DWORD optimizedAdjacencyInfo[Mesh-&gt;GetNumFaces() * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">Mesh-&gt;OptimizeInplace(</span><br><span class="line">    D3DXMESHOPT_ATTRSORT |</span><br><span class="line">    D3DXMESHOPT_COMPACT |</span><br><span class="line">    D3DXMESHOPT_VERTEXCACHE,</span><br><span class="line">    adjacencyInfo,</span><br><span class="line">    optimizedAdjacencyInfo,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>);</span><br><span class="line">　　一个更简单的方法是Optimize方法，它输出一个优化的mesh，而不是在原来mesh的基础上进行优化：</span><br><span class="line">HRESULT ID3DXMesh::Optimize(</span><br><span class="line">    DWORD Flags,</span><br><span class="line">    CONST DWORD* pAdjacencyIn,</span><br><span class="line">    DWORD* pAdjacencyOut,</span><br><span class="line">    DWORD* pFaceRemap,</span><br><span class="line">    LPD3DXBUFFER* ppVertexRemap,</span><br><span class="line">    LPD3DXMESH* ppOptMesh <span class="comment">// the optimized mesh to be output</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>10.5 属性表<br>　　当一个mesh被使用D3DXMESHOPT_ATTRSORT参数来优化后，mesh的几何信息将按照属性进行排序，这样各个子集的顶点/索引将组成连续的块（如图10.3）。</p>
<p>图10.3<br>　　除了进行几何信息的排序外，D3DXMESHOPT_ATTRSORT优化项还将创建一个属性表。该表是D3DXATTRIBUTERANGE结构的一个数组。在属性表中的每一项对应mesh的一个子集并指示顶点/索引缓存中的一个连续连续内存块，这个子集的几何信息就包含在这个块中。D3DXATTRIBUTERANGE结构的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">D3DXATTRIBUTERANGE</span> &#123;</span></span><br><span class="line">    DWORD AttribId;</span><br><span class="line">    DWORD FaceStart;</span><br><span class="line">    DWORD FaceCount;</span><br><span class="line">    DWORD VertexStart;</span><br><span class="line">    DWORD VertexCount;</span><br><span class="line">&#125; D3DXATTRIBUTERANGE;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>AttribId — 子集的ID。</li>
<li>FaceStart — 该子集的面的起始值，FaceStart*3就是起始三角形在索引缓存中的序号。</li>
<li>FaceCount — 在子集中的面（三角形）数。</li>
<li>VertexStart — 该子集的起始顶点在顶点缓存中的序号。</li>
<li>VertexCount — 在子集中的顶点数。<br>　　我们能够很容易的明白D3DXATTRIBUTERANGE结构的各个成员，如图10.3。在图10.3中mesh的属性表有三项——它们和各个子集一一对应。<br>　　建立了属性表以后，渲染一个子集就很容易了。仅仅查一下属性表就能找出自己的几何信息。注意如果没有属性表，每渲染一个子集就需要对属性缓存进行一次线性搜索来找出子集包含的几何信息。<br>　　可以使用下面的方法来访问mesh的属性表：<br>HRESULT ID3DXMesh::GetAttributeTable(<br>  D3DXATTRIBUTERANGE<em> pAttribTable,<br>  DWORD</em> pAttribTableSize<br>);<br>　　这个方法能够做两件事情：它可以返回属性表的属性数，也可以用属性数据来填充一个D3DXATTRIBUTERANGE结构数组。<br>　　要得到属性表的元素个数，可以就将第一个参数设置为0：<br>DWORD numSubsets = 0;<br>Mesh-&gt;GetAttributeTable(0, &amp;numSubsets);<br>　　一旦我们知道了属性表的元素个数，我们就能够通过写属性表来填充一个D3DXATTRIBUTERANGE结构数组：<br>D3DXATTRIBUTERANGE table = new D3DXATTRIBUTERANGE [numSubsets];<br>Mesh-&gt;GetAttributeTable( table, &amp;numSubsets );<br>　　我们能够使用ID3DXMesh::SetAttributeTable方法来直接设置属性表。下面的代码就是设置一个有12个子集的属性表：<br>D3DXATTRIBUTERANGE attributeTable[12];<br>// …fill attributeTable array with data<br>Mesh-&gt;SetAttributeTable( attributeTable, 12);<br>10.6 邻接信息<br>　　对于mesh的某些操作，如优化，有必要了解的是三角形之间的邻接信息。Mesh的邻接数组存储了这些信息。<br>　　邻接数组是一个DWORD数组，其中的每一项对应了mesh中的一个三角形。例如，第i项对应的三角形由以下三个索引值定义：<br>A = i ??3<br>B = i ??3 + 1<br>C = i ??3 + 2<br>注意，使用ULONG_MAX = 4294967295表示该边没有邻接三角形。我们也可以用-1来表示，因为-1转换成DWORD就是ULONG_MAX。回想一下，DWORD就是一个unsigned32-bit整数。<br>　　因为每个三角形都有三条边，所以他就有三个邻接三角形（如图10.4）。<br>　　<br>　　图10.4<br>　　因此，邻接数组必须有三项（ID3DXBaseMesh::GetNumFaces()<em>3）—— 在mesh中每个三角形都可能有三个邻接三角形。<br>　　很多D3Dxmesh创造函数都能输出邻接信息，但我们也可以使用下面的方法：<br>HRESULT ID3DXMesh::GenerateAdjacency(<br>  FLOAT fEpsilon,<br>  DWORD</em> pAdjacency<br>);</li>
<li>fEpsilon — 指示当两个点距离有多近时，可以认为是一个点。当两点间的距离小于epsilon时，可认为它们是同一个点。</li>
<li><p>pAdjacency — 一个指向填充了邻接信息的DWORD数组指针。<br>　　例子：<br>DWORD adjacencyInfo[Mesh-&gt;GetNumFaces() * 3];<br>Mesh-&gt;GenerateAdjacency(0.001f, adjacencyInfo);<br>10.7 复制<br>　　有时我们需要将一个mesh中的数据拷贝到另一个之中。我们可以使用ID3DXBaseMesh::CloneMeshFVF方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXMesh::CloneMeshFVF(</span><br><span class="line">    DWORD Options,</span><br><span class="line">    DWORD FVF,</span><br><span class="line">    LPDIRECT3DDEVICE9 pDevice,</span><br><span class="line">    LPD3DXMESH* ppCloneMesh</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Options — 用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</p>
</li>
<li>D3DXMESH_32BIT — mesh使用32位索引。</li>
<li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li>
<li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li>
<li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li>
<li>FVF — 创建复制mesh的灵活顶点格式。</li>
<li>pDevice — 与复制mesh有关的设备。</li>
<li>ppCloneMesh — 输出复制的mesh。<br>　　注意这个方法允许指定与原mesh不同的options和FVF。例如我们有顶点格式为D3DFVF_XYZ的mesh，现在想复制一个顶点格式为D3DFVF_XYZ|D3DFVF_NORMAL的mesh。我们可以这样写：<br>// 假设_mesh和device是有效的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID3DXMesh* clone = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;CloneMeshFVF(</span><br><span class="line">    Mesh-&gt;GetOptions(), <span class="comment">// 使用与源模型同样的选项</span></span><br><span class="line">    D3DFVF_XYZ | D3DFVF_NORMAL,<span class="comment">// 指定克隆的FVF</span></span><br><span class="line">    Device,</span><br><span class="line">    &amp;clone</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>10.8 创建一个Mesh（D3DXCreateMeshFVF）<br>　　我们可以使用D3DXCreate*函数来创建mesh物体。然而，我们也可以使用  D3DXCreateMeshFVF函数来创建一个空mesh。所谓空mesh是指我们已经指定了顶点数和面数，函数D3DXCreateMeshFVF也分配了适当大小的内存给顶点、顶点索引、属性缓冲区。有了这些缓冲区后，就可以手动填写上下文数据了（需要分别向顶点缓存，索引缓存、属性缓存提供顶点、索引、属性数据）。<br>　　我们使用D3DXCreateMeshFVF函数来创建空mesh：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateMeshFVF</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumFaces,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumVertices,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD Options,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD FVF,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXMESH* ppMesh</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>NumFaces — mesh将拥有的面数。该值必须大于0。</li>
<li>NumVertices — mesh将拥有的顶点数。该值必须大于0。</li>
<li>Options —用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</li>
<li>D3DXMESH_32BIT — mesh使用32位索引。</li>
<li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li>
<li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li>
<li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li>
<li>FVF — mesh的顶点格式。</li>
<li>pDevice — 与mesh相关的设备。</li>
<li>ppMesh — 输出创建好的mesh。<br>　　下一节将给出实例程序，它演示了用这个函数怎样创建一个mesh以及手动填充mesh的数据内容。<br>　　另外，你也可以使用D3DXCreateMesh来创建空mesh。它的原型是：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateMesh</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumFaces,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD NumVertices,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD Options,</span></span></span><br><span class="line"><span class="function"><span class="params">    CONST LPD3DVERTEXELEMENT9* pDeclaration,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXMESH* ppMesh</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　这些参数和D3DXCreateMeshFVF的参数是非常相似的，除了第四个。作为替代指定的FVF，我们指定一个D3DVERTEXELEMENT9结构，它描述了顶点格式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXDeclaratorFromFVF</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD FVF, <span class="comment">// input format</span></span></span></span><br><span class="line"><span class="function"><span class="params">    D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]<span class="comment">//output format</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意：D3DVERTEXELEMENT9将在第17章中讨论。<br>　　这个函数通过输入一个FVF返回一个D3DVERTEXELEMENT9结构的数组。注意MAX_FVF_DECL_SIZE的定义如下：<br>typedef enum {<br>    MAX_FVF_DECL_SIZE = 18<br>} MAX_FVF_DECL_SIZE;<br>10.9 实例程序：创建和渲染Mesh<br>这一章的实例程序是渲染一个立方体（如图10.5）</p>
<p>图10.5<br>它演示了这一章中的大部分功能，包括如下一些操作：</p>
<ul>
<li>创建一个空mesh。</li>
<li>用一个立方体几何信息来填充mesh。</li>
<li>根据mesh的每个面指定子集。</li>
<li>产生mesh的邻接信息。</li>
<li>优化mesh。</li>
<li>绘制mesh。<br>　　注意，我们忽略一些无关的代码来讨论本例。你能在叫做D3DXCreateMeshFVF的例子中找到全部的代码。<br>　　另外，为了更容易调试和研究mesh的构成，我们执行如下的函数来将内在内容放进文件中：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpVertices</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpIndices</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAttributeBuffer</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAdjacencyBuffer</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAttributeTable</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　这些函数的名字就显示了它们的功能。执行这些函数是非常简单的，我们在这里讨论时忽略它们（可以看程序的原代码）。在这一节我们只展示一个dumpAttributeTable函数。<br>　　我们首先来浏览一下该例子，看看如下的一些全局变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ID3DXMesh* Mesh = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> DWORD NumSubsets = <span class="number">3</span>;</span><br><span class="line">IDirect3DTexture9* Textures[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">// texture for each subset</span></span><br><span class="line"><span class="built_in">std</span>::ofstream OutFile; <span class="comment">// used to dump mesh data to file</span></span><br></pre></td></tr></table></figure></p>
<p>　　这里我们定义了一个mesh对象的指针，我们以后要创建的。我们也定义了mesh拥有的子集数——三。在这个例子中，每个子集都用一个不同的纹理来渲染；纹理数组包含每个子集的纹理，如第i个纹理对应mesh的第i个子集。最后，Outfile变量被用来把mesh的内容输出为一个文本文件。<br>　　这个例子的大部分工作是在setup函数中进行。我们首先创建一个空的mesh：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HRESULT hr = <span class="number">0</span>;</span><br><span class="line">    hr = D3DXCreateMeshFVF(</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">24</span>,</span><br><span class="line">        D3DXMESH_MANAGED,</span><br><span class="line">        Vertex::FVF,</span><br><span class="line">        Device,</span><br><span class="line">         &amp;Mesh);</span><br></pre></td></tr></table></figure></p>
<p>这里我们分配一个有12个面和24个顶点的mesh，这是描述一个盒子所必须的。<br>　　这样的话，mesh是空的，因此我们需要将组成盒子的顶点和索引分别写入顶点缓存和索引缓存。锁定顶点/索引缓存并手动写入数据这是很容易的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill in vertices of a box</span></span><br><span class="line">Vertex* v = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;LockVertexBuffer(<span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v);</span><br><span class="line"><span class="comment">// fill in the front face vertex data</span></span><br><span class="line">v[<span class="number">0</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">1</span>] = Vertex(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">v[<span class="number">22</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">v[<span class="number">23</span>] = Vertex( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">Mesh-&gt;UnlockVertexBuffer();</span><br><span class="line"><span class="comment">// Define the triangles of the box</span></span><br><span class="line">WORD* i = <span class="number">0</span>;</span><br><span class="line">Mesh-&gt;LockIndexBuffer(<span class="number">0</span>, (<span class="keyword">void</span>**)&amp;i);</span><br><span class="line"><span class="comment">// fill in the front face index data</span></span><br><span class="line">i[<span class="number">0</span>] = <span class="number">0</span>; i[<span class="number">1</span>] = <span class="number">1</span>; i[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">i[<span class="number">3</span>] = <span class="number">0</span>; i[<span class="number">4</span>] = <span class="number">2</span>; i[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill in the right face index data</span></span><br><span class="line">i[<span class="number">30</span>] = <span class="number">20</span>; i[<span class="number">31</span>] = <span class="number">21</span>; i[<span class="number">32</span>] = <span class="number">22</span>;</span><br><span class="line">i[<span class="number">33</span>] = <span class="number">20</span>; i[<span class="number">34</span>] = <span class="number">22</span>; i[<span class="number">35</span>] = <span class="number">23</span>;</span><br><span class="line">Mesh-&gt;UnlockIndexBuffer();</span><br></pre></td></tr></table></figure></p>
<p>　　一旦mesh的几何信息被写入，我们必须指定每个三角形在哪个子集中。回想一下属性缓存就是存储的在mesh中每个三角形所属的子集信息。在这个例子中，我们指定索引缓存中的前四个三角形子集为0，接着的四个三角形子集为1，最后四个三角形子集为2。代码如下：<br>DWORD<em> attributeBuffer = 0;<br>Mesh-&gt;LockAttributeBuffer(0, &amp;attributeBuffer);<br>for(int a = 0; a &lt; 4; a++) // triangles 1-4<br>    attributeBuffer[a] = 0; // subset 0<br>for(int b = 4; b &lt; 8; b++) // triangles 5-8<br>    attributeBuffer[b] = 1; // subset 1<br>for(int c = 8; c &lt; 12; c++) // triangles 9-12<br>    attributeBuffer[c] = 2; // subset 2<br>Mesh-&gt;UnlockAttributeBuffer();<br>　　现在我们已经创建了一个包含有效数据的mesh。在这一小部分我们将渲染mesh，不过首先还是先将其优化一下。注意虽然这对于一个盒子mesh来说，优化mesh数据没有真正的效果，但是我们还是用ID3DXMesh接口方法来实践一下。为了优化一个mesh，我们首先需要计算mesh的邻接信息：<br>std::vector<dword> adjacencyBuffer(Mesh-&gt;GetNumFaces() </dword></em> 3);<br>Mesh-&gt;GenerateAdjacency(0.0f, &amp;adjacencyBuffer[0]);<br>　　然后我们就能够优化mesh了：<br>hr = Mesh-&gt;OptimizeInplace(<br>        D3DXMESHOPT_ATTRSORT |<br>        D3DXMESHOPT_COMPACT |<br>        D3DXMESHOPT_VERTEXCACHE,<br>        &amp;adjacencyBuffer[0],<br>         0, 0, 0);<br>　　设置好了mesh以后，我们就为渲染它做好了准备。不过在setup函数中还有最后一个问题，也就是在前面我们说的将mesh的内在数据内容写入文件的函数。这能够检查mesh的数据，它能帮助我们调试和学习mesh的结构。<br>OutFile.open(“Mesh Dump.txt”);<br>dumpVertices(OutFile, Mesh);<br>dumpIndices(OutFile, Mesh);<br>dumpAttributeTable(OutFile, Mesh);<br>dumpAttributeBuffer(OutFile, Mesh);<br>dumpAdjacencyBuffer(OutFile, Mesh);<br>OutFile.close();<br>…Texturing loading, setting render states, etc., snipped<br>return true;<br>} // end Setup()<br>　　例如，dumpAttributeTable函数将属性表的数据写入文件。它的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpAttributeTable</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; outFile, ID3DXMesh* mesh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outFile &lt;&lt; <span class="string">"Attribute Table:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// number of entries in the attribute table</span></span><br><span class="line">    DWORD numEntries = <span class="number">0</span>;</span><br><span class="line">    mesh-&gt;GetAttributeTable(<span class="number">0</span>, &amp;numEntries);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;D3DXATTRIBUTERANGE&gt; table(numEntries);</span><br><span class="line">    mesh-&gt;GetAttributeTable(&amp;table[<span class="number">0</span>], &amp;numEntries);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numEntries; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Entry "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Subset ID: "</span> &lt;&lt; table[i].AttribId &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Face Start: "</span> &lt;&lt; table[i].FaceStart &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Face Count: "</span> &lt;&lt; table[i].FaceCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Vertex Start: "</span> &lt;&lt; table[i].VertexStart &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="string">"Vertex Count: "</span> &lt;&lt; table[i].VertexCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        outFile &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outFile &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的文本文件来自于通过dumpAttributeTable函数得到的mesh Dump.txt文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Attribute Table:</span><br><span class="line">----------------</span><br><span class="line">Entry 0</span><br><span class="line">------------</span><br><span class="line">Subset ID: 0</span><br><span class="line">Face Start: 0</span><br><span class="line">Face Count: 4</span><br><span class="line">Vertex Start: 0</span><br><span class="line">Vertex Count: 8</span><br><span class="line">Entry 1</span><br><span class="line">------------</span><br><span class="line">Subset ID: 1</span><br><span class="line">Face Start: 4</span><br><span class="line">Face Count: 4</span><br><span class="line">Vertex Start: 8</span><br><span class="line">Vertex Count: 8</span><br><span class="line">Entry 2</span><br><span class="line">------------</span><br><span class="line">Subset ID: 2</span><br><span class="line">Face Start: 8</span><br><span class="line">Face Count: 4</span><br><span class="line">Vertex Start: 16</span><br><span class="line">Vertex Count: 8</span><br></pre></td></tr></table></figure></p>
<p>我们能够了解到我们为mesh所指定的相匹配的数据——有三个子集且每个子集有4个三角形。建议你去看看本例子Dump.txt的完整信息。该文件在本示例文件目录下。<br>最后，我们使用下面的代码就能够非常容易地渲染mesh了；我们只需要循环每个子集，设置相关联的纹理然后在绘制子集即可。这是非常容易的，因为我们已经为每个子集指定的下标如0，1，2，…，n-1，这里的n就是子集的个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...update frame code snipped</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,<span class="number">0x00000000</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumSubsets; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Device-&gt;SetTexture( <span class="number">0</span>, Textures[i] );</span><br><span class="line">            Mesh-&gt;DrawSubset( i );</span><br><span class="line">        &#125;</span><br><span class="line">        Device-&gt;EndScene();</span><br><span class="line">        Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Fonts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Fonts/" class="post-title-link" itemprop="url">第九章 字体(Fonts)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:12:44" itemprop="dateCreated datePublished" datetime="2019-04-11T15:12:44+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ID3DXFont"><a href="#ID3DXFont" class="headerlink" title="ID3DXFont"></a>ID3DXFont</h1><p>在D3DX库中提供了一个ID3DXFont接口，它能被用于在Direct3D应用程序中绘制文字。这个接口是使用GDI来绘制文字的，因此我们能够使用这个接口来执行这个操作。无论如何，因为ID3DXFont使用的是GUI，所以它能够联合字体句柄和格式化字体。</p>
<h2 id="创建一个ID3DXFont"><a href="#创建一个ID3DXFont" class="headerlink" title="创建一个ID3DXFont"></a>创建一个ID3DXFont</h2><p>　　我们能够使用D3DXCreateFontIndirect函数来创建一个ID3DXFont接口。<br>HRESULT D3DXCreateFontIndirect(<br>    LPDIRECT3DDEVICE9 pDevice, // device to be associated with the font<br>    CONST LOGFONT<em> pLogFont, // LOGFONT structure describing the font<br>    LPD3DXFONT</em> ppFont // return the created font<br>);<br>　　下面的代码片段显示了怎样使用这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LOGFONT lf;</span><br><span class="line">ZeroMemory(&amp;lf, <span class="keyword">sizeof</span>(LOGFONT));</span><br><span class="line">lf.lfHeight = <span class="number">25</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWidth = <span class="number">12</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWeight = <span class="number">500</span>; <span class="comment">// boldness, range 0(light) - 1000(bold)</span></span><br><span class="line">lf.lfItalic = <span class="literal">false</span>;</span><br><span class="line">lf.lfUnderline = <span class="literal">false</span>;</span><br><span class="line">lf.lfStrikeOut = <span class="literal">false</span>;</span><br><span class="line">lf.lfCharSet = DEFAULT_CHARSET;</span><br><span class="line"><span class="built_in">strcpy</span>(lf.lfFaceName, <span class="string">"Times New Roman"</span>); <span class="comment">// font style</span></span><br><span class="line">ID3DXFont* font = <span class="number">0</span>;</span><br><span class="line">D3DXCreateFontIndirect(Device, &amp;lf, &amp;font);</span><br><span class="line">　　我们必须填充一个LOGFONT结构来描述想创建的字体类型。</span><br><span class="line">　　注意：你也能够使用D3DXCreateFont函数来获得一个ID3DXFont接口指针。</span><br><span class="line"><span class="number">9.1</span><span class="number">.2</span>绘制文本</span><br><span class="line">　　一旦我们获得了ID3DXFont接口指针，绘制文本就是很简单的事情了，我们只要调用ID3DXFont::DrawText方法就可以实现了。</span><br><span class="line">INT ID3DXFont::DrawText(</span><br><span class="line">    LPCSTR pString,</span><br><span class="line">    INT Count,</span><br><span class="line">    LPRECT pRect,</span><br><span class="line">    DWORD Format,</span><br><span class="line">    D3DCOLOR Color</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>pString — 指向要绘制的文字。</li>
<li>Count — 字符串中特征字符的数量。假如字符是以null结束的字符串则可将其指定为-1。</li>
<li>pRect — 指向一个RECT结构，它定义一个文字被绘制在屏幕上的范围。</li>
<li>Format — 可选参数，指定文字怎样被格式化；要获得更详细的信息请查看SDK文档。</li>
<li>Color — 文字的颜色。<br>　　例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Font-&gt;DrawText(</span><br><span class="line">    <span class="string">"Hello World"</span>, <span class="comment">// String to draw.</span></span><br><span class="line">    <span class="number">-1</span>, <span class="comment">// Null terminating string.</span></span><br><span class="line">    &amp;rect, <span class="comment">// Rectangle to draw the string in.</span></span><br><span class="line">    DT_TOP | DT_LEFT, <span class="comment">// Draw in top-left corner of rect.</span></span><br><span class="line">     <span class="number">0xff000000</span></span><br><span class="line">     ); <span class="comment">// Black.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>9.1.3计算每秒的渲染帧数<br>　　这一章的ID3DXFont和Cfont例子是计算和显示每秒渲染的帧数（FPS）。这一部分说明怎样计算FPS。<br>　　首先，我们定义如下三个全局变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD FrameCnt; <span class="comment">// The number of frames that have occurred.</span></span><br><span class="line"><span class="keyword">float</span> TimeElapsed; <span class="comment">// The time that has elapsed so far.</span></span><br><span class="line"><span class="keyword">float</span> FPS; <span class="comment">// The frames rendered per second.</span></span><br></pre></td></tr></table></figure></p>
<p>　　我们计算每一秒的FPS；它给我们一个很好的平均。另外，在同一秒中内只保存一个FPS，这给了我们足够时间来读取它，在它再一次改变之前。<br>　　因此每一帧我们增加FrameCnt并且把从上一帧到现在流逝的时间写进TimeElapsed：<br>FrameCnt++;<br>TimeElapsed += timeDelta;<br>这里timeDelta是两帧之间的时间。<br>　　    在一秒种结束以后，我们能够用下面的公式来计算FPS：<br>FPS = (float)FrameCnt / TimeElapsed;<br>我们从新设置FrameCnt和TimeElapsed为计算下一秒的FPS做准备。下面就是合在一起的代码：<br>void CalcFPS(float timeDelta)<br>{<br>    FrameCnt++;<br>    TimeElapsed += timeDelta;<br>    if(TimeElapsed &gt;= 1.0f)<br>    {<br>        FPS = (float)FrameCnt / TimeElapsed;<br>        TimeElapsed = 0.0f;<br>        FrameCnt = 0;<br>    }<br>}<br>9.2 CD3DFont<br>　　DirectX SDK给我们提供了一些很有用的代码，它们在你的DXSDK目录下的\Samples\C++\Commond下。CD3DFont类代码是使用纹理三角形和Direct3D。因为CD3DFont使用Direct3D代替GDI来渲染， 这比ID3DXFont快的多。然而，CD3DFont不能够联合字体句柄和格式化ID3DXFont。假如你追求速度和只需要一些简单的字体，CD3DFont类就能满足你的要求了。<br>　　使用CD3DFont类，你需要添加下列文件到你的程序中：d3dfont.h, d3dfont.cpp, d3dutil.h, d3dutil.cpp, dxutil.h和dxutil.cpp。这些文件可以在刚才所说目录下的Include和Src目录下。<br>9.2.1创建一个CD3DFont<br>　　为了创建一个CD3DFont实例，我们只需要简单地象一般的C++对象那样实例化就可以了；下面是它的构造原型：<br>CD3DFont(const TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags=0L);</p>
<ul>
<li>strFontName — 以null结束的字符串，它指定字体类型。</li>
<li>dwHeight — 字体的高度。</li>
<li>dwFlags — 可选参数；你能设置该参数为0或者用下面参数；D3DFONT_BOLD, D3DFONT_ITALIC, D3DFONT_ZENABLE。<br>　　实例化一个CD3DFont对象以后，我们必须调用下面的方法来初始化字体：<br>Font = new CD3DFont(“Times New Roman”, 16, 0); // instantiate<br>Font-&gt;InitDeviceObjects( Device );<br>Font-&gt;RestoreDeviceObjects();<br>9.2.2绘制文本<br>　　现在我们已经创建和初始化了一个CD3DFont对象，这已经为绘制文字做好了准备。绘制文字是使用下面的方法：<br>HRESULT CD3DFont::DrawText(FLOAT x, FLOAT y, DWORD dwColor,<br>  const TCHAR* strText, DWORD dwFlags=0L);</li>
<li>x — 文字在屏幕上开始绘制的x坐标。</li>
<li>y —文字在屏幕上开始绘制的y坐标。 </li>
<li>dwColor — 文字的颜色。</li>
<li>strText — 要绘制的文字。</li>
<li>dwFlags — 可选参数；你能设置该参数为0或者用下面参数；D3DFONT_CENTERED, D3DFONT_TWOSIDED, D3DFONT_FILTERED。<br>　　例子：<br>   Font-&gt;DrawText(20, 20, 0xff000000, “Hello, World”);<br>9.2.3 清除<br>　　在删除一个CD3DFont对象之前，我们必须首先调用一些清除程序，就象下面列举的代码片段：<br>Font-&gt;InvalidateDeviceObjects();<br>Font-&gt;DeleteDeviceObjects();<br>delete Font;<br>9.3 D3DXCreateText<br>　　最后的函数是被用来创建一个3D 文字网格。图9.1显示了本章FontMes3D实例渲染的3D文字网格。</li>
</ul>
<p>图9.1<br>　　该函数的原型是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    HDC hDC,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pText,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT Deviation,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT Extrusion,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXMESH* ppMesh,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPD3DXBUFFER* ppAdjacency,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPGLYPHMETRICSFLOAT pGlyphMetrics</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个函数如果调用成功则返回D3D_OK。</p>
<ul>
<li>pDevice — 和mesh关联的device。</li>
<li>hDC — 我们将要用来产生mesh的包含描述字体的设备环境句柄。 </li>
<li>pText — 指向以null结束的字符串的指针，此字符串是用来指定创建什么文字mesh。</li>
<li>Deviation — 字型轮廓段数间距。该值必须大于等于0。当它为0时，段数等于字体原始设计单位（该值越接近0，那么字体就越光滑）。</li>
<li>Extrusion — 文字在z轴方向的深度。</li>
<li>ppMesh — 返回创建的mesh。</li>
<li>ppAdjacency — 返回创建mesh的相关信息。假如你不需要它可以将其指定为null。</li>
<li>pGlyphMetrics — 一个指向LPGLYPHMETRICSFLOAT结构数组的指针，它包含了字型米数据。假如你不关心此数据，你可以把它设置为0。<br>　　 下面的示例代码展示的是使用这个函数来创建一个文字3D 网格模型。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtain a handle to a device context.</span></span><br><span class="line">HDC hdc = CreateCompatibleDC( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill out a LOGFONT structure that describes the font’s properties.</span></span><br><span class="line">LOGFONT lf;</span><br><span class="line">ZeroMemory(&amp;lf, <span class="keyword">sizeof</span>(LOGFONT));</span><br><span class="line"></span><br><span class="line">lf.lfHeight = <span class="number">25</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWidth = <span class="number">12</span>; <span class="comment">// in logical units</span></span><br><span class="line">lf.lfWeight = <span class="number">500</span>; <span class="comment">// boldness, range 0(light) - 1000(bold)</span></span><br><span class="line">lf.lfItalic = <span class="literal">false</span>;</span><br><span class="line">lf.lfUnderline = <span class="literal">false</span>;</span><br><span class="line">lf.lfStrikeOut = <span class="literal">false</span>;</span><br><span class="line">lf.lfCharSet = DEFAULT_CHARSET;</span><br><span class="line"><span class="built_in">strcpy</span>(lf.lfFaceName, <span class="string">"Times New Roman"</span>); <span class="comment">// font style</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a font and select that font with the device context.</span></span><br><span class="line">HFONT hFont;</span><br><span class="line">HFONT hFontOld;</span><br><span class="line">hFont = CreateFontIndirect(&amp;lf);</span><br><span class="line">hFontOld = (HFONT)SelectObject(hdc, hFont);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the 3D mesh of text.</span></span><br><span class="line">ID3DXMesh* Text = <span class="number">0</span>;</span><br><span class="line">D3DXCreateText(_device, hdc, <span class="string">"Direct3D"</span>, <span class="number">0.001f</span>, <span class="number">0.4f</span>, &amp;Text, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reselect the old font, and free resources.</span></span><br><span class="line">SelectObject(hdc, hFontOld);</span><br><span class="line">DeleteObject( hFont );</span><br><span class="line">DeleteDC( hdc );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在你便能简单地调用mesh的DrawSubset方法来渲染一个3D文字：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text-&gt;DrawSubset(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
