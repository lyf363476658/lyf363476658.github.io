<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/12/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/12/RTR-4th-Chapter2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/12/RTR-4th-Chapter2/" class="post-title-link" itemprop="url">RTR 4th Chapter2 图形渲染管线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-12 23:14:20" itemprop="dateCreated datePublished" datetime="2019-04-12T23:14:20+08:00">2019-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RTR-4th/" itemprop="url" rel="index"><span itemprop="name">RTR-4th</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/12/RTR-4th-Chapter2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/12/RTR-4th-Chapter2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>整个渲染流水线的目标是实时地通过一个虚拟的camera，把光源，3D物体（包括上面的纹理）等渲染到2D图像上，流水线是并行化执行的，但是会出现stall，直到流水线中最慢的一个阶段完成它的任务<br>整条流水线的架构，主要依次分为四个阶段：<br>Application,Geometry Processing,Rasterization和Pixel Processing</p>
<p><div align="center"><img src="/2019/04/12/RTR-4th-Chapter2/1.jpg"></div><br>每个阶段内部也有自己的pipeline的。<br>我们要区别“阶段（functional stage）”和具体的实现结构，也就是说具体的某个实现结合可能合并了几个stage的内容到一个单元（unit），使得其过程时间消耗更短。</p>
<h1 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>Application阶段主要是在CPU上完成的，可以利用现代CPU的多和特性进行多线程优化，这一部分通常包括碰撞检测，全局加速算法，动画，物理模拟等待，这些取决于application的类型。<br>Geometry Processing阶段主要处理转换（transforms），投影（projections）等等其他所有类型的几何操作，这个阶段计算了什么将会被渲染，怎样被渲染，在哪里被渲染，主要在GPU上完成。<br>Rasterization阶段一般接受三个顶点，构建出一个三角形，找到所有被这个三角形包含着的像素点，然后把这些像素点传递给Pixel Processing阶段，这部分完全在GPU上完成。<br>Pixel Processing阶段执行逐像素的程序，计算每个像素的color，也许会进行Z-Test等进行可见性判断，也许会进行blend操作等，这部分也完全在GPU上完成。</p>
<h1 id="具体介绍每个阶段"><a href="#具体介绍每个阶段" class="headerlink" title="具体介绍每个阶段"></a>具体介绍每个阶段</h1><h2 id="Application-Stage"><a href="#Application-Stage" class="headerlink" title="Application Stage"></a>Application Stage</h2><p>这部分是开发者完全控制的阶段，因为这部分通常是基于CPU执行的，对于这部分的改变会影响后续阶段的performance（比如这里可以通过算法减低要被渲染的三角形的数量）但是现在在这部分平台上也可以使用计算着色器来借GPU的力量加速。这个阶段的最后，渲染图元（点、线、三角形）传入到Geometry Procssing阶段。<br>这个部分是不能被分割成子部分的，因为这个是基于软件的实现方式，我们最多只能借助CPU的多核编写多线程程序来提升性能<br>这个阶段也是用来处理外接设备的输入，两个物体的碰撞检测，加速算法（比如部分剔除算法）</p>
<h2 id="Geometry-Processing"><a href="#Geometry-Processing" class="headerlink" title="Geometry Processing"></a>Geometry Processing</h2><p>用来负责逐三角形和逐顶点的操作。这部分可以被分为4个阶段：Vertex Shading，Projection，Clipping和Screen Mapping，下面逐一介绍：<br>Vertex Shading：这个子阶段主要处理两个任务：1.计算顶点位置 2.计算每个顶点包含的其他性质，如发现，纹理坐标等<br>以前会在这里实现逐顶点的光照，所以叫顶点着色器，现在顶点着色器变成了一个更加通用的用来设定与操作每个顶点相关的数据的计算单元（比如可以实现顶点动画等）<br>这个阶段同时是转换坐标的阶段，把坐标从模型空间转换到世界空间，为了便于后续的投影和裁剪，在使用view transform转换到相机空间，同时保存每个顶点对应的material，normal等信息，接下来把它转换到一个单位(-1,-1,-1)(1,1,1)中进行投影（z也可能是[0,1]），首先是进行投影，投影可分为正交投影和透视投影，在进行顶点着色器的操作<br>这个子阶段的输出（包含颜色，纹理坐标等）被送到Rasterization和Pixel Processing阶段被插值，用来计算表面的shading，这一步结束后，z-轴坐标不再存储在image中，而是z-buffer内，也就是说，这一步把3D-&gt;2D。</p>
<p>Optional Vertex Processing：这个阶段是可选的，而且不同的GPU对这部分的硬件支持程度也是不同的。简单来说依次是曲面细分，几何着色和流输出。</p>
<p>Clipping：只有那些全部部分在view volume中的渲染图元才能够pass这个阶段进入后续的阶段，使用投影矩阵意味着把transform后的图元裁剪单位立方体中。</p>
<img src="/2019/04/12/RTR-4th-Chapter2/2.jpg">
<p>Screen Mapping：把还是3D的坐标转换成屏幕坐标（屏幕坐标原点取决于API）</p>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>目标：找到所有被渲染图元包含或覆盖的像素点<br>这部分分为两个部分：三角形建立和三角形遍历。把2D的顶点在屏幕空间转换到屏幕上的像素，在这里，三角形通过传入的3个点得以简历，最后把所有图元的像素点传递到Pixel Processing中。这个阶段通常是由硬件实现的。</p>
<h2 id="Pixel-Processing"><a href="#Pixel-Processing" class="headerlink" title="Pixel Processing"></a>Pixel Processing</h2><p>这个阶段通常分为2个子阶段，分别是Pixel Shading和Mergeing<br>Pixel Shading：所有逐像素的计算都在这里完成，这里的输入是通过shading data的插值得到的。这里是基本上完全可编程的，通过自定义片元着色器（或者叫像素着色器）在GPU上完成光照，纹理等计算<br>Mergeing：每个像素存储来一个叫颜色缓冲的地方，我们需要一个Merge阶段处理片元着色器出来的颜色和buffer中本来存着的颜色之间的关系，这部分也用来负责可见性问题（使用z-buffer算法）<br>模版缓冲是一个离屏缓冲用来记录渲染图元的位置，每个像素通常为8bit，可以用来控制后续图元的渲染情况（通过模版测试的方式）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/unity-render-optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/unity-render-optimize/" class="post-title-link" itemprop="url">Unity中的渲染优化技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 20:01:17" itemprop="dateCreated datePublished" datetime="2019-04-11T20:01:17+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/unity-render-optimize/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/unity-render-optimize/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="移动平台的特点"><a href="#移动平台的特点" class="headerlink" title="移动平台的特点"></a>移动平台的特点</h1><p>和PC平台相比，移动平台上的GPU架构有很大的不同。由于处理资源等条件的限制，移动设备上的GPU架构专注于尽可能使用更小的带宽和公共能，也由此带来许多和PC平台完全不同的现象。<br>例如，为了尽可能移除那些隐藏的表面，减少overdraw（即一个像素被绘制多次），PowerVR芯片（通常用于iOS设备和某些Android设备）使用了基于瓦片的延迟渲染（Tiled-based Deffered Rendering，TBDR）架构，把所有的渲染图像装入一个个瓦片（tile）中，再由硬件找到可见的片元，而只有这些可见片元才会执行片元着色器。另一些基于瓦片的GPU架构，如Adreno（高通的芯片）和Mali（ARM的芯片）则会使用Early-Z或相似的技术进行一个低精度的深度检测，来剔除那些不需要渲染的片元。还有一些GPU，如Tegra（英伟达的芯片），则使用了传统的架构设计，因为在这些设备上，overdraw更可能造成性能的瓶颈。<br>由于这些芯片架构造成的不同，一些游戏往往需要针对不通的芯片发布不同的版本，以便对每个芯片进行更有针对性的优化。尤其是在Android平台上，不通设备使用的硬件，如图形芯片、屏幕分辨率等，大相径庭，这对图形优化提出了更高的挑战。相比于Android平台，iOS平台的硬件条件则相对统一。</p>
<h1 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h1><p>首先，在学习如何优化之前，我们得先了解影响游戏性能的因素有哪些。对于一个游戏来说，它主要需要使用两种计算资源：CPU和GPU。它们会互相合作，来让我们的游戏可以在预期的帧率和分辨率下工作。其中，CPU主要负责保证帧率，GPU主要负责分辨率相关的一些处理。<br>据此，可以把造成游戏性能瓶颈的主要原因分成以下几个方面。</p>
<ol>
<li>CPU<ul>
<li>过多的draw call</li>
<li>复杂的脚本或者物理模拟</li>
</ul>
</li>
<li>GPU<ul>
<li>顶点处理<ul>
<li>过多的顶点</li>
<li>过多的逐顶点计算</li>
</ul>
</li>
<li>片元处理<ul>
<li>过多的片元（既可能是由于分辨率造成的，也可能是由于overdraw造成的）。</li>
<li>过多的逐片元计算。</li>
</ul>
</li>
</ul>
</li>
<li>带宽<ul>
<li>使用了尺寸很大且未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ul>
</li>
</ol>
<p>对于CPU来说，限制它的主要是每一帧draw call的数目。简单来说，就是CPU在每次通知GPU进行渲染之前，都需要提前准备好顶点数据（如位置、法线、颜色、纹理坐标等），然后调用一系列API把它们放到GPU可以访问到的指定位置，最后，调用一个绘制命令，来告诉GPU。而调用一次绘制命令的时候，就会产生一个draw call。过多的draw call会造成CPU的性能瓶颈，这是因为每次调用draw call时，CPU往往都需要改变很多渲染状态的设置，而这些操作是非常耗时的。如果一帧中需要的draw call数目过多的话，就会导致CPU把大部分时间都花费在提交draw call的工作上面了。当然，其他原因也可能造成CPU瓶颈，例如物理、布料模拟、蒙皮、粒子模拟等，这些都是计算量很大的操作。<br>而对于GPU来说，它负责整个渲染流水线。它从处理CPU传递过来的模拟数据开始，进行顶点着色器、片元着色器等一系列工作，最后输出屏幕上的每个像素。因此，GPU的性能瓶颈和需要处理的顶点数目、屏幕分辨率、显存等因素有关。而相关的优化策略可以减少处理的数据（包括顶点数目和片元数目）、减少运算复杂度等方面入手。</p>
<ol>
<li>CPU优化<ul>
<li>使用批处理技术减少draw call数目</li>
</ul>
</li>
<li>GPU优化<ul>
<li>减少需要处理的顶点数目。<ul>
<li>优化几何体</li>
<li>使用模型的LOD（Level of Detail）技术</li>
<li>使用遮挡剔除（Ovvlusion Culling）技术</li>
</ul>
</li>
<li>减少需要处理的片元数目<ul>
<li>控制绘制顺序</li>
<li>警惕透明物体</li>
<li>减少实时光照</li>
</ul>
</li>
<li>减少计算复杂度<ul>
<li>使用Shader的LOD（Level Of Deail）技术</li>
<li>代码方面的优化</li>
</ul>
</li>
<li>节省内存带宽<ul>
<li>减少纹理大小</li>
<li>利用分辨率缩放</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在开始优化之前，我们首先需要知道是哪个步骤造成了性能瓶颈。而这可以利用Unity提供的一些渲染分析工具来实现。</p>
<h1 id="Unity中的渲染分析工具"><a href="#Unity中的渲染分析工具" class="headerlink" title="Unity中的渲染分析工具"></a>Unity中的渲染分析工具</h1><p>Unity内置了一些工具，来帮助我们方便地查看和渲染相关的各个统计数据。这些数据可以帮助我们分析游戏渲染性能，从而更有针对性的进行优化。这些工具包括了渲染统计窗口（Rendering Statistics Window）、性能分析器（Profiler），以及帧调试器（Frame Debugger）。需要注意的是，在不同的目标平台上，这些工具中显示的数据也会发生变化。</p>
<h2 id="渲染统计窗口"><a href="#渲染统计窗口" class="headerlink" title="渲染统计窗口"></a>渲染统计窗口</h2><p>渲染统计窗口主要包含了音频（Audio）、图像（Graphics）。这里我们只关心图像相关的渲染统计结果。<br>渲染统计窗口中显示了很多重要的渲染数据，例如FPS、批处理数目、顶点和三角网格的数目等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信息名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>每帧的时间和FPS</td>
<td>在Graphic的右侧显示，给出了处理和渲染一帧所需的时间，以及FPS数目</td>
</tr>
<tr>
<td>Batches</td>
<td>一帧中需要进行的批处理数目</td>
</tr>
<tr>
<td>Saved by batching</td>
<td>合并的批处理数目，这个数字表明了批处理为我们节省了多少的draw call</td>
</tr>
<tr>
<td>Tris和Verts</td>
<td>需要绘制的三角面片和顶点数目</td>
</tr>
<tr>
<td>Screen</td>
<td>屏幕的大小，以及它占用的内存大小</td>
</tr>
<tr>
<td>SetPass calls</td>
<td>渲染使用的Pass的数目，每个Pass都需要Unity的runtime来绑定一个新的Shader，这可能造成CPU瓶颈</td>
</tr>
<tr>
<td>Shadow casters</td>
<td>场景中有多少可以投射阴影的物体，一般这些物体都作为场景中光源</td>
</tr>
<tr>
<td>visible skinned meshed</td>
<td>渲染皮肤网格的数量</td>
</tr>
<tr>
<td>animations</td>
<td>正在播放动画的数量</td>
</tr>
</tbody>
</table>
</div>
<h2 id="性能分析器的渲染区域"><a href="#性能分析器的渲染区域" class="headerlink" title="性能分析器的渲染区域"></a>性能分析器的渲染区域</h2><img src="/2019/04/11/unity-render-optimize/1.jpg">
<p>性能分析器显示了绝大部分在渲染统计窗口中提供的信息，例如，绿线显示了批处理数目、蓝线显示了Pass数目等，同时还给出了许多其他非常有用的信息，例如，draw call数目、动态批处理/静态批处理的数目、渲染纹理的数目和内存占用等。<br>结合渲染统计窗口和性能分析器，我们可以查看与渲染相关的绝大多数重要的数据。一个值得注意的想象是，性能分析器给出的draw call数目和批处理数目、Pass数目并不相等，并且看起来好像要大于我们估算的数目，这是因为Unity在背后需要进行很多工作，例如，初始化各个缓存、为阴影更新深度纹理和阴影映射纹理等，因此需要花费比“预期”更多的draw call。</p>
<h2 id="帧调试器"><a href="#帧调试器" class="headerlink" title="帧调试器"></a>帧调试器</h2><p><div align="center"><img src="/2019/04/11/unity-render-optimize/2.jpg"></div><br>帧调试器的调试面板上显示了渲染这一帧锁需要的所有的渲染时间，在本例中，事件数目为41，而其中包含了36个draw call事件（其他渲染时间多为清空缓存等）。通过单击面板上的每个事件，我们可以在Game视图查看该时间的绘制结果，同时渲染统计面上的数据也会显示成截至当前事件为止的各个渲染统计数据。</p>
<h2 id="其他性能分析工具"><a href="#其他性能分析工具" class="headerlink" title="其他性能分析工具"></a>其他性能分析工具</h2><p>对于Android平台来说，高通的Adreno分析工具可以对不同的测试机进行详细的性能分析。英伟达提供的NVPerfHUD工具来帮助我们得到几乎所有需要的性能分析数据，例如，每个draw call的GPU时间，每个shader话费的cycle数目等。<br>对于iOS平台来说，Unity内置的分析器可以得到整个场景的花费的GPU时间。PowerVRaw的PVRUniSCo shader分析器也可以给出一个大致的性能评估。Xcode中的OpenGL ES Driver Instruments可以给出一些宏观上的性能信息，例如，设备利用率、渲染器利用率等。但相对于Android平台，对iOS的性能分析更加困难（工具较少）。而且PowerVR芯片采用了基于瓦片的延迟渲染器，因此，想要得到每个draw call话费的GPU时间是几乎不可能的。这是，一些宏观上统计数据可能更有参考价值。</p>
<h1 id="减少draw-call数目"><a href="#减少draw-call数目" class="headerlink" title="减少draw call数目"></a>减少draw call数目</h1><p>批处理的实现原理就是为了减少每一帧需要的draw call数目。为了把一个对象渲染到屏幕上，</p>
<h4 id="动态批处理"><a href="#动态批处理" class="headerlink" title="动态批处理"></a>动态批处理</h4><p>基本原理：每一帧把可以进行批处理的模型网格进行合并，再把合并后的模型数据传递给GPU，然后使用同一个材质对其渲染。动态批处理的一个好处是实现方便，另一个好处是，经过批处理的物体仍然可以移动，这是由于在处理每帧时Unity都会重新合并一次网格。</p>
<p>条件限制：</p>
<ul>
<li>能够进行动态批处理的网格的顶点属性规模要小于900。例如，如果shader中需要使用顶点位置、发现和纹理坐标这3个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。</li>
<li>多Pass的shader会中断批处理。在前向渲染中，我们有时需要使用额外的Pass来为模型添加更多的光照效果，但这样一来模型就不会被动态批处理了。</li>
</ul>
<h4 id="静态批处理"><a href="#静态批处理" class="headerlink" title="静态批处理"></a>静态批处理</h4><p>Unity提供了另一种批处理方式，即静态批处理。相比于动态批处理来说，静态批处理适用于任何大小的几何模式。它的实现原理是，只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网络结构中，这意味着这些模型不可以在运行时刻被移动。但由于它只需要进行一次合并操作，因此，比动态批处理更加高效。静态批处理的另一个缺点在与，它往往需要占用更多的内存来存储合并后的几何结构。这是因为，如果在静态批处理钱一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品，即一个网格会变成多个网格在发送给GPU。如果这类使用同一网格的对象很多，那么这就会成为一个性能瓶颈了。例如，如果在一个使用了1000个相同模型的森林中使用静态批处理，那么，就会多使用1000倍的内存，这会造成严重的内存影响。</p>
<h4 id="共享材质"><a href="#共享材质" class="headerlink" title="共享材质"></a>共享材质</h4><p>无论是静态批处理还是动态批处理，都要求模型之间需要共享同一个材质。但不同的模型之间总会需要有不同的渲染属性，例如，使用不同的纹理、颜色等。这是，我们需要一些策略来尽可能地合并材质。<br>如果两个材质之间只有使用的纹理不同，我们可以把这些纹理合并到一张更大的纹理中，这张更大的纹理被称为是一张图集（atlas）。一旦使用了同一张纹理，我们就可以使用同一个材质，再使用不同的采样坐标对纹理采样即可。<br>但有时，除了纹理不同外，不同的物体在材质上还有一些微小的参数变化，例如，颜色不同、某些浮点属性不同。但是，不管是动态批处理还是静态批处理，它们的前提都是要使用同一个材质。是同一个，而不是使用了同一种Shader的材质，也就是说它们指向的材质必须是同一个实体。这意味着，只要我们调整了参数，就会影响所有使用这个材质的对象，那么想要微小的调整怎么办？一种常用的方法就是使用网格的顶点（最常见的就是顶点颜色数据）来存储这些参数。经过批处理后的物体会被处理成更大的VBO发送给GPU，VBO中的数据可以作为输入传递给顶点着色器，因此，我们可以巧妙地对VBO中的数据进行控制，从而达到不通效果的目的。一个例子是，森林场景中所有的树使用了同一种材质，我们希望它们可以通过批处理来减少draw call，但不同树的颜色可能不同。这么，我们可以利用网格的顶点的颜色数据来调整。</p>
<h4 id="批处理的注意事项"><a href="#批处理的注意事项" class="headerlink" title="批处理的注意事项"></a>批处理的注意事项</h4><h3 id="减少需要处理的顶点数目"><a href="#减少需要处理的顶点数目" class="headerlink" title="减少需要处理的顶点数目"></a>减少需要处理的顶点数目</h3><h4 id="优化几何体"><a href="#优化几何体" class="headerlink" title="优化几何体"></a>优化几何体</h4><p>移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离。</p>
<h4 id="模型的LOD技术"><a href="#模型的LOD技术" class="headerlink" title="模型的LOD技术"></a>模型的LOD技术</h4><h4 id="遮挡剔除技术"><a href="#遮挡剔除技术" class="headerlink" title="遮挡剔除技术"></a>遮挡剔除技术</h4><h3 id="减少需要处理的片元数目"><a href="#减少需要处理的片元数目" class="headerlink" title="减少需要处理的片元数目"></a>减少需要处理的片元数目</h3><h4 id="控制绘制顺序"><a href="#控制绘制顺序" class="headerlink" title="控制绘制顺序"></a>控制绘制顺序</h4><h4 id="时刻警惕透明物体"><a href="#时刻警惕透明物体" class="headerlink" title="时刻警惕透明物体"></a>时刻警惕透明物体</h4><h4 id="减少实时光照和阴影"><a href="#减少实时光照和阴影" class="headerlink" title="减少实时光照和阴影"></a>减少实时光照和阴影</h4><h3 id="节省带宽"><a href="#节省带宽" class="headerlink" title="节省带宽"></a>节省带宽</h3><h4 id="减少纹理大小"><a href="#减少纹理大小" class="headerlink" title="减少纹理大小"></a>减少纹理大小</h4><ul>
<li>纹理的长宽比最好是正方形，长宽值最好是2的整数幂</li>
<li>多级渐远纹理技术（mipmapping）和纹理压缩。</li>
</ul>
<h4 id="利用分辨率缩放"><a href="#利用分辨率缩放" class="headerlink" title="利用分辨率缩放"></a>利用分辨率缩放</h4><h3 id="减少计算复杂度"><a href="#减少计算复杂度" class="headerlink" title="减少计算复杂度"></a>减少计算复杂度</h3><h4 id="Shader的LOD技术"><a href="#Shader的LOD技术" class="headerlink" title="Shader的LOD技术"></a>Shader的LOD技术</h4><h4 id="代码方面的优化"><a href="#代码方面的优化" class="headerlink" title="代码方面的优化"></a>代码方面的优化</h4><h4 id="根据硬件进行缩放"><a href="#根据硬件进行缩放" class="headerlink" title="根据硬件进行缩放"></a>根据硬件进行缩放</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/physics-base-render/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/physics-base-render/" class="post-title-link" itemprop="url">基于物理的渲染</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 16:58:13" itemprop="dateCreated datePublished" datetime="2019-04-11T16:58:13+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/physics-base-render/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/physics-base-render/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="双向反射分布函数（BRDF）"><a href="#双向反射分布函数（BRDF）" class="headerlink" title="双向反射分布函数（BRDF）"></a>双向反射分布函数（BRDF）</h2><p><strong>辐射率（radiance）</strong>是单位面积、单位方向上光源的辐射通量，通常用L表示，被认为是对单一光线的亮度和颜色评估。<font color="red">在渲染中，我们通常会基于表面的入射光线的入射辐射率 $ L<em>i  $ 来计算出射辐射率 $L</em>{0}$ ，这个过程往往也称为<strong>着色（shading）</strong>过程。</font><br>而要得到出射辐射率$L_{o}$，我们需要知道物体表面一点是如何和光进行交互的。而这个过程就可以使用<strong>BRDF（Bidirectional Reflectance Distribution Function，双向反射分布函数）</strong>来定量分析。在大多数情况下，BRDF可以用$f(I,v)$来表示，其中I为入射方向和v为观察方向（双向的含义）。这种情况下，绕着表面法线旋转入射方向或观察方向并不会影响BRDF的结果，这种BRDF被称为是<strong>各项同性（isotropic）</strong>的BRDF。与之对应的则是<strong>各项异性（anisotropic）</strong>的BRDF。</p>
<p>公式如下：</p>
<p>$L<em>{o}(p,w</em>{o}) = \int<em>\Omega(k</em>{d}{c \over \pi} + k<em>{s}{DGF \over 4(w</em>{o} \cdot n)(w<em>{i} \cdot n)})L</em>{i}(p,w<em>{i})(w</em>{i} \cdot n)dw_{i}$</p>
<p>这是PBR的核心，也是主要的劝退点。<br>翻译成自然语言，大概是这样的：</p>
<p>$输出颜色 = \int<em>\Omega(漫反射比例{纹理颜色 \over \pi} + 镜面反射比例{镜面高光 x 几何遮蔽 x 菲涅尔效应 \over 4(view</em>{Dir} \cdot normal)(lightDir \cdot normal)})光源颜色(lightDir,normal)dw_{i}$</p>
<p>先解释下这个公式遗留的部分。半球积分($\int<em>\Omega………dw</em>{i}$)</p>
<h3 id="放置反射探针"><a href="#放置反射探针" class="headerlink" title="放置反射探针"></a>放置反射探针</h3><p>在实时渲染中，我们经常会使用Cubemap来模拟物体的反射效果。例如，在赛车游戏中，我们需要对车身或车窗使用反射映射的技术来模拟它们的反光材质。然而，如果我们永远使用同一个Cubemap，那么，当赛车周围的场景发生较大变化时，就很容易出现“穿帮镜头”，因为车身或车窗的环境反射并没有随环境变化而变换。一种解决办法是可以在脚本中控制何时生成从当前位置观察到的Cubemap，Unity中提供了反射探针<strong>（Reflection Probes）</strong>。反射探针的工作原理和光照探针（Light Probes）类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity会把这些邻近探针存储的反射结果传递给物体使用的反射纹理。如果物体周围存在多个反射探针，Unity还会在这些反射之间进行插值，来得到平滑渐变的反射效果。实际上，Unity会在场景中放置一个默认的反射探针，这个反射探针粗怒触了对场景使用的Skybox的反射结果，来作为场景的环境光照。如果我们需要让场景中的物体包含额外的反射效果，就需要放置更多的反射探针。<br>反射探针同样有3种类型：Baked，这种类型的反射探针是通过提前烘培来得到该位置使用的Cubemap的，在游戏运行时反射探针中存储的Cubemap并不会发生变化。需要注意的是，这种类型的反射探针在烘培时同样只会处理那些静态物体（即那些被标志为Reflection Probe Static的物体）；Realtime，这种类型则会实时更新当前的Cubemap，并且不受静态物体还是动态物体的影响。当然，这种类型的反射探针需要花费更多的处理时间，因此，在使用时应当非常小心它们的性能。幸运的是，Unity允许我们从脚本中通过触发来精确控制反射探针的更新；最后一种类型是Custom，这种类型的探针即可以让我们从编辑器中烘培它，也可以让我们使用一个自定义的Cubemap来作为反射映射，但自定义的Cubemap不会被实时更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/The-Effects-Framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/The-Effects-Framework/" class="post-title-link" itemprop="url">第十九章 效果架构(The Effects Framework)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:35:43" itemprop="dateCreated datePublished" datetime="2019-04-11T15:35:43+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/The-Effects-Framework/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/The-Effects-Framework/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一个渲染效果一般由以下部分组成：一个顶点和/或像素着色器，一个需要设置的设备状态列表，一个或更多的渲染通道（rendering passes）。此外，有一个能在不同级别的图形硬件上渲染效果的可靠机制通常是值得的（也就是说，有不同的可用的效果版本执行同样的效果或尽可能尝试执行同样的效果）。显然，所有这些必要的任务组合在一起成为一个效果。因此，一个合理的做法是，设法将这些任务封装到一个单元中。<br>Direct3D效果构架提供了这样一个机制：将渲染效果的任务封装到一个效果文件。在效果文件中实现效果有两方面优势。其一，它允许我们不必重编译应用程序就能改变一个效果的执行。这是一种更新效果的过程，不管是修正一个bug，一些简单的加强，或者利用最新的3D硬件特性。第二，它将所有的效果组成部分封装到一个文件。<br>这一章指导你用必要信息和步骤，编写和创建一个效果文件的。我们注意到效果文件象我们的HLSL程序一样可以写在任何ASCII文件中。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>理解一个效果文件的结构和组织</li>
<li>找到HLSL中的一些额外的对象</li>
<li>学习如何在效果文件中指定设备状态</li>
<li>学习如何创建并使用一个效果</li>
<li>通过学习一些例子程序，取得使用效果框架上的一些经验<h1 id="技术与传递（Techniques-and-Passes）"><a href="#技术与传递（Techniques-and-Passes）" class="headerlink" title="技术与传递（Techniques and Passes）"></a>技术与传递（Techniques and Passes）</h1>一个效果文件由一个或多个技术组成。一个技术是用一个特殊的方法渲染一些特效。所以换句话说，一个效果文件提供了渲染相同特效的一个或多个不同的传递。为什么同样的效果需要几个不同实现呢？是的，一些硬件可能不支持一个效果的一种特定实现。因此，必需在不同硬件上实现相同效果的不同版本。<br>注意：例如，我们可能实现一种效果的两个版本，一种用着色器实现而一种用固定管线实现。这样，那些有着色器（shader）支持的显卡用户能够利用着色器实现，而那些不支持着色器的用户仍然可以使用固定管线实现。<br>可以在一个效果文件中实现所有版本的效果，这让我们更完整的封装了所有的效果，也是效果框架的目标之一 ―― 封装（encapsulation）。<br>每种技术包括一次或多次渲染传递（passes）。一次渲染传递（rendering pass）在特定传递（pass）中封装了设备状态、采样器、和/或用于渲染几何体的着色器。<br>注意：一个效果不仅限于可编程管线使用。例如，它可以使用固定功能管线控制设备状态，比如灯光、材质以及纹理。<br>使用多次传递（multiple passes）的理由是，因为对每种特效，是通过使用不同的设备状态、着色器等等，对同样的几何体进行多次渲染来完成的。举例来说，回忆第8章 ，我们不得不在每帧里用不同的设备状态、多次渲染相同的几何体，以达到反射效果。</li>
</ul>
<p>这个例子，是一个用两种技术实现的效果文件的框架，第一种技术包括一次传递而每二种技术包括两次传递:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// effect.txt</span></span><br><span class="line"></span><br><span class="line">technique T0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first and only pass for this technique</span></span><br><span class="line">    pass P0</span><br><span class="line">    &#123;</span><br><span class="line">        [specify pass device states, shaders, samplers, etc.]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">technique T1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first pass</span></span><br><span class="line">    pass P0</span><br><span class="line">    &#123;</span><br><span class="line">        [specify pass device states, shaders, samplers, etc.]</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// second pass</span></span><br><span class="line">    pass P1</span><br><span class="line">    &#123;</span><br><span class="line">        [specify pass device states, shaders, samplers, etc.]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更多HLSL内置对象（-More-HLSL-Intrinsic-Objects）"><a href="#更多HLSL内置对象（-More-HLSL-Intrinsic-Objects）" class="headerlink" title="更多HLSL内置对象（ More HLSL Intrinsic Objects）"></a>更多HLSL内置对象（ More HLSL Intrinsic Objects）</h2><p>这是一些在HLSL中额外的内建对象类型。我们以前没有过早的提及，是因为它们主要用于效果框架。</p>
<h3 id="纹理对象"><a href="#纹理对象" class="headerlink" title="纹理对象"></a>纹理对象</h3><p>   HLSL内建纹理类型描述了一个IDirect3DTexture9对象。通过使用纹理对象我们可以直接地在效果文件中对特定的采样器阶段结合纹理。纹理对象有下面的可以访问的数据成员：</p>
<ul>
<li>type—纹理类型 (例如：2D, 3D)</li>
<li>format—纹理的像素格式</li>
<li>width—纹理的宽度（单位像素）</li>
<li>height—纹理的高度（单位像素）</li>
<li>depth—纹理的深度（如果是3D纹理，单位像素）</li>
</ul>
<p>注意：迄今为止我们仅仅使用纹理来存贮图形数据，但是当你学到更高级的技术，你会发现纹理可用来保存任意表格信息。换句话说，纹理仅是数据表，不是必须包含图形数据。例如，在碰撞映射（bump mapping）时我们用到一种叫做法线图的东东（normal map），就是一种在每个点上包括了法向量的纹理。</p>
<h3 id="采样器对象与采样器状态"><a href="#采样器对象与采样器状态" class="headerlink" title="采样器对象与采样器状态"></a>采样器对象与采样器状态</h3><p>我们在18章讨论了采样器对象，然而，效果框架定义了新的关键字：sampler_state。使用sampler_state关键字，我们能初始化一个采样器对象（即，直接在效果方件中设置采样器对象的纹理和状态）。下面的例子说明了这点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Texture Tex;</span><br><span class="line">sampler SO = sampler_state</span><br><span class="line">&#123;</span><br><span class="line">     Texture = (Tex);  <span class="comment">// 纹理</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 采样器状态</span></span><br><span class="line">     MinFilter = LINEAR;</span><br><span class="line">     MagFilter = LINEAR;</span><br><span class="line">     MipFilter = LINEAR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>这里我们给采样器S0的texture成员关联了纹理 Tex，并给状态成员设置了采样状态。我们直接明了的在效果文件中设置所有信息。
</code></pre><h3 id="顶点与像素着色器对象（Vertex-and-Pixel-Shader-Objects）"><a href="#顶点与像素着色器对象（Vertex-and-Pixel-Shader-Objects）" class="headerlink" title="顶点与像素着色器对象（Vertex and Pixel Shader Objects）"></a>顶点与像素着色器对象（Vertex and Pixel Shader Objects）</h3><p>vertexshader 和 pixelshader是HLSL的内建类型，分别表示顶点着色器和像素着色器。它们在效果文件中表示特定顶点和/或像素着色器，用于一个特定的渲染传递(pass)。vertexshader和/或pixelshader类型在应用程序中用ID3DXEffect::SetVertexShader和ID3DXEffect::SetPixelShader函数分别设置。例如，在效果文件中，让Effect是一个有效的ID3DXEffect对象，让VS是一个有效的IDirect3DVertexShader9对象，以及让VSHandle是一个D3DXHANDLE（是vertexshader 对象的引用）。然后，我们可以通过如下写法初始化VSHandle所引用的顶点着色器：<br>Effect-&gt;SetVertexShader(VSHandle, VS);<br>当在应用程序中设置效果文件中的变量时，多数时候我们使用SetVertexShader 和 SetPixelShader。<br>做为选择，我们可以直接在效果文件中写顶点和/或像素着色器。当使用一种特定的编译语法时，我们可以设置一个着色器变量。下面的例子展示了如何初始化一个pixelshader类型的变量ps。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义入口函数</span></span><br><span class="line"><span class="function">OUTPUT <span class="title">Main</span><span class="params">(INPUT input)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译入口函数</span></span><br><span class="line">pixelshader ps = compile ps_2_0 Main();</span><br></pre></td></tr></table></figure></p>
<p>观察在pixelshader关键字之后的特定的版本名，接下来是着色器入口函数。注意，当用这种方式（style）初始化一个顶点或像素着色器对象时，入口函数必须定义在效果文件中。</p>
<p>最后，我们给一个特定传递关联一个着色器，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义入口函数</span></span><br><span class="line"><span class="function">OUTPUT <span class="title">Main</span><span class="params">(INPUT input)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译入口函数</span></span><br><span class="line">vertexshader vs = compile vs_2_0 Main();</span><br><span class="line"></span><br><span class="line">pass P0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 给这个传递（pass）关联一个着色器（vs）</span></span><br><span class="line">    vertexshader = (vs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者更简洁的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pass P0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置这个传递的顶点着色器，为入口函数" Main()"的顶点着色器</span></span><br><span class="line">    vertexshader = compile vs_2_0 Main();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：这是一个相当有价值的论述，因此你至少要明白，你能用这样的语法来初始化一个vertexshader 和 pixelshader 类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vertexshader vs = <span class="keyword">asm</span> &#123; <span class="comment">/*assembly instructions go here */</span> &#125;;</span><br><span class="line">pixelshader ps = <span class="keyword">asm</span> &#123; <span class="comment">/*assembly instructions go here */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果你用汇编语言来写着色器，你就用这种语法。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>最后，这是一个字符串对象，它的用法是这样地：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> filename = <span class="string">"texName.bmp"</span>;</span><br></pre></td></tr></table></figure></p>
<p>尽管没有任何HLSL的内建函数支持字符串类型，但它可以在应用程序中读取。这样，我们能进一步封装效果使用的数据文件，比如纹理文件名和X文件字。</p>
<h3 id="注解-Annotations"><a href="#注解-Annotations" class="headerlink" title="注解 (Annotations)"></a>注解 (Annotations)</h3><p>除我们已经描述过的语义符之外，注解可以用在变量上。注解在HLSL中是不使用的，但是它们可以被应用程序通过效果框架访问。它们仅仅服务于一个绑定 “note”的变量，这样应用程序就能够访问这个变量了。为注解加入了<annotation>语法。下面一行举例说明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texture tex0 &lt; <span class="built_in">string</span> name = <span class="string">"tiger.bmp"</span>; &gt;;</span><br></pre></td></tr></table></figure></annotation></p>
<p>在这个例子中的注解是<string name="tiger. bmp" ;>。它关联了一个字符串到变量tex0，即保存纹理数据的文件名。很明显，用相应的文件名注解一个纹理是有益的。<br>注解可以使用下面函数被重新得到：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D3DXHANDLE ID3DXEffect::GetAnnotationByName(</span><br><span class="line">     D3DXHANDLE hObject,</span><br><span class="line">     LPCSTR pName</span><br><span class="line">);</span><br></pre></td></tr></table></figure></string></p>
<p>pName是我们要操作的注解的名字，而hObject是注解所在的父块句柄，如一个technique、pass或者结构块。一旦我们有了一个注解的句柄，我们就能通过应用ID3DXEffect::GetParameterDesc得到有关它的信息。查看DirectX SDK文档以得到更多详细的内容。</p>
<h2 id="效果文件的设备状态（-Device-States-in-an-Effect-File）"><a href="#效果文件的设备状态（-Device-States-in-an-Effect-File）" class="headerlink" title="效果文件的设备状态（ Device States in an Effect File）"></a>效果文件的设备状态（ Device States in an Effect File）</h2><p>通常，为了正确执行一个效果，我们必须设置设备的状态，比如渲染状态、纹理状态、材质、灯光和纹理。将全部效果封装进一个文件使它有支持全部效果的能力，效果框架允许我们在效果文件中设置设备状态。设备状态被在渲染的传递部分（pass block）里设置，语法看起来象这样：<br>State= Value;<br>对于完整的状态的列表，在DirectX SDK文档的索引（index）中查找”states”，或者从SDK的目录（Contents）标签下，查找DirectX Graphics\Reference\Effect Reference\Effect Format\States<br>考虑FillMode状态。如果你看了一下刚刚提到的SDK中的内容，值与D3DFILLMODE一样，但没有D3DFILL_前缀。如果我们在SDK文档中查找D3DFILLMODE，我们找到值：D3DFILL_POINT, D3DFILL_WIREFRAME, and D3DFILL_SOLID。因而，对于效果文件我们省略了前缀，并获得下列状态FillMode的有效值：POINT, WIREFRAME, 和 SOLID。例如，你可以在效果文件中这么写-：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FillMode = WIREFRAME;</span><br><span class="line">FillMode = POINT;</span><br><span class="line">FillMode = SOLID;</span><br></pre></td></tr></table></figure></p>
<p>注意：在后面的小节中我们将在例子程序中设置几个设备状态。多数时候能够通过状态的名字猜到它的用途，但如果你想得到更详细的描述，请查看SDK文档。</p>
<h2 id="创建效果"><a href="#创建效果" class="headerlink" title="创建效果"></a>创建效果</h2><pre><code>效果用ID3DXEffect接口表示，我们用下面的D3DX函数创建它：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">D3DXCreateEffectFromFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     LPDIRECT3DDEVICE9 pDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPCSTR pSrcFile,</span></span></span><br><span class="line"><span class="function"><span class="params">     CONST D3DXMACRO* pDefines,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXINCLUDE pInclude,</span></span></span><br><span class="line"><span class="function"><span class="params">     DWORD Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXEFFECTPOOL pPool,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXEFFECT* ppEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">     LPD3DXBUFFER *ppCompilationErrors</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pDevice—被创建的ID3DXEffect对象所关联的设备</li>
<li>pSrcFile—我们要编译的包括效果源代码的文本文件的名字（效果文件名）</li>
<li>pDefines—这个参数是可选的，在本书中指定为null</li>
<li>pInclude—ID3DXInclude接口指针。这个接口被设计成由应用程序执行，因而我们可以替换默认行为。通常，默认行为就挺好，我们可以指定null忽略这个参数。</li>
<li>Flags—编译效果文件中的shader的选项标志，指定0为没有标志。有效选项为：<br>o D3DXSHADER_DEBUG—指示编译器写入调试信息<br>o D3DXSHADER_SKIPVALIDATION—指示编译器不做任何代码检测。这只在你正在用到一个已知正常工作的shader时使用。<br>o D3DXSHADER_SKIPOPTIMIZATION—指示编译器不执行任何优化。实际上这只用于调试时，当你不想让编译器对代码做任何更改时。</li>
<li>pPool—可选的ID3DXEffectPool接口指针，用于指定效果参数如何共享其它的效果实例。本例中指定null，表示我们不在参数与效果文件之间共享。</li>
<li>ppEffect—返回一个ID3DXEffect接口指针，表示被创建的效果。</li>
<li>ppCompilationErrors—返回一个包含错误代码字符串和消息的ID3DXBuffer指针。</li>
</ul>
<p>这是一个调用D3DXCreateEffectFromFile的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修建效果</span></span><br><span class="line">ID3DXEffect* Effect = <span class="number">0</span>;</span><br><span class="line">ID3DXBuffer* errorBuffer = <span class="number">0</span>;</span><br><span class="line">hr = D3DXCreateEffectFromFile(</span><br><span class="line">     Device,           <span class="comment">// 关联的设备</span></span><br><span class="line">     <span class="string">"effect.txt"</span>,     <span class="comment">// 效果源文件</span></span><br><span class="line">     <span class="number">0</span>,                <span class="comment">// no preprocessor definitions</span></span><br><span class="line">     <span class="number">0</span>,                <span class="comment">// no ID3DXInclude interface</span></span><br><span class="line">     D3DXSHADER DEBUG, <span class="comment">// 编译标记</span></span><br><span class="line">     <span class="number">0</span>,                <span class="comment">// 不共享参数</span></span><br><span class="line">     &amp;Effect,          <span class="comment">// 返回创建效果的指针</span></span><br><span class="line">     &amp;errorBuffer);    <span class="comment">// 返回的错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出错误信息</span></span><br><span class="line"><span class="keyword">if</span>( errorBuffer )</span><br><span class="line">&#123;</span><br><span class="line">     ::MessageBox(<span class="number">0</span>, (<span class="keyword">char</span>*)errorBuffer-&gt;GetBufferPointer(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">    ::MessageBox(<span class="number">0</span>, <span class="string">"D3DXCreateEffectFromFile() - FAILED"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="设置系数（Setting-Constants）"><a href="#设置系数（Setting-Constants）" class="headerlink" title="设置系数（Setting Constants）"></a>设置系数（Setting Constants）</h2><p>因为对于顶点和像素着色器，我们需要从程序代码中初始化效果文件中的变量。代替使用常量表，就象我们在顶点和像素着色器中做的那样，ID3DXEffect接口中有内建的设置变量的方法。我们这里不会列出所有的设置不同类型变量的方法，因为要完全列出实在是大多了—请查看DirectX SDK文档以获得完整列表。这里是一个删节的列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::SetFloat(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    FLOAT f</span><br><span class="line">);</span><br><span class="line">Sets a floating-point variable in the effect file identified by hParameter to the value f </span><br><span class="line">HRESULT ID3DXEffect::SetMatrix(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    CONST D3DXMATRIX* pMatrix</span><br><span class="line">);</span><br><span class="line">Sets a matrix variable in the effect file identified by hParameter to the value pointed to by pMatrix </span><br><span class="line">HRESULT ID3DXEffect::SetString(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    CONST LPCSTR pString</span><br><span class="line">);</span><br><span class="line">Sets a matrix variable in the effect file identified by hParameter to the value pointed to by pString </span><br><span class="line">HRESULT ID3DXEffect::SetTexture(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    LPDIRECT3DBASETEXTURE9 pTexture</span><br><span class="line">);</span><br><span class="line">Sets a texture variable in the effect file identified by hParameter to the value pointed to by pTexture </span><br><span class="line">HRESULT ID3DXEffect::SetVector(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    CONST D3DXVECTOR4* pVector</span><br><span class="line">);</span><br><span class="line">Sets a <span class="built_in">vector</span> variable in the effect file identified by hParameter to the value pointed to by pVector </span><br><span class="line">HRESULT ID3DXEffect::SetVertexShader(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    LPDIRECT3DVERTEXSHADER9</span><br><span class="line">      pVertexShader</span><br><span class="line">);</span><br><span class="line">Sets a vertex shader variable in the effect file identified by hParameter to the value pointed to by pVertexShader </span><br><span class="line">HRESULT ID3DXEffect::SetPixelShader(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    LPDIRECT3DPIXELSHADER9 pPShader</span><br><span class="line">);</span><br><span class="line">Sets a pixel shader variable in the effect file identified by hParameter to the value pointed to by pPShader</span><br></pre></td></tr></table></figure></p>
<p>我们通过下面的方法得到变量（又叫效果参数effect parameters）句柄：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D3DXHANDLE ID3DXEffect::GetParameterByName(</span><br><span class="line">    D3DXHANDLE hParent, <span class="comment">// scope of variable - parent structure</span></span><br><span class="line">    LPCSTR pName        <span class="comment">// name of variable</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>它的用法与D3DXConstantTable::GetConstantByName方法一样。即每一个参数是一个D3DXHANDLE，它标识我们想得到的在哪个父结构中的变量句柄。对于没有父结构的全局变量，我们指定null。第二个参数是在效果文件中所显示的变量名。<br>做为例子，以下显示如何设置效果文件中的一些变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some data to set</span></span><br><span class="line">D3DXMATRIX M;</span><br><span class="line">D3DXMatrixIdentity(&amp;M);</span><br><span class="line"></span><br><span class="line"><span class="function">D3DXVECTOR4 <span class="title">color</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">IDirect3DTexture9* tex = <span class="number">0</span>;</span><br><span class="line">D3DXCreateTextureFromFile(Device, <span class="string">"shade.bmp"</span>, &amp;tex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get handles to parameters</span></span><br><span class="line">D3DXHANDLE MatrixHandle = Effect-&gt;GetParameterByName(<span class="number">0</span>, <span class="string">"Matrix"</span>);</span><br><span class="line">D3DXHANDLE MtrlHandle   = Effect-&gt;GetParameterByName(<span class="number">0</span>, <span class="string">"Mtrl"</span>);</span><br><span class="line">D3DXHANDLE TexHandle    = Effect-&gt;GetParameterByName(<span class="number">0</span>, <span class="string">"Tex"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set parameters</span></span><br><span class="line">Effect-&gt;SetMatrix(MatrixHandle, &amp;M);</span><br><span class="line">Effect-&gt;SetVector(MtrlHandle, &amp;color);</span><br><span class="line">Effect-&gt;SetTexture(TexHandle, tex);</span><br></pre></td></tr></table></figure></p>
<p>注意：对每一个ID3DXEffect::Set<em>方法都有相应的ID3DXEffect::Get</em>方法用来取得效果文件中的变量值。例如，为得到一个距阵类型的变量，我们可以用这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::GetMatrix(</span><br><span class="line">    D3DXHANDLE hParameter,</span><br><span class="line">    D3DXMATRIX* pMatrix</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>要取得所有的方法列表，查看DirectX SDK文档。</p>
<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><pre><code>在这一节和它的小节，我们展示一旦一个效果被创建出来后如何使用它。下面步骤概述了全部过程：
</code></pre><ol>
<li>得到一个在你想使用的效果文件中的技术句柄。</li>
<li>激活想得到的技术。</li>
<li>启动当前活动的技术。</li>
<li>对每个激活技术中的渲染传递，渲染想要的几何体。回想一下，技术可能由几个渲染传递组成，我们必须在每个传递中渲染一次几何体。</li>
<li>结束当前激活的技术。</li>
</ol>
<h3 id="获得效果句柄（-Obtaining-a-Handle-to-an-Effect）"><a href="#获得效果句柄（-Obtaining-a-Handle-to-an-Effect）" class="headerlink" title="获得效果句柄（ Obtaining a Handle to an Effect）"></a>获得效果句柄（ Obtaining a Handle to an Effect）</h3><p>使用技术的第一步是获得一个技术D3DXHANDLE。可以用这个方法得到一个技术句柄：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D3DXHANDLE ID3DXEffect::GetTechniqueByName(</span><br><span class="line">    LPCSTR pName <span class="comment">// Name of the technique.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>注意：实际上，一个效果文件包括几个技术，每一个都被针对一个特定的硬件能力设计。因此，应用程序通常在系统上运行一些能力测试，然后通过这些测试选择最好的技术。看下面小节中的ID3DXEffect::ValidateTechnique。</p>
<h3 id="激活一个效果（-Activating-an-Effect）"><a href="#激活一个效果（-Activating-an-Effect）" class="headerlink" title="激活一个效果（ Activating an Effect）"></a>激活一个效果（ Activating an Effect）</h3><p>一旦得到了想要的技术的句柄，我们必须激活这个技术。这可以通过下面方法实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::SetTechnique(</span><br><span class="line">    D3DXHANDLE hTechnique <span class="comment">// Handle to the technique to set.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>注意：在激活一项技术前你可能想用现有设备验证它。也就是说，你也许想确保硬件支持的特色、配置技术的使用。你可以用下面的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::ValidateTechnique(</span><br><span class="line">    D3DXHANDLE hTechnique <span class="comment">// Handle to the technique to validate.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>回想一个效果文件可能有几个技术，每个偿试用不同的硬件特色执行一个特定效果，希望最少一个技术将在用户系统上执行。对于一个效果，你将遍例每一个技术并用ID3DXEffect::ValidateTechnique运行它，因而你能检测哪个技术是被支持的而哪个不被支持，然后进行适当的动作。</p>
<h3 id="启动效果"><a href="#启动效果" class="headerlink" title="启动效果"></a>启动效果</h3><p>为了使用一个效果渲染几何体，我们必须围绕绘图函数在ID3DXEffect::Begin 和 ID3DXEffect::End技术间调用。这些函数就是分别开启和关闭效果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::Begin(</span><br><span class="line">    UINT* pPasses,</span><br><span class="line">    DWORD Flags</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>pPasses—返回在当前活动的技术中的传递的数量。</li>
<li>Flags—下面标志的任何一个：<br>o Zero (0)—指定效果保存当前设备状态和着色状态，并在效果结束（这时ID3DXEffect::End被调用）后恢复它们。因为效果文件能够改变状态，对于可以保存启动效果前的状态来说，是很有用的。<br>o D3DXFX_DONOTSAVESTATE—指示效果不保存和恢复设备状态（除shader状态外）。<br>o D3DXFX_DONOTSAVESHADERSTATE—指示效果不保存和恢复shader状态。</li>
</ul>
<h3 id="设置当前的渲染传递（Setting-the-Current-Rendering-Pass）"><a href="#设置当前的渲染传递（Setting-the-Current-Rendering-Pass）" class="headerlink" title="设置当前的渲染传递（Setting the Current Rendering Pass）"></a>设置当前的渲染传递（Setting the Current Rendering Pass）</h3><p>在我们用效果渲染任何几何体前，我们必须指定使用的渲染传递。回想一个技术包括一个或多个渲染传递，每一个传递封装了不同的设备状态、采样器、和/或用于这一传递的着色器。渲染传递通过下面方法指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HRESULT ID3DXEffect::Pass(</span><br><span class="line">     UINT iPass <span class="comment">// Index identifying the pass.</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>一个技术的渲染传递被用标识为0…n-1的索引，共n个传递。因而，我们能用一个简单的循环遍例每一个传递，并用这一传递渲染几何体。19.6.6节有一个例子。</p>
<h3 id="结束效果（Ending-an-Effect）"><a href="#结束效果（Ending-an-Effect）" class="headerlink" title="结束效果（Ending an Effect）"></a>结束效果（Ending an Effect）</h3><p>最后，对于每个传递，我们渲染完几何体后，停止并结束效果时使用ID3DXEffect::End方法：<br>HRESULT ID3DXEffect::End(VOID);</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面的代码片断示例了以上的使用一个效果的必要的五个步骤：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效果文件中</span></span><br><span class="line">technique T0</span><br><span class="line">&#123;</span><br><span class="line">    pass P0</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在应用程序中，取得技术句柄</span></span><br><span class="line">D3DXHANDLE hTech = <span class="number">0</span>;</span><br><span class="line">hTech = Effect-&gt;GetTechniqueByName(<span class="string">"TO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活技术</span></span><br><span class="line">Effect-&gt;SetTechnique(hTech );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动激活的技术</span></span><br><span class="line">UINT numPasses = <span class="number">0</span>;</span><br><span class="line">Effect-&gt;Begin(&amp;numPasses, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍例每个传递</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPasses; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置当前传递</span></span><br><span class="line">    Effect-&gt;Pass(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在传递中渲染几何体</span></span><br><span class="line">    Sphere-&gt;Draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束效果</span></span><br><span class="line">Effect-&gt;End();</span><br></pre></td></tr></table></figure>
<h2 id="例子程序-Lighting-and-Texturing-in-an-Effect-File"><a href="#例子程序-Lighting-and-Texturing-in-an-Effect-File" class="headerlink" title="例子程序: Lighting and Texturing in an Effect File"></a>例子程序: Lighting and Texturing in an Effect File</h2><p>做为热身，让我们创建一个在3D模型中操作灯光和纹理的效果文件。这个例子完全运行于固定功能管线，意味着效果框架不仅限于使用着色器。图19.1展示了使用灯光和纹理例子的屏幕截图。</p>
<p>图19.1: 灯光和纹理例子的屏幕截图. 纹理、材质和灯光状态在效果文件中指定。</p>
<p>以下是效果文件的实现：<br>// File: light tex.txt<br>// Desc: 效果文件控制光的设备状态，和纹理一个3D模型<br>?<br>// 全局变量<br>matrix WorldMatrix;<br>matrix ViewMatrix;<br>matrix ProjMatrix;<br>?<br>texture Tex;<br>?<br>// 过滤器<br>?<br>// Associated the texture ‘Tex’ with the texture stage ‘S0’<br>// corresponds with and also set the sampler states for the sampler<br>// stage ‘S0’ corresponds with.<br>sampler S0 = sampler state<br>{<br>     Texture   = (Tex);<br>     MinFilter = LINEAR;<br>     MagFilter = LINEAR;<br>     MipFilter = LINEAR;<br>};</p>
<p>// Effect<br>technique LightAndTexture<br>{<br>     pass P0<br>     {<br>          // Set misc. render states.?<br>          pixelshader      = null;   // No pixel shader.<br>          vertexshader     = null;   // No vertex shader.<br>          fvf = XYZ | Normal | Tex1; // Flexible vertex format<br>          Lighting         = true;   // Enable lighting.<br>          NormalizeNormals = true;   // Renormalize normals.<br>          SpecularEnable   = false;  // Disable specular highlights.</p>
<pre><code>      // Set transformation states?
      WorldTransform[0]   = (WorldMatrix);
      ViewTransform       = (ViewMatrix);
      ProjectionTransform = (ProjMatrix);

      // Set a light source at light index 0. We fill out all the
      // components for light[0] because the Direct3D
      // documentation recommends filling out all components
      // for best performance.?
      LightType[0]         = Directional;
      LightAmbient[0]      = {0.2f, 0.2f, 0.2f, 1.0f};
      LightDiffuse[0]       = {1.0f, 1.0f, 1.0f, 1.0f};
      LightSpecular[0]     = {0.0f, 0.0f, 0.0f, 1.0f};
      LightDirection[0]     = {1.0f, -1.0f, 1.0f, 0.0f};
      LightPosition[0]      = {0.0f, 0.0f, 0.0f, 0.0f};
      LightFalloff[0]        = 0.0f;
      LightRange[0]        = 0.0f;
      LightTheta[0]        = 0.0f;
      LightPhi[0]          = 0.0f;
      LightAttenuation0[0]  = 1.0f;
      LightAttenuation1[0]  = 0.0f;
      LightAttenuation2[0]  = 0.0f;
</code></pre><p>?<br>          // Finally, enable the light:?<br>          LightEnable[0] = true;<br>?<br>          // Set material components. This is like calling<br>          // IDirect3DDevice9::SetMaterial.?<br>          MaterialAmbient  = {1.0f, 1.0f, 1.0f, 1.0f};<br>          MaterialDiffuse  = {1.0f, 1.0f, 1.0f, 1.0f};<br>          MaterialEmissive = {0.0f, 0.0f, 0.0f, 0.0f};<br>          MaterialPower    = 1.0f;<br>          MaterialSpecular = {1.0f, 1.0f, 1.0f, 1.0f};<br>?<br>          // Hook up the sampler object ‘S0’ to sampler stage 0,<br>          // which is given by Sampler[0].?<br>          Sampler[0] = (S0);<br>     }<br>}</p>
<pre><code>在这个效果文件中我们主要设置设备状态，就象在19.3节所述。例如，我们直接在效果文件中设置一个光源和一个材质。此外，我们指定转换距阵和纹理及采样器状态。这些状态被指定，然后用LightAndTexture方法和渲染传递P0渲染全部几何体，。
</code></pre><p>   注意：考虑到在一个效果文件中涉及到的的变量，你必须把它们装入圆括号中。举例来说，涉及到距阵变量，你必须这样写：(WorldMatrix), (ViewMatrix), and (ProjMatrix)。不使用圆括号是违法的。</p>
<p>   因为大部分必需的和繁琐的工作都在效果文件里做了，比如设置灯光、材质和纹理。应用程序代码就是做一些创建效果和开启效果等简单的事情。例子中有下面一些相关的全局变量：<br>ID3DXEffect* LightTexEffect   = 0;</p>
<p>D3DXHANDLE WorldMatrixHandle  = 0;<br>D3DXHANDLE ViewMatrixHandle   = 0;<br>D3DXHANDLE ProjMatrixHandle   = 0;<br>D3DXHANDLE TexHandle          = 0;</p>
<p>D3DXHANDLE LightTexTechHandle = 0;</p>
<p>　　?这些东西很没劲 ——- 只是一个ID3DXEffect指针和一些句柄。LightTexTechHandle是一个技术的句柄，因此在它的名字中有子字符串“Tech”。</p>
<p>   RestoreDeviceObjects函数执行三个主要步骤：创建效果，获得作为效果参数的我们要用的技术的句柄，并初始化一些效果参数。下面是删节的实现：<br>bool Setup()<br>{<br>    HRESULT hr = 0;<br>　　// …省略了采样器的读取<br>?<br>    // 创建效果<br>    ID3DXBuffer<em> errorBuffer = 0;<br>    hr = D3DXCreateEffectFromFile(<br>        m_pd3dDevice ,<br>        “light_tex.txt”,<br>        0,                // 没有定义预处理器<br>        0,                // 没有ID3DXInclude接口<br>        D3DXSHADER_DEBUG, // 编译标记<br>        0,                // 不共享参数<br>        &amp;m_LightTexEffect,<br>        &amp;errorBuffer);<br>?<br>    // 输出错误信息<br>    if( errorBuffer )<br>    {<br>        ::MessageBox(0, (char</em>)errorBuffer-&gt;GetBufferPointer(), 0, 0);<br>        SAFE_RELEASE(errorBuffer);<br>    }<br>?<br>    if(FAILED(hr))<br>    {<br>        ::MessageBox(0, “D3DXCreateEffectFromFile() - FAILED”, 0, 0);<br>        return false;<br>    }<br>?<br>    // 保存经常访问的参数句柄<br>    m_WorldMatrixHandle  = m_LightTexEffect-&gt;GetParameterByName(0, “WorldMatrix”);<br>    m_ViewMatrixHandle   = m_LightTexEffect-&gt;GetParameterByName(0, “ViewMatrix”);<br>    m_ProjMatrixHandle   = m_LightTexEffect-&gt;GetParameterByName(0, “ProjMatrix”);<br>    m_TexHandle         = m_LightTexEffect-&gt;GetParameterByName(0, “Tex”);?<br>    m_LightTexTechHandle =<br>　　　　m_LightTexEffect-&gt;GetTechniqueByName(“LightAndTexture”);<br>?<br>    // 设置效果参数<br>    // 设置矩阵<br>    D3DXMATRIX W, P;?<br>    D3DXMatrixIdentity(&amp;W);<br>    m_LightTexEffect-&gt;SetMatrix( m_WorldMatrixHandle, &amp;W);?</p>
<pre><code>D3DXMatrixPerspectiveFovLH(
    &amp;P,
    D3DX_PI * 0.25f, // 45 - degree
    (float)800.0f / (float)600.0f,
    1.0f,
    1000.0f);?
m_LightTexEffect-&gt;SetMatrix( m_ProjMatrixHandle, &amp;P);
</code></pre><p>?<br>    // Set texture<br>    IDirect3DTexture9<em> tex = 0;<br>    D3DXCreateTextureFromFile(m_pd3dDevice, “Terrain_3x_diffcol.jpg”, &amp;tex);?<br>    LightTexEffect-&gt;SetTexture(TexHandle, tex);<br>    d3d::Release&lt;IDirect3DTexture9</em>&gt;(tex);<br>?<br>    return true;<br>}</p>
<p>Disply函数很简单，运行步聚在19.6 节中简要说明:<br>bool Display(float timeDelta)<br>{<br>　　if( Device )<br>　　{<br>       // …[Camera update snipped]<br>       // set the new updated view matrix<br>       LightTexEffect-&gt;SetMatrix(ViewMatrixHandle, &amp;V);</p>
<pre><code>   // Activate the technique and render
   Device-&gt;Clear(0, 0, D3DCLEAR TARGET | D3DCLEAR ZBUFFER,
               0xffffffff, 1.0f, 0);
   Device-&gt;BeginScene();

   // set the technique to use
   LightTexEffect-&gt;SetTechnique( LightTexTechHandle );

   UINT numPasses = 0;
   LightTexEffect-&gt;Begin(&amp;numPasses, 0);

   for(int i = 0; i &lt; numPasses; i++)
   {
        LightTexEffect-&gt;Pass(i);

        for(int j = 0; j &lt; Mtrls.size(); j++)
        {
           Mesh-&gt;DrawSubset(j);
        }
   }
   LightTexEffect-&gt;End();

   Device-&gt;EndScene();
   Device-&gt;Present(0, 0, 0, 0);
</code></pre><p>　　}<br>　　<br>　　return true;<br>}</p>
<p>19.8例子程序: Fog Effect<br>    非常遗憾，我们没有用一整章篇幅来介绍Direct3D雾化效果。雾化效果（以下简称雾）提高了场景的真实性，可以用它来模拟逼真的天气状况。另外，雾可以大大减少长剪裁（far-clip）平面视觉效果。<br>    虽然我们不能给它应有的重视，这里我们还是挤出了一个简要的雾化例程。虽然我们不涉及详细的细节，我们还是展示并解释了Direct3D代码，这是很直接的。<br>    Direct3D雾化是固定功能管线的一部份，受渲染状态限制。下面的效果文件设置顶点雾，以达到必要的雾化状态。</p>
<p>   注意：Direct3D也支持像素雾（也叫表格雾table fog），比顶点雾要更精确。<br>// File: fog.txt<br>// Desc: Effect file that handles device states for linear vertex fog.<br>technique Fog<br>{<br>     pass P0<br>     {<br>          // Set misc render states.?<br>          pixelshader      = null;<br>          vertexshader     = null;<br>          fvf              = XYZ | Normal;<br>          Lighting         = true;<br>          NormalizeNormals = true;<br>          SpecularEnable   = false;<br>?<br>          // Fog states?<br>          FogVertexMode = LINEAR;     // Linear fog function.<br>          FogStart      = 50.0f;       // Fog starts 50 units away from viewpoint.<br>          FogEnd        = 300.0f;     // Fog ends 300 units away from viewpoint.<br>?<br>          FogColor      = 0x00CCCCCC; // Gray colored fog.<br>          FogEnable     = true;        // Enable vertex fog.<br>     }<br>}</p>
<p>就象你看到的，线性顶点雾能够通过五个简单的渲染状态控制：<br>*???????? FogVertexMode—使用指定的雾函数用于顶点雾。雾函数指定雾如何根据距离增长，自然界的雾在近视口的地方比较薄并且根据距离增长变得厚起来了。有效的任务类型为LINEAR、EXP、EXP2。这些函数被定义为：</p>
<p>d 是到视口的距离(viewpoint.)</p>
<p>   注意：如果你用EXP或EXP2雾化函数，你不用设置FogStart 和 FogEnd，因为它们在这些雾函数类型中没被用到。代替的你必须设置雾密度（fog density）渲染状态（如，FogDensity = someFloatType）<br><em>???????? FogStart—标记了物体将开始雾化的起始深度。
</em>???????? FogEnd—标记了物体将结束雾化的结束深度。<br>   注意：FogStart 与 FogEnd本质上定义了物体在其中被雾化的深度间隔（从视口）。<br><em>???????? FogColor—一个DWORD 或 D3DCOLOR值，以描述雾的颜色
</em>???????? FogEnable—指定true以开启顶点雾或false以关闭顶点雾</p>
<p>   任何我们用fog.txt效果渲染的几何体将被雾化。通过这种方式，我们可以控制哪一物体得到雾化，而哪些不用雾化。这对只雾化特定区域是很有用的。例如，通常屋外是有雾的，屋里不被雾化。同样的，一定地理部分可能有雾，而另外部分可能没有。图19.2展示了这一小节的调用雾效果的例程的屏幕截图。<br>图19.2: 雾化效果例子程序的屏幕截图，在这个例子中我们使用线性雾函数，而且雾化渲染状态在效果文件中指定。<br>19.9例子程序: Cartoon Effect<br>   到目前为止的2个效果文件的例子，我们没有使用着色器（shader）。因为着色器在特效中的重要部分，我们想展示一个最精简的例子。例程CartoonEffect执行了在17章中讨论的卡通着色器，但是这次应用效果框架。下面是一个删节版的效果文件：<br>// File: tooneffect.txt<br>// 在效果文件中的卡通着色器<br>extern matrix WorldMatrix;<br>extern matrix ViewMatrix;<br>extern matrix ProjMatrix;<br>extern vector Color;<br>extern vector LightDirection;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};<br>extern texture ShadeTex;<br>?<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     float2 uvCoords : TEXCOORD;<br>     vector diffuse  : COLOR;<br>};<br>?<br>// Cartoon Shader Function:<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     …[Implementation omitted for brevity.]<br>}<br>?<br>sampler ShadeSampler = sampler state<br>{<br>     Texture = (ShadeTex);<br>     MinFilter = POINT; // no filtering for cartoon shading<br>     MagFilter = POINT;<br>     MipFilter = NONE;<br>};<br>?<br>technique Toon<br>{<br>     pass P0<br>     {<br>          // Set P0’s vertex shader.<br>          vertexShader = compile vs_1_1 Main();<br>          // Hook up the sampler object to sampler stage 0.<br>          Sampler[0] = (ShadeSampler);<br>     }<br>}</p>
<p>   我们注意到卡通着色器函数被定义在效果文件中，并且我们指定着色器使用一个特定的传递，在传递部分使用语法：vertexShader = compile vs_1_1_Main();。在效果文件中的设备状态象通常一样设置。</p>
<p>19.10 效果编辑（EffectEdit）<br>   在结束这章前，我们想提一下在DirectX SDK中的EffectEdit程序。可以在\DXSDK\Samples\C++\Direct3D\Bin文件夹中找到它。图19.3显示了一个屏幕截图。</p>
<p>图19.3: 一个在DirectX SDK 中的EffectEdit 程序的屏幕截图<br>    这个EffectEdit程序在测试和书写效果文件时是很有用的。我们推荐您在这个工具上花点时间。</p>
<p>19.11摘要<br>略</p>
<p>相关文章：<br>AGP内存<br>AGP（Accelerate Graphical Port），加速图形接口。随着显示芯片的发展，PCI总线日益无法满足其需求。英特尔于1996年7月正式推出了AGP接口，它是一种显示卡专用的局部总线。严格的说，AGP不能称为总线，它与PCI总线不同，因为它是点对点连接，即连接控制芯片和AGP显示卡，但在习惯上我们依然称其为AGP总线。AGP接口是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz。<br>　　AGP总线直接与主板的北桥芯片相连，且通过该接口让显示芯片与系统主内存直接相连，避免了窄带宽的PCI总线形成的系统瓶颈，增加3D图形数据传输速度，同时在显存不足的情况下还可以调用系统主内存。所以它拥有很高的传输速率，这是PCI等总线无法与其相比拟的。<br>　　由于采用了数据读写的流水线操作减少了内存等待时间，数据传输速度有了很大提高；具有133MHz及更高的数据传输频率；地址信号与数据信号分离可提高随机内存访问的速度；采用并行操作允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存；显示带宽也不与其它设备共享，从而进一步提高了系统性能。<br>　　AGP标准在使用32位总线时，有66MHz和133MHz两种工作频率，最高数据传输率为266Mbps和533Mbps，而PCI总线理论上的最大传输率仅为133Mbps。目前最高规格的AGP 8X模式下，数据传输速度达到了2.1GB/s。<br>　　AGP接口的发展经历了AGP1.0(AGP1X、AGP2X)、AGP2.0(AGP Pro、AGP4X)、AGP3.0(AGP8X)等阶段，其传输速度也从最早的AGP1X的266MB/S的带宽发展到了AGP8X的2.1GB/S。<br>AGP 1.0（AGP1X、AGP2X）<br>　 1996年7月AGP 1.0 图形标准问世，分为1X和2X两种模式，数据传输带宽分别达到了266MB/s和533MB/s。这种图形接口规范是在66MHz PCI2.1规范基础上经过扩充和加强而形成的，其工作频率为66MHz，工作电压为3.3v，在一段时间内基本满足了显示设备与系统交换数据的需要。这种规范中的AGP带宽很小，现在已经被淘汰了，只有在前几年的老主板上还见得到。<br>AGP2.0(AGP4X)<br>　　显示芯片的飞速发展，图形卡单位时间内所能处理的数据呈几何级数成倍增长，AGP 1.0 图形标准越来越难以满足技术的进步了，由此AGP 2.0便应运而生了。1998年5月份，AGP 2.0 规范正式发布，工作频率依然是66MHz，但工作电压降低到了1.5v，并且增加了4x模式，这样它的数据传输带宽达到了1066MB/sec，数据传输能力大大地增强了。<br>AGP Pro<br>　　AGP Pro接口与AGP 2.0同时推出，这是一种为了满足显示设备功耗日益加大的现实而研发的图形接口标准，应用该技术的图形接口主要的特点是比AGP 4x略长一些，其加长部分可容纳更多的电源引脚，使得这种接口可以驱动功耗更大（25-110w）或者处理能力更强大的AGP显卡。这种标准其实是专为高端图形工作站而设计的，完全兼容AGP 4x规范，使得AGP 4x的显卡也可以插在这种插槽中正常使用。AGP Pro在原有AGP插槽的两侧进行延伸，提供额外的电能。它是用来增强，而不是取代现有AGP插槽的功能。根据所能提供能量的不同，可以把AGP Pro细分为AGP Pro110和AGP Pro50。在某些高档台式机主板上也能见到AGP Pro插槽，例如华硕的许多主板。<br>AGP 3.0(AGP8X)<br>　　2000年8月，Intel推出AGP3.0规范，工作电压降到0.8V,并增加了8x模式，这样它的数据传输带宽达到了2133MB/sec，数据传输能力相对于AGP 4X成倍增长，能较好的满足当前显示设备的带宽需求。<br>AGP接口的模式传输方式<br>　　不同AGP接口的模式传输方式不同。1X模式的AGP，工作频率达到了PCI总线的两倍—66MHz，传输带宽理论上可达到266MB/s。AGP 2X工作频率同样为66MHz，但是它使用了正负沿（一个时钟周期的上升沿和下降沿）触发的工作方式，在这种触发方式中在一个时钟周期的上升沿和下降沿各传送一次数据，从而使得一个工作周期先后被触发两次，使传输带宽达到了加倍的目的，而这种触发信号的工作频率为133MHz，这样AGP 2X的传输带宽就达到了266MB/s×2（触发次数）＝533MB/s的高度。AGP 4X仍使用了这种信号触发方式，只是利用两个触发信号在每个时钟周期的下降沿分别引起两次触发，从而达到了在一个时钟周期中触发4次的目的，这样在理论上它就可以达到266MB/s×2（单信号触发次数）×2（信号个数）＝1066MB/s的带宽了。在AGP 8X规范中，这种触发模式仍然使用，只是触发信号的工作频率变成266MHz，两个信号触发点也变成了每个时钟周期的上升沿，单信号触发次数为4次，这样它在一个时钟周期所能传输的数据就从AGP4X的4倍变成了8倍，理论传输带宽将可达到266MB/s×4（单信号触发次数）×2（信号个数）＝2133MB/s的高度了。</p>
<p>　　目前常用的AGP接口为AGP4X、AGP PRO、AGP通用及AGP8X接口。需要说明的是由于AGP3.0显卡的额定电压为0.8—1.5V，因此不能把AGP8X的显卡插接到AGP1.0规格的插槽中。这就是说AGP8X规格与旧有的AGP1X/2X模式不兼容。而对于AGP4X系统，AGP8X显卡仍旧在其上工作，但仅会以AGP4X模式工作，无法发挥AGP8X的优势。</p>
<p>Direct3D中实现图元的鼠标拾取<br>索引：<br>　　1、什么是拾取，拾取能做什么？<br>　　2、拾取操作的步骤和实现<br>　　2.1． 变换并获得通过视点和屏幕上点击点的射线矢量（Dir）<br>　　 2.1.1 确定鼠标选取点的屏幕坐标<br>　　 2.1.2 得到Dir在观察坐标空间内的表示<br>　　 2.1.3 转换Dir到世界坐标空间，并得到观察点在世界坐标系中的坐标<br>　　2.2 使用射线矢量对场景中的所有三角形图元求交，获得三角形索引值和重心坐标。<br>　　 2.2.1 D3D扩展函数实现求交<br>　　 2.2.2射线三角面相交的数学算法<br>　　 2.2.3 拾取完成根据获得的中心坐标计算我们关心的常见量<br>　　3、结束及声明<br>　　4、参考文献<br>　　补充：重心坐标的概念<br>　　3D交互图形应用程序中，常常要用鼠标去选择图形，其实现的机制基于鼠标拾取算法。本文主要讲述如何在D3D中实现图元的鼠标拾取。为了讨论简单，本文假定读者理解D3D 坐标变换流程和基本的图形学知识，如果阅读有困难请参考相关资料。<br>1、什么是拾取，拾取能做什么？<br>   首先，拾取操作指当我们在屏幕上用鼠标点击某个图元，应用程序能返回该图元的一个标志和某些相关信息。有图形程序设计经验的人都知道，有这些信息就表示我们有了对该图元的控制权，我们可以删除，可以编辑，可以任意对待该图元，至于你到底想干什么，就是阁下自己的事了^_^。</p>
<p>2、拾取操作的步骤和实现<br>　　拾取算法的思想很简单：得到鼠标点击处的屏幕坐标，通过投影矩阵和观察矩阵把该坐标转换为通过视点和鼠标点击点的一条射入场景的光线，该光线如果与场景模型的三角形相交（本文只处理三角形图元），则获取该相交三角形的信息。本文讲述的方法除可以得到三角形的一个索引号以外还可以得到相交点的重心坐标。<br>从数学角度来看，我们只要得到射线的方向矢量和射线的发射点，我们就具备了判断射线与空间三角面是否相交的条件，本文主要讨论如何获得这些条件，并描述了射线与三角面相交判断算法和D3D的通常实现方法。 </p>
<p>　　根据拾取操作的处理顺序，大概可以依次分为以下几个步骤<br>2.1． 变换并获得通过视点和屏幕上点击点的射线矢量（Dir）<br>详细介绍之前，为了大家方便理解，我们要先简单说一下d3d坐标转换的大概流程，如下图:</p>
<p>　　 所以我们要通过一系列的反变换，得到我们关心的值在世界坐标中的表示。<br>　　2.1.1 确定鼠标选取点的屏幕坐标<br>　　这一步是非常简单的Windows给我们提供了API来完成屏幕坐标的获取，使用GetCursorPos获得鼠标指针位置，然后再利用ScreenToClient转换坐标到客户区坐标系(以窗口视区左上角为坐标原点，单位为像素)，设该坐标为（POINT screenPt）。<br>　　2.1.2 得到Dir在观察坐标空间内的表示<br>　　在观察坐标系中，Dir是一条从观察坐标原点出发的射线，所以我们只需要再确定一个该射线经过的点，就可以得到它在观察坐标系中的表示。假设我们要求的射线上的另外一点为该射线与透视投影平截头体近剪切面的交点，针对最普遍的透视投影而言，透视投影平截头体经投影变换后，变成一个1/2立方体（请允许我这么叫^_^，因为它的大小为一个正方体的一半，x,y方向边长为2，z方向为1）如图：</p>
<p>投影坐标系以近剪切面中心为坐标原点，该立方体从z轴负向看过去与图形程序视区相对应，最终近剪切面（前剪切面）上一点与屏幕坐标之间的对应关系如下图所示：</p>
<p>　　根据比例关系，screenPt与投影空间上的点projPt之间的关系为<br>　　假设图形程序窗口的宽为screenWidth,高为screenHeight,<br>　　projPt.x = (screenPt.x-screenWidth/2)/screenWidth<em>2; （公式1）<br>　　projPt.y = (screenPt.y-screenHeight/2)/screenHeight</em>2; （公式2）<br>　　projPt.z =0;（实际该值可任意取，不影响最终结果。为了处理简单，我们取改值为0，表示该点取在近剪切面上）<br>　　得到projPt后，我们需要做的是把该点坐标从投影空间转换到观察空间(view space),<br>　　根据透视投影的定义，可假设点(projPt.x，projPt.y，projPt.z)<br>　　对应的其次坐标为<br>　　(projPt.x<em>projPt.w，projPt.y</em>projPt.w，projPt.z<em>projPt.w，projPt.w)<br>　　我们可以通过 GetTransform( D3DTS_PROJECTION, &amp;ProjMatrix)函数获得投影矩阵ProjMatrix,则根据观察空间到投影空间的变换关系则：投影坐标 = 观察坐标×投影矩阵<br>　　(projPt.x</em>projPt.w，projPt.y<em>projPt.w，projPt.z</em>projPt.w，projPt.w)<br>　　= (viewPt.x，viewPt.y，viewPt.z, 1)<em>pProjMatrx;<br>　　根据定义和图形学原理<br>　　ProjMatrix = =<br>　　所以,<br>　　(projPt.x</em>projPt.w，projPt.y<em>projPt.w，projPt.z</em>projPt.w，projPt.w)<br>　　= ( viewPt.x<em>ProjMatrix._m11,<br>　　   viewPt.y</em>ProjMatrix._m22,<br>　　   viewPt.z*Q-QZn,<br>       viewPt.z)</p>
<p>　　所以<br>　　projPt.x<em>projPt.w = viewPt.x</em>ProjMatrix._m11<br>　　projPt.y<em>projPt.w = viewPt.y</em>ProjMatrix._m22<br>　　projPt.z<em>projPt.w = viewPt.z</em>Q-QZn （注意projPt.z = 0）<br>　　projPt.w = viewPt.z;<br>　　解得<br>　　viewPt.x = projPt.x<em>Zn/ ProjMatrix._m11;<br>　　viewPt.y = projPt.y</em>Zn/ ProjMatrix._m22;<br>　　viewPt.z = Zn;<br>　　好了，到这里为止我们终于求出了射线与近剪切面交点在观察坐标系中的坐标，现在我们拥有了射线的出发点(0,0,0)和射线方向上另外一点(viewPt.x,viewPt.y,viewPt.z),则该射线的方向矢量在观察空间中的表示可确定为（viewPt.x-0,viewPt.y-0,viewPt.z-0）,化简一下三个分量同除近剪切面z坐标Zn，该方向矢量可写作<br>　　DIRview = (projPt.x/projMatrix._m11,projPt.y/projMatrix._m22,1)<br>　　代入公式1，公式2<br>　　DIRview.x = (2<em>screenPt.x/screenWidth-1)/projMatrix._m11;<br>　　DIRview.y = (2</em>screenPt.y/screenHeight-1)/projMatrix._m22;<br>　　DIRview.z = 1;<br>     其中screenWidth和screenHeight可以通过图像显示的backBuffer的目标表面（D3DSURFACE_DESC）来获得，该表面在程序初始化时由用户创建。</p>
<p>　　2.1.3 转换Dir到世界坐标空间，并得到观察点在世界坐标系中的坐标<br>　　由于最终的运算要在世界坐标空间中进行，所以我们还需要把矢量DIRview从观察空间转换为世界坐标空间中的矢量DIRworld。<br>　　因为<br>　　DIRview = DIRworld<em>ViewMatrix;<br>　　其中ViewMatrix为观察矩阵，在D3D中可以用函数GetTransform( D3DTS_VIEW, &amp;ViewMatrix )得到。<br>　　所以DIRworld = DIRview </em> inverse_ViewMatrix,其中inverse_ViewMatrix为ViewMatrix的逆矩阵。<br>　　观察点在观察坐标系中坐标为OriginView（0，0，0，1），所以其在世界坐标系中的坐标同样可以利用ViewMatrix矩阵，反变换至世界坐标系中，事实上我们可以很简单的判断出,其在世界坐标系中的表示为:<br>　　OriginWorld = (inverse_ViewMatrix._41,<br>　　inverse_ViewMatrix._42,<br>　　inverse_ViewMatrix._43,<br>　　1);<br>　　到这里为止，判断射线与三角面是否相交的条件就完全具备了。<br>2.2 使用射线矢量对场景中的所有三角形图元求交，获得三角形索引值和重心坐标。<br>　　这一步骤地实现由两种途径:<br>　　第一种方法非常简单，利用D3D提供的扩展函数D3DXIntersect可以轻松搞定一切。见2.1<br>　　第二种方法就是我们根据空间解析几何的知识，自己来完成射线三角形的求交算法。一般来讲，应用上用第一种方法就足够了，但是我们如果要深入的话，必须理解相交检测的数学算法，这样才能自由的扩展，面对不同的需求，内容见2.2<br>　　下面分别讲解两种实现途径：<br>　　2.2.1 D3D扩展函数实现求交<br>　　这种方法很简单也很好用，对于应用来说应尽力是用这种方式来实现，毕竟效率比自己写得要高得多。<br>　　实际上其实没什么好讲的，大概讲一下函数D3DXIntersect吧<br>　　D3D SDK该函数声明如下<br>　　HRESULT D3DXIntersect(<br>　　LPD3DXBASEMESH pMesh,<br>　　CONST D3DXVECTOR3 <em>pRayPos,<br>　　CONST D3DXVECTOR3 </em>pRayDir,<br>　　BOOL <em>pHit,<br>　　DWORD </em>pFaceIndex,<br>　　FLOAT <em>pU,<br>　　FLOAT </em>pV,<br>　　FLOAT <em>pDist,<br>　　LPD3DXBUFFER </em>ppAllHits,<br>　　DWORD <em>pCountOfHits<br>　　);<br>　　l pMesh指向一个ID3DXBaseMesh的对象，最简单的方式是从.x文件获得，描述了要进行相交检测的三角面元集合的信息，具体规范参阅direct9 SDK<br>　　l pRayPos 指向射线发出点<br>　　l pRayDir 指向前面我们辛辛苦苦求出的射线方向的向量<br>　　l pHit 当检测到相交图元时，指向一个true,不与任何图元相交则为假<br>　　l pU 用于返回重心坐标U分量<br>　　l pV返回重心坐标V分量<br>　　l pDist 返回射线发出点到相交点的长度<br>　　注意：以上红色字体部分均指最近的一个返回结果（即</em>pDist最小）<br>　　l ppAllHits用于如果存在多个相交三角面返回相交的所有结果<br>　　l pCountOfHits 返回共有多少个三角形与该射线相交<br>　　补充：重心坐标的概念<br>三角形的重心坐标：　　<br>P1，P2，P3为空间三角形的三个顶点矢量， (U,?V)就称为三角形的重心坐标<br>在空间三角形平面上的点可以表示为：　P?=?P1?+?U?<em>?(P2?-?P1)?+?V?</em>?(P3?-?P1)<br>当0?&lt;?U?&lt;?1，0?&lt;?V?&lt;?1，0?&lt;?U?+?V?&lt;?1时，这个点P就在这个三角形的内部<br>                                                                             收集<br>　　<br>　　其中pU和pV用到了重心坐标的概念，下面稍作描述<br>　　一个三角形有三个顶点，在迪卡尔坐标系中假设表示：<br>　　V1(x1,y1,z1),<br>　　V2(x2,y2,z2),<br>　　V3(x3,y3,z3),<br>　　则三角形内任意一点的坐标可以表示为（pV为任意点）：<br>　　pV = V1 + U(V2-V1) + V(V3-V1)<br>　　所以已知三个顶点坐标的情况下，任意一点可用坐标(U,V)来表示，其中 参数U控制V2在结果中占多大的权值，参数V控制V3占多大权值，最终V1占多大权值 = 1 - U - V，这种坐标定义方式就叫重心坐标。<br>　　<br>　　2..2.2射线三角面相交的数学算法<br>　　使用d3d扩展函数，毕竟有时不能满足具体需求，掌握了该方法，我们才能够获得最大的控制自由度，任意修改算法。<br>　　已知条件: 射线源点orginPoint,三角形三个顶点 v1,v2,v3,射线方向 Dir（均以三维坐标向量形式表示）。<br>　　算法目的: 判断射线与三角形是否相交，如果相交求出交点的重心坐标(U,V)和射线原点到交点的距离T。<br>　　我们可先假设射线与三角形相交则交点<br>　　(注以下均为向量运算：<br>dot(X,Y)       点乘；<br>　　cross(X，Y)    叉乘；<br>　　U，V，T      标量(这三个值为X、Y、Z轴坐标))<br>　　<br>　　则：（IntersectPoint为三角形上的交点）<br>　　IntersectPoint = V1 + U×(V2-V1) + V×(V3-V1) ;<br>　　IntersectPoint = originPoint + T×Dir；<br>　　所以：<br>　　orginPoint + T×Dir = V1 + U×(V2-V1) + V×(V3-V1);<br>　　整理得：<br>　　orginPoint - V1 = U×(V2-V1) + V×(V3-V1) - T×Dir;<br>?<br>这是一个简单的线性方程组，若有解则行列式［-Dir, V2-V1, V3-V1］不为0。<br>   根据T,U,V的含义当T&gt;0, 0&lt;U&lt;1,0&lt;V&lt;1,0&lt;U+V&lt;1时该交点在三角形内部，解此方程组即可获得我们关心的值,具体解法不再赘述，克莱姆法则就够了（详细见线性代数）:射线原点到相交点的距离T,和交点的中心坐标(U,V)。<br>下面给出Direct 9 SDK示例程序中的实现代码：<br>IntersectTriangle( const D3DXVECTOR3&amp; orig,<br>??????????????????      const D3DXVECTOR3&amp; dir, D3DXVECTOR3&amp; v0,<br>?????? ????????????     D3DXVECTOR3&amp; v1, D3DXVECTOR3&amp; v2,<br>?????? ????????????     FLOAT<em> t, FLOAT</em> u, FLOAT* v )<br>{<br>??? // 算出两个边的向量<br>??? D3DXVECTOR3 edge1 = v1 - v0;<br>??? D3DXVECTOR3 edge2 = v2 - v0;<br>?<br>   D3DXVECTOR3 pvec;<br>   D3DXVec3Cross( &amp;pvec, &amp;dir, &amp;edge2 );</p>
<p>   // 如果det为0，或接近于零则射线与三角面共面或平行，不相交<br>   //此处det就相当于上面的[-Dir, V2-V1, V3-V1]，<br>??? FLOAT det = D3DXVec3Dot( &amp;edge1, &amp;pvec );<br>?<br>??? D3DXVECTOR3 tvec;<br>??? if( det &gt; 0 )<br>??? {<br>??????? tvec = orig - v0;<br>??? }<br>??? else<br>??? {<br>??????? tvec = v0 - orig;<br>??????? det = -det;<br>??? }<br>?<br>??? if( det &lt; 0.0001f )<br>??????? return FALSE;<br>?<br>??? // 计算u并测试是否合法（在三角形内）<br>??? <em>u = D3DXVec3Dot( &amp;tvec, &amp;pvec );<br>??? if( </em>u &lt; 0.0f || <em>u &gt; det )<br>??????? return FALSE;<br>?<br>??? // Prepare to test V parameter<br>??? D3DXVECTOR3 qvec;<br>??? D3DXVec3Cross( &amp;qvec, &amp;tvec, &amp;edge1 );<br>?<br>??? //计算u并测试是否合法（在三角形内）<br>??? </em>v = D3DXVec3Dot( &amp;dir, &amp;qvec );<br>??? if( <em>v &lt; 0.0f || </em>u + <em>v &gt; det )<br>??????? return FALSE;<br>?<br>??? /</em>计算t,并把t,u,v放缩为合法值（注意前面的t,v,u不同于算法描述中的相应量，乘了一个系数det）,注意：由于该步运算需要使用除法，所以放到最后来进行，避免不必要的运算，提高算法效率<em>/<br>??? </em>t = D3DXVec3Dot( &amp;edge2, &amp;qvec );<br>??? FLOAT fInvDet = 1.0f / det;<br>??? <em>t </em>= fInvDet;<br>??? <em>u </em>= fInvDet;<br>??? <em>v </em>= fInvDet;<br>?<br>??? return TRUE;<br>}</p>
<p>?<br>2.2.3? 拾取完成根据获得的中心坐标计算我们关心的常见量<br>根据重心坐标（U,V）,我们可以很容易的算出各种相关量比如纹理坐标和交点的差值颜色，假设以纹理坐标为例设V1,V2,V3的纹理坐标分别为T1(tu1,tv1),T2(tu2,tv2),T3(tu3,tv3)则交点的坐标为<br>?<br>IntersectPointTexture = T1 + U(T2-T1) + V(T3-T1)</p>
<p>3、结束及声明<br>　　Ok, 到这里为止关于拾取的相关知识就介绍完了，小弟第一次写这种文章，不知道有没有把问题说清楚，希望对大家有所帮助，有任何问题可以给我发email: jzhang1@mail.xidian.edu.cn<br>　　或者到我的网站留言： www.heavysword.com<br>　　声明：<br>　　本文写作的目的是为了广大D3D学习者方便学习服务，文中算法为作者参考相关文献总结，作者无意把这些据为自己的成果，所有权原算法提出者所有（参阅参考文献），文中代码为D3d SDK的示例内容，由笔者进行了必要的解释，代码版权归microsoft所有。<br>4、参考文献<br>　　【1】Microsoft DirectX 9.0 SDK,microsoft<br>　　【2】fast,Minimun Storage Ray/Triangle Intersection,Tomas Moler,Ben Trumbore</p>
<p>?BY</p>
<p>克莱姆（Cramer）法则<br>一、线性方程组<br>　　元线性方程组是指形式为：<br>　　　　　　　　（1）<br>的方程组，其中代表个未知量，是方程的个数，， ; 称为方程组的系数，称为常数项。<br>　　线性方程组的一个解是指由个数组成的有序数组， 当个未知量分别用代入后，式（1）中每个等式都成为恒等式。方程组（1）的解的全体称为它的解集合，如果两个线性方程组有相同的解集合，就称它们是同解方程组。<br>　　为了求解一个线性方程组，必须讨论以下一些问题：<br>　　(1).这个方程组有没有解？<br>　　(2).如果这个方程组有解，有多少个解？<br>　　(3).在方程组有解时,解之间的关系,并求出全部解。<br>　　本节讨论方程的个数与未知量的个数相等(即)的情形。</p>
<p>二、克莱姆法则</p>
<p>　　定理1（克莱姆法则）如果线性方程组<br>　　　　　 ???????????（2）<br>的系数行列式：<br>　　　　<br>那么这个方程组有解，并且解是唯一的，这个解可表示成：<br>　　　　　　　　（3）<br>其中是把中第列换成常数项所得的行列式，即<br>　　　　。<br>　　分析：定理一共有3个结论：方程组有解；解是唯一的；解由公式（3）给出。因此证明的步骤是：<br>　　第一，把 代入方程组，验证它确实是解。这样就证明了方程组有解，并且（3）是一个解，即证明了结论与。<br>　　第二，证明如果是方程组（２）的一个解，那么一定有。这就证明了解的唯一性，即证明了结论。<br>　　证明：先回忆行列式的一个性质，设阶行列式，则有：<br>　<br>接下来证明定理。首先，证明（3）确实是（2）的解。将行列式按第列展开得：<br>　　　　，<br>其中是行列式中元素的代数余子式。现把<br>代入第个方程的左端，得：</p>
<p>这说明将（3）代入第个方程后，得到了一个恒等式，所以（3）是（2）的一个解。<br>　　其次，设是方程组（2）的一个解，那么，将代入（2）后，得到个恒等式：<br>　　　　　　　　　　（4）<br>用系数行列式的第列的代数余子式依次去乘（4）中个恒等式，得到：<br>　　　　<br>将此个等式相加，得：</p>
<p>从而有：。这就是说，如果是方程组（2）的一个解，那么一定有，所以方程组只有一个解。</p>
<p>三、齐次线性方程组<br>　　在线性方程组中，有一种特殊的线性方程组，即常数项全为零的方程组，称为齐次线性方程组。显然，齐次线性方程组总是有解的，因为就是它的解，这个解称为零解；其他的，即不全为零的解（如果还有的话），称为非零解。所以，对于齐次线性方程组，需要讨论的问题，不是有没有解，而是有没有非零解。这个问题与齐次线性方程组解的个数是有密切关系的。如果一个齐次线性方程组只有零解，那么这个方程组就只有唯一解；反之， 如果某个齐次线性方程组有唯一解， 那么由于零解是一个解，所以这个方程组不可能有非零解。<br>　　对于方程个数与未知量个数相同的齐次线性方程组，应用克莱姆法则，有<br>　　推论1? 如果齐次线性方程组<br>　　　　　　　　（5）<br>的系数行列式不等于零，那么（5）只有零解。<br>　　推论2　齐次线性方程组<br>　　　　<br>有非零解的必要条件是它的系数行列式等于零。</p>
<p>四、例子<br>　　例1　解线性方程组<br>　　　　<br>　　解：方程组的系数行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　<br>　<br>所以这个线性方程组的唯一解为：<br>　　　　<br>　　例2　解线性方程组<br>　　　　<br>　　解：方程组的系数行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　　　<br>　　　<br>所以这个线性方和组的唯一解为：<br>　　　　<br>　　例3???????? 已知三次曲线在四个点处的值分别为：，试求其系数。<br>　　解：将三次曲线在4点处的值代入其方程，得到关于的线性方程组：<br>　　　　<br>它的系数行列式是范德蒙行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　　　<br>　　　<br>所以，即所求的三次曲线方程为。<br>　　例4　如果齐次线性方程组<br>　　　　<br>有非零解，那么必须满足什么条件？<br>　　解：由克莱姆法则知，齐次线性方程组有非零解的必要条件是其系数行列式等于零，因此有<br>　　　　<br>又由：，从而必须满足的条件为。<br>　　注　用克莱姆法则求解系数行列式不等于零的元非齐次线性方程组，需要计算个阶行列式，它的计算工作量很大。实际上关于数字系数的线性方程组（包括系数行列式等于零及方程个数和未知量个数不相同的线性方程组）的解法，一般都采用后续章节介绍的方法来求解。克莱姆法则主要是在理论上具有重要的意义，特别是它明确地揭示了方程组的解和系数之间的关系。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Introduction-to-Pixel-Shaders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Introduction-to-Pixel-Shaders/" class="post-title-link" itemprop="url">第十八章 像素着色器入门(Introduction to Pixel Shaders)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:29:49" itemprop="dateCreated datePublished" datetime="2019-04-11T15:29:49+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Introduction-to-Pixel-Shaders/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Introduction-to-Pixel-Shaders/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>   像素着色器是一个执行在图形卡的GPU上的程序，它运行在对每个像素进行光栅化处理时。（不像顶点着色器，Direct3D不会以软件模拟像素着色器的功能。）它实际上替换了固定功能管线的多纹理化阶段（the multitexturing stage），并赋予我们直接操纵单独的像素和访问每个像素的纹理坐标的能力。这种对像素和纹理坐标的直接访问使我们可以达成各种特效，例如：多纹理化（multitexturing）、每像素光照（per pixel lighting）、景深（depth of field）、云状物模拟（cloud simulation）、焰火模拟（fire simulation）、高级阴影技术（sophisticated shadowing technique）。</p>
<p>   图形卡支持的像素着色器的版本可以通过D3DCAPS9结构的PixelShaderVersion成员和D3DPS_VERSION宏进行检查。下列代码片断展示了这点：<br>// If the device’s supported version is less than version 2.0<br>if( caps.PixelShaderVersion &lt; D3DPS_VERSION(2, 0) )<br>     // Then pixel shader version 2.0 is not supported on this device.</p>
<p>目标</p>
<ul>
<li>获得对多纹理化概念的基本理解</li>
<li>学习如何编写、创建并使用像素着色器</li>
<li>学习如何使用像素着色器实现多纹理化效果</li>
</ul>
<p>18.1多纹理化概览<br>   多纹理化（Multitexturing）可能是用像素着色器实现的最简单的技巧了。此外，因为像素着色器替换多纹理化阶段，那么接下来我们应该对多纹理化“是什么”和“做什么”有一个最基本的理解。本节介绍多纹理化的简明概览。</p>
<p>   当我们一开始讨论纹理化（texturing）的时候（第6章），我们忽略了固定功能管线中对多纹理化的讨论，这有两个原因：第一，多纹理化是有一点棘手的过程，我们考虑到这在当时是一个高级话题；此外，固定功能多纹理化阶段被新的和更强有力的像素着色器替换掉了。因此花时间在已经过时的固定功能纹理化阶段上是无意义的。</p>
<p>   多纹理化后面的概念有一点和混合（blending）相关。在第七章中我们了解到：可以将正要被光栅化的像素与之前写入后台缓冲的像素进行混合来达成一种特效。我们延伸这种相同的思想到多纹理化中（multiple texture）。也就是说，我们一次使用几个纹理，然后定义这些纹理如何被混合在一起，以达到一种特殊效果。多纹理化的一个通常的用法是执行光照。作为在顶点处理阶段使用Direct3D的光照模型的替代，我们使用一种叫做“光照图”（light map）的特殊纹理贴图（texture map），它编码（encode）表面是如何被光照的。例如，假设我们希望一盏聚光灯（spotlight）照在一个大木箱上，我们要么可以定义一个D3DLIGHT9结构的聚光灯，要么可以将代表木箱的纹理贴图与代表聚光灯的光照映射混合在一起，如图18.1所示。</p>
<p>图18.1：使用多纹理化渲染一个通过聚光灯照亮的木箱。这里我们通过将相应的纹理像素（texels）相乘来将这两个纹理组合起来。</p>
<p>注意：用第七章里的混合，结果图像依赖于纹理被混合的方式。在固定功能管线的多纹理化阶段，混合方程式被纹理渲染状态（texture render state）控制。用像素着色器，我们 能够以可编程的方式在代码中写出混合函数的简单表达式。这使我们可以用任何我们想要的方式混合纹理。我们将在讨论本章的例子程序时详细讨论纹理混合。</p>
<p>混合多个纹理（本例中是两个）来照亮木箱比起Direct3D的光照来有两个好处：</p>
<ul>
<li>光照是是预先在聚光灯的光照贴图里计算好的。因此，光照不需要在运行时被计算，这节省了处理时间。当然，只有静态对象和静态灯光的光照可以被预先计算。</li>
<li>因为光照图是预先计算好的，我们能够使用比Direct3D的（光照）模型多的多的更加精确的和成熟的光照模型。（更好的光照可以产生更真实的场景。）</li>
</ul>
<p>备注：多纹理化阶段的典型应用是实现静态对象的完全光照引擎（full lighting engine）。例如，我们可以用一个纹理贴图保存对象的颜色，比如木箱的纹理贴图。然后我们可以用一个散射光照贴图（diffuse light map）保存散射表面着色（diffuse surface shade），一个单独的镜面光照贴图保存镜面表面着色，一个雾状物贴图（fog map）保存覆盖在表面的雾状物的总量，还有可以用一个详细贴图（detail map）保存小的、高访问率的表面的细节。当所有这些纹理被组合起来，只需到这些预先计算的纹理中检索，就可以有效的照亮、着色并且增加细节到场景中去。</p>
<p>注意：聚光灯光照贴图在很基础的光照贴图中是一个价值不高（trivial）的例子。一般的的程序通过给定的场景和光源来生成光照贴图。生成光照贴图超越了本书的范围。有兴趣的读者可以参考Alan Watt和Fabio Policarpo在《3D Games: Real-time Rendering and Software Technology》中描述的光照贴图。</p>
<p>18.1.1 允许多个纹理<br>   回忆一下，纹理是用IDirect3DDevice9::SetTexture方法设置，而采样器状态（sampler state）是用IDirect3DDevice9::SetSamplerState方法设置，原型如下：<br>HRESULT IDirect3DDevice9::SetTexture(<br>     DWORD Stage, // specifies the texture stage index<br>     IDirect3DBaseTexture9 *pTexture<br>);</p>
<p>HRESULT IDirect3DDevice9::SetSamplerState(<br>     DWORD Sampler, // specifies the sampler stage index<br>     D3DSAMPLERSTATETYPE Type,<br>     DWORD Value<br>);</p>
<p>注意：一个特定的采样器阶段索引I联合第i个纹理阶段（texture stage）。即第i个采样器阶段指定采样器状态是第i集（set）纹理。</p>
<p>   纹理/采样器阶段索引标识了我们希望设置的纹理/采样器的纹理/采样器阶段。因此，我们可以允许多个纹理并通过使用不同的阶段索引设置其相应的采样器状态。在本书前面的部分中，我们总是指定0，来指示第一个阶段，因为我们一次仅使用一个纹理。所以例如，假设我们要允许三个纹理，我们像这样使用阶段0,1和2：<br>// Set first texture and corresponding sampler states.<br>Device-&gt;SetTexture(0, Tex1);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); </p>
<p>// Set second texture and corresponding sampler states.<br>Device-&gt;SetTexture(1, Tex2);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); </p>
<p>// Set third texture and corresponding sampler states.<br>Device-&gt;SetTexture(2, Tex3);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);<br>这段代码使用Tex1, Tex2和Tex3，并设置每个纹理的过滤模式。</p>
<p>18.1.2 多纹理坐标<br>   回忆一下第六章，对于每个3D三角形，我们应该在纹理上定义一个三角形以映射该3D三角形。我们通过对每个顶点增加纹理坐标完成映射。因此，每三个顶点定义一个三角形，它对应于纹理上的三角形。</p>
<p>   因为我们现在使用多纹理，每三个顶点定义一个三角形，我们需要在每个被使用的纹理上定义一个相应的三角形。我们通过给每个顶点增加额外的一套纹理坐标——每个顶点一套，对应于每个使用的纹理。举个例子，如果我们混合三个纹理到一起，那么每个顶点必须有三套纹理坐标以索引到三个使用的纹理。因此，一个包含三个纹理的多纹理化顶点结构看起来可能像这样：<br>struct MultiTexVertex<br>{<br>     MultiTexVertex(float x, float y, float z,<br>                    float u0, float v0,<br>                    float u1, float v1,<br>                    float u2, float v2)<br>     {<br>          _x =  x;   _y = y; _z = z;<br>          _u0 = u0;  _v0 = v0;<br>          _u1 = u1;  _v1 = v1;<br>          _u2 = u2;  _v2 = v2;<br>     } </p>
<pre><code> float _x, _y, _z;
 float _u0, _v0; // Texture coordinates for texture at stage 0.
 float _u1, _v1; // Texture coordinates for texture at stage 1.
 float _u2, _v2; // Texture coordinates for texture at stage 2. 

 static const DWORD FVF;
</code></pre><p>};<br>const DWORD MultiTexVertex::FVF = D3DFVF_XYZ | D3DFVF_TEX3;</p>
<p>注意，指定自由顶点格式标记D3DFVF_TEX3表明顶点结构包含3套纹理坐标。固定功能管线支持最多8套纹理坐标。如果多于8套，你必须使用顶点声明和可编程顶点管线。</p>
<p>注意：在新版本像素着色器中，我们可以使用一套纹理坐标集来索引多个纹理，并因此消除了对多个纹理坐标的需要。当然这得假设每个纹理阶段使用相同的纹理坐标。如果每个阶段的纹理坐标不同，则我们仍然需要多纹理坐标。</p>
<h1 id="像素着色器输入和输出"><a href="#像素着色器输入和输出" class="headerlink" title="像素着色器输入和输出"></a>像素着色器输入和输出</h1><p>有两样东西要输入到像素着色器：颜色和纹理坐标。两样都是以每像素为单位的。<br>注意：回想一下，顶点颜色是在图元的面（face of primitive）间进行插值的。<br>每个像素的纹理坐标就是简单的 (u , v) ，它指定了纹理的哪个图素被映射到像素上。在输入到像素着色器前，Direct3D根据顶点颜色和顶点纹理坐标，为每个像素计算颜色和纹理坐标。输入到像素着色器的颜色和纹理坐标的数值依赖于顶点着色器输出的颜色和纹理坐标的数值。例如，如果一个顶点着色器输出了两个颜色和三个纹理坐标，那么Direct3D将会为每个像素计算两个颜色和三个纹理坐标并且把它们把它们输入到像素着色器。我们使用带语意的语法（semantic syntax）映射输入颜色和纹理坐标进我们的着色器程序的变量里。用前面的例子，我们可以这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_INPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="built_in">vector</span> c0 : COLOR0;</span><br><span class="line">     <span class="built_in">vector</span> c1 : COLOR1;</span><br><span class="line">     float2 t0 : TEXCOORD0;</span><br><span class="line">     float2 t1 : TEXCOORD1;</span><br><span class="line">     float2 t2 : TEXCOORD2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于输出，像素着色器只输出一个计算过的该像素的颜色值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_OUTPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="built_in">vector</span> finalPixelColor : COLOR0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用像素着色器的步骤"><a href="#使用像素着色器的步骤" class="headerlink" title="使用像素着色器的步骤"></a>使用像素着色器的步骤</h1><p>下面的列表概述了创建和使用像素着色器的必要步骤：</p>
<ol>
<li>编写并编译像素着色器</li>
<li>创建一个IDirect3DPixelShader9接口来代表基于已编译代码的像素着色器</li>
<li>用IDirect3DDevice9::SetPixelShader方法允许该像素着色器</li>
</ol>
<p>当然，用完顶点着色器之后我们必须销毁它。下面几个小节将深入这些步骤。</p>
<p>18.3.1 编写并编译像素着色器<br>   我们用与编译顶点着色器一样的方式编译像素着色器。首先，我们必须编写一个像素着色器程序。本书中，我们用HLSL编写我们的着色器。一旦写好着色器代码，我们就可以用D3DXCompileShaderFromFile函数编译该着色器了，如16.2节所述。回忆一下，这个函数返回一个ID3DXBuffer指针，它包含已编译的着色器代码。</p>
<p>注意：因为我们使用的是像素着色器，所以要记得把编译目标改成像素着色器目标（比如：ps_2_0），而不是顶点着色器目标（比如：vs_2_0）。编译目标通过D3DXCompileShaderFromFile函数的一个参数指定。详见16.2节。<br>18.3.2 创建像素着色器<br>   一旦我们编译了着色器代码，我们就可以获得一个IDirect3DPixelShader的接口指针，它代表一个像素着色器，使用下面的方法：<br>HRESULT IDirect3DDevice9::CreatePixelShader(<br>      CONST DWORD <em>pFunction,<br>      IDirect3DPixelShader9*</em> ppShader<br>);<br>pFunction——已编译着色器代码的指针<br>ppShader——返回一个IDirect3DPixelShader9接口的指针</p>
<p>例如，假设变量shader是一个包含已编译着色器代码的ID3DXBuffer接口指针。那么要获得IDirect3DPixelShader9接口，我们应该写：<br>IDirect3DPixelShader9<em> MultiTexPS = 0;<br>hr = Device-&gt;CreatePixelShader(<br>           (DWORD</em>)shader-&gt;GetBufferPointer(),<br>           &amp;MultiTexPS);<br>注意：重申一遍，D3DXCompileShaderFromFile是一个可以返回已编译着色器代码（shader）的函数。</p>
<p>18.3.3 建立像素着色器<br>   在我们获得一个代表我们的像素着色器的IDirect3DPixelShader9接口的指针之后，我们可以使用下面的方法使用它：<br>HRESULT IDirect3DDevice9::SetPixelShader(<br>      IDirect3DPixelShader9* pShader<br>);<br>   这个方法只接受一个参数，我们通过它传递一个我们希望使用的指向像素着色器的指针。要使用我们在18.3.2节创建的像素着色器，我们应该写：<br>Device-&gt;SetPixelShader(MultiTexPS);</p>
<p>18.3.4 销毁像素着色器<br>   和其它所有Direct3D接口一样，要清除这些接口，我们必须在使用完毕后调用它们的Release方法。继续使用我们在18.3.2节创建的像素着色器，我们写：<br>d3d::Release<idirect3dpixelshader9*>(MultiTexPS);</idirect3dpixelshader9*></p>
<p>18.4 HLSL采样器对象<br>   在像素着色器中使用HLSL的内建函数tex*XXXX给纹理采样。<br>注意：采样时引用纹理上图素的坐标索引和采样器状态来生成像素。<br>   看16.7节详细地解释了这些函数，通常这些函数需要我们做2件事：</p>
<ul>
<li>使用纹理中的索引建立(u, v)纹理坐标。</li>
<li><p>给特定的纹理中编入索引。</p>
<p> 将纹理坐标（u, v）输入到像素着色器，在一个指定的HLSL对象中的像素着色器中，我们想编入索引的纹理是在像素着色器中被定义过的，在HLSL中叫作采样器。（The particular texture that we want to index into is identified in the pixel shader by a special HLSL object called a sampler.），我们可以把采样器对象想象成定义纹理和采样器阶段的对象。例如：假如我们使用3张纹理，这意味着我们需要在像素着色器里能够引用3个阶段中的每个一个。在像素着色器中我们这样写：<br>sampler FirstTex;<br>sampler SecondTex;<br>sampler ThirdTex;<br> Direct3D将给每个采样器对象连接一个唯一的纹理级别(stage)，在应用程序中我们找出与采样器对象相关联的阶段，并设置相应的纹理和采样器状态给该阶段。下列代码将举例说明如何在应用程序中设置纹理并把采样器状态设置为FirstTex：<br>// 创建<br>IDirect3DTexture9* Tex;<br>D3DXCreateTextureFromFile(Device, “tex.bmp”, &amp;Tex);<br>… …<br>// 取得常量FirstTex的句柄<br>FirstTexHandle = MultiTexCT-&gt;GetConstantByName(0, “FirstTex”);</p>
</li>
</ul>
<p>// 取得常量的描述<br>D3DXCONSTANT_DESC FirstTexDesc;<br>UINT count;<br>MultiTexCT-&gt;GetConstantDesc(FirstTexHandle, &amp;FirstTexDesc, &amp;count);<br>… …<br>// 为FirstTex设置纹理和采样器状态. We identify<br>// the stage FirstTex is associated with from the<br>// D3DXCONSTANT_DESC::RegisterIndex member:<br>Device-&gt;SetTexture(FirstTexDesc.RegisterIndex, Tex);</p>
<p>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);<br>   注意：作为选择，替换使用采样器类型，你可以使用更多特殊的、强大的类型，如：sampler1D，sampler2D，sampler3D，和samplerCube类型，这些类型更安全并且它们只使用tex<em> 函数。例如：一个sampler2D对象只使用tex2D</em>函数，同样一个sampler3D对象只使用tex3D*函数。<br>18.5 例子程序：Multitexturing in a Pixel Shader<br>   这章中的例子演示了在像素着色器中使用多纹理，这个例子将纹理一个基于图18.2方格，渲染的目标是一个木箱纹理，一个聚光灯纹理，和一个包含字符串的纹理。这就是例子程序：Pixel Shader。</p>
<p>   图18.2: 混合纹理. 让我们分别取得木箱纹理上、聚光灯纹理和字符串纹理上相关联的像素颜色：b，s和t，然后定义如何将这些颜色混合： c = b × s + t 。<br>   这个例子可以不使用像素着色器来实现，但实现这个程序是简单直接，它允许我们示范如何写，创建，而且使用像素着色器实现一些特效不必使用那些复杂的算法。<br>   虽然在这个例子中一次只使用3张纹理，检查采样器对象的成员以确定每个像素着色器能够使用的版本，这是值得的。换句话说，我们一次能使用多少纹理这依赖  于使用的像素着色器的版本。</p>
<ul>
<li>像素着色器的版本ps_1_1 到 ps_1_3支持4个纹理采样器。</li>
<li>像素着色器的版本ps_1_4支持6个纹理采样器。</li>
<li>像素着色器的版本ps_2_0到 ps_3_0支持16个纹理采样器。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: ps_multitex.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Desc: Pixel shader that does multitexturing.</span></span><br><span class="line"><span class="comment">// Globals</span></span><br><span class="line">sampler BaseTex;</span><br><span class="line">sampler SpotLightTex;</span><br><span class="line">sampler StringTex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Structures</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_INPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     float2 base      : TEXCOORD0;</span><br><span class="line">     float2 spotlight : TEXCOORD1;</span><br><span class="line">     float2 text      : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PS_OUTPUT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="built_in">vector</span> diffuse : COLOR0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main</span></span><br><span class="line"><span class="function">PS_OUTPUT <span class="title">Main</span><span class="params">(PS_INPUT input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// zero out members of output</span></span><br><span class="line">     PS_OUTPUT output = (PS_OUTPUT)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// sample appropriate textures</span></span><br><span class="line">     <span class="built_in">vector</span> b = tex2D(BaseTex,      input.base);</span><br><span class="line">     <span class="built_in">vector</span> s = tex2D(SpotLightTex, input.spotlight);</span><br><span class="line">     <span class="built_in">vector</span> t = tex2D(StringTex,    input.text);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// combine texel colors</span></span><br><span class="line">     <span class="built_in">vector</span> c =b *s +t;</span><br><span class="line">     <span class="comment">// increase the intensity of the pixel slightly</span></span><br><span class="line">     c += <span class="number">0.1f</span>;</span><br><span class="line">     <span class="comment">// save the resulting pixel color</span></span><br><span class="line">     output.diffuse = c;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先像素着色器定义了3个sampler对象，要渲染的每个纹理，接下来定义是input和output结构。注意：我们没有将任何的颜色值输入到像素着色器中，这是因为我们使用纹理自己的颜色和光照；即BaseTex保存表面的颜色，SpotLightTex是光照图。像素着色器输出只一个简颜色值，指定了我们计算过的这个特定像素的颜色。<br>Main函数使用tex2D函数采样3  个纹理，即它取得每个纹理的图素，计算映射到的像素，这通常依赖于指定的纹理坐标和采样器对象。然后我们混合图素的颜色用公式：c = b * s + t。接下来我们让全部的像素变亮一个bit，给每个部分增加0.1f。最后我们保存结果像素颜色并返回它。<br>现在我们看到了的像素着色器的代码，现在我们改变并考虑应用程序的代码。应用程序有下列相应的全局变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IDirect3DPixelShader9* MultiTexPS = <span class="number">0</span>;</span><br><span class="line">ID3DXConstantTable* MultiTexCT    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">IDirect3DVertexBuffer9* QuadVB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">IDirect3DTexture9* BaseTex      = <span class="number">0</span>;</span><br><span class="line">IDirect3DTexture9* SpotLightTex = <span class="number">0</span>;</span><br><span class="line">IDirect3DTexture9* StringTex    = <span class="number">0</span>;</span><br><span class="line">D3DXHANDLE BaseTexHandle      = <span class="number">0</span>;</span><br><span class="line">D3DXHANDLE SpotLightTexHandle = <span class="number">0</span>;</span><br><span class="line">D3DXHANDLE StringTexHandle    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">D3DXCONSTANT_DESC BaseTexDesc;</span><br><span class="line">D3DXCONSTANT_DESC SpotLightTexDesc;</span><br><span class="line">D3DXCONSTANT_DESC StringTexDesc;</span><br></pre></td></tr></table></figure></p>
<p>多纹理顶点结构的例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MultiTexVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     MultiTexVertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z,</span><br><span class="line">                    <span class="keyword">float</span> u0, <span class="keyword">float</span> v0,</span><br><span class="line">                    <span class="keyword">float</span> u1, <span class="keyword">float</span> v1,</span><br><span class="line">                    <span class="keyword">float</span> u2, <span class="keyword">float</span> v2)</span><br><span class="line">     &#123;</span><br><span class="line">          _x =  x;   _y =  y; _z = z;</span><br><span class="line">          _u0 = u0;  _v0 = v0;</span><br><span class="line">          _u1 = u1;  _v1 = v1;</span><br><span class="line">          _u2 = u2,  _v2 = v2;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">float</span> _x,  _y,  _z;</span><br><span class="line">     <span class="keyword">float</span> _u0,  _v0;</span><br><span class="line">     <span class="keyword">float</span> _u1,  _v1;</span><br><span class="line">     <span class="keyword">float</span> _u2,  _v2;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> DWORD MultiTexVertex::FVF = D3DFVF_XYZ | D3DFVF_TEX3;</span><br></pre></td></tr></table></figure></p>
<p>它包含3个纹理坐标系统。</p>
<p>Setup函数执行下列功能：</p>
<ul>
<li>填充方形的顶点缓存</li>
<li>编译着像素色器</li>
<li>创建像素色器</li>
<li>读取纹理</li>
<li>设置投影矩阵，不使用光照</li>
<li>取得采样器(sampler)对象的句柄</li>
<li>取得采样器对象的描述<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HRESULT hr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create quad geometry.</span></span><br><span class="line">    Device-&gt;CreateVertexBuffer(</span><br><span class="line">         <span class="number">6</span> * <span class="keyword">sizeof</span>(MultiTexVertex),</span><br><span class="line">        D3DUSAGE_WRITEONLY,</span><br><span class="line">        MultiTexVertex::FVF,</span><br><span class="line">        D3DPOOL_MANAGED,</span><br><span class="line">        &amp;QuadVB,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    MultiTexVertex*v =<span class="number">0</span>;</span><br><span class="line">    QuadVB-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">0</span>] = MultiTexVertex(<span class="number">-10.0f</span>, <span class="number">-10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">1</span>] = MultiTexVertex(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">2</span>] = MultiTexVertex( <span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">3</span>] = MultiTexVertex(<span class="number">-10.0f</span>, <span class="number">-10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    v[<span class="number">4</span>] = MultiTexVertex( <span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    v[<span class="number">5</span>] = MultiTexVertex( <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">5.0f</span>,</span><br><span class="line">                       <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    QuadVB-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compile shader</span></span><br><span class="line">    ID3DXBuffer* shader      = <span class="number">0</span>;</span><br><span class="line">    ID3DXBuffer* errorBuffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hr = D3DXCompileShaderFromFile(</span><br><span class="line">         <span class="string">"ps_multitex.txt"</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="string">"Main"</span>, <span class="comment">// entry point function name</span></span><br><span class="line">        <span class="string">"ps_1_1"</span>,</span><br><span class="line">        D3DXSHADER_DEBUG,</span><br><span class="line">        &amp;shader,</span><br><span class="line">        &amp;errorBuffer,</span><br><span class="line">        &amp;MultiTexCT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output any error messages</span></span><br><span class="line">    <span class="keyword">if</span>( errorBuffer )</span><br><span class="line">    &#123;</span><br><span class="line">        ::MessageBox(<span class="number">0</span>, (<span class="keyword">char</span>*)errorBuffer-&gt;GetBufferPointer(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        ::MessageBox(<span class="number">0</span>, <span class="string">"D3DXCompileShaderFromFile() - FAILED"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create Pixel Shader</span></span><br><span class="line">    hr = Device-&gt;CreatePixelShader((DWORD*)shader-&gt;GetBufferPointer(),&amp;MultiTexPS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        ::MessageBox(<span class="number">0</span>, <span class="string">"CreateVertexShader - FAILED"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d3d::Release&lt;ID3DXBuffer*&gt;(shader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load textures.</span></span><br><span class="line">    D3DXCreateTextureFromFile(Device, <span class="string">"crate.bmp"</span>, &amp;BaseTex);</span><br><span class="line">    D3DXCreateTextureFromFile(Device, <span class="string">"spotlight.bmp"</span>, &amp;SpotLightTex);</span><br><span class="line">    D3DXCreateTextureFromFile(Device, <span class="string">"text.bmp"</span>, &amp;StringTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set projection matrix</span></span><br><span class="line">    D3DXMATRIX P;</span><br><span class="line">    D3DXMatrixPerspectiveFovLH(&amp;P, D3DX_PI * <span class="number">0.25f</span>, (<span class="keyword">float</span>)Width / (<span class="keyword">float</span>)Height, <span class="number">1.0f</span>, <span class="number">1000.0f</span>);</span><br><span class="line"></span><br><span class="line">    Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable lighting.</span></span><br><span class="line">    Device-&gt;SetRenderState(D3DRS_LIGHTING, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get handles</span></span><br><span class="line">    BaseTexHandle      = MultiTexCT-&gt;GetConstantByName(<span class="number">0</span>, <span class="string">"BaseTex"</span>);</span><br><span class="line">    SpotLightTexHandle = MultiTexCT-&gt;GetConstantByName(<span class="number">0</span>, <span class="string">"SpotLightTex"</span>);</span><br><span class="line">    StringTexHandle    = MultiTexCT-&gt;GetConstantByName(<span class="number">0</span>, <span class="string">"StringTex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set constant descriptions:</span></span><br><span class="line">    UINT count;</span><br><span class="line"></span><br><span class="line">    MultiTexCT-&gt;GetConstantDesc(BaseTexHandle, &amp;BaseTexDesc, &amp;count);</span><br><span class="line">    MultiTexCT-&gt;GetConstantDesc(SpotLightTexHandle, &amp;SpotLightTexDesc, &amp;count);</span><br><span class="line">    MultiTexCT-&gt;GetConstantDesc(StringTexHandle,&amp;StringTexDesc, &amp;count);</span><br><span class="line"></span><br><span class="line">    MultiTexCT-&gt;SetDefaults(Device);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Display函数设置像素着色器，使用2个纹理，并且在渲染方格前设置他们对应的采样器状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">(<span class="keyword">float</span> timeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Device )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...camera update code snipped</span></span><br><span class="line">        <span class="comment">// Render</span></span><br><span class="line">        Device-&gt;Clear(<span class="number">0</span>, <span class="number">0</span>, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,</span><br><span class="line">                   <span class="number">0xffffffff</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">        Device-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the pixel shader</span></span><br><span class="line">        Device-&gt;SetPixelShader(MultiTexPS);</span><br><span class="line">     Device-&gt;SetFVF(MultiTexVertex::FVF);</span><br><span class="line">     Device-&gt;SetStreamSource(<span class="number">0</span>, QuadVB, <span class="number">0</span>, <span class="keyword">sizeof</span>(MultiTexVertex));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// base tex</span></span><br><span class="line">     Device-&gt;SetTexture(BaseTexDesc.RegisterIndex, BaseTex);</span><br><span class="line">     Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// spotlight tex</span></span><br><span class="line">     Device-&gt;SetTexture(SpotLightTexDesc.RegisterIndex, SpotLightTex);</span><br><span class="line">     Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// string tex</span></span><br><span class="line">     Device-&gt;SetTexture(     StringTexDesc.RegisterIndex, StringTex);</span><br><span class="line">     Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br><span class="line">     Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,</span><br><span class="line">                             D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// draw the quad</span></span><br><span class="line">     Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     Device-&gt;EndScene();</span><br><span class="line">     Device-&gt;Present(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然我们必须想着在Cleanup函数中释放我们自己分配的接口。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d3d::Release&lt;IDirect3DVertexBuffer9*&gt;(QuadVB);</span><br><span class="line">    d3d::Release&lt;IDirect3DTexture9*&gt;(BaseTex);</span><br><span class="line">    d3d::Release&lt;IDirect3DTexture9*&gt;(SpotLightTex);</span><br><span class="line">    d3d::Release&lt;IDirect3DTexture9*&gt;(StringTex);</span><br><span class="line"></span><br><span class="line">    d3d::Release&lt;IDirect3DPixelShader9*&gt;(MultiTexPS);</span><br><span class="line">    d3d::Release&lt;ID3DXConstantTable*&gt;(MultiTexCT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>像素着色器取代了固定功能管线的多纹理级别（stage），而且，像素着色器给我们更改单独像素的能力，以任何方式选择和访问纹理数据。因而，使我们能实现很多使用固定功能管线所不能完成的特殊效果。</li>
<li>多纹理是一次使用几个纹理，并渲染它们一起创造出一个想要的结果的一个过程。多纹理代表性的用法是用它为静态几何图形实现光引擎。</li>
<li>HLSL内建的采样器（sampler）对象，标识特定的纹理/采样器级别（stage）。A采样器常用于从像素着色器中引用一个纹理/采样器级别。</li>
</ul>
<p>注意：一旦你懂得了如何去实现顶点和像素着色器，你需要的一些特效的创意，可以用它们去实现。得到特效创意最好的方法是，学习现有的用顶点和像素着色器实现的特效。《Direct3D ShaderX: Vertex and Pixel Shader Tips》和《Tricks edited by Wolfgang Engel》这2本书是众多出版物中最好的，像Nvidia和ATI的开发站点：<a href="http://developer.nvidia.com/" target="_blank" rel="noopener">http://developer.nvidia.com/</a> 和 <a href="http://ati.com/developer/index.html。另外我们推荐CG方面：由Randima" target="_blank" rel="noopener">http://ati.com/developer/index.html。另外我们推荐CG方面：由Randima</a> Fernando 和 Mark J. Kilgard写的《The Cg Tutorial by Randima Fernando》，这本书对于使用Cg的3D图形编程是一本相当好的指南，它基本上和Direct3D’s HLSL相同。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Introduction-to-Vertex-Shaders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Introduction-to-Vertex-Shaders/" class="post-title-link" itemprop="url">Introduction-to-Vertex-Shaders</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:28:59" itemprop="dateCreated datePublished" datetime="2019-04-11T15:28:59+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Introduction-to-Vertex-Shaders/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Introduction-to-Vertex-Shaders/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>第十七章 顶点着色器入门(Introduction to Vertex Shaders)<br>概览<br>   顶点着色器（vertex shader）是一个在图形卡的GPU上执行的程序，它替换了固定功能管线（fixed function pipeline）中的变换（transformation）和光照（lighting）阶段。（这不是百分之百的正确，因为顶点着色器可以被Direct3D运行时（Direct3D runtime）以软件模拟，如果硬件不支持顶点着色器的话）。图16.1说明了管线中顶点着色器替换的部件。</p>
<p>图16.1：顶点着色器替换固定功能管线的光照和变形阶段</p>
<p>   从图16.1，我们知道，顶点以局部坐标输入到顶点着色器，并且必须输出齐次剪裁空间的有颜色的顶点。（为了保持简单，本书中我们没有深入研究投影变换的细节。但是经投影矩阵变换顶点后的空间称作齐次剪裁空间（homogeneous clip space）。因此，要把一个顶点从局部空间变换到齐次坐标空间，我们必须应用下列变换序列：世界变换（world transformation），视图变换（view transformation）和投影变换（projection transformation），它们分别由世界矩阵，视图矩阵和投影矩阵来完成。）对于点元（point primitive），顶点着色器也被用于操作每个顶点的顶点大小。</p>
<p>   由于顶点着色器是我们（在HLSL中）写的一个自定义程序，因此我们在图形效果方面获得了我们能够达到的极大的自由性。我们不再受限于Direct3D的固定光照算法。此外，应用程序操纵顶点位置的能力也有了多样性，例如：cloth simulation，粒子系统的点大小操纵，还有顶点混合/morphing。此外，我们的顶点数据结构更自由了，并且可以在可编程管线中包含比在固定功能管线中多得多的数据。</p>
<p>   顶点着色器仍然是相对新的特性，并且许多图形卡不支持它们，特别是随DirectX 9发布的较新版本的顶点着色器。通过检查D3DCAPS9结构的VertexShaderVersion成员，可以测试顶点着色器的版本。下列代码段展示了这一点：<br>// If the device’s supported version is less than version 2.0<br>if( caps.VertexShaderVersion &lt; D3DVS VERSION(2, 0) )<br>     // Then vertex shader version 2.0 is not supported on this device.</p>
<p>我们看到D3D_VERSION的两个参数分别接收主和次版本号。现在，D3DXCompileShaderFromFile函数支持顶点着色器版本1.1和2.0。</p>
<p>目标</p>
<ul>
<li>学习如何在可编程管线中定义顶点结构的分量</li>
<li>了解顶点分量的不同用法</li>
<li>学习如何创建、设置和销毁一个顶点着色器</li>
<li>学习如何使用顶点着色器实现卡通动画渲染效果</li>
</ul>
<p>17.1顶点声明<br>   到现在为止，我们已经使用自由顶点格式（flexible vertex format，FVF）来描述顶点结构中的各分量。但是，在可编程管线中，顶点数据包含的数据比用FVF所能表达的多很多。因此，我们通常使用更具表达性并且更强大的顶点声明（vertex declaration）。</p>
<p>注意：如果FVF能够描述我们的顶点格式 我们仍然可以在可编程管线中使用它。不管用何种方法，只是为了方便，同样FVF会在内部被转换为一个顶点声明。</p>
<p>17.1.1 描述顶点声明<br>   我们将一个顶点声明描述为一个D3DVERTEXELEMENT9结构的数组。D3DVERTEXELEMENT9数组中的每个成员描述了一个顶点的分量。所以，如果你的顶点结构有三个分量（例如：位置、法线、颜色），那么其相应的顶点声明将描述3个D3DVERTEXELEMENT9结构的数组。这个D3DVERTEXELEMENT9结构定义如下：<br>typedef struct _D3DVERTEXELEMENT9 {<br>     BYTE Stream;<br>     BYTE Offset;<br>     BYTE Type;<br>     BYTE Method;<br>     BYTE Usage;<br>     BYTE UsageIndex;<br>} D3DVERTEXELEMENT9;</p>
<ul>
<li>Stream——指定关联到顶点分量的流</li>
<li>Offset——偏移，按字节，相对于顶点结构成员的顶点分量的开始。例如，如果顶点结构是：<br>struct Vertex<br>{<br>   D3DXVECTOR3 pos;<br>   D3DXVECTOR3 normal;<br>};<br>……pos分量的偏移是0，因为它是第一个分量；normal分量的偏移是12，因为sizeof(pos) == 12。换句话说，normal分量以Vertex的第12个字节为开始。</li>
<li>Type——指定数据类型。它可以是D3DDECLTYPE枚举类型的任意成员；完整列表请参见文档。常用类型如下：</li>
<li>D3DDECLTYPE_FLOAT1——浮点数值</li>
<li>D3DDECLTYPE_FLOAT2——2D浮点向量</li>
<li>D3DDECLTYPE_FLOAT3——3D浮点向量</li>
<li>D3DDECLTYPE_FLOAT4——4D浮点向量</li>
<li><p>D3DDECLTYPE_D3DCOLOR—D3DCOLOR类型，它扩展为RGBA浮点颜色向量(r g b a)，其每一分量都是归一化到区间[0, 1]了的。</p>
</li>
<li><p>Method——指定网格化方法。我们认为这个参数是高级的，因此我们使用默认值，标识为D3DDECLMETHOD_DEFAULT.。</p>
</li>
<li><p>Usage——指定已计划的对顶点分量的使用。例如，它是否准备用于一个位置向量、法线向量、纹理坐标等？有效的用途标识符（usage identifier）是D3DDECLUSAGE枚举类型的：<br>typedef enum _D3DDECLUSAGE {<br>   D3DDECLUSAGE_POSITION     = 0,  // Position.<br>   D3DDECLUSAGE_BLENDWEIGHTS = 1,  // Blending weights.<br>   D3DDECLUSAGE_BLENDINDICES = 2,  // Blending indices.<br>   D3DDECLUSAGE_NORMAL       = 3,  // Normal vector.<br>   D3DDECLUSAGE_PSIZE        = 4,  // Vertex point size.<br>   D3DDECLUSAGE_TEXCOORD     = 5,  // Texture coordinates.<br>   D3DDECLUSAGE_TANGENT      = 6,  // Tangent vector.<br>   D3DDECLUSAGE_BINORMAL     = 7,  // Binormal vector.<br>   D3DDECLUSAGE_TESSFACTOR   = 8,  // Tessellation factor.<br>   D3DDECLUSAGE_POSITIONT    = 9,  // Transformed position.<br>   D3DDECLUSAGE_COLOR        = 10, // Color.<br>   D3DDECLUSAGE_FOG          = 11, // Fog blend value.<br>   D3DDECLUSAGE_DEPTH        = 12, // Depth value.<br>   D3DDECLUSAGE_SAMPLE       = 13  // Sampler data.<br>} D3DDECLUSAGE;</p>
<p> D3DDECLUSAGE_PSIZE类型用于指定一个顶点的点的大小。它用于点精灵，因此我们可以基于每个顶点控制其大小。一个D3DDECLUSAGE_POSITION成员的顶点声明意味着这个顶点已经被变换，它通知图形卡不要把这个顶点送到顶点处理阶段（变形和光照）。</p>
</li>
</ul>
<p>注意：这些中的少数用途类型（usage type）未在本书中提及，例如BLENDWEIGHTS, BLENDINDICES, TANGENT, BINORMAL, 和TESSFACTOR</p>
<ul>
<li>UsageIndex——用于标识多个相同用途的顶点分量。这个用途索引是位于区间[0, 15]间的一个整数。例如，假设我们有三个用途为D3DDECLUSAGE_NORMAL的顶点分量。我们可以为第一个指定用途索引为0，为第二个指定用途索引为1，并且为第三个指定用途索引为2。按这种方式，我们可以通过其用途索引标识每个特定的法线。</li>
</ul>
<p>顶点描述声明的例子：假设我们想要描述的顶点格式由位置向量和三个法线向量组成。顶点声明可以指定如下：<br>D3DVERTEXELEMENT9 decl[] =<br>{<br>{0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_POSITION, 0},<br>　<br>{0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 0},<br>　<br>{0, 24, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 1},<br>　<br>{0, 36, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 2},</p>
<p>D3DDECL_END()<br>};<br>D3DDECL_END宏用于初始化D3DVERTEXELEMENT9数组的最后一个顶点元素。同样的，注意法线向量的用途索引标签。</p>
<p>17.1.2 创建顶点声明<br>一旦你描述了一个顶点声明为D3DVERTEXELEMENT9数组，我们就可以使用下面的方法获得一个IDirect3DVertexDeclaration9接口指针：<br>HRESULT IDirect3DDevice9::CreateVertexDeclaration(<br>     CONST D3DVERTEXELEMENT9<em> pVertexElements,<br>     IDirect3DVertexDeclaration9*</em> ppDecl<br>);</p>
<ul>
<li>pVertexElements——D3DVERTEXELEMENT9结构数组，它描述我们想要创建的顶点声明。</li>
<li>ppDecl——用于返回创建的IDirect3DVertexDeclaration9接口指针<br>例子调用，其中decl是一个D3DVERTEXELEMENT9数组：<br>IDirect3DVertexDeclaration9* _decl = 0;<br>hr = _device-&gt;CreateVertexDeclaration(decl, &amp;_decl);</li>
</ul>
<p>17.1.3 使用一个顶点声明<br>   回忆一下：自由顶点格式是一个方便的特性并且在内部转换成了顶点声明。因此，当直接使用顶点声明，我们不再需要调用：Device-&gt;SetFVF( fvf );<br>相反，我们调用：Device-&gt;SetVertexDeclaration( _decl );<br>其中，_decl是一个IDirect3DVertexDeclaration9接口指针。<br>17.2顶点数据用途<br>考虑这个顶点声明：<br>D3DVERTEXELEMENT9 decl[] =<br>{<br>{0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_POSITION, 0},</p>
<p>{0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL,   0},</p>
<p>{0, 24, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL,   1},</p>
<p>{0, 36, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>  D3DDECLUSAGE_NORMAL,   2},</p>
<p>D3DDECL_END()<br>};</p>
<p>   我们需要一种方式，来定义一个顶点声明的元素到顶点着色器的Input结构的数据成员的映射。我们在Input结构中通过指定每个数据成员的语义（: usage-type [usage-index]）定义这个映射。语义通过元素的用途类型和用途索引标识顶点声明中的一个元素。由数据成员的语义标识的顶点元素是得以映射到数据成员的元素。例如，对应于前面的顶点声明的输入结构是：<br>struct VS_INPUT<br>{<br>     vector position    : POSITION;<br>     vector normal     : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};</p>
<p>注意：如果我们遗漏了用途索引，就意味着用途索引为零。例如，POSITION和POSITION0是同一样东西。</p>
<p>   这里decl中的元素0，由用途POSITION和用途索引0标识，它映射到position。decl中的元素1，由用途NORMAL和用途索引0标识，它映射到normal。decl中的元素2，由NORMAL和用途索引1标识，它映射到faceNormal1。decl中的元素3，由用途NORMAL和用途索引2标识，它映射到faceNormal2。</p>
<p>受支持的顶点着色器输入用途（input usage）是：</p>
<ul>
<li>POSITION [n]——位置</li>
<li>BLENDWEIGHTS [n]——混合权重</li>
<li>BLENDINDICES [n]——混合索引</li>
<li>NORMAL [n]——法线向量</li>
<li>PSIZE[n]——顶点大小</li>
<li>DIFFUSE [n]——散射颜色</li>
<li>SPECULAR [n]——镜面颜色</li>
<li>TEXCOORD [n]——纹理坐标<br>其中，n是一个位于区间[0, 15]的可选整数。</li>
</ul>
<p>注意：再重复一遍，这些用途类型中的少数未在本书中提及，如：BLENDWEIGHTS, TANGENT, BINORMAL, BLENDINDICES, 和TESSFACTOR。</p>
<p>   此外，对于输出结构，我们必须指定每个成员是用来做什么的。例如，数据成员应该被作为位置向量、颜色、纹理坐标等对待吗？图形卡没主意，除非你强制的告诉它。这也需要通过语法的语义来完成：<br>struct VS_OUTPUT<br>{<br>     vector position  : POSITION;<br>     vector diffuse   : COLOR0;<br>     vector specular  : COLOR1;<br>};</p>
<p>受支持的顶点着色器输出用途是：</p>
<ul>
<li>POSITION—位置</li>
<li>PSIZE—顶点大小</li>
<li>FOG—雾混合值</li>
<li>COLOR [n]—顶点颜色。注意：可以有多个顶点颜色被输出，并且这些颜色可以被混合在一起以产生最终的颜色。</li>
<li>TEXCOORD [n]—顶点纹理坐标。注意：多个顶点纹理坐标可以被输出。<br>其中，n是一个位于区间[0, 15]的可选整数。</li>
</ul>
<p>17.3使用顶点着色器的步骤<br>下面的列表概括了创建和使用顶点着色器的必须步骤：</p>
<ol>
<li>编写并编译顶点着色器</li>
<li>创建一个IDirect3DVertexShader9接口以引用已编译的着色器代码上的顶点着色器。</li>
<li>用IDirect3DDevice9:: SetVertexShader方法使用这个顶点着色器。</li>
</ol>
<p>当然，在我们做完这些之后，我们还得销毁这个顶点着色器。下面的各小节将更详细的迈入这些步骤。</p>
<p>17.3.1 编写并编译顶点着色器<br>   首先，我们必须编写一个顶点着色器程序。在本书中的HLSL一章中，我们已经编写了我们的着色器（译者注：参见我翻译的译文第一章中各节）。一旦着色器代码写好之后，我们就使用D3DXCompileShaderFromFile函数编译这个着色器，如16.2.2节所述。回忆一下，这个函数返回一个ID3DXBuffer指针，它包含已编译的着色器代码。</p>
<p>17.3.2 创建顶点着色器<br>   一旦我们拥有了编译好的着色器代码，我们就能够获得一个IDirect3DVertexShader9接口的指针，它代表一个顶点着色器——通过使用下面的方法：<br>HRESULT IDirect3DDevice9::CreateVertexShader(<br>     const DWORD <em>pFunction,<br>     IDirect3DVertexShader9*</em> ppShader<br>);<br>pFunction——已编译着色器代码的指针<br>ppShader——返回一个IDirect3DVertexShader9接口的指针</p>
<p>例如，假设变量shader是一个包含已编译的，着色器代码的ID3DXBuffer指针。然后要获得一个IDirect3DVertexShader9接口，我们可以写：<br>IDirect3DVertexShader9<em> ToonShader = 0;<br>hr = Device-&gt;CreateVertexShader(<br>           (DWORD</em>)shader-&gt;GetBufferPointer(),<br>           &amp;ToonShader);<br>注意：重申一遍，D3DXCompileShaderFromFile是一个函数，它将返回已编译着色器的代码（shader）。</p>
<p>17.3.3 建立顶点着色器<br>   在我们获得了一个代表我们的顶点着色器的IDirect3DVertexShader9接口的指针之后，我们就能够使用下面的方法使用它：<br>HRESULT IDirect3DDevice9::SetVertexShader(<br>     IDirect3DVertexShader9* pShader<br>);<br>这个方法仅接受一个参数，我们在其中传递一个想要使用的顶点着色器的指针。要使用这个我们在17.3.2节创建的着色器，我们可以写：Device-&gt;SetVertexShader(ToonShader);</p>
<p>17.3.4 销毁顶点着色器<br>   和所有的Direc3D接口一样，要清除他们，我们就必须在用完它们之后调用其的Release方法。仍然以我们在17.3.2节创建的顶点着色器为例，我们写：<br>d3d::Release<idirect3dvertexshader9*>(ToonShader);</idirect3dvertexshader9*></p>
<p>17.4样例应用程序：散射光照<br>   作为创建并使用顶点着色器的热身，我们写一个顶点着色器，它用一个方向（平行）光对每个顶点进行标准的散射光照。简而言之，散射光照根据顶点法线和光线向量（它的点朝向光源方向）的角度计算顶点接收到的光线的数量。角度越小，则顶点接收到的光线就越多；而角度越大，则顶点接收到的光线就越少。如果角度大于等于90度，顶点就接收不到光线了。</p>
<p>我们以检阅着色器代码作为开始：<br>// File: diffuse.txt<br>// Desc: Vertex shader that does diffuse lighting.<br>// Global variables we use to hold the view matrix, projection matrix,<br>// ambient material, diffuse material, and the light vector that<br>// describes the direction to the light source. These variables are<br>// initialized from the application.</p>
<p>matrix ViewMatrix;<br>matrix ViewProjMatrix;<br>vector AmbientMtrl;<br>vector DiffuseMtrl;<br>vector LightDirection;</p>
<p>// 环境光强度，漫射光强度<br>// 这些变量定义在着色器代码中<br>vector DiffuseLightIntensity = {0.0f, 0.0f, 1.0f, 1.0f};<br>vector AmbientLightIntensity = {0.0f, 0.0f, 0.2f, 1.0f};</p>
<p>// Input and Output structures.<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};</p>
<p>//Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     // zero out all members of the output instance.<br>     VS_OUTPUT output = (VS_OUTPUT)0;</p>
<pre><code> // 变换位置到齐次坐标空间，保存到output.position成员中
 output.position = mul(input.position, ViewProjMatrix);

 // 变换光和法线到视图空间，设置w分量为0，是因为变换的向量不是点 
 LightDirection.w = 0.0f;
 input.normal.w  = 0.0f;
 LightDirection   = mul(LightDirection, ViewMatrix);
 input.normal    = mul(input.normal, ViewMatrix);

 // 计算光与法线夹角的余弦
 float s = dot(LightDirection, input.normal); 

 // 回忆一下，如果法线和光的夹角大于90度，则表面接收不到光。
 if( s &lt; 0.0f )
     s = 0.0f;

 // 环境光反射是执行一个叉积（环境材质向量与环境光强度向量），
 // 漫射光反射是执行一个叉积（漫射材质向量与漫射光强度向量，
 // 更进一步讲，我们测量着色器的颜色，基于顶点从光源处接收到多少光
 //环境光和漫射光综合起来，决定一个顶点的最终颜色
 output.diffuse = (AmbientMtrl * AmbientLightIntensity) +
                  ((DiffuseMtrl * DiffuseLightIntensity) * s);
 return output;
</code></pre><p>}</p>
<p>   既然我们已经看到了实际的顶点着色器的代码，那么就让我们改变方式来看看应用程序的代码。这个应用程序有下列相关的全局变量：<br>IDirect3DVertexShader9<em> DiffuseShader = 0;<br>ID3DXConstantTable</em> DiffuseConstTable = 0;<br>ID3DXMesh* Teapot               = 0;<br>D3DXHANDLE ViewMatrixHandle     = 0;<br>D3DXHANDLE ViewProjMatrixHandle = 0;<br>D3DXHANDLE AmbientMtrlHandle    = 0;<br>D3DXHANDLE DiffuseMtrlHandle    = 0;<br>D3DXHANDLE LightDirHandle       = 0;<br>D3DXMATRIX Proj;<br>   有代表顶点着色器及其常量表的变量，有茶壶网格的变量，接着是一组D3DXHANDLE，其名字描述了他们引用的变量：</p>
<p>Setup函数执行下列任务：</p>
<ul>
<li>创建茶壶网格</li>
<li>编译顶点着色器</li>
<li>根据已编译代码创建顶点着色器</li>
<li>通过常量表获取着色器程序中的几个变量的句柄</li>
<li>通过常量表初始化着色器的这几个变量</li>
</ul>
<p>注意：对于本应用程序，我们的顶点结构不需要任何自由顶点格式没有的额外的分量。因此，在本例中，我们使用一个自由顶点格式来代替顶点声明。回想一下，自由顶点格式描述最终在内部被转换为一个顶点声明。<br>bool Setup()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> // Create geometry:
 D3DXCreateTeapot(Device, &amp;Teapot, 0); 

 // Compile shader
 ID3DXBuffer* shader      = 0;
 ID3DXBuffer* errorBuffer = 0;

 hr = D3DXCompileShaderFromFile(
      &quot;diffuse.txt&quot;,
      0,
      0,
      &quot;Main&quot;, // entry point function name
      &quot;vs_1_1&quot;,
      D3DXSHADER_DEBUG,
      &amp;shader,
      &amp;errorBuffer,
      &amp;DiffuseConstTable);

 // output any error messages
 if( errorBuffer )
 {
    ::MessageBox(0, (char*)errorBuffer-&gt;GetBufferPointer(), 0, 0);
    d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);
 }

 if(FAILED(hr))
 {
    ::MessageBox(0, &quot;D3DXCompileShaderFromFile() - FAILED&quot;, 0, 0);
    return false;
 }

 // Create shader
 hr = Device-&gt;CreateVertexShader(
      (DWORD*)shader-&gt;GetBufferPointer(),
      &amp;DiffuseShader);

  if(FAILED(hr))
 {
    ::MessageBox(0, &quot;CreateVertexShader - FAILED&quot;, 0, 0);
    return false;
 }

 d3d::Release&lt;ID3DXBuffer*&gt;(shader);

 // Get Handles
 LightDirHandle    = DiffuseConstTable-&gt;GetConstantByName(0, &quot;LightDirection&quot;);
 ViewMatrixHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;ViewMatrix&quot;);
 ViewProjMatrixHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;ViewProjMatrix&quot;);
 AmbientMtrlHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;AmbientMtrl&quot;);
 DiffuseMtrlHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;DiffuseMtrl&quot;);


 // Set shader constants:
 // Light direction:
 D3DXVECTOR4 directionToLight(-0.57f, 0.57f, -0.57f, 0.0f);
 DiffuseConstTable-&gt;SetVector(Device, LightDirHandle,  &amp;directionToLight); 

 // Materials:
 D3DXVECTOR4 ambientMtrl(0.0f, 0.0f, 1.0f, 1.0f);
 D3DXVECTOR4 diffuseMtrl(0.0f, 0.0f, 1.0f, 1.0f);
 DiffuseConstTable-&gt;SetVector(Device,AmbientMtrlHandle,&amp;ambientMtrl);
 DiffuseConstTable-&gt;SetVector(Device,DiffuseMtrlHandle,&amp;diffuseMtrl);

 DiffuseConstTable-&gt;SetDefaults(Device);

 // Compute projection matrix.
 D3DXMatrixPerspectiveFovLH(
   &amp;Proj, D3DX PI * 0.25f,
   (float)Width / (float)Height, 1.0f, 1000.0f);

 return true;
</code></pre><p>}</p>
<p>   Display函数非常简单。它检测用户输入（译者注：这里指的是用户输入的传入着色器程序的变量），并相应的更新视图矩阵。但是，因为我们在着色器中执行这个视图矩阵变换，所以我们还必须更新着色器中的视图矩阵变量。我们用常量表完成这件事情。<br>bool Display(float timeDelta)<br>{<br>     if( Device )<br>     {<br>          // Update view matrix code snipped…<br>          D3DXMATRIX V;<br>          D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;target, &amp;up);<br>          DiffuseConstTable-&gt;SetMatrix(Device, ViewMatrixHandle, &amp;V);<br>          D3DXMATRIX ViewProj =V *Proj;</p>
<pre><code>      DiffuseConstTable-&gt;SetMatrix(Device, ViewProjMatrixHandle,
                                  &amp;ViewProj);

      // Render
      Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                    0xffffffff, 1.0f, 0);
      Device-&gt;BeginScene();
      Device-&gt;SetVertexShader(DiffuseShader);
      Teapot-&gt;DrawSubset(0);
      Device-&gt;EndScene();
      Device-&gt;Present(0, 0, 0, 0);
 }
 return true;
</code></pre><p>}</p>
<p>同样注意，就在DrawSubset调用之前，我们允许了这个我们希望使用的顶点着色器。<br>清理也需要被完成；我们简单的释放了这个已分配的接口：<br>void Cleanup()<br>{<br>     d3d::Release<id3dxmesh*>(Teapot);<br>     d3d::Release<idirect3dvertexshader9*>(DiffuseShader);<br>     d3d::Release<id3dxconstanttable*>(DiffuseConstTable);<br>}</id3dxconstanttable*></idirect3dvertexshader9*></id3dxmesh*></p>
<p>17.5 卡通渲染<br>   作为第二个顶点着色器的例子，让我们编写两个顶点着色器，它们以卡通风格的绘画方式对网格着色（shade）并画轮廓（outline）。图17.2展示了这一点：</p>
<p>图17.2：（a）使用卡通着色法着色的对象（注意着色间的尖锐过渡）。（b）增强卡通效果，轮廓边（silhouette edge）被勾出。（c）使用标准散射光照着色的对象</p>
<p>注意：卡通渲染是一种特定类型的非写实渲染（non-photorealistic rendering），有时被称作风格化渲染（stylistic rendering）。</p>
<p>   虽然卡通渲染不适用于所有游戏，例如激烈的第一人称射击游戏，但是它仍然可以增强一些希望表现卡通感觉类型游戏的气氛。此外，卡通渲染是漂亮的，并易于实现。让我们好好的演示一个顶点着色器。</p>
<p>我们将卡通渲染分为两步：</p>
<ol>
<li>卡通绘画的特点是：在一个顶点到下一个顶点的强烈转换时，有少量的阴影强度级别；我们看一下这个卡通阴影（cartoon shading）。在图17.2（a）中，我们看到网络着色使用了三种阴影强度（亮、中、暗），而且其间的过渡是不平滑的——不像图17.2（c），其明暗过渡是平滑的。</li>
<li>卡通绘图的主要特点是：在其外框上勾画轮廓，如图17.2（b）所示。<br>这两个步骤都需要其各自的顶点着色器。</li>
</ol>
<p>17.5.1 卡通着色<br>   要实现卡通着色，我们采用Lander在2000年3月发表在Game Developer Magazine的文章“Shades of Disney: Opaquing a 3D World”中所描述的方法。它像这样工作：我们创建一个带强度级别的灰度纹理，它包含我们需要的不同的着色强度。图17.3显示了我们在样例程序中使用的这个纹理。</p>
<p>图 17.3：用来保存着色强度的着色纹理。注意观察不连续的着色间过渡和纹理着色强度必须从左到右增加。<br>   然后在顶点着色器中，我们执行标准散射点积运算（standard diffuse calculation dot product）来确定顶点法线N和光线向量L之间角度的余弦，用以确定顶点接收到多少光线：s=L·N</p>
<p>   如果s＜0，就表示光线向量和顶点法线之间的角度大于90度，也就表示该表面接收不到光线。因此，如果s＜0，我们就让s＝0。所以s ∈ [0, 1]。</p>
<p>   现在，在通常的散射光照模型中，我们使用s来标记颜色向量。这样，顶点颜色的明暗取决于接收到的光照的数量：diffuseColor = s(r, g, b, a)<br>   但是，这将会导致从亮到暗之间平滑的着色。这是与我们期望的卡通着色相反的。我们想要一种在几个不同着色器间突然转换颜色的效果（对卡通渲染来说，在2至4种着色器工作起来还是挺不错的）。</p>
<p>   不使用s来标记颜色向量，我们将使用s作为早先提到的强度纹理的u纹理坐标——如图17.3。<br>注意：标量（scalar）s必定是一个有效的纹理坐标，因为s ∈ [0, 1]，这是通常的纹理坐标区间。</p>
<p>   按这种方式，顶点不会被平滑着色，而是间断的。例如，强度纹理可能被分成3种着色，如图17.4所示：</p>
<p>图17.4：那么，s ∈ [0, 0.33]的值使用shader0着色，s ∈ [ 0.33，0.66]的值使用shader1着色，s ∈ [0.66,1]的值使用shader2着色。当然，从这些着色的一种到另一种的过渡是不平滑的，这就赋予了我们期望的效果。</p>
<p>注意：我们还为卡通着色关闭了纹理过滤，因为这种过滤会试图使着色过渡变平滑。这对于我们要求的不连续过渡是多余的。</p>
<p>17.5.2 卡通着色的顶点着色器代码<br>   我们现在介绍卡通着色的顶点着色器。这个着色器的主要任务只是根据s=L·N计算并设置纹理坐标。注意观察输出结构，我们已经增加了一个数据成员来存储已被计算过的纹理坐标。同时还需注意，我们仍然输出顶点颜色，虽然我们不修改它，不过当颜色被与强度纹理组合起来的时候，它呈现为被着色的。<br>// File: toon.txt<br>// Desc: Vertex shader that lights geometry so it appears to be<br>// drawn in a cartoon style.</p>
<p>// Globals<br>extern matrix WorldViewMatrix;<br>extern matrix WorldViewProjMatrix;<br>extern vector Color;<br>extern vector LightDirection;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};</p>
<p>// Structures<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     float2 uvCoords : TEXCOORD;<br>     vector diffuse  : COLOR;<br>};</p>
<p>// Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>      // zero out each member in output<br>　　　VS_OUTPUT output = (VS_OUTPUT)0;<br>　　　<br>      // transform vertex position to homogenous clip space<br>　　　output.position = mul(input.position, WorldViewProjMatrix);<br>　　　<br>      // Transform lights and normals to view space.  Set w<br>      // components to zero since we’re transforming vectors.<br>      // Assume there are no scalings in the world<br>      // matrix as well.<br>      LightDirection.w = 0.0f;<br>      input.normal.w   = 0.0f;<br>      LightDirection   = mul(LightDirection, WorldViewMatrix);<br>      input.normal     = mul(input.normal, WorldViewMatrix);</p>
<pre><code>  // Compute the 1D texture coordinate for toon rendering.
</code></pre><p>　　　float u = dot(LightDirection, input.normal);<br>　　　<br>      // Clamp to zero if u is negative because u<br>      // negative implies the angle between the light<br>      // and normal is greater than 90 degrees.  And<br>      // if that is true then the surface receives no light.<br>      if(u &lt; 0.0f)<br>         u = 0.0f;</p>
<pre><code>  // Set other tex coord to middle.
  float v = 0.5f;
  output.uvCoords.x = u;
  output.uvCoords.y = v;

  // save color
</code></pre><p>　　　output.diffuse = Color;<br>　　　<br>      return output;<br>}</p>
<p>两点注解：</p>
<ul>
<li>我们假设世界矩阵没有执行任何缩放。因为如果它执行，它就会弄乱乘以它的顶点的长度和方向。</li>
<li>我们总是设置v纹理坐标为纹理的中点。这意味着我们仅使用纹理中一条单一的线，那就是说我们可以使用1D强度纹理来代替2D的那个纹理。不管怎样，1D和2D纹理都能工作。本例中，我们使用了2D纹理而不是1D纹理，这是没有什么特别的原因的。</li>
</ul>
<p>17.5.3轮廓勾勒<br>要完成卡通效果，我们还需要勾勒（outline）轮廓边（silhouette edge）。这比卡通着色稍微复杂一点。</p>
<p>17.5.3.1 边的表示法<br>我们将一个网格的一条边表示为一个四元组（构建自2个三角形）——参见图17.5。</p>
<p>图 17.5：表示边的四元组</p>
<p>   我们选择四元组有两个原因：我们可以通过调整四元组的维容易的改变边的厚度，并且我们可以渲染退化的四元组来隐藏某些边，也即非轮廓边。在Direct3D中，我们从两个三角形来构建一个四元组。退化四元组（degenerate quad）是从两个退化三角形构建而来的四元组。退化三角形（degenerate triangle）是一个面积为零的三角形，或者换句话说，是一个三点位于一线上的三角形。如果我们传入一个退化三角形到渲染管线，则该三角形显示为空。这是很有用的，因为如果我们希望隐藏特定三角形，我们可以简单的退化它而不需要实际的从三角形列表（顶点缓冲）移除它。回想一下，我们只需要显示轮廓边——而不是网格的每一条边。</p>
<p>   当我们首先创建一条边的时候，我们指定其四个顶点，并使其退化，这意味着边将会被隐藏（渲染时不显示）。</p>
<p>图17.6：由两个三角形共用边描述的退化四元组</p>
<p>   注意图17.6中的两个顶点v0和v1，我们设置其顶点法线向量为零向量。然后当我们将边的顶点送入顶点着色器的时候，顶点着色器将会检测顶点是否位于轮廓边上；如果是，则顶点着色器将按顶点法线的方向偏移顶点位置的标量。观察法线向量为零的顶点，它不会被偏移。</p>
<p>因此，我们最终以一个非退化四元组（non-degenerate quad）来表示轮廓边，如图17.7所示。</p>
<p>图17.7：位于轮廓边上的顶点v2和v3被按照其各自的顶点法线n2和n3进行偏移。观察顶点v0和v1仍然保持在其固定位置，因为其顶点法线等于零向量，因此对于它们来说没有偏移发生。按这种方式，四元组成功的重新生成来表示轮廓边。</p>
<p>备注：如果我们没有设置顶点v0和v1的顶点法线为零向量，那么那些顶点就同样会被偏移。但是如果偏移描述轮廓边的所有四个顶点，那么我们仅是平移了该退化四元组。通过保持顶点v0和v1固定并仅仅偏移顶点v2和v3，我们重新生成了四元组。</p>
<p>17.5.3.2 轮廓边测试<br>   若两个三角面face0和face1在视图方向上与两个不同方向的面共享同一条边，则该边为轮廓边。也就是说，如果一个面是前面（front facing）而另一个面是后面（back facing），那么这条边就是一条轮廓边。图17.8给出了一个轮廓边和一个非轮廓边的例子。</p>
<p>图17.8：在（a）中，由v0 和v1定义的共享边的一个面是前面，而共享边另一个面是背面，因此该边是轮廓边。在（b）中，由v0 和v1定义的这两个共享边面都是前面，因此该边不是轮廓边。</p>
<p>   接下来，为了检测一个顶点是否在轮廓边上，我们必须以每个顶点为基础了解face0 和 face1的法线向量。我们的边的顶点数据结构反映如下：<br>struct VS_INPUT<br>{<br>     vector position    : POSITION;<br>     vector normal      : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};</p>
<p>   前两个分量很直接，但让我们看看两个额外的法线向量，它们是faceNormal1和faceNormal2。这些向量描述了两个三角面的面法线，共享边的顶点位于这两个面的共享边上，这两个面是face0和face1。</p>
<p>   实际检测顶点是否在共享边上的数学如下。假设我们在视图空间中，令v为一原点指向检测顶点的向量——图17.8，令n0为face0的面法线且n1为face0的面法线，若下面的不等式为真，则顶点位于轮廓边上：<br>（1）（v·n0）（v·n1）＜0</p>
<p>   若两点积符号相异，则不等式为真，使得不等式左边为负。回想一下点积的性质：两个点积的符号相异，这意味着一个三角面是前面而另一个是后面。</p>
<p>   现在，考虑一条边只有一个三角形共享它的情况，如图17.9，其法线将会被存储在faceNormal1中。</p>
<p>图 17.9：顶点v0和v1定义的边只有一个三角面共享它</p>
<p>   我们定义这种边总为轮廓边。要确保顶点着色器将这种边作为轮廓边处理，我们要让faceNormal2 = -faceNormal1。因此，反向的面法线和不等式（1）为真，表示该边为一轮廓边。</p>
<p>17.5.3.3 边的生成<br>   生成网格的边是微不足道的；我们简单的遍历网格的每个三角面并为三角面上每条边计算一个四元组（退化的，如图17.6所示）。<br>注意：每个三角面有三条边，因为每个三角形有三条边。</p>
<p>   对于每条边上的顶点，我们同样需要知道共享边的两个三角面。一个面是边所在的三角形。例如，如果要计算第1个面的一条边，那么第1个面共享该边。共享该边的另一个面可以使用网格的邻接信息找到。<br>17.5.4 轮廓边顶点着色器代码<br>   我们现在呈现渲染轮廓边的顶点着色器代码。这个着色器的主要任务就是确定传入的顶点是否在轮廓边上。如果是，顶点着色器就以一定的值，按顶点法线的方向偏移顶点。<br>// File: outline.txt<br>// Desc: Vertex shader renders silhouette edges.</p>
<p>// Globals</p>
<p>extern matrix WorldViewMatrix;<br>extern matrix ProjMatrix;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};</p>
<p>// Structures<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};<br>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse : COLOR;<br>};</p>
<p>// Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>      // zero out each member in output<br>      VS_OUTPUT output = (VS_OUTPUT)0; </p>
<pre><code>  // transform position to view space
  input.position = mul(input.position, WorldViewMatrix); 

  // Compute a vector in the direction of the vertex
  // from the eye. Recall the eye is at the origin
</code></pre><p>　　　// in view space - eye is just camera position.<br>      vector eyeToVertex = input.position; </p>
<pre><code>  // transform normals to view space.  Set w
  // components to zero since we&#39;re transforming vectors.
  // Assume there are no scalings in the world
  // matrix as well.
  input.normal.w      = 0.0f;
  input.faceNormal1.w = 0.0f;
  input.faceNormal2.w = 0.0f;
  input.normal      = mul(input.normal,      WorldViewMatrix);
  input.faceNormal1 = mul(input.faceNormal1, WorldViewMatrix);
  input.faceNormal2 = mul(input.faceNormal2, WorldViewMatrix); 

  // compute the cosine of the angles between
  // the eyeToVertex vector and the face normals.
  float dot0 = dot(eyeToVertex, input.faceNormal1);
  float dot1 = dot(eyeToVertex, input.faceNormal2);

  // if cosines are different signs (positive/negative)
  // then we are on a silhouette edge. Do the signs
  // differ?
  if( (dot0 * dot1) &lt; 0.0f )
  {
       // yes, then this vertex is on a silhouette edge,
       // offset the vertex position by some scalar in the
       // direction of the vertex normal.
       input.position += 0.1f * input.normal;
  }

  // transform to homogeneous clip space
  output.position = mul(input.position, ProjMatrix);

  // set outline color
  output.diffuse = Black; 

  return output;
</code></pre><p>}</p>
<p>17.6 摘要</p>
<ul>
<li>使用顶点着色器，我们可以替换固定功能管线的变换和光照阶段。通过用我们自己的程序（顶点着色器）替换此固定处理，我们可以在图形效果方面获得我们能够达到的极大的自由性。</li>
<li>顶点声明用于描述顶点格式。它们和自由顶点格式相似，但是更加自由并允许我们描述FVF不能描述的顶点格式。注意，如果顶点可以用FVF描述，我们仍然可以使用它们；不管怎样，在内部它们被转换为顶点声明。</li>
<li>对于输入，用途语义指定了顶点分量如何被从顶点声明映射到HLSL程序中的变量。对于输出，用途语义指定了顶点分量是用来做什么的（例如：位置、颜色、纹理坐标，等等）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Intorduction-to-the-High-Level-Shading-Language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Intorduction-to-the-High-Level-Shading-Language/" class="post-title-link" itemprop="url">高级着色器语言入门(Introduction to the High-Level Shading Language)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:27:51" itemprop="dateCreated datePublished" datetime="2019-04-11T15:27:51+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Intorduction-to-the-High-Level-Shading-Language/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Intorduction-to-the-High-Level-Shading-Language/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>   在这一章里我们描述高级着色器语言（High-Level Shading Language ，简称HLSL），在下三章里我们用它去编写顶点和像素着色器。简单的说，在我们写的程序里顶点和像素是很小的对象，它们由GPU来执行，是固定功能管线的一部分。用我们自己写的着色器程序替换一部分固定功能管线，在绘制效果上我们获得很大的灵活性。我们不再局限于预定义的”固定”操作。<br>   为了编写着色器程序，我们需要一种语言。 在DirectX 8.x,中，着色器是用低级着色器汇编语言编写的。幸运的是，我们不必再用汇编语言来写着色器了，DirectX 9支持一种高级着色器语言来xyna写。用HLSL在汇编语言来写着色器程序与使用高级语言有同样的优势，像C++，它超越了汇编语言，即：</p>
<ul>
<li>增加生产力—用高级语言比用低级语言写程序更快、更容易。 我们可以花费更多的时间关注于算法而不是代码。</li>
<li>增加可读性—用高级语言写的程序更易读，这意味着用高级语言编程更易于调试和维护。</li>
<li>大多数情况下，编译器产生的汇编代码比手写有效率。</li>
<li>使用HLSL 编译器，我们可以编译我们的代码到任何可用shader版本，使用汇编语言我们将不得不为每个需要的版本移植代码。</li>
</ul>
<p>HLSL 同C和C++语法很类似, 所以缩短了学习曲线。<br>   最后，如果你的显卡不支持顶点和像素着色器的话，为了执行着色器的例子程序你将需要转换REF设备。使用REF设备意味着着色器例子运行的会很慢，但它至少能显示结果，让我们去检查是否代码可以被执行。</p>
<p>提示：顶点shaders可以用软件来模拟 ―― D3DCREATE_SOFTWARE_VERTEX-PROCESSING。16.1 </p>
<p>目标</p>
<ul>
<li>学习如何定、编译一个HLSL 着色器程序。</li>
<li>学习如何将程序中的数据传送到着色器程序。</li>
<li><p>熟悉语法、类型，和HLSL的内建函数。</p>
<h1 id="编写HLSL着色器"><a href="#编写HLSL着色器" class="headerlink" title="编写HLSL着色器"></a>编写HLSL着色器</h1><p>我们可以在程序源文件中用字符串直接编写HLSL着色器代码，然而更方便、更模块化的方法是把它与程序代码分离出来。因此，我们在记事本中编写着色器并保存成一般的ASCII文本文件，然后可以用D3DXCompileShaderFromFile函数(section 16.2.2)来编译它们。<br>作为介绍，下面是用HLSL编写的一个简单的顶点着色器，用记事本生成并保存成文本文件“Transform.txt”。全部工程都在标题为Transform的目录下，顶点着色器用组合视图和投影矩阵转换顶点，并设置顶点漫射光为蓝色。</p>
<p> 注意：这是一个顶点着色器的例子，不必关心顶点着色器做了什么，这是下一章包含的内容，现在的目标是熟悉HLSL编程的语法和格式。<br>// File: transform.txt<br>// Author: Frank D. Luna (C) All Rights Reserved<br>// System: AMD Athlon 1800+ XP, 512 DDR, Geforce 3, Windows XP,<br>// MSVC++ 7.0</p>
</li>
</ul>
<p>// Desc: 顶点着色器用组合视图和投影矩阵转换顶点，并设置顶点漫射光为蓝色.</p>
<p>//全局变量<br>//用来保存视图和投影的组合矩阵，在程序中初始化变量<br>matrix ViewProjMatrix;</p>
<p>// 初始化颜色变量（蓝色）<br>vector Blue = {0.0f, 0.0f, 1.0f, 1.0f};</p>
<p>// 结构<br>// Input结构用来描述输入到着色器的顶点，这个Input顶点只包含一个位置成员<br>struct VS_INPUT<br>{<br>     vector position  : POSITION;<br>};</p>
<p>//Output结构用来描述从着色器输出的顶点，这个Output顶点包含位置和颜色成员<br>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};</p>
<p>//主入口点，这个main函数接收一个Input顶点的拷贝作为参数，返回一个Output顶点的拷贝<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     // 将output结构所有成员初始化<br>     VS_OUTPUT output = (VS_OUTPUT)0;<br>     // 将位置变换到投影空间<br>     output.position  = mul(input.position, ViewProjMatrix);<br>     // 设置顶点颜色<br>     output.diffuse = Blue;<br>     //Output the projected and colored vertex.<br>     return output;<br>}</p>
<p>16.1.1 全局变量<br>首先是2个全局变量：<br>matrix ViewProjMatrix;<br>vector Blue = {0.0f, 0.0f, 1.0f, 1.0f};<br>   第1个变量ViewProjMatrix是矩阵类型，它是一个在HLSL 内创建的4×4的矩阵类型。这个变量保存视图与投影的组合矩阵，它描述两者的变换。使用这种方法我们只要做一个向量和矩阵的乘法（而不是二个）。注意，在着色器源代码的任何地方都没有初始化这个变量，因为它是我们在应用程序的源代码里设置的，而不是在着色器中。从应用程序向着色器程序通讯是常用的操作，例子在16.2.1节。<br>   第二个变量Blue是built-in（内建）类型的4D向量，我们简单的将它初始化成蓝色，它是个RGBA的颜色向量。</p>
<p>16.1.2 输入和输出结构<br>   在全局变量定义之后，定义2个特殊的结构，我们调用输入和输出结构。对于顶点着色器而言，这些结构定义了顶点的数据，分别是：<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>};</p>
<p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};<br>注意：给像素着色器的结构定义输入和输出像素数据。</p>
<p>   在例子中，INPUT 顶点着色器只包含位置成员（POSITION），OUTPUT顶点着色器包含位置和颜色成员（POSITION and COLOR）。<br>   特殊的冒号是一种语义，用于是声明变量。这与vertex结构中的自由顶点格式（FVF）相似。例如，在VS_INPUT中有成员：vector position : POSITION;<br>   “: COLOR”是说顶点的漫射光是用VS_OUTPUT结构的COLOR成员来说明的。在下一章中对于顶点和像素着色器中向量的标识符用法，我们将会有更多的讨论。<br>   注意：从底层来说，着色器变量的语义和语法同硬件寄存器是相关联的。即，input变量与input寄存器关联，output变量与output寄存器关联。例如，VS_INPUT中的position成员与顶点input的position寄存器相关联。同样，diffuse与顶点的output 的color寄存器关联。</p>
<p>16.1.3 函数的入口点<br>   在C++程序中，每个HLSL程序有一个入口点。在我们的着色器例子中，我们调用入口点函数main。然而名字不是强制的。入口点函数名可以是任何有效的函数名，入口点函数必须有一个input结构参数，它通过input顶点进入着色器。入口点函数必须返回一个output结构实例，在着色器中使用output操作顶点。<br>VS_OUTPUT Main(VS_INPUT input)<br>{</p>
<p>   注意：实际上，使用input、output结构不是强制的。例如，有时你将会看到使用类似下面的语法，特别是在像素着色器中：<br>float4 Main(in float2 base : TEXCOORD0,<br>            in float2 spot : TEXCOORD1,<br>            in float2 text : TEXCOORD2) : COLOR<br>{<br>…<br>}</p>
<p>   例子中，输入到着色器中的参数是3个纹理坐标。着色器输出（返回）一个颜色，COLOR语句在函数的声明以后。这种定义是类似于：<br>struct INPUT<br>{<br>     float2 base : TEXCOORD0;<br>     float2 spot : TEXCOORD1;<br>     float2 text : TEXCOORD2;<br>};</p>
<p>struct OUTPUT<br>{<br>     float4 c : COLOR;<br>};</p>
<p>OUTPUT Main(INPUT input)<br>{<br>…<br>}</p>
<p>   输入点函数负责根据给定的input顶点计算output顶点。例子中的着色器简单的变换input顶点到视图空间和投影空间，设置顶点颜色为蓝色，并返回结果顶点。首先我们定义VS_OUTPUT的实例并初始化所有成员为0。<br>VS_OUTPUT output = (VS_OUTPUT)0; // zero out all members<br>   然后着色器变换input顶点位置用ViewProjMatrix变量，使用mul 函数。它是一个built-in（内建）函数，实现向量与矩阵相乘，或矩阵与矩阵相乘。我们保存结果变换的向量（在output实例的position成员中）。<br>// 变换后为投影空间的位置<br>output.position = mul(input.position, ViewProjMatrix);<br>   然后设置output的成员diffuse的颜色为蓝色：<br>// 设置顶点颜色<br>output.diffuse = Blue;<br>   最后返回结果向量：<br>return output;<br>}<br>16.2 编译HLSL 着色器<br>16.2.1 常量表<br>   每个着色器有一个常量表，用来保存它的变量。D3DX库通过ID3DXConstantTable接口，提供给应用程序访问着色器的常量表。通过这个接口我们能够在应用程序中设置着色器源代码中的变量。<br>   我们现在描述一个被节选了的ID3DXConstantTable接口的方法列表的实现，全部的列表请查阅Direct3D文档。<br>16.2.1.1 取得常量句柄<br>   为了在应用程序中设置着色器中的一个特定变量，需要有一种方法去引用它，我们能够在应用程序中用D3DXHANDLE引用一个在着色器中的变量，下面的方法返回一个着色器中的变量的D3DXHANDLE，使用时，需要传递一个变量的名字作为参数：<br>D3DXHANDLE ID3DXConstantTable::GetConstantByName(<br>     D3DXHANDLE hConstant, // scope of constant<br>     LPCSTR pName          // name of constant<br>);</p>
<ul>
<li>Hconstant——我们要取得的父结构中变量句柄的D3DXHANDLE标识。例如，如果我们想获得一个特定数据结构中单一数据成员的句柄，我们可以传递结构实例的句柄。如果我们获得一个顶级变量的句柄，给这个参数设为0。</li>
<li>PName——我们想获得的句柄的着色器代码中的变量的名字。</li>
</ul>
<p>例如，如果在着色器中变量的名字为ViewProjMatrix，并且这是顶级变量，我们这么写：<br>// 取得着色器中ViewProjMatrix变量的句柄<br>D3DXHANDLE h0;<br>h0 = ConstTable-&gt;GetConstantByName(0, “ViewProjMatrix”);</p>
<p>16.2.1.2 设置常量<br>   一旦应用程序有了一个D3DXHANDLE，要引用着色器代码中的具体变量，我们可以在应用程序中使用ID3DXConstantTable::SetXXX方法设置变量。如果我们想设置一个向量数组类型的变量，方法名是SetVectorArray。<br>   ID3DXConstantTable::SetXXX的一般语法是：<br>HRESULT ID3DXConstantTable::SetXXX(<br>     LPDIRECT3DDEVICE9 pDevice,<br>     D3DXHANDLE hConstant,<br>     XXX value<br>);</p>
<ul>
<li>PDevice：常量表所关联的设备的指针。</li>
<li>HConstant：我们正在设置的变量句柄的引用。</li>
<li><p>Value：我们要把变量设置成的值，XXX是我们设置的要替换的变量类型名，对于有些类型（bool, int, float），传递变量值的COPY，另外一些类型（vectors, matrices, structures），传递值的指针。</p>
<p> 下面列表描述了我们能用ID3DXConstantTable接口设置的类型列表。这里假定我们有一个有效的设备，和一个有效句柄。<br>SetBool—Used to set a Boolean value. Sample call:<br>bool b = true;<br>ConstTable-&gt;SetBool(Device, handle, b);</p>
</li>
</ul>
<p>SetBoolArray—Used to set a Boolean array. Sample call:<br>bool b[3] = {true, false, true};<br>ConstTable-&gt;SetBoolArray(Device, handle, b, 3);</p>
<p>SetFloat—Used to set a float. Sample call:<br>float f = 3.14f;<br>ConstTable-&gt;SetFloat(Device, handle, f);</p>
<p>SetFloatArray—Used to set a float array. Sample call:<br>float f[2] = {1.0f, 2.0f};<br>ConstTable-&gt;SetFloatArray(Device, handle, f, 2);</p>
<p>SetInt—Used to set an integer. Sample call:<br>int x = 4;<br>ConstTable-&gt;SetInt(Device, handle, x);</p>
<p>SetIntArray—Used to set an integer array. Sample call:<br>int x[4] = {1, 2, 3, 4};<br>ConstTable-&gt;SetIntArray(Device, handle, x, 4);</p>
<p>SetMatrix—Used to set a 4 × 4 matrix. Sample call:<br>D3DXMATRIX M(…);<br>ConstTable-&gt;SetMatrix(Device, handle, &amp;M);</p>
<p>SetMatrixArray—Used to set a 4 × 4 matrix array. Sample call:<br>D3DXMATRIX M[4];<br>// …Initialize matrices<br>ConstTable-&gt;SetMatrixArray(Device, handle, M, 4);</p>
<p>SetMatrixPointerArray—Used to set an array of 4 × 4 matrix pointers. Sample call:<br>D3DXMATRIX* M[4];<br>// …Allocate and initialize matrix pointers<br>ConstTable-&gt;SetMatrixPointerArray(Device, handle, M, 4);</p>
<p>SetMatrixTranspose—Used to set a transposed 4 × 4 matrix. Sample call:<br>D3DXMATRIX M(…);<br>D3DXMatrixTranspose(&amp;M, &amp;M);<br>ConstTable-&gt;SetMatrixTranspose(Device, handle, &amp;M);</p>
<p>SetMatrixTransposeArray—Used to set an array of 4 × 4 transposed matrices. Sample call:<br>D3DXMATRIX M[4];<br>// …Initialize matrices and transpose them.<br>ConstTable-&gt;SetMatrixTransposeArray(Device, handle, M, 4);</p>
<p>SetMatrixTransposePointerArray—Used to set an array of pointers to 4 × 4 transposed matrices. Sample call:<br>D3DXMATRIX* M[4];<br>// …Allocate,initialize matrix pointers and transpose them.<br>ConstTable-&gt;SetMatrixTransposePointerArray(Device, handle, M, 4);</p>
<p>SetVector—Used to set a variable of type D3DXVECTOR4. Sample call:<br>D3DXVECTOR4 v(1.0f, 2.0f, 3.0f, 4.0f);<br>ConstTable-&gt;SetVector(Device, handle, &amp;v);</p>
<p>SetVectorArray—Used to set a variable that is a vector array. Sample call:<br>D3DXVECTOR4 v[3];<br>// …Initialize vectors<br>ConstTable-&gt;SetVectorArray(Device, handle, v, 3);</p>
<p>SetValue—Used to set an arbitrarily sized type, such as a structure. In the sample call, we use SetValue to set a D3DXMATRIX:<br>D3DXMATRIX M(…);<br>ConstTable-&gt;SetValue(Device, handle, (void*)&amp;M, sizeof(M));</p>
<p>16.2.1.3 设置常量默认值<br>   下一个方法就是设置常量的默认值，这些默认值在声明时初始化。这个方法应该在应用程序建立（setup）期间被一次性调用（called once）。<br>   HRESULT ID3DXConstantTable::SetDefaults(<br>        LPDIRECT3DDEVICE9 pDevice<br>   );<br>   pDevice——关联到常量表的设备的指针。</p>
<p>16.2.2 编译HLSL着色器<br>   我们可以编译一个着色器——用我们已保存的着色器的文本文件——使用下列函数：<br>   HRESULT D3DXCompileShaderFromFile(<br>        LPCSTR               pSrcFile,<br>        CONST D3DXMACRO<em>     pDefines,<br>        LPD3DXINCLUDE        pInclude,<br>        LPCSTR               pFunctionName,<br>        LPCSTR               pTarget,<br>        DWORD                Flags,<br>        LPD3DXBUFFER</em>        ppShader,<br>        LPD3DXBUFFER<em>        ppErrorMsgs,<br>        LPD3DXCONSTANTTABLE</em> ppConstantTable<br>   );</p>
<ul>
<li>pSrcFile——要编译的包含着色器源代码的文本文件的文件名</li>
<li>pDefines——参数可选，本书中指定为空。</li>
<li>pInclude——ID3DXInclude接口指针。这个接口被设计成由应用程序实现，所以我们可以重载默认include的行为。通常，默认行为就可以了，而且我们可以通过将其指定为空忽略此参数。</li>
<li>pFunctionName——指定入口点函数名的字符串。例如，如果着色器的入口点函数叫做Main，我们可以给此参数传递“Main”。</li>
<li><p>pTarget——指定要编译成的HLSL着色器源文件的版本的字符串。有效的顶点着色器版本是：vs_1_1, vs_2_0, vs_2_sw。有效的像素着色器版本是2.0，我们可以给此参数传递vs_2_0。</p>
<p> 备注：有编译不同版本着色器的能力，是HLSL与汇编语言比的主要优势。用HLSL我们只需为需要的目标简单的重新编译，便可快速移植着色器到不同的版本。使用汇编，我们可能需要手动移植代码。</p>
</li>
<li>Flags——可选的编译标记，指定为0标识没有标记。有效的选项是：</li>
<li>D3DXSHADER_DEBUG——通知编译器写入调试信息</li>
<li>D3DXSHADER_SKIPVALIDATION——通知编译器不要做任何代码检查。此项仅用于你已知着色器能够工作时</li>
<li>D3DXSHADER_SKIPOPTIMIZATION——通知编译器不要执行任何代码优化。实践中，这个选项应该仅用于调试，因为这种情况下你不希望编译器以任何方式修改代码。</li>
<li>ppShader——返回已编译的着色器代码的ID3DXBuffer指针。这个已编译过的着色器代码将作为另一个实际创建顶点/像素着色器函数的参数</li>
<li>ppErrorMsgs——返回包含错误码和错误消息字符串的ID3DXBuffer指针</li>
<li><p>ppConstantTable——返回包含此着色器常量表数据的ID3DXConstantTable指针</p>
<p> 这里是一个调用D3DXCompileShaderFromFile的例子：<br> // Compile shader</p>
<p> ID3DXConstantTable<em> TransformConstantTable = 0;<br> ID3DXBuffer</em> shader      = 0;<br> ID3DXBuffer* errorBuffer = 0;</p>
<p> hr = D3DXCompileShaderFromFile(</p>
<pre><code>  &quot;transform.txt&quot;,      // shader filename
  0,
  0,
  &quot;Main&quot;,               // entry point function name
  &quot;vs 2 0&quot;,             // shader version to compile to
  D3DXSHADER_DEBUG,     // debug compile
  &amp;shader,
  &amp;errorBuffer,
  &amp;TransformConstantTable);
</code></pre><p> // output any error messages<br> if( errorBuffer )<br> {</p>
<pre><code>  ::MessageBox(0, (char*)errorBuffer-&gt;GetBufferPointer(), 0, 0);
  d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);
</code></pre><p> }</p>
<p> if (FAILED (hr))<br> {</p>
<pre><code>  ::MessageBox(0, &quot;D3DXCreateEffectFromFile() - FAILED&quot;, 0, 0);
  return false;
</code></pre><p> }</p>
</li>
</ul>
<p>16.3 变量类型<br>   注意：除了下列各小节中描述的类型外，HLSL还有一些内建的对象类型（如：纹理对象）。但是，由于这些对象类型主要用于效果框架，我们将对其延迟到第19章讨论。</p>
<p>16.3.1 数值类型<br>HLSL支持下列数值类型（scalar type）：</p>
<ul>
<li>bool—True or false value. Note that HLSL provides the true and false keywords.</li>
<li>int—32-bit signed integer</li>
<li>half—16-bit floating-point number</li>
<li>float—32-bit floating-point number</li>
<li>double—64-bit floating-point number<br> 注意：一些平台不支持int, half, and double类型，这时我们使用 float类型模拟。</li>
</ul>
<p>16.3.2 向量类型<br>HLSL有下列内建的向量类型（vector type）：</p>
<ul>
<li>vector——各分量为float类型的4D向量</li>
<li><p>vector<t, n>——一个n维向量，其每个分量都为T类型。n维必须在1到4之间。这里是一个2D double向量的例子：<br>vector<double, 2> vec2;</double,></t,></p>
<p> 我们可以使用数组下标的语法访问向量的一个分量。例如，要设置向量vec的第i个分量，我们可以写成：<br>vec[i] = 2.0f;</p>
<p> 此外，我们可以像访问结构的成员一样访问向量vec的一个分量，使用已定义的分量名x，y，z，w，r，g，b和a。<br>vec.x = vec.r = 1.0f;<br>vec.y = vec.g = 2.0f;<br>vec.z = vec.b = 3.0f;</p>
</li>
</ul>
<p>vec.w = vec.a = 4.0f;</p>
<p>   名称为r，g，b和a的分量分别对应x，y，z和w的分量。当使用向量来表示颜色时，RGBA符号是更适合的，因为它加强了向量所表示的颜色。</p>
<p>   作为选择，我们可以使用其它一些预定义类型，分别用来代表2D，3D和4D向量的类型：<br>float2 vec2;<br>float3 vec3;<br>float4 vec4;</p>
<p>   考虑向量u = (ux, uy, uz, uw)，假设我们要拷贝u的所有分量到一个像v = (ux, uy, uy, uw)这样的向量v。最直接的方法可能是逐个从u往v拷贝每个分量。但不管怎样，HLSL提供了一种特殊的语法做这些无序的拷贝，它叫做“鸡尾酒”（swizzles）：<br>vector u = {l.0f, 2.0f, 3.0f, 4.0f};<br>vector v = {0.0f, 0.0f, 5.0f, 6.0f};<br>v = u.xyyw; // v = {1.0f, 2.0f, 2.0f, 4.0f}</p>
<p>拷贝数组时，我们不必拷贝每个分量。例如，我们可以仅拷贝x和y分量，代码段举例如下：<br>vector u = {1.0f, 2.0f, 3.0f, 4.0f};<br>vector v = {0.0f, 0.0f, 5.0f, 6.0f};<br>v.xy = u; // v = {l.0f, 2.0f, 5.0f, 6.0f}</p>
<p>16.3.3 矩阵类型<br>HLSL有下列内建矩阵类型：</p>
<ul>
<li>matrix——一个4×4矩阵，其各项类型为float</li>
<li>matrix<t, m, n>——一个m×n矩阵，其每个成员为类型T。矩阵维数m和n必须在1至4之间。</t,></li>
</ul>
<p>这里是一个2×2整型矩阵的例子：<br>matrix<int, 2 2,> m2x2;</int,></p>
<p>作为选择，我们可以定义一个m×n矩阵，其m和n在1至4之间，使用下列语法：<br>floatmxn matmxn;<br>实例：<br>float2x2 mat2x2;<br>float3x3 mat3x3;<br>float4x4 mat4x4;<br>float2x4 mat2x4;<br>注意：类型不必是float类型——我们可以使用其它类型。举例来说，我们可以用整型，写成这样：<br>int2x2 i2x2;<br>int2x2 i3x3;<br>int2x2 i2x4;</p>
<p>我们可以用二维数组的下标语法访问矩阵中的项。例如，要设置矩阵M的第i，j个项，我们可以写成：<br>M[i] [j] = value;</p>
<p>此外，我们可以像访问结构的成员那样访问矩阵M的项。下列条目已定义：<br>以1为基数的：<br>M._11 = M._12 = M._13 = M._14 = 0.0f;<br>M._21 = M._22 = M._23 = M._24 = 0.0f;<br>M._31 = M._32 = M._33 = M._34 = 0.0f;<br>M._41 = M._42 = M._43 = M._44 = 0.0f;</p>
<p>以0为基数的：<br>M._m00 = M._m01 = M._m02 = M._m03 = 0.0f;<br>M._m10 = M._m11 = M._m12 = M._m13 = 0.0f;<br>M._m20 = M._m21 = M._m22 = M._m23 = 0.0f;<br>M._m30 = M._m31 = M._m32 = M._m33 = 0.0f;</p>
<p>有时，我们想要访问矩阵中一个特定的行。我们可以用一维数组的下标语法来做。例如，要引用矩阵M中第i行的向量，我们可以写：<br>vector ithRow = M[i]; // get the ith row vector in M</p>
<p>注意：可以使用两种语法在HLSL中初始化变量：<br>vector u = {0.6f, 0.3f, 1.0f, 1.0f};<br>vector v = {1.0f, 5.0f, 0.2f, 1.0f};</p>
<p>也可以，等价的，使用构造风格的语法：<br>vector u = vector(0.6f, 0.3f, 1.0f, 1.0f);<br>vector v = vector(1.0f, 5.0f, 0.2f, 1.0f);</p>
<p>其它一些例子:<br>float2x2 f2x2 = float2x2(1.0f, 2.0f, 3.0f, 4.0f);<br>int2x2 m = {1, 2, 3, 4};<br>int n = int(5);<br>int a = {5};<br>float3 x = float3(0, 0, 0);</p>
<p>16.3.4 数组<br>我们可以用类似C++的语法声明特定类型的一个数组。例如：<br>float  M[4][4];<br>half   p[4];<br>vector v[12];</p>
<p>16.3.5 结构<br>结构的定义和在C++里一样。但是，HLSL里的结构不能有成员函数。这是一个HLSL里的结构的例子：<br>struct MyStruct<br>{<br>     matrix T;<br>     vector n;<br>     float  f;<br>     int    x;<br>     bool   b;<br>};<br>MyStruct s; // instantiate<br>s.f = 5.0f; // member access</p>
<p>16.3.6 typedef关键字<br>   HLSL的typedef关键字功能和C++里的完全一样。例如，我们可以给类型vector<float, 3>用下面的语法命名：<br>typedef vector<float, 3> point;<br>然后，不用写成：<br>vector<float, 3> myPoint;<br>……我们只需这样写：<br>point myPoint;</float,></float,></float,></p>
<p>这里是另外两个例子，它展示了如何对常量和数组类型使用typedef关键字：<br>typedef const float CFLOAT;<br>typedef float point2[2];</p>
<p>1.3.7 变量前缀<br>下列关键字可以做变量声明的前缀：</p>
<ul>
<li><p>static——如果带static关键字前缀，那它是全局变量。就表示它不是暴露于着色器之外的。换句话说，它是着色器局部的。如果一个局部变量以static关键字为前缀，它就和C++中static局部变量有相同的行为。也就是说，该变量在函数首次执行时被一次性初始化，然后在所有函数调用中维持其值。如果变量没有被初始化，它就自动初始化为0。static int x = 5;</p>
</li>
<li><p>uniform——如果变量以uniform关键字为前缀，就意味着此变量在着色器外面被初始化，比如被C++应用程序初始化，然后再输入进着色器。</p>
</li>
<li><p>extern——如果变量以extern关键字为前缀，就意味着该变量可在着色器外被访问，比如被C++应用程序。仅全局变量可以以extern关键字为前缀。不是static的全局变量默认就是extern。</p>
</li>
<li><p>shared——如果变量以shared关键字为前缀，就提示效果框架（参见19章）：变量将在多个效果间被共享。仅全局变量可以以shared为前缀。</p>
</li>
<li><p>volatile——如果变量以volatile关键字为前缀，就提示效果框架（参见19章）：变量将被时常修改。仅全局变量可以以volatile为前缀。</p>
</li>
<li><p>const——HLSL中的const关键字和C++里的意思一样。也就是说，如果变量以const为前缀，那此变量就是常量，并且不能被改变。const float pi = 3.14f;<br>16.4关键字、语句和强制转换<br>16.4.1 关键字<br>为便于参考，这里给出一个HLSL定义的关键字列表：<br>asm        bool        compile       const          decl         do<br>double      else        extern         false          float         for<br>half        if           in            inline         inout         int<br>matrix      out         pass           pixelshader    return        sampler<br>shared      static       string          struct         technique     texture<br>true        typedef     uniform        vector         vertexshader   void<br>volatile     while</p>
</li>
</ul>
<p>下面的集合显示了被保留并且未使用但是将来可能成为关键字的标识符：<br>auto            break        case           catch         char          class<br>const_cast       continue      default         delete        dynamic cast   enum<br>explicit         friend         goto           long         mutable       namespace<br>new            operator       private         protected     public         register<br>reinterpret_cast   short         signed          sizeof        static_cast     switch<br>template         this          throw          try           typename     union<br>unsigned         using        virtual </p>
<p>16.4.2 基本程序流程<br>HLSL支持很多与C++相似的选择、重复、和一般程序流程语句。这些语句的语法和C++极为相似。<br>return语句：<br>return (expression);<br>if和if…else语句：<br>if( condition )<br>{<br>     statement(s);<br>}</p>
<p>if( condition )<br>{<br>     statement(s);<br>}<br>else<br>{<br>     statement(s);<br>}</p>
<p>for语句：<br>for(initial; condition; increment)<br>{<br>     statement(s);<br>}</p>
<p>while语句：<br>while( condition )<br>{<br>     statement(s);<br>}</p>
<p>do…while语句：<br>do<br>{<br>     statement(s);<br>}while( condition );</p>
<p>16.4.3 强制转换（casting）<br>   HLSL支持一种非常自由的强制转换设计。HLSL中强制转换的语法和C程序语言中的一样。例如要把float转换到matrix，我们写：<br>float f = 5.0f;<br>matrix m = (matrix)f;</p>
<p>   从本书的例子中，你就能推断出这个转换语法的意思。但是，如果想要得到更详细的受支持的转换的信息，那么在DirectX SDK里，Content（内容）标签页下，看DirectX Graphics\Reference\Shader Reference\High Level Shading Language\Type就可以了。</p>
<p>16.5 操作符<br>   HLSL支持很多类似C++的操作符。除了很少一些底下注释的例外以外，他们的用法和C++里的完全一样。下表列出了HLSL的操作符：<br>[]<br>?<br>&gt;<br>&lt;<br>&lt; =</p>
<blockquote>
<p>=<br>! =<br>= =<br>!<br>&amp;&amp;<br>?<br>?:<br>+</p>
<ul>
<li>=<br>-</li>
</ul>
<ul>
<li>=<br><em>
</em>=<br>/<br>/=<br>%<br>%=</li>
</ul>
<h2 id><a href="#" class="headerlink" title="+ +"></a>+ +</h2><p>=<br>()<br>‘</p>
</blockquote>
<p>   虽然操作符的行为和C++很相似，但是也有一些差异。第一，求模%运算符对整型和浮点型都起作用。为了使用求模操作符，左边的值和右边的值都必须有相同的正负号（如：左边和右边必须都是正或者负）。</p>
<p>   第二，要注意HLSL操作是以每个分量为基础的。这是由于实际上向量和矩阵是语言内建的，并且这些类型是由若干个分量组成。通过将这些操作施加在分量级别之上，我们可以像使用数值类型一样完成诸如向量/矩阵的加法，减法和相等测试这些操作（），见下例：</p>
<p>注意：操作符的行为正如对数值操作一样（也就是说，按一般C++的方式）。<br>vector u = {1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 2.0f, 1.0f, 0.0f};<br>// adds corresponding components<br>vector sum = u + v; // sum = (-3.0f, 2.0f, -2.0f, 1.0f)</p>
<p>增量一个向量就是增量其每个分量：<br>// before increment: sum = (-3.0f, 2.0f, -2.0f, 1.0f)<br>sum++; // after increment: sum = (-2.0f, 3.0f, -1.0f, 2.0f)</p>
<p>向量相乘也是按分量的：<br>vector u = {1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 2.0f, 1.0f, 0.0f};</p>
<p>// multiply corresponding components<br>vector sum = u * v; // product = (-4.0f, 0.0f, -3.0f, 0.0f)</p>
<p>比较操作也是按分量进行的，并且返回一个每个分量都为bool类型的向量或者数组。作为结果的“bool”向量包含了每个分量比较的结果。例如：<br>vector u = { 1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 0.0f, 1.0f, 1.0f};<br>vector b = (u == v); // b = (false, true, false, true)</p>
<p>最后，我们以讨论二元操作的变量提升（promotion）作为结束：</p>
<ul>
<li>对于二元操作，如果（操作符的）左边和右边维数不同，则维数较少的一边提升（强制转换）到具有和维数较大的一边相同的维数。例如，如果x的类型为float，而y的类型为float3，在表达式(x + y)中变量x被提升到float3，并且计算出来的表达式的值的类型也为float3。提升使用已定义的转换完成。注意，若转换未定义则提升也是未定义的。例如，我们不能转换float2到float3，因为没有定义这个转换。</li>
<li>对于二元操作，如果左边和右边类型不同，那么较低精度的类型（the lower type resolution）被提升（强制转换）到具有同类型的较高精度的类型（the higher type resolution）。例如，如果x类型为int，y类型为half，则表达式(x + y)中的变量x被提升到half，并且计算出来的表达式的值的类型也为half。</li>
</ul>
<p>16.6 用户定义函数<br>HLSL中的函数有下例属性：</p>
<ul>
<li>函数使用类似C++的语法</li>
<li>参数总是按值传递</li>
<li>递归不被支持</li>
<li>函数总是inline的</li>
</ul>
<p>此外，函数还加上了一些用于其上的额外的关键字。例如，考虑一个写在HLSL中的下面这个函数：<br>bool foo(in const bool b,   // input bool<br>         out int r1,        // output int<br>         inout float r2)    // input/output float<br>{<br>     if( b )               // test input value<br>     {<br>          r1 = 5;          // output a value through r1<br>     }<br>     else<br>     {<br>          r1 = 1;          // output a value through r1<br>     }</p>
<pre><code> // since r2 is inout we can use it as an input
 // value and also output a value through it
 r2 = r2 * r2 * r2;

 return true;
</code></pre><p>}</p>
<p>函数几乎和C++函数是一样的，除了in，out和inout关键字：</p>
<ul>
<li>in——指定型参（argument，特指传递给实参的变量）应该在函数开始前被拷贝给实参。传入参数不必强制指定，因为实参默认是in的。例如，下面两段是等价的：<br>float square(in float x)<br>{<br>   return x * x;<br>}</li>
</ul>
<p>也可以不强制指定in：<br>float square(float x)<br>{<br>     return x * x;<br>}</p>
<ul>
<li><p>out——指定实参应该在函数返回时被拷贝给型参。这样可以通过参数返回值。out关键字是必须的，因为HLSL不允许传递一个引用或一个指针。我们要注意：如果实参标记为out，在函数开始前，型参就不拷贝给实参。换句话说，out实参仅可以被用于输出数据——它不能用于输入。<br>void square(in float x, out float y)<br>{<br>   y = x * x;<br>}<br>这里，我们输入了要被乘方的数x，并且通过参数y返回了x的乘方。</p>
</li>
<li><p>inout——这是一个指示实参既用于输入又用于输出的快捷方法。如果要使用实参同时用作输入和输出，就指定inout。<br>void square(inout float x)<br>{<br>   x = x * x;<br>}<br>这里，我们输入了要被乘方的数x，同时又通过x返回了的x的乘方。</p>
</li>
</ul>
<p>16.7内建函数<br>   HLSL有一个丰富的内建函数的集合，它们对3D图形来说非常有用。下表是一个删减了的列表。在下两章中，我们会使用这些函数中的一些进行实践。而现在，熟悉它们就够了。</p>
<p>注意：要得到更多的参考，可以参看DirectX文档中内建HLSL函数的完整列表，在Content页下，然后到DirectX Graphics\Reference\Shader Reference\High Level Shader Language\Intrinsic Functions。</p>
<p>译者注：以下表格中，//<variable>//表示变量variable的模（例如向量的绝对值）。<br>函数<br>描述<br>abs(x)<br>返回 |x|<br>ceil(x)<br>返回 ≥ x 的最小整数<br>clamp(x, a, b)<br>clamp(x, a, b)<br>clamp(x, a, b)<br>clamp(x, a, b)<br>cross(u, v)<br>返回 u × v（叉积）<br>degrees(x)<br>转换 x 从弧度到角度<br>determinant(M)<br>返回矩阵M的行列式det(M)<br>distance(u, v)<br>返回u点和v点之间的距离||v - u||<br>dot(u, v)<br>返回 u · v（点积）<br>floor(x)<br>返回 ≤ x 的最大整数<br>length(v)<br>返回 ||v||<br>lerp(u, v, t)<br>在u和v之间线性插值，根据参数 t ? [0, 1 ]<br>log(x)<br>返回 ln(x)<br>log10(x)<br>返回 log10(x)<br>log2(x)<br>返回 log2(x)<br>max(x, y)<br>如果x ≥ y，则返回 x；否则返回 y<br>min(x, y)<br>如果 x ≤ y，返回x；否则返回 y<br>mul(M, N)<br>返回矩阵乘积 MN. 注意：矩阵乘积必须是已定义的. 如果M是一个向量，它被作为一个行向量，则向量－矩阵（vector-matrix）乘法是已定义的。类似的,如果N 是一个向量，他被作为一个列向量，则矩阵－向量（matrix-vector）乘法是已定义的<br>normalize(v)<br>返回 v/∥v∥<br>pow(b, n)<br>返回 bn<br>radians(x)<br>转换 x 从 角度 到 弧度<br>reflect(v, n)<br>给定向量v和表面法线n，计算其反射向量<br>refract(v,n, eta)<br>给定向量v、表面法线n和两种材质的两个索引的比率eta，计算其折射向量. 翻看一下物理书中Snell的规则或者在互联网上搜索一下关于refraction（反射）的信息<br>rsqrt(x)<br>返回x的平方根的倒数<br>saturate(x)<br>返回clamp(x, 0.0, 1.0)<br>sin(x)<br>返回x的正弦,其中x单位为弧度<br>返回x的正弦,其中x单位为弧度<br>返回x的正弦和余弦，其中x单位为弧度<br>sqrt(x)<br>返回x的平方根<br>tan(x)<br>返回x的正切,其中 x 单位为弧度<br>transpose(M)<br>返回MT的转置</variable></p>
<p>   大多数函数已经重载以使其可以对所有内建类型有意义。例如，abs对所有数值类型有意义，所以它为所有这些数值类型进行了重载。又例如，叉积的叉乘仅对3D向量有意义，所以它对所有类型的3D向量（比如：int，float，double的3D向量）进行了重载。另一方面，线性插值——lerp，对于数值、2D、3D和4D向量有意义，因此重载了这些类型。</p>
<p>注意：如果你传递进去一个非数值类型到一个（要求）数值类型的函数，也就是一个仅能对数值类型进行操作的函数（比如：cos(x)），那么这个函数会对传进去的每个分量进行操作。例如，你写：<br>floats v = float3 (0.0f, 0.0f, 0.0f);<br>v = cos(v);</p>
<p>那么函数将会对每个分量进行操作：v=(cos(x),cos(y),cos(z))。<br>下例展示了这些固有的函数可能被调用的方式：<br>float x = sin(1.0f);       // sine of 1.0f radian.<br>float y = sqrt(4.0f);      // square root of 4.</p>
<p>vector u = {1.0f, 2.0f, -3.0f, 0.0f};<br>vector v = {3.0f, -1.0f, 0.0f, 2.0f};<br>float  s = dot(u, v);      // compute dot product of u and v.</p>
<p>float3 i = {1.0f, 0.0f, 0.0f};<br>float3 j = {0.0f, 1.0f, 0.0f};<br>float3 k = cross(i, j);    // compute cross product of i and j.</p>
<p>matrix<float, 2 2,> M = {1.0f, 2.0f, 3.0f, 4.0f};<br>matrix<float, 2 2,> T = transpose(M); // compute transpose</float,></float,></p>
<p>16.8 摘要</p>
<ul>
<li>我们在ASCII文本文件中编写了HLSL程序，并且在我们的应用程序中使用D3DXCompileShaderFromFile函数编译了它们。</li>
<li>ID3DXConstantTable接口允许我们在应用程序中对着色器程序中的变量进行设置。这种通信是必须的，因为被着色器使用的变量可以按一帧一帧的变化而改变。例如，如果应用程序中的视图矩阵发生了改变，我们需要使用新的视图矩阵更新着色器的视图矩阵变量。我们可以用ID3DXConstantTable完成这种更新。</li>
<li>对于每个着色器，我们必须定义一个输入和一个输出结构，这些结构分别描述了着色器中输入和输出数据的格式。</li>
<li>每个着色器有一个入口点函数，它有一个输入结构参数用于传递数据进着色器。此外，每个着色器返回一个输出结构的实例，它用于从着色器输出数据。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Picking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Picking/" class="post-title-link" itemprop="url">第十五章 选取(Picking)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:26:08" itemprop="dateCreated datePublished" datetime="2019-04-11T15:26:08+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Picking/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Picking/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>概览(OVERVIEW)<br>   如果用户点击了屏幕上的点 s = (x, y)。 从图15.1 我们能看到用户选取了茶壶。 无论如何，应用程序无法根据给定的s点就立即确定茶壶是被选取。所以，我们必须拿出计算这个动作技巧来，叫做选取技巧。</p>
<p>   图15.1 用户正在选择茶壶</p>
<p>   我们知道一些知识：关于茶壶和它的关联点s，茶壶投影在围绕s点的区域，更准确的说是：它投影到投影窗口上围绕p点的区域，与它对应的屏幕点是s。因为这个问题依赖于3D物体与它的投影之间的关系，我们看图15.2就可以了解。</p>
<p>图15.2放射线穿过点p点将会相交于围绕p点投影的对象。 注意：在投影窗口上的点 p与荧屏上被按下了点s相关联。</p>
<p>   图15.2我们看到如果我们发射一条选取射线，从原点发出，经过点p，会与围绕p点投影的对象相交，即茶壶。所以一旦我们计算选取射线，我们可以遍例场景中的每个对象并测试，看射线是否与它相交。与射线相交的对象即是用户选择的对象，在这个例子中用户选取的对象是茶壶。<br>   上面的例子讲解了点s与茶壶的关系。通常我们任意点击屏幕上的点，我们遍例场景中的每个对象，如果对象与射线相交，那么这个对象就是用户选取的对象。例如，图15.1中，如果用户没有点击5个对象中的一个，而是点击了白色的背景区域，射线将不能相交任何对象。因此，结论是：如果射线没有与场景中的任何对象相交，则用户没有点击任何一个对象，其它的我们不关心。<br>   “选取”适用于所有种类的游戏和3D程序。例如，玩家通过用鼠标点击来影响3D世界中的不同对象，玩家可能点击向敌人射击，或点击拾取物品。好的程序会适当做出反应，程序需要知道哪个对象被选取（是敌人还是物品），和在3D空间中的位置（开枪会击中哪？或玩家将要移动到哪去拾取物品？）。选取回答了我们这些问题。</p>
<p>目标<br>学习如何计算选取算法并了解它是如何工作的，我们将选取分解成四步：<br>1) 给一个屏幕点s，找出它在投影窗口上相交的点，即p。<br>2) 计算射线，它是从原点出发并经过点p。<br>3) 转换射线与模型到同一空间。<br>4) 测试与射线相交的对象，相交的对象即是屏幕上点击的对象。<br>15.1 屏幕到投影窗口的转换<br>首先，转换屏幕点到投影窗口，视口变换矩阵是：</p>
<p>根据屏幕上的点s = (sx, sy)，通过视口转换，得到在投影窗口上的点p = (px, py, pz)：</p>
<p>回忆一下2D图形部分：视口转换后z轴是不用保存的，而被保存在z缓存中。<br>给出屏幕点s，我们要找到点p，使用下列公式：</p>
<p>假定视口成员x和y都是0，通常我们能进一步得到：</p>
<p>因为前面的定义，投影窗口就是z=1的平面，所以pz = 1。</p>
<p>可是我们还什么都没做，投影矩阵缩放投影窗口上的点，来模拟不同的视角。为了返回缩放前的点值，我们必须用与缩放相反的操作来转换点。P是投影矩阵，因为P00 和 P11转换距阵缩放点的x和y坐标，我们得到：</p>
<p>15.2 计算射线<br>   回忆一下，射线能够描述参数方程：p(t) = p0 + tu。其中p0是射线的起点，用来描述它的位置，u是向量，用来描述它的方向。<br>   如图15.2，我们知道射线的起点总是视图空间的原点，所以p0 = (0, 0, 0)，如果p是射线穿过投影窗口上的点，方向向量u给出：u = p - p0 = (px, py, 1) - (0, 0, 0) = p。<br>   下面的方法用来计算选取射线（从屏幕空间点击的点所对应的视图空间的点x、y坐标）：<br>d3d::Ray CalcPickingRay(int x, int y)<br>{<br>     float px = 0.0f;<br>     float py = 0.0f;</p>
<pre><code> D3DVIEWPORT9 vp;
 Device-&gt;GetViewport(&amp;vp);
 D3DXMATRIX proj;
 Device-&gt;GetTransform(D3DTS_PROJECTION, &amp;proj);

 px = ((( 2.0f*x) / vp.Width)  - 1.0f) / proj(0, 0);
 py = (((-2.0f*y) / vp.Height) + 1.0f) / proj(1, 1);

 d3d::Ray ray;
 ray._origin    = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
 ray._direction = D3DXVECTOR3(px, py, 1.0f);

 return ray;
</code></pre><p>}<br>where Ray is defined as:<br>struct Ray<br>{<br>     D3DXVECTOR3 _origin;<br>     D3DXVECTOR3 _direction;<br>};<br>   我们更新d3dUtility.h文件，在d3d命名空间中加入选取射线Ray。</p>
<p>15.3 变换射线<br>   上一节讲到，选取射线的计算被描述在视图空间，为了完成射线的相交的测试，射线和对象必须在同一个坐标系统。通常转换射线到世界空间（甚至对象在本地空间）要好于将所有对象转换到视图空间。<br>   我们能够将一个变换矩阵转换为一条原点为p0，方向为u的射线r(t) = p0 + tu，注意：原点转换为一个点，方向转换为一个向量，在本章的选取例子中，下列函数转换一条射线：<br>void TransformRay(d3d::Ray<em> ray, D3DXMATRIX</em> T)<br>{<br>      // transform the ray’s origin, w = 1.<br>      D3DXVec3TransformCoord(<br>           &amp;ray-&gt;_origin,<br>           &amp;ray-&gt;_origin,<br>           T);</p>
<pre><code>  // transform the ray&#39;s direction, w = 0.
  D3DXVec3TransformNormal(
       &amp;ray-&gt;_direction,
       &amp;ray-&gt;_direction,
       T);

  // normalize the direction
  D3DXVec3Normalize(&amp;ray-&gt;_direction, &amp;ray-&gt;_direction);
</code></pre><p>}<br>   D3DXVec3TransformCoord和D3DXVec3TransformNormal接受一个Ray类型参数（包含二个3D向量成员）。 D3DXVec3TransformCoord函数中，射线的原点（_origin）向量的第四部分w = 1。相反，函数D3DXVec3TransformNormal中，射线的方向（_direction）向量的第四部分w = 0。<br>   这样，当我们向世界空间转换时，能够用D3DXVec3TransformCoord转换一个点，用D3DXVec3TransformNormal转换一个向量。</p>
<p>15.4 射线－对象 交点<br>   我们将射线和对象转换到同一坐标系统后，准备测试哪个对象与射线相交。因为我们将对象描述为三角形组成的网络，下面详细说明这种方法。遍例场景中每个对象的三角形列表并测试，如果射线相交于一个三角形，它就与三角形所在的对象相交。<br>   然而，通过遍例场景中的每个三角形来实现射线相交在计算上会增加时间，一种比较快的方法，虽然准确性会差一点。它将每个对象围成一个近似的球形（边界球），这样我们就能通过遍例每个边界球来测试射线相交。用边界球来描述相交的对象。<br>   注意：射线可能相交多个对象，然而离照相机近的对象会被选取。因为近距离对象遮挡了后面的对象。<br>   给出一个边界球的圆心c和半径r，使用下列恒等式能够测试点p是否在边界球上：<br>   ||p-c||-r = 0<br>   如果恒等式满足，则点p在边界球上。如图15.3</p>
<p>   图15.3 向量p到c的长度表示为：||p - c||，如果等于半径则表示点p在边界球上。注意：我们使用边界球是为了方便，但这将扩展出三个种情况。<br>   假定射线p(t) = p0 + tu相交于边界球，我们将射线代入球的恒等式中，使参数t满足了球的恒等式，给出了满足相交点的参数。</p>
<p>将射线p(t) = p0 + tu代入球的恒等式：<br>||p(t) - c|| - r = 0   —&gt;   ||p0 + tu - c|| - r = 0</p>
<p>通过以上推导，我们得到二次方程：<br>At2 + Bt + C = 0</p>
<p>其中A = u · u, B = 2(u · (p0 - c))，而C = (p0 - c) . (p0 - c) – r 2。<br>如果u是标准化的，那么A = 1。<br>因为u是标准化的，我们解t0 和 t1：</p>
<p>   图15.4显示可能返回的t0 和 t1，并显示了一些返回值的几何意义：</p>
<p>   图15.4 (a)射线从球边上擦过；(b)射线在球前；(c)射线在球的内部；(d)射线相交于球；(e)射线是球的切线。<br>   下列方法射线通过并与边界球相交，返回true；射线错过边界球，返回false。<br> bool PickApp::raySphereIntersectionTest(Ray<em> ray,<br>                                        BoundingSphere</em> sphere)<br>{<br>     D3DXVECTOR3 v = ray-&gt;_origin - sphere-&gt;_center;<br>     float b = 2.0f <em> D3DXVec3Dot(&amp;ray-&gt;_direction, &amp;v);<br>     float c = D3DXVec3Dot(&amp;v, &amp;v) - (sphere-&gt;_radius </em> sphere-&gt;<br>                                      _radius);</p>
<pre><code> // find the discriminant
 float discriminant = (b * b) - (4.0f * c);

 // test for imaginary number
 if( discriminant &lt; 0.0f )
      return false;

 discriminant = sqrtf(discriminant);

 float s0 = (-b + discriminant) / 2.0f;
 float s1 = (-b - discriminant) / 2.0f;

 // if a solution is &gt;= 0, then we intersected the sphere
 if( s0 &gt;= 0.0f || s1 &gt;= 0.0f )
      return true;

 return false;
</code></pre><p>}<br>   当然，我们已经准备了一个边界球，为了便于理解我们再次显示它的定义：<br>bool PickApp::raySphereIntersectionTest(Ray<em> ray,<br>                                        BoundingSphere</em> sphere)<br>{<br>struct BoundingSphere<br>{<br>     BoundingSphere();</p>
<pre><code> D3DXVECTOR3 _center;
 float       _radius;
</code></pre><p>};</p>
<p>15.5 例子程序：选取<br>图15.5显示了本章例子程序的屏幕截图，茶壶绕着屏幕移动，你可以用鼠标试着点击它。如果你点击到茶壶的边界球上，一个消息框将弹出，表示你点中了。我们通过测试WM_LBUTTONDOWN消息来处理鼠标点击事件：<br>case WM_LBUTTONDOWN:</p>
<p>// compute the ray in view space given the clicked screen point<br>d3d::Ray ray = CalcPickingRay(LOWORD(lParam), HIWORD(lParam));</p>
<p>// transform the ray to world space<br>D3DXMATRIX view;<br>Device-&gt;GetTransform(D3DTS_VIEW, &amp;view);</p>
<p>D3DXMATRIX viewInverse;<br>D3DXMatrixInverse(&amp;viewInverse, 0, &amp;view);</p>
<p>TransformRay(&amp;ray, &amp;viewInverse);</p>
<p>// test for a hit<br>if( RaySphereIntTest(&amp;ray, &amp;BSphere) )<br>     ::MessageBox(0, “Hit!”, “HIT”, 0);</p>
<p>break;</p>
<p>图15.5 这章例子程序的屏幕截图</p>
<p>15.6 摘要</p>
<ul>
<li>选取技巧通过鼠标点击，来确定与3D对象对应的屏幕上显示的2D投影对象。</li>
<li>选取线是一个射线，源自视图空间的原点，穿过投影窗口上的点关联到屏幕上点击的点。</li>
<li>我们能够变换一个射线r(t) = p0 + tu，通过变换原点p0和通过矩阵变换得到方向u。注意：原点变换自一个（w=1）的点，方向是（w=0）的向量。</li>
<li>测试射线与对象相交，我们能测试射线是否相交于组成对象的三角形，或测试射线是否相交于围绕对象的一个体积，比如边界球。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Particle-System/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Particle-System/" class="post-title-link" itemprop="url">第十四章 粒子系统(Particle Systems)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:24:20" itemprop="dateCreated datePublished" datetime="2019-04-11T15:24:20+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Particle-System/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Particle-System/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>   许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。<br>目标：</p>
<ul>
<li>学习我们给定的粒子属性，如何描述D3D中的粒子。</li>
<li>设计一个灵活的粒子基系统的基类，包括一般的粒子系统都有的属性和方法。</li>
<li>模拟3个具体的粒子系统，雪、爆炸、粒子枪。<br>14.1 粒子和点精灵（Point Sprite）<br> 粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案。可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0,以前，因为点元方法的局限性而完全不使用他们。代替的方法是，程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。<br> Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。</li>
</ul>
<p>14.1.1 结构的格式<br>   我们使用下面的顶点结构来描述粒子的位置和颜色：<br>struct Particle<br>{<br>     D3DXVECTOR3 _position;<br>     D3DCOLOR    _color;<br>     static const DWORD FVF;<br>};<br>const DWORD Particle::FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;<br>   这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标，我们在下一节讨论给点精灵赋予纹理。<br>   增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是：用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：<br>strict Particle<br>{<br>     D3DXVECTOR3 _position;<br>     D3DCOLOR    _color;<br>     float       _size;<br>     static const DWORD FVF;<br>};<br>const DWORD Particle::FVF = D3DFVF XYZ | D3DFVF DIFFUSE |<br>  D3DFVF_PSIZE;<br>   注意：通过vertex shader，能够获取每个粒子的大小，即使你的硬件不支持D3DFVFCAPS_PSIZE。Vertex shaders的内容在本书的第IV部分。</p>
<p>14.1.2点精灵（Point Sprite）渲染状态<br>   点精灵的行为大部分由渲染状态（render states）来控制，现在让我们来看一下这些渲染状态：<br>D3DRS_POINTSPRITEENABLE—A Boolean value. The default value is false.<br>True表示将当前的纹理全部映射到点精灵上。<br>False 表示用指定的纹理坐标映射到点精灵的点（图素）上。<br>_device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);</p>
<p>D3DRS_POINTSCALEENABLE—A Boolean value. The default value is false.<br>True表示用视图空间单位来解释点的大小。视图空间单位的3D空间点在照相机中，点精灵将会自动缩放，这取决到它有多远, 像其他对象一样，离照相机近的粒子比离照相机远的粒子要小。<br>False 表示点的大小将用屏幕空间单位来解释。屏幕空间单位是屏幕上的像素单位。. 因此如果你指定false, 例如, 设置点精灵的尺寸为3, 则点精灵在屏幕区域中的尺寸为3×3像素。.<br>_device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);</p>
<p>D3DRS_POINTSIZE—表示点精灵的尺寸. 这个值可以任意指定视图空间或屏幕空间的点精灵的尺寸, 取决于D3DRS_POINTSCALEENABLE 状态如何设置. 下面的代码段设置点的尺寸为2.5个单位。:<br>_device-&gt;SetRenderState( D3DRS_POINTSIZE, d3d::FtoDw(2.5f) );</p>
<p>d3d::FtoDw 是我们新加进 d3dUtility.h/cpp 文件中的一个函数，它将float型转换为 DWORD型。 我们必须这么做是因为所有的IDirect3DDevice9::SetRenderState 都要一个 DWORD 型的值而不是float型。<br>DWORD d3d::FtoDw(float f)<br>{<br>     return <em>((DWORD</em>)&amp;f);<br>}</p>
<p>D3DRS_POINTSIZE_MIN—表示点精灵的最小尺寸。例子，将设置最小值为0.2：<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE_MIN, d3d::FtoDw(0.2f));</p>
<p>D3DRS_POINTSIZE_MAX—表示点精灵的最大尺寸。例子，将设置最大值为5.0:<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE_MAX, d3d::FtoDw(5.0f));</p>
<p>D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C—这3个常量表示如何根据距离控制点精灵的尺寸—这个距离是点精灵到照相机的距离。</p>
<p>D3D用以下的公式去计算点精灵的最终尺寸，这取决于距离和这3个常量。</p>
<p>其中：<br>FinalSize：距离计算后，点精灵的最后尺寸。<br>ViewportHeight：视口的高度。<br>Size：分别为D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, and D3DRS_POINTSCALE_C值。<br>D：在视图空间中点精灵与照相机的距离。因为照相机被放置在视图空间中的原点，这个值是：，也是点精灵所在的位置。</p>
<p>   下面代码设置点精灵的距离常量，因此远处的点精灵将变小。<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_A, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_B, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_C, d3d::FtoDw(1.0f));</p>
<p>14.1.3 粒子和他们的属性<br>    一个粒子系统是由除了位置、颜色以外的更多的属性组成，例如，一个粒子有某些速度。然而，这些额外的属性对于渲染粒子来说不是必须的。因此，我们在单独的结构中保存渲染粒子所必须的数据和属性。当我们创建、显示或更新粒子时，我们使用属性来工作。当我们准备渲染时，我们从Particle（粒子）结构中COPY位置和颜色。<br>   对于我们模拟的具体粒子系统，粒子的属性也是不同的。因此我们能够归纳一些通用的属性，一面的结构例子中包含一些通用的属性，大多数系统用不上这么多，一些系统需要的属性这里可能还没有。<br>struct Attribute<br>{<br>     D3DXVECTOR3 _position;<br>     D3DXVECTOR3 _velocity;<br>     D3DXVECTOR3 _acceleration;<br>     float       _lifeTime;<br>     float       _age;<br>     D3DXCOLOR   _color;<br>     D3DXCOLOR   _colorFade;<br>     bool        _isAlive;<br>};<br>_position—粒子在世界空间中的位置<br>_velocity—粒子的速度，每秒多少个单位。<br>_acceleration—粒子的加速度, 每秒多少个单位。<br>_lifeTime—粒子的生命周期. 例如,当一个时间段后，我们可以杀死一个激光柱的粒子.<br>_age—粒子的当前年龄。<br>_color—粒子的颜色。<br>_colorFade—粒子随时间的变化而褪去的颜色。<br>_isAlive—True 表示粒子活着;false 表示粒子死了。 </p>
<p>14.2 粒子系统的组成<br>   粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。<br>   虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的Psystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下Psystem类：<br>class PSystem<br>{<br>public:<br>     PSystem();<br>     virtual ~PSystem();</p>
<pre><code> virtual bool init(IDirect3DDevice9* device, char* texFileName);
 virtual void reset();
 virtual void resetParticle(Attribute* attribute) = 0;
 virtual void addParticle();
 virtual void update(float timeDelta) = 0;

 virtual void preRender();
 virtual void render();
 virtual void postRender();

 bool isEmpty();
 bool isDead();
</code></pre><p>protected:<br>     virtual void removeDeadParticles();</p>
<p>protected:<br>     IDirect3DDevice9<em>       _device;<br>     D3DXVECTOR3             _origin;<br>     d3d::BoundingBox        _boundingBox;<br>     float                   _emitRate;<br>     float                   _size;<br>     IDirect3DTexture9</em>      _tex;<br>     IDirect3DVertexBuffer9* _vb;<br>     std::list<attribute>    _particles;<br>     int                     _maxParticles;</attribute></p>
<pre><code> DWORD _vbSize;
 DWORD _vbOffset;
 DWORD _vbBatchSize;
</code></pre><p>};</p>
<p>   一些数据成员：</p>
<ul>
<li>_origin—粒子系统的原点， 这是粒子系统产生时的位置。</li>
<li>_boundingBox—创建粒子系统使用的边界盒，用于限制粒子的活动范围。例如，假如我们让雪系统只落在一个围绕高山的峰顶的体积内； 我们会定义一个包括这个体积的边界盒, 出界的粒子将会被杀死。</li>
<li>_emitRate—新增加到系统中的粒子的速度。 通常的标准是每秒。</li>
<li>_size—系统中所有粒子的尺寸。</li>
<li>_particles—系统中粒子属性的一个列表。 我们用这个列表创建，释放及更新粒子。 当我们准备画粒子时, 我们COPY列表节点的一部分到顶点缓存并画粒子。 当我们COPY另外一批时绘制这批粒子，然后重复这一过程直到绘制完所有粒子。 这有点太简单了，我们将在section 14.2.1节详细的解释绘制的过程。</li>
<li>_maxParticles—在给定的时间内，系统中允许的粒子最大数。例如, 如果创建粒子的速度比释放快的话, 随着时间的增长粒子的数量将会是巨大的，这个成员将避免出现这样的问题。</li>
<li>_vbSize—在给定的时间内顶点缓存中能够保存的粒子的数量，这个值与实际的粒子系统中的粒子数量无关。<br>注意：member _vbOffset和_vbBatchSize数据成员在渲染粒子系统时使用，我们在稍后的section 14.2.1节讨论。</li>
</ul>
<p>方法：</p>
<ul>
<li>PSystem/ ~PSystem—用来初始化默认值的构造器/用来释放设备接口的析构器 (vertex buffer, texture)。</li>
<li>init—这个方法做与设备无关的初始化工作, 比如创建用来保存点精灵的顶点缓存或创建纹理。 顶点缓存的创建包括一些标记，现在我们都已经讨论过了，但还没有用:<br>hr = device-&gt;CreateVertexBuffer(<br>   _vbSize * sizeof(Particle),<br>   D3DUSAGE DYNAMIC | D3DUSAGE POINTS | D3DUSAGE WRITEONLY,<br>   Particle::FVF,<br>   D3DPOOL_DEFAULT,<br>   &amp;_vb,<br>   0) ;</li>
<li>o 注意： 我们使用动态的顶点缓存（D3DUSAGE DYNAMIC）。 因为我们需要在每帧中更新我们的粒子,意思是我们将会去存取顶点缓存的内存，回想一下，访问一个静态的顶点缓存慢得不可接受， 所以我们使用动态的顶点缓存。<br>o 查看我们用过的 D3DUSAGE_POINTS 标记,它说明顶点缓存将保存点精灵。<br>o 顶点缓存的尺寸是由_vbSize预先确定的，而且与系统中粒子的数量无关。 也就是说, _vbSize 将小于等于系统中粒子的数量。 这是因为渲染粒子系统是一批一批的，不是一次渲染全部。 我们将在section 14.2.1节中解释渲染过程。<br>o 我们使用默认的内存池(pool)代替通常使用的托管内存池，因为动态顶点缓存不能用在托管内存池中。</li>
<li>reset—这个方法重新设置系统中每个粒子的属性:<br>void PSystem::reset()<br>{<br>   std::list<attribute>::iterator i;<br>   for(i = _particles.begin(); i != _particles.end(); i++)<br>   {<pre><code>    resetParticle( &amp;(*i) );
</code></pre>   }<br>}</attribute></li>
<li>resetParticle—这个方法重新设置粒子的属性。如何重设粒子的属性，这依赖于具体粒子系统的特性。因此我们定义这个方法为虚拟的，等待子类去实现。</li>
<li>addParticle—这个方法用来在系统中增加一个粒子。在增加它到粒子列表之前，使用resetParticle 方法先初始化粒子:<br>void PSystem::addParticle()<br>{<br>   Attribute attribute;<br>   resetParticle(&amp;attribute);<br>   _particles.push_back(attribute);<br>}<br>void PSystem::addParticle()</li>
<li>update—这个方法更新系统中所有的粒子。因为这个的方法的执行取决于具体粒子系统的特性, 因此我们定义这个方法为抽象的，等待子类去实现。</li>
<li>render—这个方法用来显示系统中所有的粒子。 执行起来很复杂，我们将在14.2.1 节讨论。</li>
<li><p>preRender—用它来初始化渲染状态， 在渲染前设置。 因为系统与系统之间是不同的,所以我们定义它为虚拟的。 默认将执行下列代码:<br>void PSystem::preRender()<br>{<br>_device-&gt;SetRenderState(D3DRS_LIGHTING, false);<br>_device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE, d3d::FtoDw( size));<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE MIN, d3d::FtoDw(0.0f));</p>
<p>// control the size of the particle relative to distance<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE A, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE B, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE C, d3d::FtoDw(1.0f));</p>
<p>// use alpha from texture<br><em>device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA</em><br>   TEXTURE);<br><em>device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP</em><br>   SELECTARG1);</p>
<p>_device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);<br>_device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>}</p>
</li>
<li>注意：我们使用alpha混合渲染，以便设置纹理的alpha通道，来设置纹理像素的透明度。 用它产生多种效果；一种特殊的情况是：获得象纹理那样的非矩形的粒子。例如， 获得一个圆形“雪球形”的粒子, 我们使用一个简单的带有alpha通道的纹理， 它看上去是背景为黑色的带有白色圆形的样子。因此，显示出来时只是一个白圆，这比白色的矩形纹理要好。</li>
<li><p>postRender—用它去保存所有渲染状态，它是一个特殊的粒子系统可能有的设置。因为系统与系统间是不同的,所以我们定义它为虚拟的。默认将执行下列代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PSystem::postRender()</span><br><span class="line">&#123;</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_LIGHTING,          <span class="literal">true</span>);</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, <span class="literal">false</span>);</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE,  <span class="literal">false</span>);</span><br><span class="line">    _device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE,  <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>isEmpty—如果为True 则在当前的系统中没有粒子， 否则为false.</p>
</li>
<li>isDead—如果为True 则系统中的所有粒子都是死的，否则为false。 注意： 系统中所有粒子状态为idDead时并不意味着isEmpty. 空意思着系统中没有粒子。 Dead的意思是系统中有粒子，但都是死的。.</li>
<li>removeDeadParticles—搜索属_particle性表，从表中杀死并删除粒子。<br>14.2.1 绘制粒子系统<br> 因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下:</li>
<li><p>创建一个足够大的顶点缓存保存最大数量的粒子。</p>
<pre><code>   每一帧里执行：
</code></pre><p>A. 更新所有粒子。<br>B. COPY所有活着的粒子到顶点缓存。<br>C. 绘制顶点缓存。<br> 这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，并且我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。</p>
<p>  更好的办法（SDK中点精灵例程中用到的方法）就象这样：<br> 提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。</p>
<p> 创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。</p>
</li>
</ul>
<ul>
<li>然后创建一个全局变量 i = 0 ，用来记录片段。<pre><code>   每一帧里执行:
</code></pre>A. 更新所有粒子。<br>B. 直到所有粒子渲染完毕。:</li>
</ul>
<ol>
<li>如果顶点缓存没有满：<br>a 用D3DLOCK_NOOVERWRITE标记锁定缓存片段i<br>b COPY 500个粒子到片段i</li>
<li><p>如果顶点缓存满了：<br>a 从起始的地方开始顶点缓冲: i=0<br>b 用D3DLOCK_NOOVERWRITE标记锁定缓存段i<br>c COPY 500个粒子到片段i </p>
</li>
<li><p>渲染片段i. </p>
</li>
<li><p>下一片段： i+ +<br>备注：顶点缓存是动态的， 因此我们能利用动态锁定标记D3DLOCK_NOOVERWRITE 和 D3DLOCK_DISCARD。这两个标记允许我们锁定顶点缓存的某一部分。当顶点缓存中的其他部分被渲染时，它是不能渲染的。例如，假如我们正在使用D3DLOCK_NOOVERWRITE标记渲染片段0时， 当渲染片段0的时候我们能锁定并填充片段1。这样可以防止渲染的延迟。</p>
<p>这个方法更有效率。首先，我们减少顶点缓存的尺寸；然后， CPU与显卡在协调的工作。也就是说，当我们绘制一小批粒子时(graphics card work)，同时拷贝另一小批粒子到顶点缓存 (CPU work)。这个动作是连续执行的，直到所有的粒子都被渲染完毕，就像你了解的一样， 显卡在全部顶点缓存被填充的时候是不用处于空闲状态的。<br>我们现在将注意力转向这一个渲染方案的实现，为了方便使用这个粒子系统的渲染方案, 我们使用 PSystem 类中的下列数据成员:</p>
</li>
</ol>
<ul>
<li>_vbSize—在给定时间内我们的顶点缓存能够保存的粒子数量。这个值与实际的粒子系统中的粒子数无关。</li>
<li>_vbOffset—这个变量是在顶点缓存中的偏移，在顶点缓存里我们将用它开始COPY下一批粒子，例如，如果第一批在缓存中是0到499，偏移到第二批COPY的开始处将是500。</li>
<li>_vbBatchSize—定义一批缓存中的粒子数量。</li>
<li>我们现在介绍渲染方法的代码：<br>void PSystem::render()<br>{<br>if( !_particles.empty() )<br>{<br>   // set render states<br>   preRender();<br>   _device-&gt;SetTexture(0, _tex);<br>   _device-&gt;SetFVF(Particle::FVF);<br>   _device-&gt;SetStreamSource(0, _vb, 0, sizeof(Particle));</li>
</ul>
<p>// start at beginning if we’re at the end of the vb<br>     if(_vbOffset &gt;= _vbSize)<br>          _vbOffset = 0;</p>
<pre><code> Particle*v =0;

 _vb-&gt;Lock(
      _vbOffset    * sizeof( Particle ),
      _vbBatchSize * sizeof( Particle ),
      (void**)&amp;v,
      _vbOffset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);

 DWORD numParticlesInBatch = 0;

 //
 // Until all particles have been rendered.
 //
 std::list&lt;Attribute&gt;::iterator i;
 for(i = _particles.begin(); i != _particles.end(); i++)
 {
      if( i-&gt;_isAlive )
      {
           //
           // Copy a batch of the living particles to the
           // next vertex buffer segment
           //
           v-&gt;_position = i-&gt;_position;
           v-&gt;_color = (D3DCOLOR)i-&gt;_color;
           v++; // next element;

           numParticlesInBatch++; //increase batch counter

           // is this batch full?
           if(numParticlesInBatch == _vbBatchSize)
           {
                //
                // Draw the last batch of particles that was
                // copied to the vertex buffer.
                //
                _vb-&gt;Unlock();
                _device-&gt;DrawPrimitive(
                     D3DPT_POINTLIST,
                     _vbOffset,
                     _vbBatchSize);

           //
           // While that batch is drawing, start filling the
           // next batch with particles.
           //

           // move the offset to the start of the next batch
           _vbOffset += _vbBatchSize;

           // don&#39;t offset into memory thats outside the vb&#39;s
           // range. If we&#39;re at the end, start at the beginning.
           if(_vbOffset &gt;= _vbSize)
                _vbOffset = 0;

           _vb-&gt;Lock(
                _vbOffset    * sizeof( Particle ),
                _vbBatchSize * sizeof( Particle ),
                (void**)&amp;v,
                _vbOffset ? D3DLOCK_NOOVERWRITE :
                   D3DLOCK_DISCARD);

           numParticlesInBatch = 0; // reset for new batch
      }//end if
   }//end if
 }//end for

 _vb-&gt;Unlock();

 // it&#39;s possible that the LAST batch being filled never
 // got rendered because the condition
 // (numParticlesInBatch == _vbBatchSize) would not have
 // been satisfied.  We draw the last partially filled batch now.

 if( numParticlesInBatch )
 {
       _device-&gt;DrawPrimitive(
            D3DPT_POINTLIST,
            _vbOffset,
            numParticlesInBatch);
 }

 // next block
 _vbOffset += _vbBatchSize;

 postRender();
 }//end if
</code></pre><p>}// end render()</p>
<p>14.2.2 随机<br>   这有一个随机的粒子系统。例如，如果我们模拟雪花，不能让所有雪花以完全相同的方式落下。我们要让它们按相似的方式落下而不是完全相同的方式。为了使粒子系统的随机功能更简单，我们增加了下列两个函数到d3dUtility.h/cpp文件。<br>   第一个函数在[lowBound, highBound]区间内随机的返回一个Float类型值：<br>float d3d::GetRandomFloat(float lowBound, float highBound)<br>{<br>     if( lowBound &gt;= highBound ) // bad input<br>          return lowBound;</p>
<pre><code> // get random float in [0, 1] interval
 float f = (rand() % 10000) * 0.0001f;

 // return float in [lowBound, highBound] interval.
 return (f * (highBound - lowBound)) + lowBound;
</code></pre><p>}<br>   第二个函数在边界盒的范围内，输出一个随机的向量。<br>void d3d::GetRandomVector(<br>       D3DXVECTOR3<em> out,<br>       D3DXVECTOR3</em> min,<br>       D3DXVECTOR3* max)<br>{<br>       out-&gt;x = GetRandomFloat(min-&gt;x, max-&gt;x);<br>       out-&gt;y = GetRandomFloat(min-&gt;y, max-&gt;y);<br>       out-&gt;z = GetRandomFloat(min-&gt;z, max-&gt;z);<br>}</p>
<p>   注意：记得用srand()去seed随机数生成器。<br>14.3 具体的粒子系统：雪、火、粒子枪<br>现在让我们用Psystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到Psystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。这些系统的名字基本上概括了他们的模型。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。<br>注意：照例，用全部的工程代码来说明这些系统，你能够在本章找到这些文件。</p>
<p>14.3.1 例子程序：雪</p>
<p>图14.2 雪系统例子的屏幕截图</p>
<p>雪系统类定义如下：<br>class Snow : public PSystem<br>{<br>public:<br>     Snow(d3d::BoundingBox<em> boundingBox, int numParticles);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta);<br>};<br>备注：因为父类做了大部分的工作，所以雪系统的接口非常简单。事实上，我们在这一节中实现的这三个粒子系统，接口简单并相对容易实现。<br>   构造器提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造器的实现：<br>Snow::Snow(d3d::BoundingBox<em> boundingBox, int numParticles)<br>{<br>     _boundingBox   = </em>boundingBox;<br>     _size          = 0.8f;<br>     _vbSize        = 2048;<br>     _vbOffset      = 0;<br>     _vbBatchSize   = 512;<br>     for(int i = 0; i &lt; numParticles; i++)<br>          addParticle();<br>}<br>   同样注意：我们指定顶点缓存的尺寸，每一批的尺寸和开始的偏移。<br>   ResetParticle方法创建一个雪花，在x、z轴随机的位置并在边界盒的范围内。设置y轴高度为边界盒的顶部。如果给雪花一个速度，以便让雪花下落时稍稍向左倾斜。雪花是白色的。<br>void Snow::resetParticle(Attribute* attribute)<br>{<br>     attribute-&gt;_isAlive = true;</p>
<pre><code> // get random x, z coordinate for the position of the snowflake.
 d3d::GetRandomVector(
      &amp;attribute-&gt;_position,
      &amp;_boundingBox._min,
      &amp;_boundingBox._max);

 // no randomness for height (y-coordinate). Snowflake
 // always starts at the top of bounding box.
 attribute-&gt;_position.y = _boundingBox._max.y;

 // snowflakes fall downward and slightly to the left
 attribute-&gt;_velocity.x = d3d::GetRandomFloat(0.0f, 1.0f)*-3.0f;
 attribute-&gt;_velocity.y = d3d::GetRandomFloat(0.0f, 1.0f)*-10.0f;
 attribute-&gt;_velocity.z = 0.0f;

 // white snowflake
 attribute-&gt;_color = d3d::WHITE;
</code></pre><p>}<br>   Update方法更新粒子和粒子间的位置，并且测试粒子是否在系统的边界盒之外，如果它已经跳出边界盒，就再重新创建。<br>void Snow::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;<br>     for(i = _particles.begin(); i != _particles.end(); i++)<br>     {<br>          i-&gt;_position += i-&gt;_velocity * timeDelta;</attribute></p>
<pre><code>      // is the point outside bounds?
      if( _boundingBox.isPointInside( i-&gt;_position ) == false )
      {
           // nope so kill it, but we want to recycle dead
           // particles, so respawn it instead.
           resetParticle( &amp;(*i) );
      }
 }
</code></pre><p>}</p>
<p>14.3.2 例子程序：火</p>
<p>图14.3 火粒子系统例子的屏幕截图<br>火系统类定义如下：<br>class Firework : public PSystem<br>{<br>public:<br>     Firework(D3DXVECTOR3<em> origin, int numParticles);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta); void preRender();<br>     void postRender();<br>};<br>   构造器需要提供一个点作为粒子系统中的原点，和系统中的粒子数，原点是火焰爆发的那个点。<br>ResetParticle方法在原点位置初始化粒子系统，并在边界球内创建一个随机的速度，粒子系统中的每个例子有一个随机的颜色，我们定义粒子只能存活2秒。<br>void Firework::resetParticle(Attribute* attribute)<br>{<br>     attribute-&gt;_isAlive = true;<br>     attribute-&gt;_position = _origin;</p>
<pre><code> D3DXVECTOR3 min = D3DXVECTOR3(-1.0f, -1.0f, -1.0f);
 D3DXVECTOR3 max = D3DXVECTOR3( 1.0f,  1.0f,  1.0f);

 d3d::GetRandomVector(
      &amp;attribute-&gt;_velocity,
      &amp;min,
      &amp;max);
 // normalize to make spherical
 D3DXVec3Normalize(
      &amp;attribute-&gt;_velocity,
      &amp;attribute-&gt;_velocity);

 attribute-&gt;_velocity *= 100.0f;

 attribute-&gt;_color = D3DXCOLOR(
      d3d::GetRandomFloat(0.0f, 1.0f),
      d3d::GetRandomFloat(0.0f, 1.0f),
      d3d::GetRandomFloat(0.0f, 1.0f),
      1.0f);

 attribute-&gt;_age      = 0.0f;
 attribute-&gt;_lifeTime = 2.0f; // lives for 2 seconds
</code></pre><p>}</p>
<p>   Update方法更新每个粒子的位置，并在粒子超出自己的生活周期时杀死它。注意：这个系统不能移除死掉的粒子，这么做是因为我们想产生一个新的火焰的时候，我们只要简单的重新设置已经存在的死了的火焰系统就可以了。这样为我们不必频繁的去产生和释放粒子。<br>void Firework::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;</attribute></p>
<pre><code> for(i = _particles.begin(); i != _particles.end(); i++)
 {
      // only update living particles
      if( i-&gt;_isAlive )
      {
           i-&gt;_position += i-&gt;_velocity * timeDelta;

           i-&gt;_age += timeDelta;

           if(i-&gt;_age &gt; i-&gt;_lifeTime) // kill
                i-&gt;_isAlive = false;
      }
 }
</code></pre><p>}<br>当渲染时，火系统使用不同的方法渲染像素。进一步讲，它不写深度缓存，我们可以简单的改变混合像素，通过重写PSystem::preRender方法和PSystem::postRender方法，下面是重写的实现：<br>void Firework::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;<br>void Firework::preRender()<br>{<br>     PSystem::preRender();</attribute></p>
<pre><code> _device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
 _device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
 // read, but don&#39;t write particles to z-buffer
 _device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, false);
</code></pre><p>}</p>
<p>void Firework::postRender()<br>{<br>     PSystem::postRender();</p>
<pre><code> _device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, true);
</code></pre><p>}<br>注意：这两个方法调用父类版本，这样，我们仍能重新使用父类的一些功能，做一些小的改变就变成了火焰系统。<br>14.3.3 例子程序：粒子枪</p>
<p>图14.4 激光枪系统的截图<br>下面是粒子枪系统的定义：<br>class ParticleGun : public PSystem<br>{<br>public:<br>     ParticleGun(Camera<em> camera);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta);</p>
<p>private:<br>     Camera<em> _camera;<br>};<br>   构造器需要提供一个照相机的位置点，这是因为系统需要知道照相机的位置及朝向，以决定在哪创建一个粒子。<br>   ResetParticle方法设置粒子的位置为当前照相机的位置，并且设置方向上的速度，在照像机视角的100个单位。这样，子弹将射向我们正在看的方向，粒子颜色为绿色。<br>void ParticleGun::resetParticle(Attribute</em> attribute)<br>{<br>     attribute-&gt;_isAlive  = true;</p>
<pre><code> D3DXVECTOR3 cameraPos;
 _camera-&gt;getPosition(&amp;cameraPos);

 D3DXVECTOR3 cameraDir;
 _camera-&gt;getLook(&amp;cameraDir);

 // change to camera position
 attribute-&gt;_position = cameraPos;
 attribute-&gt;_position.y -= 1.0f; // slightly below camera so it&#39;s
                                 // like we&#39;re carrying gun

 // travels in the direction the camera is looking
 attribute-&gt;_velocity = cameraDir * 100.0f;

 // green
 attribute-&gt;_color = D3DXCOLOR(0.0f, 1.0f, 0.0f, 1.0f);

 attribute-&gt;_age      = 0.0f;
 attribute-&gt;_lifeTime = 1.0f; // lives for 1 seconds
</code></pre><p>}</p>
<p>   Update方法更新粒子的位置，并且杀死超过其生命周期的粒子，然后，我们搜索粒子列表删除已经死了的粒子。<br>{<br>     std::list<attribute>::iterator i;</attribute></p>
<pre><code> for(i = _particles.begin(); i != _particles.end(); i++)
 {
      i-&gt;_position += i-&gt;_velocity * timeDelta;

      i-&gt;_age += timeDelta;

      if(i-&gt;_age &gt; i-&gt;_lifeTime) // kill
           i-&gt;_isAlive = false;
 }
 removeDeadParticles();
</code></pre><p>}</p>
<p>14.4 摘要</p>
<ul>
<li>用点精灵来显示一个粒子是方便且灵活的，它可能改变粒子尺寸、给粒子赋予纹理。此外，能够使用简单的顶点（vertex）来描述它们。</li>
<li>粒子系统维护一个粒子的集合，并负责创建、释放、更新和显示粒子。</li>
<li>还有一些其他粒子系统的概念，是你能够实现的：烟，火箭的轨迹，喷泉/河水车效果，火，光，爆炸，和雨。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/Basic-Terrain-Rendering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/Basic-Terrain-Rendering/" class="post-title-link" itemprop="url">第十三章 地形渲染基础(Basic Terrain Rendering)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:21:54" itemprop="dateCreated datePublished" datetime="2019-04-11T15:21:54+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Direct3D/" itemprop="url" rel="index"><span itemprop="name">Direct3D</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/11/Basic-Terrain-Rendering/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Basic-Terrain-Rendering/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实际上，地形网格不比三角形网格复杂，图13.1.(a)所示，网络的每个顶点指定了高度，格子模型用这种方式显示从山脉到河流的平滑过渡。图13.1 (b)，模拟自然地形。当然，我们可以用漂亮的纹理表现沙石地，绿色的山丘。图13.1.(c)雪山效果。</p>
<p>图 13.1: (a) 三角网格. (b) 平滑高度过渡的三角网格. (c) 光和纹理，我们在这一章节中写的例子的一个屏幕截图。<br>   这一章的内容是实现一个Terrain（地形）类。这个类的功能很强。我们的意思是，它只是储存整个地形的顶点/索引数据，然后渲染它。因为如果游戏需要一个小的地形，那么它能够在现代图形卡支持的硬件顶点处理下工作。然而实际上，游戏需要大量的地形，你必须对细节做某种（级别）程度的捡选，因为模型需要大量的几何数据，这样大的地形对于再强大的处理方法也是无法处理的。</p>
<p>目标 </p>
<ul>
<li>学习怎样生成地形的高度信息，它能使山丘、河流等地带的平滑的过度，模拟自然界的地形。</li>
<li>了解怎样生成地形的顶点和三角形数据。</li>
<li>学习使用地形的纹理和光照.</li>
<li>找到控制地形上照相机位置的方法，以便模拟在地形上走动。</li>
</ul>
<p>13.1 Heightmaps（高度图）<br>   我们使用高度图去描述地形上的山丘、河流。高度图是一个数组，数组中的每个成员指定地形顶点描述中的高度信息。我们经常把高度图想像成一个矩阵，因为每个元素都一一对应于每个地形网格中的顶点。<br>   当我们保存高度图到磁盘上时，我们通常为高度图的每个元素分配1个byte的内存，所以高度的范围是0..255，0..255的范围对于地形的高度之间保持平滑过渡是足够用的。但为了在我们的程序中匹配3D世界中的物体，可能需要的范围在0..255以外。例如，我们在3D世界中的测量单位是英尺，那么0..255的范围对于表现任何有趣的东西是不够的。因此，当我们读取数据进应用程序时，给每个高度元素分配一个整型数（或浮点型），它允许我们很好的缩放0..255范围之外的任何大小的物品。<br>   高度图图形表示法这一是灰度图(grayscale map)。较黑的值表示地形中较低的地方，较白的值表现地形中较高的地方。</p>
<pre><code> 图13.2: 高度图的灰度图表示
</code></pre><p>13.1.1 创建高度图（Heightmap）<br>   高度图不是用程序生成就是用图像编辑器生成，比如：Adobe Photoshop。使用图像编辑器大概是最容易的方法了。当你想生成地形时，可以交互式的可视化的创建。你可以利用图像编辑器的功能，比如：过滤器，创建一个有趣的高度图，图13.3显示了一个用Adobe Photoshop图像编辑器的工具创建的金字塔形的高度图。注意：当创建图像时我们指定一个灰度图类型。</p>
<pre><code> 图13.3 一幅用Adobe Photoshop创建的灰度图
 一但你画完了你的高度图，你必须将它保存为一个8bit的RAW文件。RAW文件只图像的逐个字节。我们的应用程序可以非常容易的读这样的图像。你的软件可能告诉你保存的RAW文件是有文件头的还是没有文件头的。
 注意：用RAW格式保存高度信息不是必须的；你可以用符合你需要的任何格式。RAW格式是我们能使用的的格式之一。我决定使用RAW格式是因为很多流行的图像编辑器支持导出这种格式，而且应用程序读取RAW文件的数据非常简单。这章中有使用8-bit RAW文件的例子。
</code></pre><p>13.1.2 读取RAW文件<br>   RAW文件与一段连续的bit内存块没什么分别。我们能用很简单的方法读取这段内存块，注意：变量_heightmap是Terrain类的一个成员，定义如下 ：<br>std::vector<int> _heightmap;<br>bool Terrain::readRawFile(std::string fileName)<br>{<br>     // A height for each vertex<br>     std::vector<byte> in(  numVertices );<br>     std::ifstream inFile(fileName.c_str(), std::ios_base::binary);<br>     if( inFile == 0 )<br>          return false;<br>     inFile.read(<br>          (char*)&amp;in[0], // buffer<br>          in.size());// number of bytes to read into buffer<br>     inFile.close();</byte></int></p>
<pre><code> // copy BYTE vector to int vector
 _heightmap.resize( _numVertices );
 for(int i = 0; i &lt; in.size(); i++)
      _heightmap[i] = in[i];

 return true;
</code></pre><p>}<br>我们COPY一个bytes向量到一个整形向量，这样做我们能够缩放 [0,255]以外的高度。这个方法唯一限制是：RAW文件必须读入至少与地形的顶点数一样多的高度信息。因此，如果你读取一个256x256 的RAW文件，你的地形也必须包含256x256个顶点。</p>
<p>13.1.3 访问与修改Heightmap<br>     Terrain类提供以下2个方法访问和修改Heightmap的入口。<br>int Terrain::getHeightmapEntry(int row, int col)<br>{<br>      return _heightmap[row * _numVertsPerRow + col];<br>}</p>
<p>void Terrain::setHeightmapEntry(int row, int col, int value)<br>{<br>     _heightmap[row * _numVertsPerRow + col] = value;<br>}<br>   这些方法允许我们以行和列来访问入口，并且隐藏方法。当使用它去描述矩阵时，我们必须将一个线性数组编入索引。<br>（These methods allow us to refer to an entry by row and column and hide the way we must index a linear array when using it to describe a matrix）</p>
<p>13.2 生成地形几何数据<br>   图13.4显示Terrain类的一些属性、词汇和我们提到的一些关键点。我们定义地形的大小，指定每行、每列顶点的数量，和单元的间隔。传递这些值到Terrain类的构造器中。另外，也传递地形所关联的设备，一个包含高度图数据的字符串文件名，一个用来缩放高度图成员的高度缩放值。</p>
<pre><code>     图13.4：三角形网络的属性，延着方格线上的点是地形的顶点。
</code></pre><p>class Terrain<br>{<br>public:<br>     Terrain(<br>          IDirect3DDevice9* device,<br>          std::string heightmapFileName,<br>          int numVertsPerRow,<br>          int numVertsPerCol,<br>          int cellSpacing,    // space between cells<br>          float heightScale); // value to scale heights by</p>
<pre><code> ... methods snipped
</code></pre><p>private:<br>     …device/vertex buffer etc snipped</p>
<pre><code> int _numVertsPerRow;
 int _numVertsPerCol;
 int _cellSpacing;

 int _numCellsPerRow;
 int _numCellsPerCol;
 int _width;
 int _depth;
 int _numVertices;
 int _numTriangles;

 float _heightScale;
</code></pre><p>};<br>Terrain类定义的全部的源代码，实在是太多了，无法在这里全部包含进来。根据传递给构造器的值，我们能够计算Terrain类的其他变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_numCellsPerRow  = _numVertsPerRow - <span class="number">1</span>;</span><br><span class="line">_numCellsPerCol  = _numVertsPerCol - <span class="number">1</span>;</span><br><span class="line">_width           = _numCellsPerRow * _cellSpacing;</span><br><span class="line">_depth           = _numCellsPerCol * _cellSpacing;</span><br><span class="line">_numVertices     = _numVertsPerRow * _numVertsPerCol;</span><br><span class="line">_numTriangles    = _numCellsPerRow * _numCellsPerCol * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>Terrain类定义的顶点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TerrainVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     TerrainVertex()&#123;&#125;</span><br><span class="line">     TerrainVertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> u, <span class="keyword">float</span> v)</span><br><span class="line">     &#123;</span><br><span class="line">          _x = x; _y = y; _z = z; _u = u; _v = v;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">     <span class="keyword">float</span> _u, _v;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> DWORD FVF;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>   注意：TerrainVertex是Terrain类内部的一个嵌套类（译者：看样子是结构啊？），之所以这么做，是因为它在Terrain类外部基本没有什么用处。<br>13.2.1 计算顶点<br>   在图13.4中，计算三角形网格上的顶点，我们只是在开始产生顶点的地方，一行一行的生成顶点数据，直到结束为止。单元格的顶点与顶点之间有一块空白区域，这会让我们取得x、z坐标，但y坐标是什么呢？得到y坐标很容易，当读取高度图数据结构时会找到对应的入口。<br>   注意：这个操作使用一个巨大的顶点缓存去保存所有地形上的所有顶点。这可能会引起硬件局限性的问题。例如：一个原始计数界限的最大值和3D设备设定的最大的顶点索引界限。检查MaxPrimitiveCount和D3DCAPS9结构的MaxVertexlndex成员，查看你的设备的限定值，在13.7节讨论，使用顶点缓存时存在问题和解决方法。<br>   计算纹理坐标，看图13.5，给我们一个简单的设定，允许我们用(u, v)纹理坐标去对应地形顶点坐标。</p>
<p>   图13.5：地形顶点与纹理顶点之间一一对应。<br>   u = j uCoordIncrementSize<br>   v = i vCoordIncrementSize<br>   And where:</p>
<p>   最后，用代码生成顶点：<br>bool Terrain::computeVertices()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> hr = _device-&gt;CreateVertexBuffer(
      _numVertices * sizeof(TerrainVertex),
      D3DUSAGE_WRITEONLY,
      TerrainVertex::FVF,
      D3DPOOL_MANAGED,
      &amp;_vb,
      0);

 if(FAILED(hr))
      return false;

 // 对应第一个生成的顶点坐标
 int startX = -_width / 2;
 int startZ =  _depth / 2;

 // 对应最后一个生成的顶点坐标
 int endX =  _width / 2;
 int endZ = -_depth / 2;

 // compute the increment size of the texture coordinates
 // from one vertex to the next.
 float uCoordIncrementSize = 1.0f / (float)_numCellsPerRow;
 float vCoordIncrementSize = 1.0f / (float)_numCellsPerCol;

 TerrainVertex* v = 0;
 _vb-&gt;Lock(0, 0, (void**)&amp;v, 0);

 int i = 0;
 for(int z = startZ; z &gt;= endZ; z -= _cellSpacing)
 {
      int j = 0;
      for(int x = startX; x &lt;= endX; x += _cellSpacing)
      {
           // compute the correct index into the vertex buffer
           // and heightmap based on where we are in the nested
           // loop.
           int index = i * _numVertsPerRow + j;

           v[index] = TerrainVertex(
                (float)x,
                (float)_heightmap[index],
                (float)z,
                (float)j * uCoordIncrementSize,
                (float)i * vCoordIncrementSize);

           j++; // next column
      }
      i++; // next row
 }

 _vb-&gt;Unlock();

 return true;
</code></pre><p>}</p>
<p>13.2.2 计算索引-定义三角形<br>   计算三角形网格的索引，只需要循环访问每一个格子，从左上到右下，如图13.4，并且计算组成格子的2个三角形。</p>
<p>这里的技巧是：提取出计算第ij格子的2个三角形的公式。用图13.6去推导公式，找到第ij的格子：</p>
<p>?ABC = {i · numVertsPerRow + j i·numVertsPerRow + j + 1 (i + 1). numVertsPerRow + j}<br>?CBD = {(i + 1) numVertsPerRow + j i·numVertsPerRow + j + 1 (i·l) numVertsPerRow + j + 1} </p>
<p>图13.6 方格的顶点</p>
<p>代码生成索引：<br>bool Terrain::computeIndices()<br>{<br>     HRESULT hr = 0;</p>
<pre><code> hr = _device-&gt;CreateIndexBuffer(
      _numTriangles * 3 * sizeof(WORD), // 每个三角形有3个索引
      D3DUSAGE_WRITEONLY,
      D3DFMT_INDEX16,
      D3DPOOL_MANAGED,
      &amp;_ib,
      0);

 if(FAILED(hr))
      return false;

 WORD* indices = 0;
 _ib-&gt;Lock(0, 0, (void**)&amp;indices, 0);

 // 将组成一个方格的2个三角形的一组6个索引的开始位置编入索引
 int baseIndex = 0;

 // 从头到尾计算每一个格子中的三角形
 for(int i = 0; i &lt; _numCellsPerCol; i++) //行循环
 {
      for(int j = 0; j &lt; _numCellsPerRow; j++) //列循环
      {
           indices[baseIndex]     =   i   * _numVertsPerRow + j;
           indices[baseIndex + 1] =   i   * _numVertsPerRow +
                                                 j + 1;
           indices[baseIndex + 2] = (i+1) * _numVertsPerRow + j;

           indices[baseIndex + 3] = (i+1) * _numVertsPerRow + j;
           indices[baseIndex + 4] =   i   * _numVertsPerRow +
                                                 j + 1;
           indices[baseIndex + 5] = (i+1) * _numVertsPerRow +
                                                 j + 1;

           // next quad
           baseIndex += 6;
      }
 }
 _ib-&gt;Unlock();

 return true;
</code></pre><p>};</p>
<h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>Terrain类提供2个方法去处理地形的纹理。最简单的方法是简单地读取一个已经制作好的纹理文件并使用它，下面的方法使用Terrain类实现将一个文件读取纹理到_tex成员中，然后指向一个IDirect3DTexture9接口的指针。关键是，在地形渲染之前先用Terrain: :draw方法设置_tex。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Terrain::loadTexture(<span class="built_in">std</span>::<span class="built_in">string</span> fileName)</span><br><span class="line">&#123;</span><br><span class="line">     HRESULT hr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     hr = D3DXCreateTextureFromFile(</span><br><span class="line">          _device,</span><br><span class="line">          fileName.c_str(),</span><br><span class="line">          &amp;_tex);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>13.3.1 程序上的处理方法<br>   一个可选择的方法是用程序计算地形的纹理，就是说，我们创建一个空纹理，根据定义的参数用代码计算每一个部分的颜色，在例子中，参数是地形的高度。<br>   我们用Terrain::genTexture方法用程序去生成纹理，首先用D3DXCreateTexture方法创建一个空的纹理，锁定高度级别（top level，纹理图的一个成员，有多个级别），不断的循环每一个texel（图素）并给它上色，texel的颜色取决于与方格对应的高度（近似高度）。我们的想法是：地形中较低的地方是沙滩色，中间的地方像是绿色的小山丘，较高的地方颜色好像雪山。我们定义的高度是方格中左上角的近似高度。<br>   一旦每个texel都有了颜色，我们想让每一个texel变暗或是变亮，这基于光打在格子中对应的texel上的角度，由Terrain::lightTerrain方法实现。（Once we have a color for each texel, we want to darken or brighten each texel based on the angle at which sunlight (modeled by a directional light) strikes the cell to which the texel corresponds. This is done in the Terrain::lightTerrain method）<br>   Terrain::genTexture方法通过计算lower mipmap级别的texels来得出结论，它是通过D3DXFilterTexture函数实现。用代码生成纹理：<br>bool Terrain::genTexture(D3DXVECTOR3* directionToLight)<br>{<br>     // Method fills the top surface of a texture procedurally. Then<br>     // lights the top surface. Finally, it fills the other mipmap<br>     // surfaces based on the top surface data using<br>     // D3DXFilterTexture.</p>
<pre><code> HRESULT hr = 0;

 // texel for each quad cell
 int texWidth  = _numCellsPerRow;
 int texHeight = _numCellsPerCol;

 // create an empty texture
 hr = D3DXCreateTexture(
      _device,
      texWidth, texHeight,  // dimensions
      0,                    // create a complete mipmap chain
      0,                    // usage - none
      D3DFMT_X8R8G8B8,      // 32-bit XRGB format
      D3DPOOL_MANAGED,      // memory pool
      &amp;_tex);

 if(FAILED(hr))
      return false;

 D3DSURFACE DESC textureDesc;
 _tex-&gt;GetLevelDesc(0 /*level*/, &amp;textureDesc);

 // make sure we got the requested format because our code
 // that fills the texture is hard coded to a 32-bit pixel depth.
 if( textureDesc.Format != D3DFMT_X8R8G8B8 )
      return false;

 D3DLOCKED_RECT lockedRect;
 _tex-&gt;LockRect(0/*lock top surface*/, &amp;lockedRect,
       0 /* lock entire tex*/, 0/*flags*/);

 // fill the texture
 DWORD* imageData = (DWORD*)lockedRect.pBits;
 for(int i = 0; i &lt; texHeight; i++)
 {
      for(int j = 0; j &lt; texWidth; j++)
      {
      D3DXCOLOR c;

      // get height of upper-left vertex of quad.
      float height = (float)getHeightmapEntry(i, j)/_heightScale;

      // set the color of the texel based on the height
      // of the quad it corresponds to.
      if( (height) &lt; 42.5f )       c = d3d::BEACH SAND;
      else if( (height) &lt; 85.0f )  c = d3d::LIGHT YELLOW GREEN;
      else if( (height) &lt; 127.5f ) c = d3d::PUREGREEN;
      else if( (height) &lt; 170.0f ) c = d3d::DARK YELLOW GREEN;
      else if( (height) &lt; 212.5f ) c = d3d::DARKBROWN;
      else                         c = d3d::WHITE;

      // fill locked data, note we divide the pitch by four
      // because the pitch is given in bytes and there are
      // 4 bytes per DWORD.
      imageData[i * lockedRect.Pitch / 4 + j] = (D3DCOLOR)c;
      }
 }

 _tex-&gt;UnlockRect(0);

 // light the terrain
 if(!lightTerrain(directionToLight))
 {
       ::MessageBox(0, &quot;lightTerrain() - FAILED&quot;, 0, 0);
       return false;
 }

 // fill mipmaps
 hr = D3DXFilterTexture(
      _tex,// texture to fill mipmap levels
      0,   // default palette
       0,   // use top level as source for lower levels
       D3DX_DEFAULT); // default filter

 if (FAILED (hr))
 {
       ::MessageBox(0, &quot;D3DXFilterTexture() - FAILED&quot;, 0, 0);
       return false;
 }

 return true;
</code></pre><p>}</p>
<p>注意：颜色常量BEACH_SAND等定义在d3dUtility.h.文件中。</p>
<p>13.4 光照<br>   Terrain::genTexture方法会调用Terrain::lightTerrain，顾名思义，光照使地形更接近于现实。当我们已经计算完地形纹理以后，我们只需要计算阴影系数（shade factor），使一个定义了光源的地形区域变亮或变暗。在这一节中，我们检验这样一个技巧，你会惊讶于为什么我们照亮地图却没有让Direct3D来做。我们自己来计算有三个好处：</p>
<ul>
<li>内存中不必保存顶点法线。</li>
<li>因为纹理是静态的，所以不能随意的移动光源。虽然我们可以重新计算光源，但因此采用Direct3D实时的照亮地形是很耗时的。</li>
<li>我们获得了一些数学上的经验，熟悉了一些基本的光照概念，并且是用Direct3D函数实践的。</li>
</ul>
<p>13.4.1概览(OVERVIEW)<br>   光照是计算地形阴影（shade）的一个最基本的技巧之一，一般认为的光是漫射光（diffuse lighting），我们定义一个平行光源，指定光的方向，延着光线的相反方向是散发平行光的光源。因此，如果我们想让光线从空中笔直落下，那么lightRaysDirection = (0, -1, 0)，按相反的方向：directionToLight = (0, 1, 0)。注意：创建光照向量要使用单位向量。<br>   注意：虽然指定方向的光是从光源发射出来的，这么说更直接一点，指定方向的光在计算上要比漫谢光更合得来。<br>   对于地形中的每个方格，我们计算光的向量与方格的面法线之间的角度。<br>   在图13.7中我们看到，当角度变得比较大时，方格的面离光源越来越远，接收的光越少。反过来说，角度变小，方格的面则离光源越来越近，相应的会接收更多的光。注意：一旦光向量与法线角度大于90度，表面就接收不到光。</p>
<p>   图13.7 光向量与平面法线的关系，我们能够创建一个阴影（shading） 标量，用0..1之间的范围来表示表面能接收到光的多少。使用阴影标量，角度大则标量接近于0。当颜色与一个阴影标量接近0的值相乘时，得到的结果是：颜色变暗。相反，乘以一个阴影标量的值接近1的值时，颜色则接近于原始亮度。</p>
<p>13.4.2 计算方格的阴影（Shade）<br>   光源的方向是一个单位向量，为了计算光源方向与面法线间的夹角，首先需要找到面法线，这是叉积的一小部分应用，但首先必须在方格里找到二个共面的非0并且不平行的向量。看图 13.8有两个这样的向量：</p>
<p>   图13.8: 计算在同一方格中的共面的二个向量</p>
<p>u = (cellSpacing, by - ay, 0)<br>v = (0, cy, -ay, -cellSpacing) </p>
<p>关于u和v，方格的法线N = u × v，当然要把N标准化：</p>
<p>找到光线与法线的夹角，回忆一下点积，是二个3维空间中的单位向量组成的夹角的余弦。</p>
<p>   它的标量是在-1..1的范围，因为-1..0的sin值符合夹角角度且大于90度，在图13.7中接受不到光照，如果它在-1..0之间那么夹角是0度。<br>float cosine = D3DXVec3Dot(&amp;n, directionToLight);</p>
<p>if(cosine &lt; 0.0f)<br>     cosine = 0.0f;</p>
<p>   现在s的夹角大于90度，s的阴影标量将在0..1之间。因为光线与法线的角度从0增加到90度时，s的值将从1到降到0。这是我们想要的结果，具体讲解请看13.4.1节。<br>   给指定的格子计算阴影系数用Terrain::computeShade方法，它需要参数：行和列来确定方格，还有平行方向光的光源。<br>float Terrain::computeShade(int cellRow, int cellCol,<br>                            D3DXVECTOR3* directionToLight)<br>{<br>     // 取得方格中三个顶点的高度（从高度图中）<br>     float heightA = getHeightmapEntry(cellRow,   cellCol);<br>     float heightB = getHeightmapEntry(cellRow,   cellCol+1);<br>     float heightC = getHeightmapEntry(cellRow+1, cellCol);</p>
<pre><code> // 创建方格中的二个顶点
 D3DXVECTOR3 u( cellSpacing, heightB - heightA, 0.0f);
 D3DXVECTOR3 v(0.0f, heightC - heightA, - cellSpacing);

 //用方格中的二个向量的叉积找到面法线
 D3DXVECTOR3 n;
 D3DXVec3Cross(&amp;n, &amp;u, &amp;v);
 D3DXVec3Normalize(&amp;n, &amp;n);

 float cosine = D3DXVec3Dot(&amp;n, directionToLight);

 if(cosine &lt; 0.0f)
      cosine = 0.0f;

 return cosine;
</code></pre><p>}</p>
<p>13.4.3 地形阴影（Shading）<br>   一旦知道了如何给指定的方格加阴影，我们就能给地形上所有的方格加阴影。只要遍例每一个方格，计算方格的阴影值，并测量方格对应的texel颜色。光照少则方格会变暗。下面一段代码展示了Terrain::lightTerrain方法的重要部分：</p>
<p>DWORD<em> imageData = (DWORD</em>)lockedRect.pBits;<br>for(int i = 0; i &lt; textureDesc.Height; i++)<br>{<br>     for(int j = 0; j &lt; textureDesc.Width; j++)<br>     {<br>          int index = i * lockedRect.Pitch / 4 + j;</p>
<pre><code>      // get current color of cell
      D3DXCOLOR c( imageData[index] );

      // shade current cell
      c *= computeShade(i, j, lightDirection);;

      // save shaded color
      imageData[index] = (D3DCOLOR)c;
 }
</code></pre><p>}</p>
<p>13.5 在地形上“行走”<br>   构造了一个地形以后，我们想要有移动照相机的能力，以便模拟在地形上行走的效果。我们需要调整照相机的高度，这依赖于地形部分的知识，好的，我们继续往下看。我们首先需要找到照相机所在的方格的位置，并给出x轴和z轴坐标，Terrain::getHeight函数能做到这些，它能提供x轴、y轴坐标参数，返回照相机需要被设置在地形上的高度值，现在看实现部分。<br>float Terrain::getHeight(float x, float z)<br>{<br>     // Translate on xz-plane by the transformation that takes<br>     // the terrain START point to the origin.<br>     x = ((float) width / 2.0f) + x;<br>     z = ((float) depth / 2.0f) - z;</p>
<pre><code> // Scale down by the transformation that makes the
 // cellspacing equal to one. This is given by
 // 1 / cellspacing since cellspacing * 1 / cellspacing = 1.
 x /= (float) cellSpacing;
 z /= (float)_cellSpacing;
</code></pre><p>   我们首先转换地形的起始点为原点，然后，我们按反方向去测量空间变量（we scale by the inverse of the cell spacing variable），设置单元空间间隔为1。我们切换到一个新的参考框架，z轴正方向是向下的。当然，没有代码转换参考框架，但现在我们知道+z是向下的。图13.9显示了这些步骤：</p>
<p>图13.9：地形网格在转换前的第一个点，转换后为原点。单元格的空间为1，转换z轴。<br>我们看到我们转换的坐标系统与矩阵的行和列相对应，也就是说左上为原点，列数的增加向右，行数的增加向下。因此，在图13.9中我们知道了单元格的空间是1，通过以下的方法我们马上就能得到单元格行和列：<br>float col = ::floorf(x);<br>float row = ::floorf(z);</p>
<p>换句话说，在x轴部分列是整数，z轴部分行也是整数。回忆floor(t)函数，。<br>现在我们将取得方格的四个顶点的高度。<br>        //  A   B<br>        //  <em>—</em><br>        //  | / |<br>        //  <em>—</em><br>        //  C   D<br>float A = getHeightmapEntry(row,   col);<br>float B = getHeightmapEntry(row,   col+1);<br>float C = getHeightmapEntry(row+1, col);<br>float D = getHeightmapEntry(row+1, col+1);</p>
<p>   现在我们知道了方格的四个顶点的高度，我们需要找到照相机所在的位置的方格的高度，因为一个方格可能同时向几个方向倾斜，这可能会稍微难一点，见图 13.10:</p>
<p>图13.10: 照相机所在的位置的方格的高度<br>   为了找到高度，我们需要知道我们在方格中的哪个三角形里。方格是由二个三角形渲染成的，找到我们所在的三角形，我们要取得我们所在的方格并且转换它，它的左上点是原点。<br>   自从用行和列来描述我们所在的方格左上顶点的位置以来，我们必须转换列x轴与行z轴，转换x、z坐标：<br>   float dx = x - col;<br>   float dz = z - row;</p>
<p>图13.11: 我们所在的方格在转换前与转换后，左上顶点变成了原点。<br>   .现在解释当我们在方格中的上三角形时如何找到高度，这和在下三角形是相似的。马上你会看到这两种情况的代码。在上三角形时，构造2个向量：u = (cellSpacing, B -A, 0) and v = (0, C - A, - cellSpacing)，三角形的边上并且在矢量q = (qx, A, qz)终点点开始的地方，如图13.12(a)。</p>
<p>   图13.12 (a) 计算三角形的邻边和对边这两个向量。 (b)使用线性差值创建高度<br>   注意：我们只关心改变的高度值，我们只修改y值，忽视其他部分，因此，Height=sum A + dxuy + dzvy<br>   以下是Terrian::getHeight函数的实现代码：<br>   （Note that since we are only concerned about the interpolated height value, we can just interpolate the y-components and ignore the other components. Thus, the height is obtained by the sum A + dxuy + dzvy.）<br>if(dz &lt; 1.0f - dx) // upper triangle ABC<br>     {<br>          float uy = B - A; // A-&gt;B<br>          float vy = C - A; // A-&gt;C</p>
<pre><code>      height = A + d3d::Lerp(0.0f, uy, dx) +
                   d3d::Lerp(0.0f, vy, dz) ;
 }
 else // lower triangle DCB
 {
      float uy = C - D; // D-&gt;C
      float vy = B - D; // D-&gt;B

      height = D + d3d::Lerp(0.0f, uy, 1.0f - dx) +
                   d3d::Lerp(0.0f, vy, 1.0f - dz);
 }    return height;
</code></pre><p>}</p>
<p>   Lerp函数是一个沿着一维直线的基本线性插值算法，实现如下：<br>float d3d::Lerp(float a, float b, float t)<br>{<br>     return a - (a<em>t) + (b</em>t);<br>}</p>
<p>13.6 例子程序: Terrain<br>   这章的例子是用一个包含高度信息的RAW文件创建一个地形，纹理和光源。用方向键在地形上行走。注意，下列函数中不相关的代码被省略了，被省略的代码用(…)表示，依赖你的硬件，这个例子可能运行得很慢，请偿试运行一个小地形。<br>   首先，增加全局变量：地形、照相机、每秒帧数。<br>Terrain<em> TheTerrain = 0;<br>Camera   TheCamera(Camera::LANDOBJECT);<br>FPSCounter</em> FPS = 0;</p>
<p>   下面是框架函数：<br>bool Setup()<br>{<br>     D3DXVECTOR3 lightDirection(0.0f, -1.0f, 0.0f);<br>     TheTerrain = new Terrain(Device, “coastMountain256.raw”,<br>                              256, 256, 10, 1.0f);<br>     TheTerrain-&gt;genTexture();<br>     TheTerrain-&gt;lightTerrain(&amp;directionToLight);<br>     …</p>
<pre><code> return true;
</code></pre><p>}</p>
<p>void Cleanup()<br>{<br>     d3d::Delete<terrain*>(TheTerrain);<br>     d3d::Delete<fpscounter*>(FPS);<br>}</fpscounter*></terrain*></p>
<p>bool Display(float timeDelta)<br>{<br>     if( Device )<br>     {<br>          // Update the scene:<br>          …[snipped input checking]</p>
<pre><code>      // Walking on the terrain: Adjust camera&#39;s height so we
      // are standing 5 units above the cell point we are
      // standing on.
      D3DXVECTOR3 pos;
      TheCamera.getPosition(&amp;pos);

      float height = TheTerrain-&gt;getHeight( pos.x, pos.z );

      pos.y = height + 5.0f;

      TheCamera.setPosition(&amp;pos);

      D3DXMATRIX V;
      TheCamera.getViewMatrix(&amp;V);
      Device-&gt;SetTransform(D3DTS VIEW, &amp;V);

      // Draw the scene:
      Device-&gt;Clear(0, 0, D3DCLEAR TARGET | D3DCLEAR ZBUFFER,
                    0xff000000, 1.0f, 0);
      Device-&gt;BeginScene();

      D3DXMATRIX I;
      D3DXMatrixIdentity(&amp;I);

      if( TheTerrain )
          TheTerrain-&gt;draw(&amp;I, false);

      if( FPS )
          FPS-&gt;render(0xffffffff, timeDelta);

      Device-&gt;EndScene();
      Device-&gt;Present(0, 0, 0, 0);
 }
 return true;
</code></pre><p>}</p>
<p>13.7 一些改进<br>   Terrain读取顶点数据到一个很大的缓存，在多重的顶点缓存中划分地形结构，在速度和可测量性方面都十分有利。为我们提出一个问题：顶点缓存最大支持多大？回答是，这依赖于你的硬件。所以你必须先检测。<br>   将地图划分为许多小的顶点缓存是重要的练习，然后将类似矩阵的数据结构编入索引，并且管理数据，这不需要引入新的概念。我们不必详细讨论它。简单的说，你基本上站在地形中一个我们叫做“blocks”的矩阵上,每个block是地形的一个矩形区域。另外，每个block区域（在它自己的顶点索引缓存中）的下方包含地形中的几何信息，为了画它在地形中的位置。<br>   另外，你可以读取地形到一个很大的ID3DXMesh接口。使用D3D函数D3DXSplitMesh划分地形为许多小的Mesh, 以下是D3DXSplitMesh函数原型：<br>void D3DXSplitMesh(<br>    const LPD3DXMESH pMeshIn,<br>    const DWORD <em>pAdjacencyIn,<br>    const DWORD MaxSize,<br>    const DWORD Options,<br>    DWORD </em>pMeshesOut,<br>    LPD3DXBUFFER <em>ppMeshArrayOut,<br>    LPD3DXBUFFER </em>ppAdjacencyArrayOut,<br>    LPD3DXBUFFER <em>ppFaceRemapArrayOut,<br>    LPD3DXBUFFER </em>ppVertRemapArrayOut<br>);<br>       这个函数将一个源Mesh划分多个小的Mesh,，pMeshIn参数是一个指针，指向想划分的Mesh，pAdjacencyIn指向一个邻接数组，MaxSize参数指定作为结果返回的最大顶点数，为返回的Meshe使用指定的创建标记，pMeshesOut参数返回ppMeshArrayOut数组中的Mesh数量，最后3个参数是可选的（可以指定为null），返回邻接信息的数组。<br>13.8 摘要</p>
<ul>
<li>我们能用三角形网格和不同的高度值来模拟地形，创建山丘、河流。</li>
<li>Heightmap数据包含地形顶点的高度值。</li>
<li>我们能通过程序使用磁盘上的图像文件生成地形上的纹理。</li>
<li>我们能照亮地形，通过计算阴影系数来使每个格子变亮或变暗，阴影系数是由光照在格子上的角度决定的。</li>
<li>使照相机在地形上走动，我们需要找到我们站立的三角形。我们计算三角形上的邻边和对边这两个向量，高度是通过…（线性插值在这些向量中每个使用x、z对应的单位向量，以左高顶点为原点为参数。）找到的。<br>（The height is then found by linearly interpolating on each of these vectors using the x- and z-coordinates in a normalized cell with an upper-left vertex at the origin as parameters.）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DTWMWSlnxcXcuUgR1H2qlVt9-gzGzoHsz',
      appKey     : 'Ms2yHVyCinQmWnsKtVv7NOHR',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
