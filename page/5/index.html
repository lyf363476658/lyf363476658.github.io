<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/5/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/06/09/game/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/09/game/" class="post-title-link" itemprop="url">game</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-09 21:57:30" itemprop="dateCreated datePublished" datetime="2019-06-09T21:57:30+08:00">2019-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Game/" itemprop="url" rel="index"><span itemprop="name">Game</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="霸体"><a href="#霸体" class="headerlink" title="霸体"></a>霸体</h1><p>在霸体过程中被任何招式击中都不会有被攻击判定(但是有伤害照算的,还有加成).霸体招式可以强制出完.实战而言有霸体的话可以胜任很多插动的场合,如果对手攻击还很容易被这类招式打出counter,之后能够继续连段的话,对压制方是很大的打击.<br>当人物进行攻击时人物的某些判定点(具有被攻击判定)在受到对方攻击且攻击判定成立的情况下,任务的动作依旧持续(受攻击时可能稍微停顿),人物的出招过程无法被打断.在此判定点上形成的伤害一般有以下几种情况下不受伤,受伤减少,受伤增加</p>
<img src="/2019/06/09/game/1.jpg">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/06/05/mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/05/mac/" class="post-title-link" itemprop="url">mac</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-05 17:16:06" itemprop="dateCreated datePublished" datetime="2019-06-05T17:16:06+08:00">2019-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="table-container">
<table>
<thead>
<tr>
<th>型号</th>
<th>分辨率</th>
<th>宽高比</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPad1</td>
<td>1024*768</td>
<td>1.3333333</td>
</tr>
<tr>
<td>iPad2</td>
<td>1024*768</td>
<td>1.3333333</td>
</tr>
<tr>
<td>iPad3</td>
<td>2048*1536</td>
<td>1.3333333</td>
</tr>
<tr>
<td>iPad4</td>
<td>2048*1536</td>
<td>1.3333333</td>
</tr>
<tr>
<td>iPad air</td>
<td>2048*1536</td>
<td>1.3333333</td>
</tr>
<tr>
<td>iPad air2</td>
<td>2048*1536</td>
<td>1.3333333</td>
</tr>
<tr>
<td>iPad mini</td>
<td>1024*768</td>
<td>1.3333333</td>
</tr>
<tr>
<td>iPad mini2</td>
<td>2048*1536</td>
<td>1.3333333</td>
</tr>
<tr>
<td>被认定的标准屏幕</td>
<td>1280*720</td>
<td>1.77777778</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/06/04/intergpaandroid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/04/intergpaandroid/" class="post-title-link" itemprop="url">Inter GPA Android真机调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-04 12:07:56" itemprop="dateCreated datePublished" datetime="2019-06-04T12:07:56+08:00">2019-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能分析/" itemprop="url" rel="index"><span itemprop="name">性能分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下载安装完成Intel GPA套件后，一共有五个工具，分别是：<br>Graphics Monitor<br>Graphics Frame Analyzer<br>Platform Analyzer<br>System Analyzer<br>Trace Analyzer<br>在Android平台进行图形调试的时候，我们主要用到的工具是System Analyzer和Graphics Frame Analyzer。<br>首先需要打开测试手机的开发者选项中的允许调试。<br>在一台安装配置完成Andriod开发环境的PC，使用USE连接需要测试的Android手机，然后在命令提示符中键入adb devices，饭回设备ID保证连接成功。<br>然后打开System Analyzer，界面会显示当前的Android设备ID，点击Connect，然后允许GPA软件在手机上的安装。<br>连接提示：</p>
<pre><code>Device error:setenforce:Couldn&#39;t set enforcing status to &#39;O&#39;:Permission denied
</code></pre><p>表示没有Root权限。<br>小米Mix2，先去解锁，通过小米助手安装驱动。看完我的团长我的团，以第一人称叙事的角度描述故事。我想，在我的博客也应该这样，应该添加一些废话，毕竟博客是给我自己一个人看的。<br>也可以抄，毕竟它只是给我一个人看的。然后这时候解锁工具就可以解锁了。然后很不幸，解锁失败了，提示让我72个小时，三天之后在解锁。我日他先人板板。要不是没钱，早就自己买一个手机了。继续看Vulkan吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/05/31/fiction-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/31/fiction-3/" class="post-title-link" itemprop="url">赤子之心</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-31 12:38:33" itemprop="dateCreated datePublished" datetime="2019-05-31T12:38:33+08:00">2019-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>赤子之心，就是一颗率直、纯真、善良、热爱生命、好奇而富想象力、生命力旺盛的心，能够常常怀着赤子之心，才可以大人。老子道德经：含德之厚，比于赤子。说的就是这个道理吧。<br>芹说他不知道自己算不算有赤子之心，但是经历了这么多。他说他想有赤子之心。<br>以前以为，功夫，两个字，一横一竖，对的，站着，错的，倒下。只有站着的才有资格说话。后来见过了高山，才发现最难过的原来是生活。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/05/29/smaa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/29/smaa/" class="post-title-link" itemprop="url">抗锯齿技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-29 14:23:37" itemprop="dateCreated datePublished" datetime="2019-05-29T14:23:37+08:00">2019-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机图形学/" itemprop="url" rel="index"><span itemprop="name">计算机图形学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SMAAD技术的全称为”Enhanced Subpixel Morphological Antialiasing”，与FXAA一样同为后期处理抗锯齿技术，可以提供基于过滤算法的通用图像抗锯齿解决方案。SMAA技术使用了更好的几何形体和对角形体检测处理机制，通过图形边缘局部特征对比来识别图像的锯齿特征，并通过重建子像素的方式实现抗锯齿功能，效果与传统的4x MSAA相近而且可以根据游戏的需要进行定制。</p>
<img src="/2019/05/29/smaa/1.gif">
<p>通过”以模糊换取精确“的手段来消除显示屏上的锯齿，而这个过程我们称其为采样(Sampling)，也就是针对某一点的像素，通过让它带有周围像素的特性，因此在足够的分辨率下，这一点便不再顽固般地锐利，也达到消除锯齿的目的。</p>
<h1 id="超级采样抗锯齿-Super-Sampling-Anti-Aliasing-SSAA"><a href="#超级采样抗锯齿-Super-Sampling-Anti-Aliasing-SSAA" class="headerlink" title="超级采样抗锯齿(Super Sampling Anti-Aliasing,SSAA)"></a>超级采样抗锯齿(Super Sampling Anti-Aliasing,SSAA)</h1><p>通过名字就知道，SSAA最大的特点来自采样过程，以常见的SSAA<em>4为例，在面对一张最后需要以1920</em>1080像素渲染的画面时，SSAA会首先渲染一张尺寸位3840*2160像素的缓存，再在这种长宽都乘以2的画面上进行采样，采样的精度和效果当然是最理想的，但是你也可以想象，这种只为追求理想情况的手段对于硬件资源的消耗非常大，成本也非常高。更重要的是，即使在原理上SSAA拥有最理想的精度，但是最现实的情况万般变化中的游戏世界，SSAA并不能永远保证采样效果是最讨好眼睛的，换句话说性价比会随着新技术的现身而面临越来越大的挑战，这其中就包括SSAA本身的一种灵活的变体：多重采样抗锯齿技术(Multi-Sampling Anti-Aliasing,MSAA)。</p>
<p>MSAA的原理和SSAA一致，都是通过将图形拉伸至更高倍率之下的缓存之后再精细的图像上进行采样，但是前者真正聪明的地方在于，再开始狮子大开口之前MSAA存在一个判断的过程，换句话说MSAA仅仅针对画面中边缘部分进行放大处理，这么一来对于硬件的负担着实大大减轻，正式因为如此，MSAA早已是最流行的抗锯齿方案之一，对于任何一款现代游戏来说，不支持MSAA几乎是不可想象的。</p>
<img src="/2019/05/29/smaa/1.png">
<img src="/2019/05/29/smaa/2.png">
<p>无论是SSAA还是MSAA，他们运作都集中在非常考前的位置，比如光栅化阶段，因此对于硬件开销有较大的呼声，但是从2012年的GeFore 600系列以来，NVIDIA就已经开始推广一款全新的抗锯齿方案，它们最大的特点就是出发点非常靠前，作为一款后处理抗锯齿它的硬件需求非常低，甚至达到几乎难以察觉的地步，同时因为较低的实现难度，它已经成为MSAA之后最流行的抗锯齿方案之一，就是快速近似抗锯齿(Fast approximate anti-aliasing)。</p>
<h1 id="SSAA画质与性能变化"><a href="#SSAA画质与性能变化" class="headerlink" title="SSAA画质与性能变化"></a>SSAA画质与性能变化</h1><p>我们再来对比开启SSAA之后的情况，首先这里可以看到SSAA的一个特点，虽然抗锯齿技术逃不过采样的过程，但是这里可以看到开启SSAA之后，原本充满锯齿的地方首先还是一如既往的清晰、锐利，衣物和衣物的过度非常干净，完全没有后处理抗锯齿那种模糊的干净，而是锯齿真的缩小既视感，不过开启SSAA的代价确实高，2倍环境下Benchmark成绩已经滑落至49.08帧。<br><img src="/2019/05/29/smaa/3.png"></p>
<h1 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h1><p>如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的的多重采样样本，它叫做多重采样缓冲（Multisample Buffer）。</p>
<p>大多数的窗口系统都应该提供一个多重采样缓冲，用以代替默认的颜色缓冲。GLFW同样给了我们这个功能，我们所要做的只是提示(Hint)GLFW，我们希望使用一个包含N个样本的多重采样缓冲。这可以在创建窗口之前调用glfwWindowHint来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_SAMPLES, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>现在再调用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会调用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。</p>
<p>现在我们已经向GLFW请求了多重采样缓冲，我们还需要调用glEnable并启用GL_MULTISAMPLE，来启用多重采样。再大多数OpenGL的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显示地调用可能会有点多余，但显示地调用一下会更保险一点。这样子不论是什么OppenGL地实现都能够正常启用多重采样了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_MULTISAMPLE);</span><br></pre></td></tr></table></figure></p>
<p>只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用<code>glEnable</code>来启用多重采样。因为多重采样的算法都在OpenGL驱动的光栅器中实现了，我们不需要再多做什么。如果现在再来渲染本节一开始的那个绿色的立方体，我们应该能看到更平滑的边缘：</p>
<h1 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h1><p>由于GLFW负责了创建多重采样缓冲，启用MSAA非常简单。然而，如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己手动生成多重采样缓冲了。</p>
<p>有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：纹理附件和渲染缓冲附件，这和帧缓冲教程中所讨论的普通附件很相似。</p>
<h2 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h2><p>为了创建一个支持存储多个采样点的纹理，我们使用<code>glTexImage2DMultisample</code>来替代glTexImage2D，它的纹理目标是<code>GL_TEXTURE_2D_MULTISAPLE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D_MULTISAPLE, tex);</span><br><span class="line">glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAPLE, samples, GL_RGB, width, height, GL_TRUE);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D_MULTISAPLE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/05/29/gameengine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/29/gameengine/" class="post-title-link" itemprop="url">GameEngine</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-29 11:23:52" itemprop="dateCreated datePublished" datetime="2019-05-29T11:23:52+08:00">2019-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GameEngine/" itemprop="url" rel="index"><span itemprop="name">GameEngine</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>python2.7<br>GnuWin32 Tools <a href="https://sourceforge.net/projects/getgnuwin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/getgnuwin32/</a> 执行download.bat和install.bat完成安装。添加环境变量</p>
<img src="/2019/05/29/gameengine/1.jpg">
<p>CLang是基于LLVM。所谓LLVM，就是一个小小的虚拟机。这个虚拟机抽象了不同的硬件平台，如x86/arm/mips等。最近还抽象了GPU。有点像Java的VM，但是又和Java的VM很不同。Java的VM是比较高层的，它的byte code包括很多硬件平台并不能直接支持的功能。而LLVM的byte code则是更加接近硬件(CPU/GPU)的实际功能，只不过它是独立于任何一个具体硬件存在的。非常简单粗糙比喻的话，各种CPU/GPU就好比各个地方的人，说各个地方的方言；而LLVM的byte code则有些像普通话，与方言有着类似1对1的对应关系。</p>
<p>所以，首先需要迁出LLVM的代码，如下操作：</p>
<p><code>svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</code></p>
<p>Clang是作为LLVM的一个前端，即，把C/C++翻译成LLVM可以懂的byte code的工具。LLVM再把byte code翻译成具体的机器指令。执行下面的命令可以迁出Clang的代码并放在LLVM妥当的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd llvm\tools</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</span><br><span class="line">cd ../..</span><br><span class="line">mkdir build</span><br><span class="line">&quot;C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2017\COMMUNITY\COMMON7\IDE\COMMONEXTENSIONS\MICROSOFT\CMAKE\CMake\bin\cmake.exe&quot; -G &quot;Visual Studio 15&quot; ../llvm</span><br><span class="line">msbuild LLVM.sln</span><br></pre></td></tr></table></figure></p>
<p><code>Visual Studio 15 Win64</code>指定编译平台为64位.</p>
<p>编译完成之后，我们来测试我们编译出的clang是否有问题。首先我们需要将生成物的目录加入环境变量PATH，以便在命令行能够找到它<br><img src="/2019/05/29/gameengine/2.jpg"><br>重启命令行，检查是否可以找到clang<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;clang -v</span><br><span class="line">clang version 9.0.0 (trunk 361927) (llvm/trunk 361929)</span><br><span class="line">Target: i686-pc-windows-msvc</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: D:\build\Debug\bin</span><br></pre></td></tr></table></figure></p>
<p>然后确保我们目前处于LLVM的顶级目录，就是下面有llvm和build这两个目录的那一集目录，执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python.exe build/Debug/bin/llvm-lit.py -sv --param build_mode=Debug --param clang_site_config=build/tools/clang/test/lit.site.cfg build/tools/clang/test --param=build_config=Debug</span><br></pre></td></tr></table></figure></p>
<p>我这里的环境执行会失败，python提示找不到一些测试用的程序。需要修改<code>build\tools\clang\test\lit.site.cfg</code><br>把所有的<code>%(build_mode)</code>改为<code>%(build_config)</code><br>如果用vim修改，可以用<code>:%s/build_mode/build_config/g</code><br>最后<code>clang main.cpp</code>编译我们的项目。<br><a href="http://clang.llvm.org/get_started.html" target="_blank" rel="noopener">http://clang.llvm.org/get_started.html</a></p>
<h1 id="Linux-编译"><a href="#Linux-编译" class="headerlink" title="Linux 编译"></a>Linux 编译</h1><p>我这边的环境是Centos7.2的虚拟机环境。</p>
<pre><code>yum install docker
systemctl start docker
docker pull tim03/clang
docker run -it --rm -v$(pwd):/usr/src tim03/clang
bash-4.4# 
bash-4.4# clang main.c
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/05/28/vulkan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/28/vulkan/" class="post-title-link" itemprop="url">Vulkan</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-28 21:36:35" itemprop="dateCreated datePublished" datetime="2019-05-28T21:36:35+08:00">2019-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下是Vulkan中的特性和改进，相较于OpenGL具有更多的优势：</p>
<ul>
<li>降低驱动程序的开销以及CPU使用率：Vulkan旨在更接近底层的图形硬件。因此，它为上层的应用程序提供了对主机计算资源的直接控制，以便GPU尽可能地进行渲染，这种方式同时也允许软件直接访问图形处理器，从而获得更好地性能。</li>
<li>多线程可扩展性：OpenGL中的多线程扩展效果非常差，要想利用线程的特性，从而更好地利用CPU是一件非常困难地事情。然后，Vulkan对此进行了专门设计，用于允许终端用户以一种非常透明地方式利用CPU的多线程特性，不存在隐式的全局状态。从创建作业以及提交作业（用于执行）时开始，不同线程下的作业之间会保持分离。</li>
<li>一套“显示”的API：OpenGL是一套“隐式”的API，其中的资源管理是驱动程序的责任。驱动程序需要应用程序的提示并跟踪资源的状态，这是一种不必要的开销。Vulkan是一套“显式”的API；在这里，驱动程序不负责跟踪资源以及它们之间的关系，把这项任务分配给了应用程序。这种干净的方法更可预测；驱动程序不会再幕后执行某些操作来管理资源（就像在OpenGL中一样）。因此，作业的处理简化且直接，从而实现最佳性能和可预测的行为。</li>
<li>预编译的中间着色语言：与需要着色器shader作为OpenGL(GLSL)源代码提供的OpenGL不同，SPIR-V(Standard Portable Intermediate Language：标准可移植中间语言)是Vulkan用于并行计算和图形操作的标准中间语言。<blockquote>
<p>注意：用于源语言的编译器，例如GLSL，HLSL和LLVM必须符合SPIR-V规范，并提供实用的工具程序来提供SPIR-V的输入。Vulkan采用Vulkan这种即时执行的二进制中间输入形式并会在着色器阶段使用。</p>
</blockquote>
</li>
<li>驱动程序层和应用程序层：在OpenGL中，与驱动程序层相比，应用程序层更薄，因为驱动程序的自动化考虑了资源管理和状态跟踪，Vulkan正好与此相反。它会确保驱动程序更接近底层的硬件且开销更小。管理逻辑、资源和状态是应用程序的责任。下图显示了这两个API的驱动程序和应用程序代码库的厚度：</li>
</ul>
<img src="/2019/05/28/vulkan/1.jpg">
<ul>
<li>内存控制：Vulkan能够在系统上暴露若干种内存类型，并要求应用程序开发人员为每个资源的预期用途选择适当的内存类型。相比之下，OpenGL驱动程序则会根据内部启发模式决定资源的放置位置，不同供应商之间的启发模式存在一定的差异，如果稍后驱动程序移动了资源，OpenGL可能会产生次优的放置或出现意外的故障。</li>
<li>可预测性：与OpenGL相比，Vulakn具有高度的可预测性；它在渲染时不会导致任何滞后或挂起。一旦将作业提供给驱动程序，就会立即提交，而OpenGL作业提交不是预先提供的，而是受到驱动调度程序的支配。</li>
<li>一套API：OpenGL为桌面API(OpenGL)和嵌入式API(OpenGL ES)提供了不同的版本。Vulkan很干净，只有一套适用所有平台的API。</li>
<li>直接访问GPU：Vulkan通过公开其功能和硬件设施，为应用程序用户提供了很多控制权。它公开了各种可用的物理设备、内存类型、命令缓冲区以及扩展。这种行为可以确保软件层更接近真实的硬件。</li>
<li>错误检查和验证：当使用OpenGL时，运行良好的应用程序在检查错误会付出一些代价，而错误在执行的时候根本不会出发。相比之下，Vulkan将这些检查和验证作为附加服务来提供，可以在需要时启用合计禁用。这些检查是可选的，可以通过启用错误检查和其他的验证层注入到运行时。因此，通过避免不必要的检查，可以减少CPU开销。理想情况下，这些错误和验证层必须在开发阶段的调试器打开，并在发布期间关闭。</li>
<li>支持各种GPU硬件：Vulkan支持移动设备光栅化器和桌面光栅化器作为实现的集成部分。它支持嵌入式平台的基于瓦片或延期的光栅化器以及本地基于平铺的前反馈光栅化器。</li>
</ul>
<p>在深入探讨基本细节之前，先来看看Vulkan中用到的一些比较重要技术术语。随着我们的进一步深入，本书还会覆盖更多的技术术语。</p>
<ul>
<li>物理设备和设备：系统可能包含多个具有Vulkan功能的物理硬件设备。物理设备表示唯一的设备，而设备device则是指应用程序中物理设备的逻辑表示，即逻辑设备。</li>
<li>队列：队列表示执行引擎和应用程序之间的口。物理设备始终包含了一个或多个队列（图形队列、计算队列、DMA队列/传输队列等）。队列的职责是收集作业（命令缓冲区）并将其分派给物理设备进行处理。</li>
<li>内存类型：Vulkan公开了各种内存类型。在更广泛的层面上，有两种类型的内存：主机内存和设备内存。</li>
<li>命令：命令是做某种行为的指令。命令可以大致分为动作，设置状态或者同步。</li>
<li>动作命令：这些命令可用于绘制图元、清除表面、复制缓冲区，查询/时间戳操作以及开始/结束子通道操作。这些命令能够更改帧缓冲区附件，读取或写入内存（缓冲区或图像）以及编写查询池。</li>
<li>同步命令：同步有助于满足两个或多个操作命令的要求，这些操作命令可能会争夺资源或具有一些内存依赖性。其中包括设置事件、等待时间，插入管线屏障以及渲染通道或子通道的依赖关系。</li>
<li>命令缓冲区：命令缓冲区是一组命令；它会记录这些命令并将它们提交给队列。</li>
</ul>
<h1 id="Vulkan的执行模型"><a href="#Vulkan的执行模型" class="headerlink" title="Vulkan的执行模型"></a>Vulkan的执行模型</h1><p>具有Vulkan功能的系统能够查询并显示系统上可用的物理设备的数量。每个物理设备会暴露一个或多个队列。这个队列会分为不同的族，每个族都有特定的功能。例如，这些功能包括图形，计算，数据传输以及稀疏内存管理。队列族的每个成员都可以包含一个或多个类似的队列，从而使它们互相兼容。例如，给定的实现可能支持同一队列上的数据传输和图形操作。</p>
<p>Vulkan允许开发人员通过应用程序对内存控制进行显式的管理，它公开了设备上可用的各种类型的堆，其中的每个堆属于不同的内存区域。Vulkan的执行模式非常直接，此处，命令缓冲区会被提交到队列中实现的。然后由物理设备使用，以便进行各种处理。</p>
<p>Vulkan应用程序负责控制各种Vulkan设备，这是通过把大量的命令记录到命令缓冲区并将它们提交到队列中实现的。该队列由驱动程序读取，驱动程序会按提交的顺序预先执行作业。命令缓冲区的构建非常昂贵，因此，一旦构建完成，就可以对它进行缓存以及将其提交到队列中，以便根据具体的需求执行若干次。此外，在应用程序中，可以使用多线程同时并行构建多个命令缓冲区。<br>下图显示了执行模型的简化图示：</p>
<img src="/2019/05/28/vulkan/2.jpg">
<p>在这里，应用程序记录了两个包含多个命令的命令缓冲区。然后根据工作性质将这些命令提供给一个或多个队列。队列将这些命令缓冲区做呕也提交到设备进行处理。最后，设备处理结构并将其显示在输出显示屏上，或将它们返回给应用程序进行一部的处理。</p>
<p>在Vulkan中，应用程序负责以下内容：</p>
<ul>
<li>为成功执行命令提供所有必要的先决条件：这其中可能包括准备资源、预编译的着色器以及将资源附加到着色器、指定渲染状态、构建管线以及绘制调用。</li>
<li>内存管理</li>
<li>同步</li>
<li>主机和设备之间的同步</li>
<li>设备上可用的不同队列之间的同步</li>
<li>危害管理</li>
</ul>
<h1 id="Vulkan的队列"><a href="#Vulkan的队列" class="headerlink" title="Vulkan的队列"></a>Vulkan的队列</h1><p>队列是Vulkan中的媒介，就是通过它将命令缓冲区送入设备的。命令缓冲区会记录一个或多个命令并将它们提交到所需的队列。设备也可能会公开多种队列，因此，应用程序有责任将命令缓冲区提交给正确的队列。</p>
<p>可以将命令缓冲区提交到以下几项：</p>
<ul>
<li>一个队列——命令缓冲区的提交顺序以及执行、回放都将保持不变，命令缓冲区以串行方式执行；</li>
<li>多个队列——允许在两个或多个队列中并行执行命令缓冲区。除非明确指定，否则无法保证命令缓冲区的提交和执行顺序，同步它们的顺序是应用程序的责任，如果没有进行同步，执行的顺序可能会完全超出预期。</li>
</ul>
<p>Vulkan提供了几种同步方式，是程序可以在单个队列或跨越多个队列对作业的执行进行相对控制。<br>这些同步方式有：</p>
<ul>
<li><strong>信号量(Semaphore)</strong>：该同步机制可以跨多个队列进行同步，火灾单个队列中同步粗粒度的命令缓冲区提交。</li>
<li><strong>事件(Events)</strong>：事件用来控制细粒度的同步并且被应用于单个队列，允许我们对提交给单个队列的一个命令缓冲区或若干个命令缓冲区序列之间进行同步工作。宿主机也可以参与基于事件的同步。</li>
<li><strong>栅栏(Fences)</strong>：该方式能够在主机和设备之间进行同步操作。</li>
<li><strong>管线屏障(Pipeline barriers)</strong>：管线屏障是一个插入指令，用于确保在该命令缓冲区中，在管线屏障之前的命令必须在被指定的、管线屏障之后的命令之前执行。</li>
</ul>
<h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><p>在应用程序级别，所有的实体（包括设备、队列、命令缓冲区、帧缓冲区、管线等）都被称为Vulkan对象。在内部，在API级别，这些Vulkan对象用句柄进行识别。这些句柄有两种类型：可分发句柄和不可分发句柄。</p>
<ul>
<li><strong>可分发句柄(a dispatchable handle)</strong>：这是一个指针，指向了内部不透明形状的实体(opaque-shaped entity)。不透明的类型不允许您直接访问这种结构的字段。只能使用API例程访问这些字段。每个可分发句柄都有一个关联的可分发类型(dispatchable type)，用于在API命令中作为参数传递。下面是一些示例：<br><code>VKInstance|VkCommandBuffer|VkPhysicalDevice|VkDevice|VkQueue</code></li>
<li><strong>不可分发句柄(Non-dispatchable handles)</strong>：这些是64位整型类型的句柄，可以包含对象信息本身，而不是指向结构的指针。示例如下：<br><code>VKSemaphore|VkFence|VkQueryPool|VkBufferView</code><br><code>VkDeviceMemory|VkBuffer|VkImage|VkPipeline</code><br><code>VkShaderModule|VkSampler|VkRenderPass|VkDescriptorPool</code></li>
</ul>
<h1 id="对象生命周期和命令语法"><a href="#对象生命周期和命令语法" class="headerlink" title="对象生命周期和命令语法"></a>对象生命周期和命令语法</h1><p>在Vulkan中，根据每个应用程序的逻辑，都要显示创建和销毁对象，并且应用程序要负责管理这些对象。<br>Vulkan中的对象使用Create创建并使用Destroy命令销毁：</p>
<ul>
<li><strong>创建语法</strong>：对象使用<code>vkCreate *</code>形式的命令创建的；这类命令接受一个<code>Vk *CreateInfo</code>结构作为输入参数。</li>
<li><strong>销毁语法</strong>：对应的，使用<code>vkCreate</code>命令生成的对象要使用<code>vkDestroy</code>进行销毁。<br>作为现有对象池或堆的一部分而创建的对象要使用<code>Allocate</code>命令创建并使用<code>Free</code>命令从池或者堆中进行释放。</li>
<li><strong>分配语法</strong>：作为对象池的一部分创建的对象使用<code>vkAllocate *</code>形式的命令，并且使用<code>Vk* AllocateInfo</code>作为输入参数。</li>
<li><strong>销毁语法</strong>：相应的，使用<code>vkFree*</code>命令把对象释放回池或者内存中。</li>
</ul>
<p>使用<code>vkGet</code>命令可以轻松访问任何给定的实现信息。<code>vkCmd</code>形式的API实现用于在命令缓冲区中记录命令。</p>
<h1 id="错误检查和验证"><a href="#错误检查和验证" class="headerlink" title="错误检查和验证"></a>错误检查和验证</h1><p>Vulkan专门提供高性能而设计，这是通过保持错误检查和验证功能作为一种可选项的形式实现的。在运行时，错误检查和验证的部分少之又少，从而使得构建命令缓冲区和提交变得更加高效。这些可选功能可以通过Vulkan的分层体系结构来实现，该分层体系结构允许把各种层（调试层和验证层）动态注入到正在运行的系统中。</p>
<h1 id="了解-Vulkan应用"><a href="#了解-Vulkan应用" class="headerlink" title="了解 Vulkan应用"></a>了解 Vulkan应用</h1><p>以下框图显示了系统中不同组件模块以及对应的联系：</p>
<img src="/2019/05/28/vulkan/3.jpg">
<h1 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h1><p>具有Vulkan功能的系统至少包含一个CPU和GPU。IHV的供应商为其专用GPU架构提供了指定Vulkan规范实现的驱动程序。驱动程序充当应用程序设备本身之间的接口。它为应用程序提供了一些高级设施，以便能够与设备进行通信。例如，驱动程序通知了系统上可用的设备数量、它们的队列和队列功能、可用的堆及其相关属性等。</p>
<h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><p>应用程序是指用户编写的程序，旨在利用Vulkan API来执行图形或计算任务。应用程序从硬件和软件的初始化开始，它会检测驱动程序并加载所有的Vulkan API。展示层(presentation layer)使用Vulkan的窗口系统集成——Window System Integration——(WSI)API进行初始化；WSI将用于渲染期间在显示表面(display surface)上绘制图形图像。应用程序创建资源并使用描述符(descripors)将它们绑定到着色器阶段(shader stage)。描述符集布局(descriptor set layout)用于把创建的资源绑定到创建的底层管线对象pipeline object(图形或计算类型graphics or compute type)。最后，记录命令缓冲区并将其提交到队列进行处理。</p>
<h1 id="WSI"><a href="#WSI" class="headerlink" title="WSI"></a>WSI</h1><p>窗口系统集成WSI(Windows System Integration)是来自Khronos的一组扩展，用于跨平台(如Linux,Windows和Android)。</p>
<h1 id="SPIR-V"><a href="#SPIR-V" class="headerlink" title="SPIR-V"></a>SPIR-V</h1><p>SPIR-V提供了一种预编译的二进制格式，用于指定Vulkan着色器。编译器可用于各种着色器语言，其中包括能够生成SPIR-V的GLSL和HLSL变种。</p>
<h1 id="LunarG-SDK"><a href="#LunarG-SDK" class="headerlink" title="LunarG SDK"></a>LunarG SDK</h1><p>LunarG的Vulkan SDK包含了各种工具和资源，用以辅助Vulkan应用程序的开发。这些工具和资源包括Vulkan加载程序、验证层、跟踪和回放工具、SPIR-V工具、Vulkan运行时安装程序、文档，示例以及演示。</p>
<h1 id="Vulkan编程模型入门"><a href="#Vulkan编程模型入门" class="headerlink" title="Vulkan编程模型入门"></a>Vulkan编程模型入门</h1><p>下图显示了Vulkan应用程序编程模型自顶向下的方法；<br><img src="/2019/05/28/vulkan/4.jpg"></p>
<h1 id="硬件初始化"><a href="#硬件初始化" class="headerlink" title="硬件初始化"></a>硬件初始化</h1><p>当Vulkan应用程序启动的时候，它的第一个工作就是硬件的初始化。在这个阶段，应用程序通过与加载器进行通信来激活Vulkan驱动程序。下图展示了一个加载器Loader及其子组件的框图：</p>
<img src="/2019/05/28/vulkan/5.jpg">
<p><strong>Loader</strong>：加载程序是应用启动时使用的一段代码，可以跨平台、以一种统一的方式在系统中定位Vulkan驱动程序。以下是加载Loader的职责：</p>
<ul>
<li><strong>定位驱动程序(Locating dirvers)</strong>：作为其主要的任务，加载程序知道在给定系统中到哪里搜索驱动程序。它会找到正确的驱动程序并加载。</li>
<li><strong>不依赖平台(Platform-independent)</strong>：初始化Vulkan在所有平台上都是一致的。这与OpenGL不同，OpenGL创建上下文需要针对每个环境(EGL,GLX,WGL)使用不同的窗口系统API。Vulkan中的平台差异以扩展名表示。</li>
<li>可注入的层(Injectable layers)：加载器支持层次化的体系结构并提供在运行时注入各层的能力。最大的改进就是驱动程序在确定应用程序堆API的使用是否有效时不需要执行任何工作，也不会保留执行该工作所需的任何状态。因此，建议在开发阶段根据应用要求打开选定的可注入层，并在部署阶段将其关闭。例如，可注入层可以以下内容：<ul>
<li>跟踪Vulkan API命令</li>
<li>捕获要渲染的场景并在稍后执行场景的渲染</li>
<li>用于调试目的的错误检查和验证</li>
</ul>
</li>
</ul>
<p>Vulkan应用程序首先执行与加载程序库的握手并初始化Vulkan具体实现的驱动程序。加载程序库会动态加载Vulkan API。加载程序还提供了一种机制，允许将特定的层自动加载到所有Vulkan应用程序中；这被称为隐式启用层。</p>
<p>一旦加载程序找到驱动程序并成功链接到API，应用程序就要复杂以下操作：</p>
<ul>
<li>创建一个Vulkan实例</li>
<li>查询物理设备的可用队列</li>
<li>查询扩展并将它们存储位函数指针，如WSI或特殊功能的API</li>
<li>启用可注入曾，进行错误检查、调试或验证操作</li>
</ul>
<h1 id="窗口展示表面-Window-presentation-surfaces"><a href="#窗口展示表面-Window-presentation-surfaces" class="headerlink" title="窗口展示表面(Window presentation surfaces)"></a>窗口展示表面(Window presentation surfaces)</h1><p>一旦加载器找到Vulkan具体实现的驱动程序，</p>
<p>好了，抄完上面的就懒得抄了，我总是这个样子，做事情一直坚持不下来。无论是上面，无所谓了，这就是我吧，感觉也没什么坏处了，唯一的坏处就是常年在外然后和李浩然拌拌嘴，其他也真没上面，哦哦，还有就是来了金山这边有点能吃了，虽然吃饭不要钱。<br>跟着Vulkan 向导走着，url是：<a href="https://vulkan-tutorial.com/Development_environment#page_Setting_up_Visual_Studio" target="_blank" rel="noopener">https://vulkan-tutorial.com/Development_environment#page_Setting_up_Visual_Studio</a> 访问还得翻墙，本来想买VPN来着，但是又舍不得掏钱，总是舍不得掏钱，于是配置了半天XX-NET，终于可以将就的看了。但是目前卡在了glw下载的过程中，趴着梯子看外面的世界确实不好受呀。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/05/27/filltriangle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/27/filltriangle/" class="post-title-link" itemprop="url">填充三角形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-27 16:30:21" itemprop="dateCreated datePublished" datetime="2019-05-27T16:30:21+08:00">2019-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="填充三角形"><a href="#填充三角形" class="headerlink" title="填充三角形"></a>填充三角形</h1><h2 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h2><p>来复习一下画线,我们知道画线的时候我们做的实际上是这样的事情：对于要画的线AB，在满足我们设定的条件（斜率 ≤ 1, A &lt; B）之后，因为我们要画的是整数的像素点，对于x每增加1，我们算出对应的y，然后来画点（x，y），这样重复直到x增加到B点：</p>
<img src="/2019/05/27/filltriangle/Bresenham.png">
<p>对于 AB 上的任意一点 P 满足：</p>
<script type="math/tex; mode=display">
P = A + t(B - A), 0 \le t \le 1</script><p>也可以写成：</p>
<script type="math/tex; mode=display">
P = (1 - t)A + tB , 0 \le t \le 1</script><p>这个公式是著名的线性插值，实际上也是我们画线的基础。因为在画线部分核心代码长这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=x0; x&lt;=x1; x++) &#123;</span><br><span class="line">  <span class="keyword">float</span> t = (x-x0)/(<span class="keyword">float</span>)(x1-x0);</span><br><span class="line">  <span class="keyword">int</span> y = y0 + (y1 - y0)*t;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于P点，我们根据增加后的x算出t值，然后算出y，得到应该画的点。</p>
<p>其实在画框架的时候我们已经画过三角形了，就画三条线就OK。现在我们要做的是来填充三角形。</p>
<h2 id="扫描法"><a href="#扫描法" class="headerlink" title="扫描法"></a>扫描法</h2><p>若要填充一个三角形，最简单的能想到的办法是对于三角形的每一个y，我们找到对应的左侧和右侧，x_left和x_right，我们画上x_left到x_right的线，那么从三角形最上面的点按y增加扫到最下面的点既可。</p>
<p>为了简单起见，我们先把三角形拆成上下两部分：</p>
<img src="/2019/05/27/filltriangle/upper_down_triangle.png">
<p>那么对于一个特定的y，我们想要找到它的左边和右边 A B 两点，思路是这样：</p>
<ul>
<li>首先排序，保证 t0 ≤ t1 ≤ t2</li>
<li>整个三角形的高度必为 t2.y - t0.y</li>
<li>那么对于上半部分，y每增加1（注意有可能t0 == t1),我们用插值法算出对应的两点A和B</li>
</ul>
<p>这样就能算出对应的 A 和 B</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// sort the vertices, t0, t1, t2 lower−to−upper (bubblesort yay!) </span></span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t1.y) <span class="built_in">std</span>::swap(t0, t1); </span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t2.y) <span class="built_in">std</span>::swap(t0, t2); </span><br><span class="line">    <span class="keyword">if</span> (t1.y&gt;t2.y) <span class="built_in">std</span>::swap(t1, t2); </span><br><span class="line">    <span class="keyword">int</span> total_height = t2.y-t0.y; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=t0.y; y&lt;=t1.y; y++) &#123; </span><br><span class="line">        <span class="keyword">int</span> segment_height = t1.y-t0.y+<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">float</span> alpha = (<span class="keyword">float</span>)(y-t0.y)/total_height; </span><br><span class="line">        <span class="keyword">float</span> beta  = (<span class="keyword">float</span>)(y-t0.y)/segment_height; <span class="comment">// be careful with divisions by zero </span></span><br><span class="line">        Vec2i A = t0 + (t2-t0)*alpha; </span><br><span class="line">        Vec2i B = t0 + (t1-t0)*beta; </span><br><span class="line">        image.<span class="built_in">set</span>(A.x, y, red); </span><br><span class="line">        image.<span class="built_in">set</span>(B.x, y, green); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/05/27/filltriangle/triangle_left_right.png">
<p>那么有了 A 和 B 之后，我们在AB之间调用我们的画线函数，再用同样的方法给下半部分填满，问题既解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// sort the vertices, t0, t1, t2 lower−to−upper (bubblesort yay!) </span></span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t1.y) <span class="built_in">std</span>::swap(t0, t1); </span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t2.y) <span class="built_in">std</span>::swap(t0, t2); </span><br><span class="line">    <span class="keyword">if</span> (t1.y&gt;t2.y) <span class="built_in">std</span>::swap(t1, t2); </span><br><span class="line">    <span class="keyword">int</span> total_height = t2.y-t0.y; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=t0.y; y&lt;=t1.y; y++) &#123; </span><br><span class="line">        <span class="keyword">int</span> segment_height = t1.y-t0.y+<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">float</span> alpha = (<span class="keyword">float</span>)(y-t0.y)/total_height; </span><br><span class="line">        <span class="keyword">float</span> beta  = (<span class="keyword">float</span>)(y-t0.y)/segment_height; <span class="comment">// be careful with divisions by zero </span></span><br><span class="line">        Vec2i A = t0 + (t2-t0)*alpha; </span><br><span class="line">        Vec2i B = t0 + (t1-t0)*beta; </span><br><span class="line">        <span class="keyword">if</span> (A.x&gt;B.x) <span class="built_in">std</span>::swap(A, B); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=A.x; j&lt;=B.x; j++) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(j, y, color); <span class="comment">// attention, due to int casts t0.y+i != A.y </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=t1.y; y&lt;=t2.y; y++) &#123; </span><br><span class="line">        <span class="keyword">int</span> segment_height =  t2.y-t1.y+<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">float</span> alpha = (<span class="keyword">float</span>)(y-t0.y)/total_height; </span><br><span class="line">        <span class="keyword">float</span> beta  = (<span class="keyword">float</span>)(y-t1.y)/segment_height; <span class="comment">// be careful with divisions by zero </span></span><br><span class="line">        Vec2i A = t0 + (t2-t0)*alpha; </span><br><span class="line">        Vec2i B = t1 + (t2-t1)*beta; </span><br><span class="line">        <span class="keyword">if</span> (A.x&gt;B.x) <span class="built_in">std</span>::swap(A, B); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=A.x; j&lt;=B.x; j++) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(j, y, color); <span class="comment">// attention, due to int casts t0.y+i != A.y </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样三角形填充就解决。代码里有很多重复的部分，然后这里决定让代码短一点，代价是读起来没那么清楚了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (t0.y==t1.y &amp;&amp; t0.y==t2.y) <span class="keyword">return</span>; <span class="comment">// I dont care about degenerate triangles </span></span><br><span class="line">    <span class="comment">// sort the vertices, t0, t1, t2 lower−to−upper (bubblesort yay!) </span></span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t1.y) <span class="built_in">std</span>::swap(t0, t1); </span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t2.y) <span class="built_in">std</span>::swap(t0, t2); </span><br><span class="line">    <span class="keyword">if</span> (t1.y&gt;t2.y) <span class="built_in">std</span>::swap(t1, t2); </span><br><span class="line">    <span class="keyword">int</span> total_height = t2.y-t0.y; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;total_height; i++) &#123; </span><br><span class="line">        <span class="keyword">bool</span> second_half = i&gt;t1.y-t0.y || t1.y==t0.y; </span><br><span class="line">        <span class="keyword">int</span> segment_height = second_half ? t2.y-t1.y : t1.y-t0.y; </span><br><span class="line">        <span class="keyword">float</span> alpha = (<span class="keyword">float</span>)i/total_height; </span><br><span class="line">        <span class="keyword">float</span> beta  = (<span class="keyword">float</span>)(i-(second_half ? t1.y-t0.y : <span class="number">0</span>))/segment_height; <span class="comment">// be careful: with above conditions no division by zero here </span></span><br><span class="line">        Vec2i A =               t0 + (t2-t0)*alpha; </span><br><span class="line">        Vec2i B = second_half ? t1 + (t2-t1)*beta : t0 + (t1-t0)*beta; </span><br><span class="line">        <span class="keyword">if</span> (A.x&gt;B.x) <span class="built_in">std</span>::swap(A, B); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=A.x; j&lt;=B.x; j++) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(j, t0.y+i, color); <span class="comment">// attention, due to int casts t0.y+i != A.y </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wavefront-obj"><a href="#wavefront-obj" class="headerlink" title="wavefront obj"></a>wavefront obj</h2><p>上一章我们画了框架，这下我们来填上三角形：</p>
<img src="/2019/05/27/filltriangle/filledframe.png">
<p>好吧，并不是很动人=。=之所以不动人是因为光影光影，我们只有颜色，没有考虑光，</p>
<p><a href="https://github.com/KrisYu/tinyrender/tree/master/code/03_filledtriangle" target="_blank" rel="noopener">代码</a></p>
<h2 id="重心坐标法"><a href="#重心坐标法" class="headerlink" title="重心坐标法"></a>重心坐标法</h2><p>除了上面提到的扫描法之外，另外一个可以想到的办法是，因为我们终究是画到二维平面上的像素，一个一个的点，那么对于我们要画的区域内的每一个点，我们是否可以检测看它是否在三角形之内，如果是的话，画它，否则不理之。这样的思路是可行的，对于三角形内及其边上的任意一点，我们都可以用重心坐标系来表示：</p>
<script type="math/tex; mode=display">
P = (1 - u - v)A + uB + vC, 0 \le u,v \le 1</script><p>这个长得也很像线性插值。</p>
<p>运算:</p>
<script type="math/tex; mode=display">
P = A + u\overrightarrow{AB}  + v\overrightarrow{AC}</script><p>继续：</p>
<script type="math/tex; mode=display">
u\overrightarrow{AB}  + v\overrightarrow{AC} + \overrightarrow{PA} = 0</script><p>PA是AB和AC的线性组合。</p>
<p>拆一拆：</p>
<script type="math/tex; mode=display">
u\overrightarrow{AB}_x  + v\overrightarrow{AC}_x + \overrightarrow{PA}_x = 0</script><script type="math/tex; mode=display">
u\overrightarrow{AB}_y  + v\overrightarrow{AC}_y + \overrightarrow{PA}_y = 0</script><p>实际上我们都可以看做是我们在寻找向量 $(u, v, 1)$ 同时垂直于向量 $(\overrightarrow{AB}_x, \overrightarrow{AC}_x,\overrightarrow{PA}_x)$ 和向量 $(\overrightarrow{AB}_y, \overrightarrow{AC}_y,\overrightarrow{PA}_y)$。 这就是叉乘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xvector = (B_x - A_x, C_x - A_x, A_x - P_x)</span><br><span class="line">yvector = (B_y - A_y, C_y - A_y, A_y - P_y)</span><br><span class="line">u = xvector x yvector</span><br><span class="line"></span><br><span class="line"># 如果 u 的 z 分量不等于1则说明P点不在三角形内</span><br></pre></td></tr></table></figure>
<p>因为我们的计算有浮点数，可能u的z分量不会一定等于1,令 u 的三个分量是 (a, b, c),我们代入原式子：</p>
<script type="math/tex; mode=display">
a\overrightarrow{AB}  + b\overrightarrow{AC} + c\overrightarrow{PA} = 0</script><script type="math/tex; mode=display">
P = (1 - a/c - b/c)A +  a/cB + b/cC, c \ne 0</script><p>代码我们这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">barycentric</span><span class="params">(Vec2f A, Vec2f B, Vec2f C, Vec2f P)</span> </span>&#123;</span><br><span class="line">    Vec3f s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i--; ) &#123;</span><br><span class="line">        s[i][<span class="number">0</span>] = C[i]-A[i];</span><br><span class="line">        s[i][<span class="number">1</span>] = B[i]-A[i];</span><br><span class="line">        s[i][<span class="number">2</span>] = A[i]-P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Vec3f u = cross(s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(u[<span class="number">2</span>])&gt;<span class="number">1e-2</span>) <span class="comment">// dont forget that u[2] is integer. If it is zero then triangle ABC is degenerate</span></span><br><span class="line">        <span class="keyword">return</span> Vec3f(<span class="number">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);</span><br><span class="line">    <span class="keyword">return</span> Vec3f(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// in this case generate negative coordinates, it will be thrown away by the rasterizator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们当然也不用把平面区域的每个点代入P去做检查，我们只需要找到三角形的 bounding_box,然后看其中的每一个整数点，如果在其中，那就画之。</p>
<p>用同样的方法来给模型填色，效果一样。</p>
<p><a href="https://github.com/KrisYu/tinyrender/tree/master/code/04_barycentricfilled" target="_blank" rel="noopener">代码</a></p>
<p>效果跟之前依旧一致，我们给每个三角形随机填上色：</p>
<img src="/2019/05/27/filltriangle/filledrandom.png">
<p>随机填色这个我们看起来倒是有点cool.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/05/27/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/27/python/" class="post-title-link" itemprop="url">Python</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-27 14:39:42" itemprop="dateCreated datePublished" datetime="2019-05-27T14:39:42+08:00">2019-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python3-怎么安装-PIL"><a href="#python3-怎么安装-PIL" class="headerlink" title="python3 怎么安装 PIL"></a>python3 怎么安装 PIL</h1><p>关于Pillow与PIL</p>
<p>PIL(Python Imaging Library)是Python一个强大方便的图像处理库，名气也比较大。不过只支持到Python 2.7。</p>
<p>PIL官方网站：<a href="http://www.pythonware.com/products/pil/" target="_blank" rel="noopener">http://www.pythonware.com/products/pil/</a></p>
<p>Pillow是PIL的一个派生分支，但如今已经发展成为比PIL本身更具活力的图像处理库。目前最新版本是3.0.0。</p>
<p>Pillow的Github主页：<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">https://github.com/python-pillow/Pillow</a><br>Pillow的文档(对应版本v3.0.0)：<a href="https://pillow.readthedocs.org/en/latest/handbook/index.html" target="_blank" rel="noopener">https://pillow.readthedocs.org/en/latest/handbook/index.html</a><br>Pillow的文档中文翻译(对应版本v2.4.0)：<a href="http://pillow-cn.readthedocs.org/en/latest/" target="_blank" rel="noopener">http://pillow-cn.readthedocs.org/en/latest/</a></p>
<p>Python 3.x 安装Pillow</p>
<p>给Python安装Pillow非常简单，使用pip或easy_install只要一行代码即可。</p>
<p>在命令行使用PIP安装：<br>pip install Pillow</p>
<p>或在命令行使用easy_install安装：<br>easy_install Pillow</p>
<p>安装完成后，使用from PIL import Image就引用使用库了。比如：<br>from PIL import Image<br>im = Image.open(“bride.jpg”)<br>im.rotate(45).show()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/05/27/DrawLine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/27/DrawLine/" class="post-title-link" itemprop="url">DrawLine</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-27 14:27:34" itemprop="dateCreated datePublished" datetime="2019-05-27T14:27:34+08:00">2019-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机图形学/" itemprop="url" rel="index"><span itemprop="name">计算机图形学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h1><p>我们先从屏幕画线开始。</p>
<p>首先，<code>y = ax + b</code> 这个并不能画出所有的线，并且有两个问题：</p>
<ul>
<li>如果a很大，那么x由 $x_0$ 增加到 $x_0+1$ 那么y增加a，如果 a 很大，那么会有分裂的样式</li>
</ul>
<img src="/2019/05/27/DrawLine/line_01.png">
<ul>
<li>无法画出平行于 y 的竖线</li>
</ul>
<img src="/2019/05/27/DrawLine/line_02.png">
<p>针对这种状况，我们采用的画图方式是利用如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Interpolate (i0, d0, i1, d1)&#123;</span><br><span class="line">    if i0 == i1 &#123;</span><br><span class="line">        return [d0] </span><br><span class="line">    &#125;</span><br><span class="line">    values = []</span><br><span class="line">    a = (d1 - d0) / (i1 - i0)</span><br><span class="line">    d = d0</span><br><span class="line">    for i = i0 to i1&#123;</span><br><span class="line">        values.append(d)</span><br><span class="line">        d = d + a</span><br><span class="line">    &#125; </span><br><span class="line">    return values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是我们利用的是要么 <code>y = ax + b</code> , 要么 <code>x = ay + b</code>, 意思是要么我们让 y 随着 x 变化，要么让 x 随着 y 变化. 在上述的伪码中，我们的 d 是 dependent value， i 是 independent value，我们让 d 随着 i 变化。</p>
<p>其次是我们分情况，看线是更加水平或者是更加竖直，如果线更加水平，那么 y 随着x变化，如果更竖直，那么x 随着y变化，这样来作图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DrawLine(P0, P1, color) &#123;</span><br><span class="line">    if abs(x1 - x0) &gt; abs(y1 -y0)&#123;</span><br><span class="line">        # Line is horizontal-ish</span><br><span class="line">        # Make sure x0 &lt; x1</span><br><span class="line">        if x0 &gt; x1 &#123;</span><br><span class="line">            swap(P0, P1)</span><br><span class="line">        &#125;</span><br><span class="line">        ys = Interpolate(x0, y0, x1, y1)</span><br><span class="line">        for x = x0 to x1&#123;</span><br><span class="line">            canvas.PutPixel(x, ys[x-x0], color)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        # Line is vertical-ish</span><br><span class="line">        # Make sure y0 &lt; y1</span><br><span class="line">        if y0 &gt; y1 &#123;</span><br><span class="line">            swap(P0,P1)</span><br><span class="line">        &#125;</span><br><span class="line">        xs = Interpolate(y0, x0, y1, x1)</span><br><span class="line">        for y = y0 to y1&#123;</span><br><span class="line">            canvas.PutPixel(xs[y-y0], y, color)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="画出来"><a href="#画出来" class="headerlink" title="画出来"></a>画出来</h2><img src="/2019/05/27/DrawLine/raster01.png">
<p><a href="https://github.com/zentia/computer-graphics-from-scratch-Notes/blob/master/raster01.py" target="_blank" rel="noopener">代码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
