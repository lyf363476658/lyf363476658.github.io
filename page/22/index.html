<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/22/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/22/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/06/09/BRDF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/BRDF/" class="post-title-link" itemprop="url">BRDF(双向反射分布函数)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 11:34:41" itemprop="dateCreated datePublished" datetime="2018-06-09T11:34:41+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在计算机图形学领域，着色（Shading）是指根据表面或者多边形相对光源和相机的角度和距离来计算它的颜色的过程。不同的用户可以使用不同的着色算法，CAD等追求相应速度的交互式图形领域可以使用简单快速的着色算法，卡通油画等艺术效果使用非真实感（Nonphotorealistic）着色算法，而追求真实感的CG电影或游戏则可以使用基于物理建模的着色算法。<br>本文关注基于物理着色的BRDF模型，希望能将BRDF的来龙去脉将清楚，并分析Cook-TorranceBRDF公式的推倒过程。<br>要模拟真实光照，我们先要弄清楚光照的现象。</p>
<h2 id="光照现象"><a href="#光照现象" class="headerlink" title="光照现象"></a>光照现象</h2><p>光由光子组成，光子即具有粒子的特性，又表现出波的特性。从波的角度看，光是电磁波的一种，不同频率（波长）的光波能量不同，频率越高（波长越短），能量越高，频率越低（波长越长），能量越低，其中波长在380nm-780nm范围内的光波能被认类的视网膜感知到，这个范围的光波成为可见光，不同频率的可见光被人感知为不同的颜色，频率越高的光偏蓝，频率较低的光则偏红。</p>
<img src="/2018/06/09/BRDF/1.jpg">
<p>光学根据研究的尺度可以分为波动光学（Wave Optics）和几何光学（Geometric Optics），波动光学比几何光学复杂，而由于图形学领域光柱的尺度远大于可见光的波长（380nm - 780nm），也很少涉及光的偏振、干涉和衍射等波动光学才能解释的现象，所以我们一般用几何光学建立光照的模型。</p>
<h2 id="光学平面边界上的散射"><a href="#光学平面边界上的散射" class="headerlink" title="光学平面边界上的散射"></a>光学平面边界上的散射</h2><img src="/2018/06/09/BRDF/2.jpg">
<p>平面边界两边物质的折射率（Refractive Index）不同，当一束光线从一种物质照射到平面边界上时，其中一部分在平面边界被反射回这种物质，反射方向为入射方向关于平面法线的对称向量：</p>
<font size="4">$r_i = 2(n \cdot l)n - l$ </font> 

<blockquote>
<p>其中$r_i$是反射向量，l是光线入射向量，n是平面发现<br>向量间的$\cdot$表示向量的点积，两个单位向量的点积等于它们夹角的余弦。</p>
</blockquote>
<p>另一部分光穿过平面边界折射进入另一种物质，折射方向可由Snell法则（<a href="https://zentia.github.io/2019/05/12/snell/">Snell’s Law</a>）计算得出：</p>
<p><font size="5"> ${sin\theta_i \over sin\theta_t}={v_i\over v_t}={\lambda_i\over \lambda_t}={n_t\over n_i}$ </font></p>
<blockquote>
<p>其中下标i表示入射介质，下标t表示折射介质，$\theta$表示光线相对于边界法线的角度，v表示介质中的光速，$\lambda$表示介质中的波长，n表示介质的折射率。<br>反射和折射的比例由菲涅尔方程(Fresnel Equations)给出，菲涅尔方程比较复杂，图形学里一般使用近似公式计算。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/06/03/TA-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/03/TA-1/" class="post-title-link" itemprop="url">3D美术人员Technical Artist的学习之旅（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-03 14:44:18" itemprop="dateCreated datePublished" datetime="2018-06-03T14:44:18+08:00">2018-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TA是美术和程序之间沟通的桥梁。美术同学需要一些更加方便，可视化更强的工具，例如拓扑的工具，各位都知道MAX里有一个石墨工具是可以用于拓扑的，但是操作石墨工具拓扑是一件很痛苦的事，这时候有一个插件工具能给解决这个问题，例如wrapit的拓扑插件。正因为有了这个插件工具，我们就不用把模型导入Topogun在再次进行二次操作，而编写这个插件就可以算作TA人员所要去做的一件事。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/19/Unity3D-ShaderLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/19/Unity3D-ShaderLab/" class="post-title-link" itemprop="url">Unity ShaderLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-19 10:56:45" itemprop="dateCreated datePublished" datetime="2018-05-19T10:56:45+08:00">2018-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CG类型"><a href="#CG类型" class="headerlink" title="CG类型"></a>CG类型</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>32位浮点数据</td>
</tr>
<tr>
<td>half</td>
<td>16位浮点数据</td>
</tr>
<tr>
<td>int</td>
<td>32位整形数据</td>
</tr>
<tr>
<td>fixed</td>
<td>12位定点数</td>
</tr>
<tr>
<td>bool</td>
<td>布尔数据</td>
</tr>
<tr>
<td>sampler</td>
<td>纹理对象的句柄，分为sampler、sampler1D、sampler2D、sampler3D、samplerCUBE和samplerRECT。</td>
</tr>
</tbody>
</table>
</div>
<p>float2x4 matrix // 表示2x4阶矩阵，包含8个float类型数据</p>
<p>使用技巧：</p>
<ul>
<li>精度够用就好</li>
<li>颜色和单位向量，使用fixed</li>
<li>其他情况，尽量使用half（即范围在[-6万，）</li>
</ul>
<p>内置数据类型：基于基础数据类型，如float3，表示float3类型的三维向量；同理，bool2表示布尔类型的二维向量。</p>
<p>向量最长不能超过四元，如float5 vector; //编译错误</p>
<p>Swizzle操作符：它可以将一个向量的成员取出组成一个新的向量。对于坐标或者角度等其它多维向量，Swizzle操作符(.)后接x、y、z、w分别表示原始向量的第一个、第二个、第三个和第四个元素；同样，对于颜色可以后接r、g、b和a来表示同样的索引。<br>例如：</p>
<pre><code>float4(a,b,c,d).xwz 等价于 float4(a,d,c)
float4(a,b,c,d).xxy 等价于 float4(a,a,b)
</code></pre><p>Swizzle操作符只能对结构体和向量使用，不能对数组使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/17/How-to-systematically-optimize-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/17/How-to-systematically-optimize-performance/" class="post-title-link" itemprop="url">如何系统地进行性能优化？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-17 11:41:24" itemprop="dateCreated datePublished" datetime="2018-05-17T11:41:24+08:00">2018-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="运行帧率低"><a href="#运行帧率低" class="headerlink" title="运行帧率低"></a>运行帧率低</h3><p>低配机器上运行帧率比较低是常见问题。<br>a)首先是做分类，把通常的问题归类到几种瓶颈下来做讨论：GPU Bound、CPU Bound、Bandwidth Bound，还有Memory。这种分类方式基本是按照硬件资源的方式来进行的。<br>b)GPU Bound是一种目前手游中比较常见的瓶颈，降低分辨率如果对帧率有非常明显的提升的话，非常大的可能就是GPU Bound。<br>c)CPU Bound,降低分辨率的方式如果并不能提高帧率，那么可能是CPU Bound。CPU通常和Draw Call祥光，或者和复杂的游戏逻辑相关，通过Unity的Profiler工具可以比较明确看出是否是CPU Bound，以及这些计算时间都消耗在了哪里。<br>TimeLine可以比较明确的看到瓶颈（5.3.8没有，暂时不研究）<br>d)Bandwith Bound 在手游中也比较常见，一种比较简单的判断方式是使用NVIDIA Tegra Graphics Debugger这个工具（对于Tegra硬件更友好，但是比较难找。。。）中将所有贴图替换成2 * 2的大小，如果帧率有明显提升可能是Bandwidth瓶颈。当然也可以自己协代码所图来确认，比如使用Unity的Quality Setting里的Texture Quality。<br><img src="http://oxcvfpext.bkt.clouddn.com/How-to-systematically-optimize-performance-1.png"><br>e)内存就用Unity地Profiler来看吧，不过这个对于帧率没什么影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/16/3d-math-base-graph-game-develop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/16/3d-math-base-graph-game-develop/" class="post-title-link" itemprop="url">3D数学：图形与游戏开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-16 17:33:40" itemprop="dateCreated datePublished" datetime="2018-05-16T17:33:40+08:00">2018-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="惯性坐标系"><a href="#惯性坐标系" class="headerlink" title="惯性坐标系"></a>惯性坐标系</h3><p>为了简化世界坐标系到物体坐标系的转换，人们引入了一种新的坐标系，称作惯性坐标系，意思是在世界坐标系到物体坐标系的“半途”。关系坐标系的原点和物体坐标系的原点重合，但惯性坐标系的轴平行于世界坐标系的轴。</p>
<h3 id="4D齐次空间"><a href="#4D齐次空间" class="headerlink" title="4D齐次空间"></a>4D齐次空间</h3><p>4D向量有4个分量，前3个是标准的x,y和z分量，第四个是w，有时称作齐次坐标。<br>为了理解标准3D坐标是怎样扩展到4D坐标的，让我们先看一下2D中的齐次坐标，它的形式为(x,y,w)。想象在3D中w=1处的标准2D平面，实际的2D点(x,y)用齐次坐标表示(x,y,1)，对于哪些不在w=1平面的点，则将它们投影到w=1平面上。所以齐次坐标(x,y,w)映射的实际2D点为(x/w,y/w)。如图9.2所示。<br>因此，给定一个2D点(x,y)，齐次空间中有无数多个点与之对应。所有点的形式都为(kx,ky,k),k≠0。这些点构成一条穿过齐次原点的直线。<br>当w=0时，除法未定义，因此不存在实际的2D点。然而，可以将2D齐次点(x,y,0)解释为“位于无穷远的点”，它描述了一个方向而不是一个位置。在下节中会有关于该点的更多讨论。<br>4D坐标的基本思想相同。实际的3D点能被认为是在4D中w=1“平面”上。4D点的形式为(x,y,z,w)，将4D点投影到这个“平面”上得到相应的实际3D点(x/w,y/w,z/w)。w=0时4D点表示“无限远点”，它描述了一个方向而不是一个位置。<br>齐次坐标和通过除以w来投影时很有趣的，那我们为什么要使用4D坐标呢？有两个基本原因使得我们要使用4D向量和4X4矩阵。第一个原因实际上就是因为它是一种方便的记法，这也是下一节将要讨论的。</p>
<h3 id="4X4平移矩阵"><a href="#4X4平移矩阵" class="headerlink" title="4X4平移矩阵"></a>4X4平移矩阵</h3><p>3X3变换矩阵表示的是线性变换，不包含平移。因为矩阵乘法的性质，零向量总是变换成零向量，因此，任何能用矩阵乘法表达的变换都不包含平移。这很不幸，因为矩阵乘法和它的逆是一种非常方便的工具，不仅可以用来复用复杂的变换组合成简单的单一变换，还可以操纵嵌入式坐标系间的关系。如果能找到一种方法将3X3变换矩阵进行扩展，使它能处理平移，这将是</p>
<h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>在数学上，如果满足下式，那么映射F(a)就是线性的：<br>$F(a+b)=F(a)+F(b)$<br>以及<br>$F(ka)=kF(a)$<br>如果映射F保持了基本运算：加法和数量乘，那么就可以称该映射为线性的。在这种情况下，将两个向量相加然后再进行变换得到的结果和先分别进行变换再讲变换后的向量相加得到的结果相同。同样，将一个向量数量乘在进行变换和先进行变换在数量乘的结果也是一样的。</p>
<h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p>仿射变换是指线性变换后接着平移。因此，仿射变换的集合是线性变换的超集，任何线性变换都是仿射变换，但不是所有仿射变换都是线性变换。</p>
<h3 id="可逆变换"><a href="#可逆变换" class="headerlink" title="可逆变换"></a>可逆变换</h3><p>如果存在一个逆变换可以“撤销”原变换，那么该变换是可逆的。换句话说，如果存在可逆变换$F^-1$，使得$F^-1(F(a))=a$，对于任意$a$，映射$F(a)$是可逆的。</p>
<h3 id="等角变换"><a href="#等角变换" class="headerlink" title="等角变换"></a>等角变换</h3><p>如果变换前后两向量夹角的大小和方向都不改变，该变换是等角的。只有平移，旋转和均匀缩放是等角变换。等角变换将会保持比例不变。镜像并不是等角变换，因为尽管两向量夹角的大小不变，但夹角的方向改变了。所有等角变换都是仿射和可逆的。</p>
<h3 id="什么是欧拉角"><a href="#什么是欧拉角" class="headerlink" title="什么是欧拉角"></a>什么是欧拉角</h3><p>heading为绕y轴的旋转量，向右旋转为正。<br>pitch为绕x轴的旋转量，注意是物体坐标系的x轴，不是原惯性坐标系的x轴。依然遵守左手法则，向下旋转为正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/14/PBR-Guide-Vol1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/PBR-Guide-Vol1/" class="post-title-link" itemprop="url">【基于物理的渲染（PBR）白皮书】（一）开篇：PBR核心知识体系总结与概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-14 19:46:49" itemprop="dateCreated datePublished" datetime="2018-05-14T19:46:49+08:00">2018-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="光与物质"><a href="#光与物质" class="headerlink" title="光与物质"></a>光与物质</h3><p>光与物质：基于物理的渲染与着色理论<br>光是一种复杂的现象，它同时展现出波与粒子两种特性。于是，为了描述光的表现特性，人们建立了各种模型。<br>作为材质艺术家，我们感兴趣的是光线模型（Light Ray Model）因为它描述了光与物质的交互作用。<br>对我们来说，理解光线如何与物质表面交互非常重要，因为我们的工作是创作描述物体表面的材质。<br>我们创作出的纹理与材质再虚拟世界中与光交互，对光线表现特效理解的越多，创作出的材质就会更好。<br>再这篇指南中，我们会讨论物理理论，而基于物理的渲染(physically-based rendering)(PBR)模型正是建立在其上的。<br>我们从光线开始，逐步讲解PBR中的关键点。</p>
<h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><p>光线模型阐明，光线在均匀透明介质（如空气）中的轨迹为直线。光线模型同时也阐明，当光传播遇到表面是，例如遇到不透明物体或穿过不同介质如从空气折射入水中，光的表现是可预测的。这样，当光从一个起点传播到某点最终转换为其他形式例如热时，我们可以将它的轨迹视觉化。<br>击中一个表面的光线成为入射光，而它击中的角度称为入射角，如图01所示。<br>一条光线射入两个不同介质间的平面交界面。<br>先放出PBR知识体系的架构图：<br><img src="/2018/05/14/PBR-Guide-Vol1/1.jpg"></p>
<h1 id="系列文章前言"><a href="#系列文章前言" class="headerlink" title="系列文章前言"></a>系列文章前言</h1><p>基于物理的渲染（Physically Based Rendering，PBR）技术，自迪士尼SIGGRAPH 2012上提出了著名的“迪士尼原则的BRDF（Disney Principled BRDF）”之后，由于其高度的易用性以及方便的工作流，已经被电影和游戏业界广泛的使用。<br><a href="http://renderwonk.com/publications/s2010-shading-course/" target="_blank" rel="noopener">http://renderwonk.com/publications/s2010-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2012-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2012-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2013-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2013-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2014-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2014-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2015-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2015-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2016-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2016-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2017-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2017-shading-course/</a><br>《Physically Based Rendering:From Theory to Implementation,Third Edition》这本书专注离线渲染，实时渲染只能用到里面很少的一部分。<br><a href="http://www.pbr-book.org/3ed-2018/contents.html" target="_blank" rel="noopener">http://www.pbr-book.org/3ed-2018/contents.html</a><br>《Real-Time Rendering 4th》中PBR的相关章节<br>《Physically Based Shader Development for Unity》，主要是PBR在Unity引擎中的使用，而且是以Surface Shader的方式，准入门级，比较浅。</p>
<h1 id="PBR知识体系概览"><a href="#PBR知识体系概览" class="headerlink" title="PBR知识体系概览"></a>PBR知识体系概览</h1><p>这篇文章接下来的部分，是这个系列文件PBR知识体系的精华浓缩版。涉及八个部分的内容：</p>
<ul>
<li>核心PBR理论</li>
<li>渲染方程与BxDF</li>
<li>迪士尼原则的BxDF（Disney Principled BxDF）</li>
<li>漫反射BRDF模型（Diffuse BRDF）</li>
<li>镜面反射BRDF模型（Specular BRDF）</li>
<li>基于物理的环境光照（Physically Based Environment Lighting）</li>
<li>离线渲染相关（Offline Rendering Related）</li>
<li>进阶渲染主题（Advanced Rendering Topics）</li>
</ul>
<h1 id="PBR核心理论与渲染原理"><a href="#PBR核心理论与渲染原理" class="headerlink" title="PBR核心理论与渲染原理"></a>PBR核心理论与渲染原理</h1><p>PBR核心知识体系的第一部分自然是PBR的核心理论以及相关的渲染原理。</p>
<img src="/2018/05/14/PBR-Guide-Vol1/2.jpg">
<p>基于物理的渲染（Physically Based Rendering，PBR）是指使用基于物理原理和微平面理论建模的着色/光照模型，以及使用从现实中测量的表面参数来准确表示真实世界材质的渲染理念。<br><img src="/2018/05/14/PBR-Guide-Vol1/3.jpg"><br>以下是对PBR基础理念的概括：</p>
<ul>
<li>微平面理论（Microfacet Theory）。微平面理论是将物体表面建模成无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。在实际的PBR工作流中，这种物体表面的不规则性用粗糙度贴图或者高光贴图来表示。</li>
<li>能量守恒（Energy Conservation）。出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。</li>
<li>菲涅尔反射（Fresnel Reflectance）。光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0是即0度角入射的菲涅尔反射。大多数非金属的F0范围是0.02~0.04，大多数金属的F0范围是0.7~1.0。</li>
<li>线性空间（Liner Space）。光照计算必须在线性空间完成，shader中输入的gamma空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。</li>
<li>色调映射（Tone Mapping）。也称色调复制（tone reproduction），是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于HDR渲染出来的亮度值会超过显示器能够现实最大亮度，所以需要使用色调映射，将光照结果从HDR转换微显示器能够正常显示的LDR。</li>
<li>物质的光学特性（Substance Optical Properties）。现实世界中有不同类型的物质可分为三大类：绝缘体（Insulators），半导体（semi-conductors）和导体（conductors）。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色/灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。即非金属的F0是一个float。而金属的F0是一个float3，如下图。<img src="/2018/05/14/PBR-Guide-Vol1/4.jpg" title="金属和非金属材质的F0范围">
</li>
</ul>
<h2 id="光与非光学平坦表面的交互原理"><a href="#光与非光学平坦表面的交互原理" class="headerlink" title="光与非光学平坦表面的交互原理"></a>光与非光学平坦表面的交互原理</h2><p>光在与非光学平坦表面（Non-Optically-Flat Surfaces）的交互时，非光学平坦表面表现得像一个微小的光学平面表面的大集合。表面上的每个点都会以略微不同的方向对入射光反射，而最终的表面外观是许多具有不同表面取向的点的聚合结果。<br><img src="/2018/05/14/PBR-Guide-Vol1/5.jpg" title="来自非光学平坦表面的可见光反射是来自具有不同方向的许多表面点的反射的总体结果"><br>在微观尺度上，表面越粗糙，反射越模糊，因为表面取向与整个宏观表面取向的偏离更强。<br><img src="/2018/05/14/PBR-Guide-Vol1/6.jpg"><br>图片顶部所示的表面，表面相对光滑；表面取向仅略有变化，从而产生更清晰的反射。图片底部所示的表面较粗糙；表面上的不同点具有广泛变化的方向取向，导致反射光方向的高度变化，并因此导致模糊的反射。注意，两个表面在肉眼可见尺度下看起来是光滑的，粗糙度差异仅在微观尺度上。<br>出于着色的目的，我们通常会去用统计方法处理这种微观几何现象，并将表面视为在每个点处在多个方向上反射（和折射）光。<br><img src="/2018/05/14/PBR-Guide-Vol1/7.jpg" title="从宏观上看，非光学平面可以被视为多个方向上反射（和折射）光"><br>从表面反射的光的行为很好理解，那么，从表面折射的光会发生什么变化？这取决于对象本身的特性：</p>
<ul>
<li>对于金属，折射会立刻被吸收-能量被自由电子立即吸收。</li>
<li>对于非金属（也成为电介质或绝缘体），一旦光在其内部折射，就表现为常规的参与介质，表现出吸收和散射两种行为。</li>
</ul>
<img src="/2018/05/14/PBR-Guide-Vol1/8.jpg" title="在金属中，所有折射的光能立即被自由电子吸收">
<img src="/2018/05/14/PBR-Guide-Vol1/9.jpg" title="在非金属中，折射的光会进行散射，直到从表面重新射出，而这通常会在经过部分吸收之后">
<h2 id="漫反射和次表面散射本质相同"><a href="#漫反射和次表面散射本质相同" class="headerlink" title="漫反射和次表面散射本质相同"></a>漫反射和次表面散射本质相同</h2><p>另外，漫反射和次表面散射其实是相同的物理现象，本质都是折射光的次表面散射的结果。唯一的区别是相对于观察尺度的散射距离。散射距离相较于像素来说微不足道，次表面散射便可以近似为漫反射。也就是说，光的折射现象，建模为漫反射还是次表面散射，取决于观察的尺度，如下图。<br><img src="/2018/05/14/PBR-Guide-Vol1/10.jpg"><br>在左上角，像素（带有红色边框的绿色圆形）大于光想离开表面之前所经过的距离。在这种情况下，可以假设出射光从入口点（右上）射出，可以当作漫反射，用局部着色模型处理。在底部，像素小于散射距离；如果需要更真实的着色效果，则不能忽略这些距离的存在，需当作次表面散射现象进行处理。</p>
<h2 id="一、PBR的范畴（Scope-of-PBR）"><a href="#一、PBR的范畴（Scope-of-PBR）" class="headerlink" title="一、PBR的范畴（Scope of PBR）"></a>一、PBR的范畴（Scope of PBR）</h2><p>寒霜（Frostbite）引擎在SIGGRAPH 2014的分享《Moving Frostbite to PBR》中提出，基于物理的渲染的范畴，由三部分组成：</p>
<ul>
<li>基于物理的材质（Material）</li>
<li>基于物理的光照（Lighting）</li>
<li>基于物理适配的摄像机（Camera）<img src="/2018/05/14/PBR-Guide-Vol1/11.jpg">
完整的这三者，才是真正完整的基于物理的渲染系统。而很多同学一提到PBR，就说PBR就是镜面反射采用微平面Cook-Torrance模型，其实是不太严谨的。<h2 id="二、渲染方程与BxDF"><a href="#二、渲染方程与BxDF" class="headerlink" title="二、渲染方程与BxDF"></a>二、渲染方程与BxDF</h2>PBR核心知识体系的第二部分是渲染方程与BxDF。渲染方程作为渲染领域中的重要理论，将BxDF代入渲染方程是求解渲染问题的一般方法。<img src="/2018/05/14/PBR-Guide-Vol1/12.jpg">
<h3 id="2-1渲染方程与反射方程"><a href="#2-1渲染方程与反射方程" class="headerlink" title="2.1渲染方程与反射方程"></a>2.1渲染方程与反射方程</h3>渲染方程（The Rendering Equation）作为渲染领域中的重要理论，其描述了光能在场景中的流动，是渲染中不可感知方面的最抽象的正式表示。根据光学的物理学原理，渲染方程在理论上给出了一个完美的结果，而各种各样的渲染技术，知识这个理想结果的一个近似。</li>
</ul>
<p>渲染方程的物理基础是能量守恒定律。在一个特定的位置和方向，出射光$L_o$是自发光$L_e$与反射光线之和，反射光线本身是各个方向的入射光Li之和诚意表面反射率及入射角。</p>
<p>这个方程金国交叉点将出射光线与入射光线联系在一起，它代表了场景中全部的光线传输。所有更加完善的算法都可以看作是这个方程的特殊形式的解。</p>
<p>某一点p的渲染方程，可以表示为：<br>$L<em>o=L_e + $<font size="5">$\int</font></em>\Omega $&lt;/font&gt;${f_r\cdot L_i \cdot (w_i\cdot n)\cdot dw_i}$<br>其中：</p>
<ul>
<li>$L_o$是p点的出射光亮度。</li>
<li>$L_e$是p点的发出的光亮度。</li>
<li>$f_r$是p点入射方向到出射方向光的反射比例，即BxDF，一般为BRDF。</li>
<li>$L_i$是p点入射光亮度。</li>
<li>$(w_i\cdot n)$是入射角带来的入射光衰减。</li>
<li><font size="5">$\int_\Omega $</font>$…dw_i$是入射方向半球积分（可以理解为无穷小的累加和）。</li>
</ul>
<img src="/2018/05/14/PBR-Guide-Vol1/13.jpg">
<p>而在实时渲染中，我们常用的反射方程（The Reflctance Equation），则是渲染方程的简化的版本，或者说是一个特例：<br>$L<em>o=L_e + $<font size="5">$\int</font></em>\Omega $&lt;/font&gt;${f_r\cdot L_i \cdot (w_i\cdot n)\cdot dw_i}$<br>同样，其中：</p>
<ul>
<li>$L_o$是p点的出射光亮度。</li>
<li>$f_r$是p点入射方向到出射方向光的反射比例，即BxDF，一般为BRDF。</li>
<li>$L_i$是p点入射光亮度。</li>
<li>$(w_i\cdot n)$是入射角带来的入射光衰减。</li>
<li><font size="5">$\int_\Omega $</font>$…dw_i$是入射方向半球积分（可以理解为无穷小的累加和）。</li>
</ul>
<h2 id="2-2-BxDF"><a href="#2-2-BxDF" class="headerlink" title="2.2 BxDF"></a>2.2 BxDF</h2><p>BxDF一般而言是对BRDF、BTDF、BSDF、BSSRDF等几种双向反射分布函数的一个统一的表示。<br>其中，BSDF可以看作BRDF和BTDF更一般的形式，而且BSDF=BRDF+BTDF。<br>而BSSRDF和BRDF的不同之处在于，BSSRDF可以指定不同的光线入射位置和出射位置。<br>在上述这些BxDF中，BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。<br><img src="/2018/05/14/PBR-Guide-Vol1/14.jpg" title="BSDF:BRDF+BTDF"><br>我们时常讨论的PBR中的BxDF，一般都为BRDF，对于进阶的一些材质的渲染，才会讨论BSDF等其它三种BxDF。<br>另外，BxDF即上文所示渲染方程以及反射方程中的$f_r$项。</p>
<h2 id="2-3-BRDF的分类"><a href="#2-3-BRDF的分类" class="headerlink" title="2.3 BRDF的分类"></a>2.3 BRDF的分类</h2><img src="/2018/05/14/PBR-Guide-Vol1/15.jpg">
<h1 id="三、迪士尼原则的BxDF（Disney-Principled-BxDF）"><a href="#三、迪士尼原则的BxDF（Disney-Principled-BxDF）" class="headerlink" title="三、迪士尼原则的BxDF（Disney Principled BxDF）"></a>三、迪士尼原则的BxDF（Disney Principled BxDF）</h1><p>PBR核心知识体系的第三部分是迪士尼原则的BxDF。迪士尼动画工作室在SIGGRAPH 2012上著名的talk《Physically-based shading at Disney》中提出了迪士尼原则的BRDF（Disney Principled BRDF）,奠定了后续游戏行业和电影行业PBR的方向和标准。了解Disney Principled BxDF，是深入理解PBR的重要一环。<br><img src="/2018/05/14/PBR-Guide-Vol1/16.jpg"><br>基于物理的渲染，其实早在20世纪就已经在图形学业界有了一些套路怒，2010年在SIGGRAPH上就已经有公开讨论的Course《SIGGRAPH 2010 Course:Physically-Based Shading Models in File and Game Production》，而直到2012~2013年，才正式进入大宗的视野，渐渐被电影和游戏业界广泛使用。</p>
<p>迪士尼动画工作室则是这次PBR革命的重要推动者。迪士尼的Brent Burley与SIGGRAPH 2012上进行了著名的talk《Physically-based shading at Disney》，提出了迪士尼原则的BRDF（Disney Principled BRDF），由于其高度的通用性，将材质复杂的物理属性，用非常直观的少量变量表达了出来（如金属度metallic和粗糙度roughness），在电影业界和游戏业界引起了不小的轰动。从此，基于物理的渲染正式进入大众的视野。<br><img src="/2018/05/14/PBR-Guide-Vol1/17.jpg" title="SIGGRAPH 2012 《Physically-based shading at Disney》"></p>
<p>在2012年受到Diney的启发后，以下是主流游戏引擎从传统渲染转移到基于物理的渲染时间节点：</p>
<ul>
<li>[SIGGRAPH 2013]UE4 : [Real shading in unreal engine 4]</li>
<li>[SIGGRAPH 2014] Frostbite （寒霜）:[Moving Frostbite to PBR]</li>
<li>[GDC 2014] Unity : [Physically Based Shading in Unity]</li>
</ul>
<h2 id="3-1-迪士尼原则的BRDF（Disney-Principled-BRDF）"><a href="#3-1-迪士尼原则的BRDF（Disney-Principled-BRDF）" class="headerlink" title="3.1 迪士尼原则的BRDF（Disney Principled BRDF）"></a>3.1 迪士尼原则的BRDF（Disney Principled BRDF）</h2><h3 id="3-1-1-Disney-Principled-BRDF核心理念"><a href="#3-1-1-Disney-Principled-BRDF核心理念" class="headerlink" title="3.1.1 Disney Principled BRDF核心理念"></a>3.1.1 Disney Principled BRDF核心理念</h3><p>在2012年迪士尼原则的BRDF被提出之前，基于物理的渲染都需要大量复杂而不直观的参数，此时PBR的优势，并没有那么明显。</p>
<p>在2012年迪士尼提出，他们的着色模型是艺术导向（Art Directable）的，而不一定要是完全物理正确（physically correct）的，并且对为平面BRDF的各项都进行了严谨的调查，并提出了清晰明确而简单的解决方案。</p>
<p>迪士尼的理念是开发一种“原则性”的易用模型，而不是严格的物理模型。正因为这种艺术导向的易用性，能让美术同学非常直观的使用少量参数，以及非常标准化的工作流，就能快速实现涉及大量不同材质的真实感的渲染工作。而这对于传统的着色模型来说，是不可能完成的任务。</p>
<p>迪士尼原则的BRDF（Disney Principled BRDF）核心理念如下：</p>
<ol>
<li>应使用直观的参数，而不是物理类的晦涩参数。</li>
<li>参数应尽可能少。</li>
<li>参数在其合理范围内应该为0到1。</li>
<li>允许参数在有意义时超出正常的合理范围。</li>
<li>所有参数组合应尽可能健壮和合理。</li>
</ol>
<p>以上五条原则，很好地保证了迪士尼原则的BRDF的易用性。</p>
<h3 id="3-1-2-Disney-Principled-BRDF参数"><a href="#3-1-2-Disney-Principled-BRDF参数" class="headerlink" title="3.1.2 Disney Principled BRDF参数"></a>3.1.2 Disney Principled BRDF参数</h3><p>以上理念为基础，迪士尼动画工作室对每个参数的添加进行了把关，最终得到了颜色参数（baseColor）和下面描述的是个标量参数：</p>
<ul>
<li><strong>baseColor（基础色）</strong>：表面颜色，通常由纹理贴图提供。</li>
<li><strong>subsurface（次表面）</strong>：使用次表面近似控制漫反射形状。</li>
<li><strong>metallic（金属度）</strong>：金属（0=电介质，1=金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色着色入射镜面反射。</li>
<li><strong>specular（镜面反射强度）</strong>：入射镜面反射两。用于取代折射率。</li>
<li><strong>specularTint（镜面反射颜色）</strong>：对美术控制的让步，用于对基础色（base color）的入射镜面反射进行颜色控制。掠射镜面反射仍然时非彩色的。</li>
<li><strong>roughness（粗糙度）</strong>：表面粗糙度，控制漫反射和镜面反射。</li>
<li><strong>anisotropic（各向异性强度）</strong>：各向异性强度。用于控制镜面反射高光的纵横比。（0=各向同性，1=最大各向异性）</li>
<li><strong>sheen（光泽度）</strong>：一种额外的掠射分量（grazing component），主要用于布料。</li>
<li><strong>sheenTine（光泽颜色）</strong>：对sheen（光泽度）的颜色控制。</li>
<li><strong>clearcoat（清漆强度）</strong>：有特殊用途的第二个镜面波瓣（specular lobe）。</li>
<li><strong>clearcoatGloss（清漆光泽度）</strong>：控制透明涂层光泽度，0=“缎面（satin）”外观，1=“光泽（gloss）”外观。</li>
</ul>
<p>每个参数的效果的渲染示例如下图所示。<br><img src="/2018/05/14/PBR-Guide-Vol1/18.jpg" title="Disney Principled BRDF，每行的参数从0到1变化，其他参数保持不变"></p>
<h2 id="3-2-迪士尼原则的BSDF（Disney-Principled-BSDF）"><a href="#3-2-迪士尼原则的BSDF（Disney-Principled-BSDF）" class="headerlink" title="3.2 迪士尼原则的BSDF（Disney Principled BSDF）"></a>3.2 迪士尼原则的BSDF（Disney Principled BSDF）</h2><p>随后的2015年，迪士尼动画工作室在Disney Principled BRDF的基础上进行了修订，提出了Disney Principled BSDF [Extenting the Disney BRDF to a BSDF with Integrated Subsurface Scattering,2015]</p>
<p>以下是开源三维动画软件Blender实现的Disney Principled BSDF的图示：<br><img src="/2018/05/14/PBR-Guide-Vol1/19.jpg" title="Disney Principled BSDF"></p>
<h1 id="四、漫反射BRDF模型（Diffuse-BRDF）"><a href="#四、漫反射BRDF模型（Diffuse-BRDF）" class="headerlink" title="四、漫反射BRDF模型（Diffuse BRDF）"></a>四、漫反射BRDF模型（Diffuse BRDF）</h1><p>为了求解渲染方程，需要分别求解Diffuse BRDF和Specular BRDF。所以PBR核心知识体系的第四部分是Diffuse BRDF。<br><img src="/2018/05/14/PBR-Guide-Vol1/20.jpg"><br>Diffuse BRDF可以分为传统型和基于物理型两大类。其中，传统型主要是总所周知的Lambert。<br>而基于物理型，从1994年的Oren Nayar开始，这里一直统计到今年（2019年）。<br>其中较新的有GDC 2017上提出的适用于GGX+Smith的基于物理的漫反射模型（PBR diffuse for GGX+Smith），也包含了最近在SIGGRAPH2018上提出的，来自《使命召唤：二战》的多散射漫反射BRDF（MultiScattrering Diffuse BRDF）：</p>
<ul>
<li>Oren Nayar[1994]</li>
<li>Simplified Oren-Nayar[2012]</li>
<li>Disney Diffuse[2012]</li>
<li>Renormalized Disney Diffuse[2014]</li>
<li>Gotanda Diffuse[2014]</li>
<li>PBR diffuse for GGX+Smith[2017]</li>
<li>MultiScattrering Diffuse BRDF[2018]</li>
</ul>
<h1 id="五、镜面反射BRDF模型（Specular-BRDF）"><a href="#五、镜面反射BRDF模型（Specular-BRDF）" class="headerlink" title="五、镜面反射BRDF模型（Specular BRDF）"></a>五、镜面反射BRDF模型（Specular BRDF）</h1><p>PBR核心知识提醒的第五部分是Specular BRDF。这也是基于物理的渲染领域中最活跃，最主要的部分。<br><img src="/2018/05/14/PBR-Guide-Vol1/21.jpg"><br>上图中加粗部分为目前业界较为主流的模型。</p>
<p>游戏业界目前最主流的基于物理的镜面反射BRDF模型是基于微平面理论（microfacet theory）的Microfacet Cook-Torrance BRDF。</p>
<p>而微平面理论（microfacet theory）源自将微观几何（microgeometry）建模为微平面（microfacets）的集合思想，一般用于描述来自非光学平坦（non-optically flat）表面的表面反射。</p>
<p>微平面理论的基本假设是微观几何（microgeometry）的存在，微观几何的尺度小于观察尺度（例如着色分辨率），但大于可见光波长的尺度（因此应用几何光学如衍射一样的波效应等可以忽略）。且微平面理论在2013年和以前时仅用于推导单反射（single-bounce）表面反射的表达式；而随着领域的深入，最近几年也出现了使用microfacet理论对多次反弹表面的一些探讨。</p>
<p>由于假设微观几何尺度明显大于可见光波长，因此可以将每个表面点视为光学平坦的。如上文所述，光学平坦表面将光线分成两个方向：反射和折射。</p>
<p>每个表面点将来自给定进入方向的光反射到单个出射方向，该方向取决于微观几何法线（microgeometry normal）m的方向。在计算BRDF项时，指定光方向I和视图方向<strong>v</strong>。这意味着所有表面点，只有那些恰好正确朝向可以将<strong>I</strong>反射到<strong>v</strong>的那些小平面可能有助于BRDF值（其他方向有正有负，积分之后，相互抵消）。</p>
<p>在下图中，我们可以看到这些“正确朝向”的表面点的表面法线<strong>m</strong>正好位于<strong>I</strong>和<strong>v</strong>之间的中间位置。<strong>I</strong>和<strong>v</strong>之间的矢量成为半矢量（half-vector）或半角矢量（half-angle vector）；我们将其表示为<strong>h</strong>。<br><img src="/2018/05/14/PBR-Guide-Vol1/22.jpg" title="仅m=h的表面点的朝向才会将光线I反射到视线v的方向，其他表面点对BRDF没有贡献。"></p>
<p>并非所有的<strong>m = h</strong>的表面点都会积极地对反射做出共享；一个被<strong>I</strong>方向（阴影shadowing），v方向（掩蔽masking）或两者的其他表面区域阻挡。Microfacet理论假设所有被遮蔽的光（shadowed light）都从镜面反射项中消失；实际上，由于多次表面反射，其中一些最终将是可见的，但这在目前常见的微平面理论中一般并未去考虑，各种类型的光表面相互作用如下图所示。<br><img src="/2018/05/14/PBR-Guide-Vol1/23.jpg"><br>上图在左侧，我们看到一些表面点从I的方向被遮挡，因为它们被遮挡并且不接受光（因此它们不能反射任何）。在中间，我们看到从视图方向v看不到一些表面点，因此当然不会看到从它们反射的任何光。在这两种情况下，这些表面点对BRDF没有共享。实际上，虽然阴影区域没有接受从I接受任何直射光，但它们确实接受（并因此反射）从其他表面区域反射的光（如右图所示）。microfacet理论忽略了这些互相反射。</p>
<h2 id="5-1-从物理现象到BRDF"><a href="#5-1-从物理现象到BRDF" class="headerlink" title="5.1 从物理现象到BRDF"></a>5.1 从物理现象到BRDF</h2><p>利用这些假设（局部光学平坦表面，没有相互反射），可以很容易推导出一个被成为Microfacet Cook-Torrnace BRDF的一般形式的Specular BRDF项。此Specular BRDF具有以下形式：</p>
<p>$f(l,v)={D(h)F(v,h)G(l,v,h)\over 4(n\cdot l)(n \cdot v)}$</p>
<p>其中：</p>
<ul>
<li><strong>D(h)</strong>:法线分布函数（Normal Distribution Function），描述微面元发现分布的概率，即正确朝向的发现的浓度。即具有正确朝向，能够将来自<strong>I</strong>的光反射到v的表面点的相对于表面面积的浓度。</li>
<li><strong>F(I,h)</strong>:菲涅尔方程（Fresnel Equation），描述不同的表面角下表面所反射的光线所占的比率。</li>
<li><strong>G(l,v,h)</strong>:几何函数（Geometry Function），描述微平面自成阴影的属性，即m=h的未被遮蔽的表面点的百分比。</li>
<li><strong>分母4(n\cdot l)(n \cdot v)</strong>:校正因子（correctionfactor），作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。</li>
</ul>
<p>关于Cook-Torrance BRDF，需要强调的两点注意事项：</p>
<ul>
<li>对于分母中的点击，仅仅避免负值时不够的，也必须避免零值。通常通过在常规的clamp或绝对值操作之后添加非常小的正值来完成。</li>
<li><strong>Microfacet Cook-Torrance BRDF是实践中使用最广泛的模型，实际上也是人们可以想到的最简单的微平面模型。它仅对几何光学系统中的单层为表面上的单个散射进行建模，没有考虑多次散射，分层材质，以及衍射。Microfacet模型，实际上还有很长的路要走。</strong></li>
</ul>
<p>下面对Microfacet Cook-Torrance BRDF中的D、F、G项分别进行简单说明。</p>
<h2 id="5-2-Specular-D"><a href="#5-2-Specular-D" class="headerlink" title="5.2 Specular D"></a>5.2 Specular D</h2><p>法线分布函数（Normal Distribution Function, NDF）D的常见模型可以总结如下：</p>
<ul>
<li>Beckmann[1963]</li>
<li>Blinn-Phong[1977]</li>
<li>GGX[2007]/Trowbridge-Reitz[1975]</li>
<li>Generalized-Trowbridge-Reitz(GTR)[2012]</li>
<li>Anisotropic Beckmann[2012]</li>
<li>Anisotropic GGX[20115]</li>
</ul>
<p>其中，业界较为主流的法线分布函数是GGX（Trowbridge-Reitz），因为具有更好的高光长尾：</p>
<font size="5">$D_{GGX} = {\alpha \over (\pi(n \cdot m)^2(\alpha^2 - 1) + 1)^2}$</font>

<img src="/2018/05/14/PBR-Guide-Vol1/24.jpg">
<p>另外，需要强调一点。<strong>Normal Distribution Function</strong>正确的翻译是法线分布函数，而不是正太分布函数。google翻译等翻译软件会将Normal Distribution Function翻译成正态分布函数，而不少中文资料就跟着翻译成正态分布函数，这是错误的。</p>
<p>其实，一些参考文献会使用术语“法线分布（distribution of normals）”来避免与高斯正太分布(Gaussian normal distribution)混淆。</p>
<h2 id="5-3-Specular-F"><a href="#5-3-Specular-F" class="headerlink" title="5.3 Specular F"></a>5.3 Specular F</h2><p>对于菲涅尔（Fresnel）项，业界方案一般都采用Schlick的Fresnel近似，因为计算成本低廉，而且精度足够：</p>
<p>$F_{Schlick}(v,h)=F_0 + (1 - F_0)(1 - (v \cdot h))^5$</p>
<p>菲涅尔项的常见模型可以总结如下：</p>
<ul>
<li>Cook-Torrance[1982]</li>
<li>Schlick[1994]</li>
<li>Gotanta[2014]</li>
</ul>
<h2 id="5-4-Specular-G"><a href="#5-4-Specular-G" class="headerlink" title="5.4 Specular G"></a>5.4 Specular G</h2><p>几何项G的常见模型可以总结如下：</p>
<ul>
<li>Smith[1967]</li>
<li>Cook-Torrance[1982]</li>
<li>Neumann[1999]</li>
<li>Kelemen[2001]</li>
<li>Implicit[2013]</li>
</ul>
<p>另外，Eric Heitz在[Heitz14]中展示了Smith几何阴影函数是正确且更准确的G项，并将其扩展为Smith联合遮蔽函数(Smith Joint Masking-Shadowing Function)，该函数具有四种形式：</p>
<ul>
<li>分离遮蔽阴影型（Separable Masking and Shadowing）</li>
<li>高度相关遮蔽阴影型（Height-Correlated Masking and Shadowing）</li>
<li>方向相关遮蔽阴影型（Direction-Correlated Masking and Shadowing）</li>
<li>高度-方向相关遮蔽阴影型（Height-Direction-Correlated Masking and Shadowing）</li>
</ul>
<p>目前较为常用的是最为简单的形式，分离遮蔽阴影（Separable Masking and Shadowing Function）。</p>
<p>该形式将几何项G分为两个独立的部分：光线方向（light）和视线方向（view），并对两者用相同的分布函数描述。根据这种思想，结合法线分布函数（NDF）与Smith几何阴影函数，于是有了以下新的Smith几何项：</p>
<ul>
<li>Smith-GGX</li>
<li>Smith-Beckmann</li>
<li>Smith-Schlick</li>
<li>Schlick-Beckmann</li>
<li>Schlick-GGx</li>
</ul>
<p>其中UE4的方案是上面列举中的”Schlick-GGX”，即基于Schlick近似，将K映射为$k = {\alpha \over 2}$，去匹配GGX Smith方程：</p>
<p>$k = {\alpha \over 2}$<br>$\alpha = roughness^2$<br>$G_1(v)={(n\cdot v)\over {(n\cdot v)(1-k)+k}}$<br>$G(l,v,h)=G_1(l)G_1(v)$</p>
<h1 id="六、基于物理的环境光照（Physically-Based-Environment-Lighting）"><a href="#六、基于物理的环境光照（Physically-Based-Environment-Lighting）" class="headerlink" title="六、基于物理的环境光照（Physically Based Environment Lighting）"></a>六、基于物理的环境光照（Physically Based Environment Lighting）</h1><p>有了直接光部分，我们也需要环境光。所以PBR核心知识体系的第六部分是基于物理的环境光照，一般大家也直接默认环境光照的技术方案是基于图像的光照（Image Based Lighting, IBL)。这也是真正让基于物理的渲染画质提升的主要贡献者。<br><img src="/2018/05/14/PBR-Guide-Vol1/25.jpg"><br>漫反射环境光照部分一般采用传统IBL中辉度环境映射（Irradiance Environment Mapping）技术，并不是基于物理的特有方案，这里暂不讨论。</p>
<p>而基于物理的镜面反射（Specular）环境光照，业界中一般会采用基于图像的光照（IBL）的方案。要将基于物理的BRDF模型与基于图像的光照（IBL）一起使用，需要求解光照亮度积分（Radiance Integral），而求解光亮度积分通常会使用重要性采样（Importance Sample）。</p>
<p>重要性采样（Importance Sample）即通过现有的一些已知条件（分布函数），想办法集中于被积函数分布可能性较高的区域（重要的区域）进行采样，进而可高效和准确的计算。</p>
<h2 id="6-1-分解求和近似（Split-Sum-Approximation）"><a href="#6-1-分解求和近似（Split-Sum-Approximation）" class="headerlink" title="6.1 分解求和近似（Split Sum Approximation）"></a>6.1 分解求和近似（Split Sum Approximation）</h2><p>基于重要性采样的思路，将蒙特卡洛积分公式代入渲染方程可得：<br><img src="/2018/05/14/PBR-Guide-Vol1/26.jpg"></p>
<p>$$</p>
<h3 id="6-3-1-流派1：2D-LUT"><a href="#6-3-1-流派1：2D-LUT" class="headerlink" title="6.3.1 流派1：2D LUT"></a>6.3.1 流派1：2D LUT</h3><p>UE4在[Real Shading in Unreal Engine 4,2013]中提出，第二个求和项，使用Schlick近似后，$F<em>0$可以从积分中分出来：<br>$\int</em>\Omega{L<em>i(l)f(l,v)cos\theta_l\cdot dl} = F_0\int</em>\Omega{f(l,v)\over F(v,h)}(1-(1-v\cdot h)^5)cos\theta<em>ldl+\int</em>\Omega{f(l,v)\over F(v,h)}(1-v\cdot h)^5cos\theta_ldl$<br>上式留下了两个输入(Roughness和$cos\theta$v)和两个输出(缩放和向$F_0$的偏差(a scale and bias to $F_0$))，即把上述方程看成是$F_0 \cdot Scale + Offset$的形式。我们预先计算此函数的结果并将其存储在2D查找纹理(LUT,look-up texture)中。<br><img src="/2018/05/14/PBR-Guide-Vol1/26.jpg"><br>这张红绿色的贴图，输入roughtness、$cos\theta$，输出环境BRDF镜面反射的强度。是关于roughness、$cos\theta$与环境BRDF镜面反射强度的固有映射关系。可以离线预计算。<br>具体的取出方式为：</p>
<p><font size="5">${1\over N}\sum<em>{k=1}^N {f(l_k,v)cos\theta</em>{l_k}\over p(l_k,v)}=LUT.r * F_0 + LUT.g$</font><br>即UE4是通过把Fresnel公式的F0提出来，组成F0*Scale+Offset的方式，再将Scale和Offset的索引存到一张2D LUT上。靠roughness和NdotV进行查找。</p>
<h3 id="6-3-2-流派2：解析拟合"><a href="#6-3-2-流派2：解析拟合" class="headerlink" title="6.3.2 流派2：解析拟合"></a>6.3.2 流派2：解析拟合</h3><p>COD: Black Ops 2的做法，是通过数学工具Mathematica(<a href="http://www.wolfram.com/mathematica/)中的数值积分拟合出曲线，即将UE4离线计算的这张2D" target="_blank" rel="noopener">http://www.wolfram.com/mathematica/)中的数值积分拟合出曲线，即将UE4离线计算的这张2D</a> LUT用如下函数进行了拟合：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">EnvironmentBRDF</span><span class="params">(<span class="keyword">float</span> g, <span class="keyword">float</span> NoV, float3 rf0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   float4 t = float4(<span class="number">1</span>/<span class="number">0.96</span>, <span class="number">0.475</span>, (<span class="number">0.0275</span> - <span class="number">0.25</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="七、离线渲染相关（Offline-Rendering-Related）"><a href="#七、离线渲染相关（Offline-Rendering-Related）" class="headerlink" title="七、离线渲染相关（Offline Rendering Related）"></a>七、离线渲染相关（Offline Rendering Related）</h1><p>虽然我们目前主要关注的是实时渲染（实时光栅图形学相关，暂时不关注实时光线追踪）领域，但很多时候，实时渲染也需要涉及到预计算，尤其是IBL相关的预计算，所以或多或少会用到离线渲染相关的知识。所以PBR核心知识体系的第七部分是离线渲染相关的主题。<br><img src="/2018/05/14/PBR-Guide-Vol1/27.jpg"><br>以下是与实时渲染结合相对紧密的离线渲染的核心主题以及概括总结（主要是统计学与概览相关）：</p>
<ul>
<li>重要性采样（Importance Sample）：蒙特卡洛积分的一种采样策略。思路是基于分布函数，尽量对被积函数分布可能性较高的区域进行采样。</li>
<li>多重要性采样（Muti Importance Sampling，MIS）：估算某一积分时，基于多个分布函数获取采样，并期望至少某一分布与被积函数形状适配。即根据各种技术对采样进行加权计算，进而消除近似于它的概览。即偶然中包含着某种必然。</li>
<li>蒙特卡洛方法（Monte Carlo Methods）：一种以概率统计理论为指导的数值计算方法。是指使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。</li>
<li>低偏差序列（Low-discrepancy sequence）：一种确定生成的超均匀分布列，也成为随机列、次随机列，常见低偏差序列有Hammersley，Halton等。</li>
<li>拟蒙特卡罗方法（Quasi-Monte Carlo Method）：使用低差异来进行数值积分和研究其它一些数值问题的方法。</li>
</ul>
<h1 id="八、进阶渲染主题（Advanced-Rendering-Topics）"><a href="#八、进阶渲染主题（Advanced-Rendering-Topics）" class="headerlink" title="八、进阶渲染主题（Advanced Rendering Topics）"></a>八、进阶渲染主题（Advanced Rendering Topics）</h1><p>前面的核心PBR主题都讨论完以后，会有更多进阶的内容浮出水面，它们共同组成了PBR核心知识体系的第八部分。<br><img src="/2018/05/14/PBR-Guide-Vol1/28.jpg"><br>以下是一个列举：</p>
<ul>
<li>进阶着色模型<ul>
<li>布料BRDF(Cloth BRDF)</li>
<li>清漆着色模型(Clear Coat Model)</li>
<li>次表面散射BRDF模型(Subsurface Scattering BRDF Model)</li>
</ul>
</li>
<li>进阶材质功能<ul>
<li>全能材质(Uber Shader)</li>
<li>分层材质(Layered Materials)</li>
<li>分层全能材质(Layered Uber Shader)</li>
<li>混合材质(Blending Material)</li>
<li>过滤材质(Filtering Materials)</li>
</ul>
</li>
<li>进阶理论<ul>
<li>物理光学(Physics of Light)</li>
<li>波动光学(Wave Optics)</li>
<li>基于物理的摄像机(Physical Based Camera)</li>
<li>基于物理的光源(Physical Based Light)</li>
<li>白炉测试(White Furnace Test)</li>
</ul>
</li>
<li>进阶BxDF<ul>
<li>BSDF</li>
<li>BTDF</li>
<li>BSSRDF</li>
</ul>
</li>
<li>进阶材质渲染<ul>
<li>皮肤渲染(Skin Rendering)</li>
<li>布料渲染(Cloth Rendering)</li>
<li>半透明表面渲染(Translucent Surfaces Rendering)</li>
<li>头发渲染(Hair Rendering)</li>
<li>毛发渲染(Fur Rendering)</li>
<li>车漆渲染(Car Paint Rendering)</li>
<li>水体渲染(Water Rendering)</li>
<li>湿润表面渲染(Wet Surface Rendering)</li>
<li>天空与大气渲染(Sky and Atmosphere Rendering)</li>
<li>薄表面材质渲染(Thin Surface Rendering)</li>
<li>体积渲染(Volumetric Rendering)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/14/d3d11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/d3d11/" class="post-title-link" itemprop="url">Direct3D 11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-14 08:50:27" itemprop="dateCreated datePublished" datetime="2018-05-14T08:50:27+08:00">2018-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>点积(dot product)计算结果是标量值；也叫标量积(scalar product)。等于两个向量对应分量的乘积之和。</li>
</ol>
<p>$\mathbf{u \cdot v} = u_xv_x+u_yv_y+u_zv_z$</p>
<h2 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a>4.1 准备工作</h2><h3 id="4-1-4-交换链和页面翻转"><a href="#4-1-4-交换链和页面翻转" class="headerlink" title="4.1.4 交换链和页面翻转"></a>4.1.4 交换链和页面翻转</h3><p>为了避免在动画中出现闪烁，最好的做法是在一个离屏（off-screen）纹理中执行所有的动画帧绘制工作，这个离屏纹理成为后台缓存区(back buffer)。当我们在后台缓冲区中完成给定帧的绘制工作后，便可以将后台缓冲区作为一个作为一个完整的帧显示在屏幕上；使用这种方法，用户不会感觉到帧的绘制过程，只会看到完整的帧。从理论上讲，将一帧显示到屏幕上所消耗的时间小于屏幕的垂直刷新时间。硬件会自动维护两个内置的纹理缓冲区来实现这一功能，这两个缓冲区分别成为前台缓冲区(front buffer)和后台缓冲区。前台缓冲区存储了当前显示在屏幕上的图像数据，而动画的下一帧会在后台缓冲区中执行绘制。当后台缓冲区的绘制工作完成之后，前后两个缓冲区的做哟个会发生翻转；后台缓冲区会变为前台huan’ch</p>
<h3 id="4-1-5-深度缓冲区"><a href="#4-1-5-深度缓冲区" class="headerlink" title="4.1.5 深度缓冲区"></a>4.1.5 深度缓冲区</h3><p><strong>深度缓冲区(depth buffer)</strong>是一个不包含图像数据的纹理对象。在一定程度上，深度信息可以被认为是一种特殊的像素。常见的深度值范围在0.0到1.0之间，其中0.0表示离观察者最近的物体，1.0表示离观察者最远的物体。深度缓冲区中的每个元素与后台缓冲区中的每个像素一一对那个（即，后台缓冲区的第ij个元素对应于深度缓冲区第ij个元素）。所以，当后台缓冲区的分辨率为1280x1024时，在深度缓冲区中有1280x1024个深度元素。</p>
<h3 id="4-1-6-纹理资源视图"><a href="#4-1-6-纹理资源视图" class="headerlink" title="4.1.6 纹理资源视图"></a>4.1.6 纹理资源视图</h3><p>纹理可以被绑定到<strong>渲染管线（rendering pipeline）</strong>的不同<strong>阶段(stage)</strong>;例如，比较常见的情况是将纹理作为渲染目标（即，Direct3D渲染到纹理）或着色器资源（即，在着色器中对纹理进行采样）。当创建用于这两种目的的纹理资源时，应使用绑定标记值：<br>    D3D11_BIND_RENDER_TARGET|D3D10_BIND_SHADER_RESOURCE<br>指定纹理所要绑定的两个管线阶段。其实，资源不能被直接绑定到一个管线阶段；我们只能把与资源关联的资源试图绑定到不同的管线阶段。无论以哪种方式使用纹理，Direct3D始终要求我们在初始化时为纹理创建相关的<strong>资源视图(resource view)</strong>。这样有助于提供运行效率，正如SDK文档指出的那样：“运行时环境与驱动程序可以在视图创建执行相应的验证和映射，减少绑定时的类型检查”。所以，当把纹理作为一个渲染目标和着色器资源时，我们要为它创建两种试图：<strong>渲染目标试图 (ID3D11RenderTargetView)</strong>和<strong>着色器资源视图 (ID3D11ShaderResourceView)</strong>。资源视图主要有两个功能：（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）；</p>
<h3 id="4-1-7-多重采样"><a href="#4-1-7-多重采样" class="headerlink" title="4.1.7 多重采样"></a>4.1.7 多重采样</h3><p>因为计算机显示器上的像素分辨率有限，所以当我们绘制一条任意直线时，该直线很难精确地显示在屏幕上。<br>当无法提高显示器的分辨率，缩小像素尺寸，也可以有效地缓解这一问题，使阶梯效应明显降低。<br>当无法提高显示器分辨率或分辨率不够高时，我们可以使用<strong>抗锯齿 (antialiasing)技术</strong>。其中的一种技术叫做<strong>超级采样（supersampling）</strong>，它把后台缓冲和深度缓冲的大小提高到屏幕分辨率的4倍。</p>
<h3 id="4-1-8-Direct3D中的多重采样"><a href="#4-1-8-Direct3D中的多重采样" class="headerlink" title="4.1.8 Direct3D中的多重采样"></a>4.1.8 Direct3D中的多重采样</h3><h2 id="4-2-对Direct3D进行初始化"><a href="#4-2-对Direct3D进行初始化" class="headerlink" title="4.2 对Direct3D进行初始化"></a>4.2 对Direct3D进行初始化</h2><ol>
<li>ID3D11Device接口用于检测显示适配器功能和分配资源。</li>
<li>ID3D11DeviceContext接口用于设置管线状态、将资源绑定到图形管线和生成渲染命令。</li>
</ol>
<h3 id="4-2-2-检测4X多重采样质量支持"><a href="#4-2-2-检测4X多重采样质量支持" class="headerlink" title="4.2.2 检测4X多重采样质量支持"></a>4.2.2 检测4X多重采样质量支持</h3><p>创建了设备后，我们就可以检查4X多重采样质量等级了。所有支持Direct3D 11的设备都支持所有渲染目标格式的4X MSAA（支持的质量等级可能并不相同）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UINT m4xMsaaQuality;</span><br><span class="line">HR(md3dDevice-&gt;CheckMultisampleQualityLevels(DXGI_FORMAT_R8G8B8AB_UNORM, <span class="number">4</span>, &amp;m4xMassQuality));</span><br><span class="line">assert(m4xMsaaQuality&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>因为4X MSAA总是被支持的，所以返回的质量等级总是大于0。</p>
<h3 id="4-2-3-描述交换链"><a href="#4-2-3-描述交换链" class="headerlink" title="4.2.3 描述交换链"></a>4.2.3 描述交换链</h3><p>下一步是创建交换链，首先需要填充一个DXGI_SWAP_CHAIN_DESC结构体来描述我们将要创建的交换链的特性。该结构体的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_SWAP_CHAIN_DESC</span>&#123;</span></span><br><span class="line">    DXGI_MODE_DESC BufferDesc;</span><br><span class="line">    DXGI_SAMPLE_DESC SampleDesc;</span><br><span class="line">    DXGI_USAGE BufferUsage;</span><br><span class="line">    UINT BufferCount;</span><br><span class="line">    HWND OutputWindow;</span><br><span class="line">    BOOL Windowed;</span><br><span class="line">    DXGI_SWAP_EFFECT SwapEffect;</span><br><span class="line">    UINT Flags;</span><br><span class="line">&#125;DXGI_SWAP_CHAIN_DESC;</span><br></pre></td></tr></table></figure></p>
<p><strong>DXGI_MODE_DESC</strong>类型是另一个结构体，其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_MODE_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT Width;					<span class="comment">// 后台缓冲区宽度</span></span><br><span class="line">    UINT Height;				<span class="comment">// 后台缓冲区高度</span></span><br><span class="line">    DXGI_RATIONAL RefreshRate; 	<span class="comment">// 显示刷新率</span></span><br><span class="line">    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; <span class="comment">// display scanline mode</span></span><br><span class="line">    DXGI_MODE_SCALING Scaling; <span class="comment">// display scaling mode </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>在下面的数据成员描述中，我们只覆盖了一些常用的标记值和选项，它们对于初学者来说非常重要。对于其他标志值和选项的描述，请参阅SDK文档。</p>
<ol>
<li><strong>BufferDesc:</strong>该结构体描述了我们所要创建的后台缓冲区的属性。我们主要关注的属性有：宽度、高度和像素骼时；其他属性的详情请参阅SDK文档。</li>
<li><strong>SampleDesc:</strong></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/26/Unity-Stencil-Buffer-Stencil-Test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/Unity-Stencil-Buffer-Stencil-Test/" class="post-title-link" itemprop="url">Shader模板缓冲和模板测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-26 17:33:58" itemprop="dateCreated datePublished" datetime="2018-04-26T17:33:58+08:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在图形学种一个像素会有如下缓存：</p>
<ul>
<li>颜色缓存color buffer/pixel buffer : 存储该点即将显示地颜色，RGBA值</li>
<li>深度缓存depth buffer/z buffer:存储该点地深度，z</li>
<li>模板缓存stencil buffer： 通常用作限制渲染区域。更高级用法需结合深度缓冲，例如某像素地模板缓冲值会随着其是否通过深度缓冲测试而改变。</li>
<li>累计缓存Accumulation Buffer:与颜色缓存类似，同样储存一个RGBA值。累计缓存是为合成多幅图像而设计地，累计缓存提供了一种在保持好地颜色分辨率下实现在场景中”多重曝光(multiple exposures”地方法。使用累计缓存可以产生许多图像效果来提高图像的真实性，其中包括：反走样，运动模糊，软阴影，深度域（景深）和卷积。要产生这些效果，必须将图像渲染多次，对场景位置（或所选的物体）进行微小的、渐增的改变，然后累计结果。</li>
</ul>
<p>stencil与颜色缓冲区和深度缓存区类似，模板缓存区可以为屏幕上的每个像素点保存一个无符号整数值（通常是个八位整数）。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程成为模板测试Stencil Test。模板测试发生在透明度测试(alpha test)之后。如果模板测试通过，则相应的像素点更新，否则不更新。图形渲染管线中，基于单个像素的测试操作的顺序如下图<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Stencil-Buffer-Stencil-Test-1.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/26/Unity-Lerp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/Unity-Lerp/" class="post-title-link" itemprop="url">Unity Lerp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-26 16:54:28" itemprop="dateCreated datePublished" datetime="2018-04-26T16:54:28+08:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有时，我们在做游戏时会发现有些跟随动作不够圆滑或者需要一个缓冲的效果，这时，一般会考虑到插值。（比如摄像机跟随主角）</p>
<p>插值是数学上的一个概念，公式： from + (to - from) * t;<br>from是起始地位置，to是目标位置，按照数字t在from到to之间插值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/21/CG-Input-Output-And-Semantic-Bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/21/CG-Input-Output-And-Semantic-Bind/" class="post-title-link" itemprop="url">CG-Input-Output-And-Semantic-Bind</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-21 19:26:35" itemprop="dateCreated datePublished" datetime="2018-04-21T19:26:35+08:00">2018-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先复习一下GPU的工作流程，第三章从CPU运行原理和数据流程的角度阐述了顶点着色器程序和片段着色程序的输入输出，即，应用程序(宿主程序)将图元信息(顶点位置、法向量、纹理坐标等)传递给顶点着色程序；顶点着色程序基于图元信息进行坐标空间变换，运算得到的数据传递到片段着色程序中；片段着色程序还可以接受从应用程序中传递的纹理信息，将这些信息综合起来计算每个片段的颜色值，最后将这些颜色值输送到帧缓冲区(或颜色缓冲区)中。<br><img src="http://oxcvfpext.bkt.clouddn.com/CG-Input-Output-And-Semantic-Bind-1.jpg"><br>这一章中，我们将讲解Cg语言通过何种机制确定数据类型和传递形式。<br>三个问题：<br>1、从应用程序传递到GPU的数据，分为图元信息数据(在GPU处理的基本数据如顶点位置信息等)和其他的离散数据(在GPU运行流程中不会发生变化，如材质对光的反射、折射信息)，这两种输入数据如何区分？<br>2、从应用程序传递到GPU中的图元信息如何区分类型，即，顶点程序怎么知道一个数据是位置数据，而不是法线量数据？<br>3、顶点着色程序与片段着色程序之间的数据传递如何进行？<br>cg关键字不但用于指定输入图元的数据含义(是位置信息，还是法向量信息),本质也则对应着这些图元数据存放的硬件资源(寄存器或者纹理)，称之为语义词(Semantics),通常也根据其用法称之为绑定语义词(binging semantics)。</p>
<p>除语义词外，Cg中还提供了三个关键字，int、out、inout，用于表示函数的输入参数的传递方式，称为输入/输出关键字，这组关键字可以和语义词合用表达硬件上不同的存储位置，即同一个语义词，使用in关键字修饰和out关键词修饰，表示的图形硬件上不同的寄存器。</p>
<p>Cg语言还提供两个修饰符：uniform,用于指定变量的数据初始化方式；const关键字的含义与C/C++中相同，表示被修饰变量为常量变量。</p>
<h3 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h3><p>Cg语言将输入输出数据流分为两类：</p>
<ol>
<li>Varying inputs,即数据流输入图元信息的各种组成要素。从应用程序输入到GPU的数据除了顶点位置数据，还有顶点的法向量数据，纹理坐标数据等。</li>
<li>Uniform inputs,表示一些与三维渲染有关的离散信息数据，这些数据通常由应用程序传入，并通常不会随着图元信息的变化而变化，如材质对光的反射信息、运动矩阵等。Uniform修饰一个参数，表示该参数的值由外部应用程序初始化并传入。<br>使用Uniform修饰的变量，除了数据来源不同外，与其他变量是完全一样的。需要注意的一点是：uniform修辞的变量是从外部传入的，所以在Cg程序(顶点程序和片段程序)中通常所有uniform参数修辞函数形参，不容许声明一个uniform修辞的局部变量！</li>
</ol>
<p>Cg语言中参数传递方式同样分为”值传递”和”引用传递”，但指针机制并不被GPU硬件支持，所以Cg语言采用不同的语法修辞符来区别”值传递”和”引用传递”.这些修辞符分别为：</p>
<ol>
<li>in   :修辞一个形参只是用于输入，进入函数体时被初始化，且该形参值的改变不会影响实参值，这是典型的值传递方式。</li>
<li>out  :修辞一个形参只是用于输出的，进入函数体时并没有被初始化，这种类型的形参一般是一个函数的运行结果；</li>
<li>inout:修辞一个形参即用于输入也用于输出，这是典型的引用传递。<br>例如： void myFunction(float x); //等价于in float x，这种用法和C/C++完全一致<br>语义词(Semantic)与语义绑定(Binding semantics)</li>
</ol>
<p>语义词，表示输入图元的数据含义(是位置信息，还是法向量信息)，也表明这些图元数据存放的硬件资源(寄存器或者纹理缓存区)。顶点着色程序和片段着色程序中Varying inputs类型的输入，必须和一个语义词相绑定，这称之为绑定语义(binding semantics)。</p>
<p>记住这一点：语义，是两个处理阶段(顶点程序、片段程序)之间的输入/输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如POSITION一般表示参数存放的数据是顶点位置。</p>
<p>语义，只对两个处理阶段的输入/输出数据有意义，也就是说，语义只有在入口函数中才有效，在内部函数(一个阶段的内部处理函数，和下一个阶段没有数据传递关系)无效，被忽略。</p>
<p>顶点着色程序必须声明一个输出变量，并绑定POSITION语义词，该变量中的数据将被用于且至被用于光栅化！</p>
<p>为了保持顶点程序输出语义和片段程序输入语义的一致性，通常使用相同的struct类型数据作为两者之间的传递，这是一种非常方便的写法，推荐使用。</p>
<p>注意：当使用struct结构中成员变量绑定语义时，需要主要到顶点着色程序中使用的POSITION语义词，是不会被片段程序所使用的。</p>
<p>都要记住vertex program中的绑定语义(POSITION除外)的输出形参中的数据会传递到fragment program中绑定相同语义的输入形参中。</p>
<p>片段着色器的输出语义词较少，通常是COLOR。这是因为片段着色程序运行完毕后，就基本到了GPU流水线的末端了。片段程序必须声明一个out向量(三元或四元),绑定语义词COLOR，这个值将被用作该片段的最终颜色值。</p>
<h3 id="语义绑定方法"><a href="#语义绑定方法" class="headerlink" title="语义绑定方法"></a>语义绑定方法</h3><p>绑定语义放在函数的参数列表的参数声明后面中：</p>
<pre><code>[const][int|out|inout]&lt;type&gt;&lt;identifier&gt;[:&lt;binding-semantic&gt;][=&lt;initializer&gt;]
</code></pre><p>绑定语义可以放在结构体(struct)的成员变量后面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &lt;struct-tag&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;type&gt;&lt;identifier&gt; [:&lt;binding-semantic&gt;];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>绑定语义词可以放在函数声明的后面，其形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; &lt;identifier&gt;(&lt;parameter-list&gt;)[:&lt;binding-semantic&gt;]</span><br><span class="line">&#123;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一种语义绑定的方法是，将绑定语义词放在全局非静态变量的声明后面。其形式为：</p>
<pre><code>&lt;type&gt; &lt;identifer&gt;[:&lt;binding-semantic&gt;][=&lt;initializer&gt;];
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
