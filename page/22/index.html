<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/22/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/22/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/07/01/Unity3D_Game_Design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/01/Unity3D_Game_Design/" class="post-title-link" itemprop="url">Unity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-01 08:47:00" itemprop="dateCreated datePublished" datetime="2018-07-01T08:47:00+08:00">2018-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ol>
<li>模型命名 Max文件中角色模型命名为skin@sk_001武器模型命名为skin@wq_001</li>
<li>颜色贴图skin@st_001.png 高光贴图skin@st_001_ctr.png</li>
</ol>
<h2 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h2><h3 id="能够从3DsMax导入Unity3D的资源"><a href="#能够从3DsMax导入Unity3D的资源" class="headerlink" title="能够从3DsMax导入Unity3D的资源"></a>能够从3DsMax导入Unity3D的资源</h3><ul>
<li>所有节点的位移、旋转、锁方、轴心和命名都将导入</li>
<li>网格模型包含顶点颜色、法线，一到两个UV通道</li>
<li>材质包含贴图以及漫反射颜色，以及单个网格的多维材质</li>
<li>动画（物体移动、旋转、缩放）</li>
<li>骨骼动画（角色动画）</li>
</ul>
<h2 id="角色模型制作规范"><a href="#角色模型制作规范" class="headerlink" title="角色模型制作规范"></a>角色模型制作规范</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ol>
<li>选人界面模型面数约4500-5000左右</li>
<li>游戏内主角模型面数2500-3000左右</li>
<li>Boss模型面数根据体型大小3000-5000左右</li>
<li>Npc模型面数900-1200造型简单面数没下限</li>
<li>武器模型面数250-500 造型简单面数没下限</li>
<li>模型在不是非常废面的情况下，转折的地方做出厚度，厚度适当夸张。</li>
<li>地面部分制作成双面或是封闭，小布条类模型做成双面模型</li>
<li>角色结构整体均衡 比如眼睛部分不需要细致刻画</li>
</ol>
<h3 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h3><p>主角 512*512 png<br>Boss 512*512 png<br>Npc 256*256 png</p>
<p>武器体积较大的使用256*256 体积较小 128*128 png</p>
<h4 id="尺寸设定"><a href="#尺寸设定" class="headerlink" title="尺寸设定"></a>尺寸设定</h4><p>制作模型前必须先确保模型尺寸，统一将显示单位与系统单位改为公尺。</p>
<h3 id="注意正反面关系"><a href="#注意正反面关系" class="headerlink" title="注意正反面关系"></a>注意正反面关系</h3><p>每个模型都包含正面和反面，一般来说引擎只会显示模型的正面，如要反面也一起显示需透过shader来实现，但增加反面显示时会降低性能，因此尽量让模型单面显示就好，而在制作模型时必须确保要显示的模型面是正面即可。</p>
<h3 id="不要存在破面和迭面"><a href="#不要存在破面和迭面" class="headerlink" title="不要存在破面和迭面"></a>不要存在破面和迭面</h3><p>制作模型时注意顶点是否焊接好，未焊接的顶点可能会导致模型有破面的情形，另外模型面与面之间最好保持距离，不然会发生迭面的情况。</p>
<h3 id="不要存在多余的顶点和T点"><a href="#不要存在多余的顶点和T点" class="headerlink" title="不要存在多余的顶点和T点"></a>不要存在多余的顶点和T点</h3><p>删除一些没用的顶点，并且避免出现T点。</p>
<h3 id="删除看不到的面"><a href="#删除看不到的面" class="headerlink" title="删除看不到的面"></a>删除看不到的面</h3><p>制作模型时有些面可能在低下或是在模型里面，都是在场景进行中看不到的面，这些面可以删除，以减少模型面数提高效能。</p>
<h3 id="物体的轴心"><a href="#物体的轴心" class="headerlink" title="物体的轴心"></a>物体的轴心</h3><p>每个物体都有一个坐标轴心，宜据物体属性设计好物体轴心位置，一般来说轴心都会放置在中心的位置，其他情况如门的轴心可能会在低下角落的位置。</p>
<h3 id="使用简单几何体来制作复杂对象"><a href="#使用简单几何体来制作复杂对象" class="headerlink" title="使用简单几何体来制作复杂对象"></a>使用简单几何体来制作复杂对象</h3><p>当遇到比较复杂的对象，且对象比较小，左乘模型反而增加了模型的面数，因此可以使用简单的平面模型结合透空贴图来实现复杂的造型，可以将图片存成PSD、PNG、TGA这种带有透明通道属性的贴图档。</p>
<h3 id="重置模型（ResetXForm）"><a href="#重置模型（ResetXForm）" class="headerlink" title="重置模型（ResetXForm）"></a>重置模型（ResetXForm）</h3><p>制作模型时可能使用了缩放功能或镜像功能，这些指令会使得模型比例错乱以及出现负数轴向的情形，因此在模型制作完毕时最好进行ResetXForm指令，让模型回归最基本的状态。</p>
<h3 id="制作虚拟碰撞体"><a href="#制作虚拟碰撞体" class="headerlink" title="制作虚拟碰撞体"></a>制作虚拟碰撞体</h3><p>可以为模型制作简单的几何体来当作物体的碰撞体，可以依据物体的重要性与精确性来设计几何体外观。</p>
<h2 id="材质贴图和UV"><a href="#材质贴图和UV" class="headerlink" title="材质贴图和UV"></a>材质贴图和UV</h2><h3 id="Unity3D支持的Max材质"><a href="#Unity3D支持的Max材质" class="headerlink" title="Unity3D支持的Max材质"></a>Unity3D支持的Max材质</h3><p>Unity3D支持3dsmax的Standard(标准材质)与Muti/Sub-Object(多维/子物体材质)。</p>
<h3 id="模型汇入Unity后没有贴图？"><a href="#模型汇入Unity后没有贴图？" class="headerlink" title="模型汇入Unity后没有贴图？"></a>模型汇入Unity后没有贴图？</h3><p>当模型汇入Unity前，可以先创建一个Texture文件夹，并事先将贴图导入，这样模型汇入后就会自动读取到贴图。</p>
<h3 id="模型塌陷"><a href="#模型塌陷" class="headerlink" title="模型塌陷"></a>模型塌陷</h3><p>制作模型时，建议将模型以一栋建筑进行塌陷，接着对模型进行UV拆解，这样可以将一个模型使用一张贴图来完成。</p>
<h3 id="避免拉伸UV"><a href="#避免拉伸UV" class="headerlink" title="避免拉伸UV"></a>避免拉伸UV</h3><p>调整UV前先将材质球使用棋格 (checkter) 贴图来观看UV比例，调整UV时尽量让棋格维持正方形的形状。</p>
<h3 id="贴图尺寸"><a href="#贴图尺寸" class="headerlink" title="贴图尺寸"></a>贴图尺寸</h3><p>贴图必须是2的N词放（8、16、32、64、128、256），建议贴图不要超过1024*1024大小。</p>
<h3 id="绘制UV出血"><a href="#绘制UV出血" class="headerlink" title="绘制UV出血"></a>绘制UV出血</h3><p>绘制材质时绘制出血边缘，可避免出现明显接缝线。</p>
<h3 id="透空贴图在Unity里的使用"><a href="#透空贴图在Unity里的使用" class="headerlink" title="透空贴图在Unity里的使用"></a>透空贴图在Unity里的使用</h3><h3 id="透空贴图毛边处理技巧"><a href="#透空贴图毛边处理技巧" class="headerlink" title="透空贴图毛边处理技巧"></a>透空贴图毛边处理技巧</h3><h3 id="透空贴图毛边处理技巧（进阶）"><a href="#透空贴图毛边处理技巧（进阶）" class="headerlink" title="透空贴图毛边处理技巧（进阶）"></a>透空贴图毛边处理技巧（进阶）</h3><h3 id="材质与贴图命名"><a href="#材质与贴图命名" class="headerlink" title="材质与贴图命名"></a>材质与贴图命名</h3><h2 id="烘培贴图教学"><a href="#烘培贴图教学" class="headerlink" title="烘培贴图教学"></a>烘培贴图教学</h2><h3 id="3dsMax-LightMap-烘培贴图"><a href="#3dsMax-LightMap-烘培贴图" class="headerlink" title="3dsMax LightMap 烘培贴图"></a>3dsMax LightMap 烘培贴图</h3><h3 id="3dsMax-CompleteMap-烘培贴图"><a href="#3dsMax-CompleteMap-烘培贴图" class="headerlink" title="3dsMax CompleteMap 烘培贴图"></a>3dsMax CompleteMap 烘培贴图</h3><h2 id="Unity烘培贴图"><a href="#Unity烘培贴图" class="headerlink" title="Unity烘培贴图"></a>Unity烘培贴图</h2><h2 id="Unity3D地形制作"><a href="#Unity3D地形制作" class="headerlink" title="Unity3D地形制作"></a>Unity3D地形制作</h2><h3 id="地形编辑器基本功能介绍"><a href="#地形编辑器基本功能介绍" class="headerlink" title="地形编辑器基本功能介绍"></a>地形编辑器基本功能介绍</h3><h3 id="水系统介绍"><a href="#水系统介绍" class="headerlink" title="水系统介绍"></a>水系统介绍</h3><h3 id="天空盒系统介绍"><a href="#天空盒系统介绍" class="headerlink" title="天空盒系统介绍"></a>天空盒系统介绍</h3><h3 id="第一人称导览"><a href="#第一人称导览" class="headerlink" title="第一人称导览"></a>第一人称导览</h3><h2 id="3dsMax角色动画导入与基本控制"><a href="#3dsMax角色动画导入与基本控制" class="headerlink" title="3dsMax角色动画导入与基本控制"></a>3dsMax角色动画导入与基本控制</h2><h3 id="单个角色动画导入"><a href="#单个角色动画导入" class="headerlink" title="单个角色动画导入"></a>单个角色动画导入</h3><h3 id="多个角色动画导入"><a href="#多个角色动画导入" class="headerlink" title="多个角色动画导入"></a>多个角色动画导入</h3><h3 id="角色基本控制"><a href="#角色基本控制" class="headerlink" title="角色基本控制"></a>角色基本控制</h3><h2 id="第三人称角色控制"><a href="#第三人称角色控制" class="headerlink" title="第三人称角色控制"></a>第三人称角色控制</h2><h3 id="角色阴影"><a href="#角色阴影" class="headerlink" title="角色阴影"></a>角色阴影</h3><h2 id="树木与粒子系统"><a href="#树木与粒子系统" class="headerlink" title="树木与粒子系统"></a>树木与粒子系统</h2><h3 id="树木制作"><a href="#树木制作" class="headerlink" title="树木制作"></a>树木制作</h3><h2 id="粒子系统-繁星粒子效果"><a href="#粒子系统-繁星粒子效果" class="headerlink" title="粒子系统-繁星粒子效果"></a>粒子系统-繁星粒子效果</h2><h2 id="粒子系统-雪花粒子效果"><a href="#粒子系统-雪花粒子效果" class="headerlink" title="粒子系统-雪花粒子效果"></a>粒子系统-雪花粒子效果</h2><h2 id="粒子系统-火焰粒子效果"><a href="#粒子系统-火焰粒子效果" class="headerlink" title="粒子系统-火焰粒子效果"></a>粒子系统-火焰粒子效果</h2><h2 id="编辑界面介绍"><a href="#编辑界面介绍" class="headerlink" title="编辑界面介绍"></a>编辑界面介绍</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><h3 id="打开工程"><a href="#打开工程" class="headerlink" title="打开工程"></a>打开工程</h3><h3 id="Project视图"><a href="#Project视图" class="headerlink" title="Project视图"></a>Project视图</h3><h3 id="Hierarchy视图"><a href="#Hierarchy视图" class="headerlink" title="Hierarchy视图"></a>Hierarchy视图</h3><h3 id="Inspector视图"><a href="#Inspector视图" class="headerlink" title="Inspector视图"></a>Inspector视图</h3><h3 id="Scene视图"><a href="#Scene视图" class="headerlink" title="Scene视图"></a>Scene视图</h3><h4 id="视图介绍"><a href="#视图介绍" class="headerlink" title="视图介绍"></a>视图介绍</h4><h4 id="移动视图"><a href="#移动视图" class="headerlink" title="移动视图"></a>移动视图</h4><h4 id="移动模型"><a href="#移动模型" class="headerlink" title="移动模型"></a>移动模型</h4><h4 id="旋转模型"><a href="#旋转模型" class="headerlink" title="旋转模型"></a>旋转模型</h4><h4 id="缩放模型"><a href="#缩放模型" class="headerlink" title="缩放模型"></a>缩放模型</h4><h4 id="场景工具"><a href="#场景工具" class="headerlink" title="场景工具"></a>场景工具</h4><h4 id="Sence视图控制条"><a href="#Sence视图控制条" class="headerlink" title="Sence视图控制条"></a>Sence视图控制条</h4><h4 id="Game视图"><a href="#Game视图" class="headerlink" title="Game视图"></a>Game视图</h4><h4 id="Game视图控制条"><a href="#Game视图控制条" class="headerlink" title="Game视图控制条"></a>Game视图控制条</h4><h2 id="工程的打包"><a href="#工程的打包" class="headerlink" title="工程的打包"></a>工程的打包</h2><h3 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h3><h3 id="游戏案例1"><a href="#游戏案例1" class="headerlink" title="游戏案例1"></a>游戏案例1</h3><h2 id="Android和iOS版本发布"><a href="#Android和iOS版本发布" class="headerlink" title="Android和iOS版本发布"></a>Android和iOS版本发布</h2><h2 id="Unity3D脚本概述"><a href="#Unity3D脚本概述" class="headerlink" title="Unity3D脚本概述"></a>Unity3D脚本概述</h2><h3 id="Unity3D脚本概述-1"><a href="#Unity3D脚本概述-1" class="headerlink" title="Unity3D脚本概述"></a>Unity3D脚本概述</h3><h3 id="Unity3D的基本语法"><a href="#Unity3D的基本语法" class="headerlink" title="Unity3D的基本语法"></a>Unity3D的基本语法</h3><h4 id="访问其他组件"><a href="#访问其他组件" class="headerlink" title="访问其他组件"></a>访问其他组件</h4><h4 id="访问其他游戏对象"><a href="#访问其他游戏对象" class="headerlink" title="访问其他游戏对象"></a>访问其他游戏对象</h4><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><h4 id="成员变量与全局变量"><a href="#成员变量与全局变量" class="headerlink" title="成员变量与全局变量"></a>成员变量与全局变量</h4><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><h4 id="协同程序与中断"><a href="#协同程序与中断" class="headerlink" title="协同程序与中断"></a>协同程序与中断</h4><h4 id="创建游戏对象"><a href="#创建游戏对象" class="headerlink" title="创建游戏对象"></a>创建游戏对象</h4><h4 id="获取游戏对象"><a href="#获取游戏对象" class="headerlink" title="获取游戏对象"></a>获取游戏对象</h4><h4 id="添加组件与修改组件"><a href="#添加组件与修改组件" class="headerlink" title="添加组件与修改组件"></a>添加组件与修改组件</h4><h4 id="脚本组件"><a href="#脚本组件" class="headerlink" title="脚本组件"></a>脚本组件</h4><h4 id="克隆游戏对象"><a href="#克隆游戏对象" class="headerlink" title="克隆游戏对象"></a>克隆游戏对象</h4><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GUILayout.Label(<span class="string">"当前游戏时间："</span> + Time.time);</span><br><span class="line">    GUILayout.Label(<span class="string">"上一帧所消耗的时间："</span> + Time.deltaTime);</span><br><span class="line">    GUILayout.Label(<span class="string">"固定增量时间："</span> + Time.fixedTime);</span><br><span class="line">    GUILayout.Label(<span class="string">"上一帧所消耗的固定时间："</span> + Time.fixedDeltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><h2 id="Unity3D-GUI界面设计（GUI-amp-NGUI-amp-UGUI）"><a href="#Unity3D-GUI界面设计（GUI-amp-NGUI-amp-UGUI）" class="headerlink" title="Unity3D GUI界面设计（GUI&amp;NGUI&amp;UGUI）"></a>Unity3D GUI界面设计（GUI&amp;NGUI&amp;UGUI）</h2><h3 id="UGUI的网格重建、动静分离"><a href="#UGUI的网格重建、动静分离" class="headerlink" title="UGUI的网格重建、动静分离"></a>UGUI的网格重建、动静分离</h3><p>动静分离：也就是说同一个界面下的UI，可活动的元素放在一个Canvas下，不可活动的元素放在另一个Canvas下。虽然两个Canvas打断了合批，但是却减少了网格重建时间，总体上是有优化的。</p>
<p>究其原因，是因为在同一个Canvas下的某个元素发生变化时，同一Canvas下的所有元素都会进行网格重建(ReBatch)。井静态的元素在逻辑上是不需要重建的，因为他们都没变过，所以需要分开。</p>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4><h3 id="GUI常用控件"><a href="#GUI常用控件" class="headerlink" title="GUI常用控件"></a>GUI常用控件</h3><h4 id="GUI-Text"><a href="#GUI-Text" class="headerlink" title="GUI Text"></a>GUI Text</h4><h4 id="GUI-Texture-LazyTexture"><a href="#GUI-Texture-LazyTexture" class="headerlink" title="GUI Texture (LazyTexture)"></a>GUI Texture (LazyTexture)</h4><h4 id="Label控件"><a href="#Label控件" class="headerlink" title="Label控件"></a>Label控件</h4><h4 id="Button控件"><a href="#Button控件" class="headerlink" title="Button控件"></a>Button控件</h4><h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><h4 id="ToolBar"><a href="#ToolBar" class="headerlink" title="ToolBar"></a>ToolBar</h4><h4 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h4><h4 id="ScrollView控件"><a href="#ScrollView控件" class="headerlink" title="ScrollView控件"></a>ScrollView控件</h4><h4 id="群组视图"><a href="#群组视图" class="headerlink" title="群组视图"></a>群组视图</h4><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><h4 id="NGUI-Panel-amp-UGUI-Canvas"><a href="#NGUI-Panel-amp-UGUI-Canvas" class="headerlink" title="NGUI Panel &amp; UGUI Canvas"></a>NGUI Panel &amp; UGUI Canvas</h4><h4 id="图集制作-TexturePacket"><a href="#图集制作-TexturePacket" class="headerlink" title="图集制作(TexturePacket)"></a>图集制作(TexturePacket)</h4><h4 id="UITween动画"><a href="#UITween动画" class="headerlink" title="UITween动画"></a>UITween动画</h4><h4 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h4><h3 id="GUI-Skin"><a href="#GUI-Skin" class="headerlink" title="GUI Skin"></a>GUI Skin</h3><h4 id="自定义风格组件"><a href="#自定义风格组件" class="headerlink" title="自定义风格组件"></a>自定义风格组件</h4><h2 id="Unity3D输入与控制"><a href="#Unity3D输入与控制" class="headerlink" title="Unity3D输入与控制"></a>Unity3D输入与控制</h2><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><h4 id="键盘按下事件"><a href="#键盘按下事件" class="headerlink" title="键盘按下事件"></a>键盘按下事件</h4><h4 id="键盘抬起事件"><a href="#键盘抬起事件" class="headerlink" title="键盘抬起事件"></a>键盘抬起事件</h4><h4 id="键盘长按事件"><a href="#键盘长按事件" class="headerlink" title="键盘长按事件"></a>键盘长按事件</h4><h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><h4 id="触摸按下事件"><a href="#触摸按下事件" class="headerlink" title="触摸按下事件"></a>触摸按下事件</h4><h4 id="触摸抬起事件"><a href="#触摸抬起事件" class="headerlink" title="触摸抬起事件"></a>触摸抬起事件</h4><h4 id="触摸长按事件"><a href="#触摸长按事件" class="headerlink" title="触摸长按事件"></a>触摸长按事件</h4><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><h4 id="鼠标按下事件"><a href="#鼠标按下事件" class="headerlink" title="鼠标按下事件"></a>鼠标按下事件</h4><h4 id="鼠标抬起事件"><a href="#鼠标抬起事件" class="headerlink" title="鼠标抬起事件"></a>鼠标抬起事件</h4><h4 id="鼠标长按事件"><a href="#鼠标长按事件" class="headerlink" title="鼠标长按事件"></a>鼠标长按事件</h4><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="输入管理器（InputHelper）"><a href="#输入管理器（InputHelper）" class="headerlink" title="输入管理器（InputHelper）"></a>输入管理器（InputHelper）</h4><h4 id="自定义按键事件"><a href="#自定义按键事件" class="headerlink" title="自定义按键事件"></a>自定义按键事件</h4><h4 id="自定义按键轴"><a href="#自定义按键轴" class="headerlink" title="自定义按键轴"></a>自定义按键轴</h4><h4 id="实例练习"><a href="#实例练习" class="headerlink" title="实例练习"></a>实例练习</h4><h3 id="角色模型与动画（Animation-amp-Animator）"><a href="#角色模型与动画（Animation-amp-Animator）" class="headerlink" title="角色模型与动画（Animation&amp;Animator）"></a>角色模型与动画（Animation&amp;Animator）</h3><h4 id="模型的载入"><a href="#模型的载入" class="headerlink" title="模型的载入"></a>模型的载入</h4><h4 id="设置角色动画"><a href="#设置角色动画" class="headerlink" title="设置角色动画"></a>设置角色动画</h4><h4 id="播放3D动画"><a href="#播放3D动画" class="headerlink" title="播放3D动画"></a>播放3D动画</h4><h4 id="动画裁切"><a href="#动画裁切" class="headerlink" title="动画裁切"></a>动画裁切</h4><h4 id="动画的帧"><a href="#动画的帧" class="headerlink" title="动画的帧"></a>动画的帧</h4><h4 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h4><h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/06/30/Shadow_Mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/30/Shadow_Mapping/" class="post-title-link" itemprop="url">阴影映射的原理和实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-30 12:20:06" itemprop="dateCreated datePublished" datetime="2018-06-30T12:20:06+08:00">2018-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="阴影贴图-Shadwom-mapping"><a href="#阴影贴图-Shadwom-mapping" class="headerlink" title="阴影贴图 (Shadwom mapping)"></a>阴影贴图 (Shadwom mapping)</h1><p>像素与以纹理形式保存的光照深度缓冲区或者深度图像比较，通过这种方式计算像素是否处于光源照射范围之内，从而生成阴影。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>阴影贴图是一种使用深度纹理来为渲染阴影提供解决方法的多通道计算。它的关键是，就是用投影光源代替最终视口来观察场景。通过移动视口到光源位置，可以观察到这个位置每个东西都是明亮的，因为从光的角度来看是没有阴影的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/06/26/Unity3D-Optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/26/Unity3D-Optimize/" class="post-title-link" itemprop="url">Unity3D优化专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-26 17:06:02" itemprop="dateCreated datePublished" datetime="2018-06-26T17:06:02+08:00">2018-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-遮挡剔除OcclusionCulling"><a href="#一-遮挡剔除OcclusionCulling" class="headerlink" title="一 遮挡剔除OcclusionCulling"></a>一 遮挡剔除OcclusionCulling</h1><p>遮挡剔除(Occlusion Culling)功能可在对象因被其他物体遮挡，当前在相机中无法看到时，禁用对象渲染。该功能不会在三维计算机图形中自动开启，因为在大部分情况下，离相机最远的对象最先渲染，离相机的对象覆盖先前的物体（该步骤称之为“重复渲染(overdraw)”）。遮挡剔除(Occlusion Culling)与视锥体剔除(Frustum Culling)不同。视锥体剔除(Frustum Culling)只禁用相机视野外的对象渲染，不禁用视野中被遮挡的任何物体的渲染。注意，使用遮挡剔除(Occlusion Culling)功能时，仍将受益于视锥体剔除(Frustum Culling)。<br>当场景中包含大量模型时，势必会造成渲染效率的降低。如果使用遮挡剔除技术，可以使用那些被阻挡的物体不被渲染，从而达到提高渲染效率的目的。</p>
<p>遮挡剔除的基本原理是在场景中创建一个遮挡区域，该遮挡区域由单元格组成；每个单元格构成整个场景遮挡区域的一部分，这些单元格会把整个场景拆分为多个部分。当摄像机能够看到该单元格时，单元格中的物体会被渲染出来，而被其他单元格挡住的不被摄像机看到的物体不会被渲染。</p>
<p>下面，我们来做遮挡剔除的案例</p>
<h1 id="二-层级消隐"><a href="#二-层级消隐" class="headerlink" title="二 层级消隐"></a>二 层级消隐</h1><p>如果场景中存在大量的小物体，则可以使用层消隐优化场景。层消隐就是在比较远的距离将小物体剔除，减少绘制调用的次数。例如，在比较远的距离，大型建筑物依然可见，但是小型的石块和碎片隐藏掉。可以将小物件单独放入一个层，并且使用Camera.main.layerCullDistance函数设置层的消隐距离。调整摄像机位置进行测试即可。只有在摄像机距离这些物体小于10M的时候，地面上的这些物体才能显示出来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SeperateControl</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">float</span>[] distance = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">32</span>];</span><br><span class="line">        distances[<span class="number">8</span>] = <span class="number">10</span>;</span><br><span class="line">        Camera.main.layerCullDistances = distances; <span class="comment">// 如果main == null,则设置camera的tag为mainCamera</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-层级细节LOD"><a href="#三-层级细节LOD" class="headerlink" title="三 层级细节LOD"></a>三 层级细节LOD</h1><p>层级细节LOD全称为LevelOfDetail,它是根据物体在游戏画面中锁占据的百分比来调用不同复杂度的模型的。简单理解就是当一个物体距离摄像机比较远的时候，使用复杂度低的模型，比较近的时候，使用复杂度高的模型。</p>
<p>在建模软件中，制作好各个层级的模型，并且根据复杂程度自高向低命名为：模型名称_LOD0,模型名称_LOD1,模型名称_LOD2，数字越低，复杂程度越高。</p>
<p>我们新建一个场景，构造最简单的LOD模型示例。</p>
<ol>
<li>准备3个Unity基本游戏对象，添加必要的材质。</li>
<li>定义一个空对象，命名为_LOD,添加LODGroup组件</li>
<li>分别将以上三个基本对象拖拽到LODGroup的各个级别上</li>
<li>首先添加LOD0的对象，当然中间需要修改父节点，点击确定即可</li>
<li>在Scene视图中，拖动摄像机分别近距离与远距离观察模型的变化。</li>
</ol>
<h1 id="四-DrawCall讲解"><a href="#四-DrawCall讲解" class="headerlink" title="四 DrawCall讲解"></a>四 DrawCall讲解</h1><p>一个DrawCall，表示U3D使用这个材质/纹理，来进行一次渲染，那么这次渲染假设有3个对象，那么当3个对象都使用这一个材质/纹理的时候，就会产生一次DrawCall，可以理解为一次将纹理输送到屏幕上的过程，（实际上引擎大多会使用如双缓冲，缓存这类的手段来优化这个过程，但在这里我们只需要这样认识就可以了），假设3个对象使用不同的材质/纹理，那么无疑会产生3个DrawCall。</p>
<p>批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体，如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点一下的物体；请注意：属性数量的限制可能会在将来进行改变。</p>
<ol>
<li>相同的物体采取相同的材质，修改其缩放比例，观察DrawCall的变化。</li>
</ol>
<p>功能描述如下：Static Batching是将标明为Static的静态物件，如果在使用相同材质球的条件下，Unity会自动帮你把这两个物体合并成一个Batch，送往GPU来处理。</p>
<p>Static Batching可以让引擎降低任何尺寸网格的Draw Call，如下图所示：</p>
<h1 id="Profile-工具使用"><a href="#Profile-工具使用" class="headerlink" title="Profile 工具使用"></a>Profile 工具使用</h1><p>性能分析工具可以给我们提供游戏性能表现的详细信息。如果我们的游戏存在性能问题，如低帧率或者高内存占用，性能分析工具可以帮助我们法线问题的起因，并协助我们解决问题。</p>
<p>Profiler布局</p>
<p>在我们使用Profiler收集游戏数据之前，先打开它熟悉下界面布局。从菜单Window-&gt;Profiler打开。</p>
<p>在窗口左侧，可以看到一列profilers，每个profiler显示我们游戏的一个方面的信息，分别为cpu使用情况，gpu使用情况，渲染，内存使用情况，声音，物理和网络。</p>
<p>当开始录制时，窗口上部的每个profiler会随着时间显示数据。性能是随着时间变化的，所以随着时间变化的信息是比仅仅一帧的信息有用的多的。有些性能问题是持续性的，有些问题是仅仅在一帧中出现的，还有一些性能问题是随着时间逐渐显现的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/06/09/BRDF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/BRDF/" class="post-title-link" itemprop="url">BRDF(双向反射分布函数)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 11:34:41" itemprop="dateCreated datePublished" datetime="2018-06-09T11:34:41+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在计算机图形学领域，着色（Shading）是指根据表面或者多边形相对光源和相机的角度和距离来计算它的颜色的过程。不同的用户可以使用不同的着色算法，CAD等追求相应速度的交互式图形领域可以使用简单快速的着色算法，卡通油画等艺术效果使用非真实感（Nonphotorealistic）着色算法，而追求真实感的CG电影或游戏则可以使用基于物理建模的着色算法。<br>本文关注基于物理着色的BRDF模型，希望能将BRDF的来龙去脉将清楚，并分析Cook-TorranceBRDF公式的推倒过程。<br>要模拟真实光照，我们先要弄清楚光照的现象。</p>
<h2 id="光照现象"><a href="#光照现象" class="headerlink" title="光照现象"></a>光照现象</h2><p>光由光子组成，光子即具有粒子的特性，又表现出波的特性。从波的角度看，光是电磁波的一种，不同频率（波长）的光波能量不同，频率越高（波长越短），能量越高，频率越低（波长越长），能量越低，其中波长在380nm-780nm范围内的光波能被认类的视网膜感知到，这个范围的光波成为可见光，不同频率的可见光被人感知为不同的颜色，频率越高的光偏蓝，频率较低的光则偏红。</p>
<img src="/2018/06/09/BRDF/1.jpg">
<p>光学根据研究的尺度可以分为波动光学（Wave Optics）和几何光学（Geometric Optics），波动光学比几何光学复杂，而由于图形学领域光柱的尺度远大于可见光的波长（380nm - 780nm），也很少涉及光的偏振、干涉和衍射等波动光学才能解释的现象，所以我们一般用几何光学建立光照的模型。</p>
<h2 id="光学平面边界上的散射"><a href="#光学平面边界上的散射" class="headerlink" title="光学平面边界上的散射"></a>光学平面边界上的散射</h2><img src="/2018/06/09/BRDF/2.jpg">
<p>平面边界两边物质的折射率（Refractive Index）不同，当一束光线从一种物质照射到平面边界上时，其中一部分在平面边界被反射回这种物质，反射方向为入射方向关于平面法线的对称向量：</p>
<font size="4">$r_i = 2(n \cdot l)n - l$ </font> 

<blockquote>
<p>其中$r_i$是反射向量，l是光线入射向量，n是平面发现<br>向量间的$\cdot$表示向量的点积，两个单位向量的点积等于它们夹角的余弦。</p>
</blockquote>
<p>另一部分光穿过平面边界折射进入另一种物质，折射方向可由Snell法则（<a href="https://zentia.github.io/2019/05/12/snell/">Snell’s Law</a>）计算得出：</p>
<p><font size="5"> ${sin\theta_i \over sin\theta_t}={v_i\over v_t}={\lambda_i\over \lambda_t}={n_t\over n_i}$ </font></p>
<blockquote>
<p>其中下标i表示入射介质，下标t表示折射介质，$\theta$表示光线相对于边界法线的角度，v表示介质中的光速，$\lambda$表示介质中的波长，n表示介质的折射率。<br>反射和折射的比例由菲涅尔方程(Fresnel Equations)给出，菲涅尔方程比较复杂，图形学里一般使用近似公式计算。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/06/03/TA-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/03/TA-1/" class="post-title-link" itemprop="url">3D美术人员Technical Artist的学习之旅（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-03 14:44:18" itemprop="dateCreated datePublished" datetime="2018-06-03T14:44:18+08:00">2018-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TA是美术和程序之间沟通的桥梁。美术同学需要一些更加方便，可视化更强的工具，例如拓扑的工具，各位都知道MAX里有一个石墨工具是可以用于拓扑的，但是操作石墨工具拓扑是一件很痛苦的事，这时候有一个插件工具能给解决这个问题，例如wrapit的拓扑插件。正因为有了这个插件工具，我们就不用把模型导入Topogun在再次进行二次操作，而编写这个插件就可以算作TA人员所要去做的一件事。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/19/Unity3D-ShaderLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/19/Unity3D-ShaderLab/" class="post-title-link" itemprop="url">Unity ShaderLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-19 10:56:45" itemprop="dateCreated datePublished" datetime="2018-05-19T10:56:45+08:00">2018-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CG类型"><a href="#CG类型" class="headerlink" title="CG类型"></a>CG类型</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>32位浮点数据</td>
</tr>
<tr>
<td>half</td>
<td>16位浮点数据</td>
</tr>
<tr>
<td>int</td>
<td>32位整形数据</td>
</tr>
<tr>
<td>fixed</td>
<td>12位定点数</td>
</tr>
<tr>
<td>bool</td>
<td>布尔数据</td>
</tr>
<tr>
<td>sampler</td>
<td>纹理对象的句柄，分为sampler、sampler1D、sampler2D、sampler3D、samplerCUBE和samplerRECT。</td>
</tr>
</tbody>
</table>
</div>
<p>float2x4 matrix // 表示2x4阶矩阵，包含8个float类型数据</p>
<p>使用技巧：</p>
<ul>
<li>精度够用就好</li>
<li>颜色和单位向量，使用fixed</li>
<li>其他情况，尽量使用half（即范围在[-6万，）</li>
</ul>
<p>内置数据类型：基于基础数据类型，如float3，表示float3类型的三维向量；同理，bool2表示布尔类型的二维向量。</p>
<p>向量最长不能超过四元，如float5 vector; //编译错误</p>
<p>Swizzle操作符：它可以将一个向量的成员取出组成一个新的向量。对于坐标或者角度等其它多维向量，Swizzle操作符(.)后接x、y、z、w分别表示原始向量的第一个、第二个、第三个和第四个元素；同样，对于颜色可以后接r、g、b和a来表示同样的索引。<br>例如：</p>
<pre><code>float4(a,b,c,d).xwz 等价于 float4(a,d,c)
float4(a,b,c,d).xxy 等价于 float4(a,a,b)
</code></pre><p>Swizzle操作符只能对结构体和向量使用，不能对数组使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/17/How-to-systematically-optimize-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/17/How-to-systematically-optimize-performance/" class="post-title-link" itemprop="url">如何系统地进行性能优化？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-17 11:41:24" itemprop="dateCreated datePublished" datetime="2018-05-17T11:41:24+08:00">2018-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="运行帧率低"><a href="#运行帧率低" class="headerlink" title="运行帧率低"></a>运行帧率低</h3><p>低配机器上运行帧率比较低是常见问题。<br>a)首先是做分类，把通常的问题归类到几种瓶颈下来做讨论：GPU Bound、CPU Bound、Bandwidth Bound，还有Memory。这种分类方式基本是按照硬件资源的方式来进行的。<br>b)GPU Bound是一种目前手游中比较常见的瓶颈，降低分辨率如果对帧率有非常明显的提升的话，非常大的可能就是GPU Bound。<br>c)CPU Bound,降低分辨率的方式如果并不能提高帧率，那么可能是CPU Bound。CPU通常和Draw Call祥光，或者和复杂的游戏逻辑相关，通过Unity的Profiler工具可以比较明确看出是否是CPU Bound，以及这些计算时间都消耗在了哪里。<br>TimeLine可以比较明确的看到瓶颈（5.3.8没有，暂时不研究）<br>d)Bandwith Bound 在手游中也比较常见，一种比较简单的判断方式是使用NVIDIA Tegra Graphics Debugger这个工具（对于Tegra硬件更友好，但是比较难找。。。）中将所有贴图替换成2 * 2的大小，如果帧率有明显提升可能是Bandwidth瓶颈。当然也可以自己协代码所图来确认，比如使用Unity的Quality Setting里的Texture Quality。<br><img src="http://oxcvfpext.bkt.clouddn.com/How-to-systematically-optimize-performance-1.png"><br>e)内存就用Unity地Profiler来看吧，不过这个对于帧率没什么影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/16/3d-math-base-graph-game-develop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/16/3d-math-base-graph-game-develop/" class="post-title-link" itemprop="url">3D数学：图形与游戏开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-16 17:33:40" itemprop="dateCreated datePublished" datetime="2018-05-16T17:33:40+08:00">2018-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="惯性坐标系"><a href="#惯性坐标系" class="headerlink" title="惯性坐标系"></a>惯性坐标系</h3><p>为了简化世界坐标系到物体坐标系的转换，人们引入了一种新的坐标系，称作惯性坐标系，意思是在世界坐标系到物体坐标系的“半途”。关系坐标系的原点和物体坐标系的原点重合，但惯性坐标系的轴平行于世界坐标系的轴。</p>
<h3 id="4D齐次空间"><a href="#4D齐次空间" class="headerlink" title="4D齐次空间"></a>4D齐次空间</h3><p>4D向量有4个分量，前3个是标准的x,y和z分量，第四个是w，有时称作齐次坐标。<br>为了理解标准3D坐标是怎样扩展到4D坐标的，让我们先看一下2D中的齐次坐标，它的形式为(x,y,w)。想象在3D中w=1处的标准2D平面，实际的2D点(x,y)用齐次坐标表示(x,y,1)，对于哪些不在w=1平面的点，则将它们投影到w=1平面上。所以齐次坐标(x,y,w)映射的实际2D点为(x/w,y/w)。如图9.2所示。<br>因此，给定一个2D点(x,y)，齐次空间中有无数多个点与之对应。所有点的形式都为(kx,ky,k),k≠0。这些点构成一条穿过齐次原点的直线。<br>当w=0时，除法未定义，因此不存在实际的2D点。然而，可以将2D齐次点(x,y,0)解释为“位于无穷远的点”，它描述了一个方向而不是一个位置。在下节中会有关于该点的更多讨论。<br>4D坐标的基本思想相同。实际的3D点能被认为是在4D中w=1“平面”上。4D点的形式为(x,y,z,w)，将4D点投影到这个“平面”上得到相应的实际3D点(x/w,y/w,z/w)。w=0时4D点表示“无限远点”，它描述了一个方向而不是一个位置。<br>齐次坐标和通过除以w来投影时很有趣的，那我们为什么要使用4D坐标呢？有两个基本原因使得我们要使用4D向量和4X4矩阵。第一个原因实际上就是因为它是一种方便的记法，这也是下一节将要讨论的。</p>
<h3 id="4X4平移矩阵"><a href="#4X4平移矩阵" class="headerlink" title="4X4平移矩阵"></a>4X4平移矩阵</h3><p>3X3变换矩阵表示的是线性变换，不包含平移。因为矩阵乘法的性质，零向量总是变换成零向量，因此，任何能用矩阵乘法表达的变换都不包含平移。这很不幸，因为矩阵乘法和它的逆是一种非常方便的工具，不仅可以用来复用复杂的变换组合成简单的单一变换，还可以操纵嵌入式坐标系间的关系。如果能找到一种方法将3X3变换矩阵进行扩展，使它能处理平移，这将是</p>
<h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>在数学上，如果满足下式，那么映射F(a)就是线性的：<br>$F(a+b)=F(a)+F(b)$<br>以及<br>$F(ka)=kF(a)$<br>如果映射F保持了基本运算：加法和数量乘，那么就可以称该映射为线性的。在这种情况下，将两个向量相加然后再进行变换得到的结果和先分别进行变换再讲变换后的向量相加得到的结果相同。同样，将一个向量数量乘在进行变换和先进行变换在数量乘的结果也是一样的。</p>
<h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p>仿射变换是指线性变换后接着平移。因此，仿射变换的集合是线性变换的超集，任何线性变换都是仿射变换，但不是所有仿射变换都是线性变换。</p>
<h3 id="可逆变换"><a href="#可逆变换" class="headerlink" title="可逆变换"></a>可逆变换</h3><p>如果存在一个逆变换可以“撤销”原变换，那么该变换是可逆的。换句话说，如果存在可逆变换$F^-1$，使得$F^-1(F(a))=a$，对于任意$a$，映射$F(a)$是可逆的。</p>
<h3 id="等角变换"><a href="#等角变换" class="headerlink" title="等角变换"></a>等角变换</h3><p>如果变换前后两向量夹角的大小和方向都不改变，该变换是等角的。只有平移，旋转和均匀缩放是等角变换。等角变换将会保持比例不变。镜像并不是等角变换，因为尽管两向量夹角的大小不变，但夹角的方向改变了。所有等角变换都是仿射和可逆的。</p>
<h3 id="什么是欧拉角"><a href="#什么是欧拉角" class="headerlink" title="什么是欧拉角"></a>什么是欧拉角</h3><p>heading为绕y轴的旋转量，向右旋转为正。<br>pitch为绕x轴的旋转量，注意是物体坐标系的x轴，不是原惯性坐标系的x轴。依然遵守左手法则，向下旋转为正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/14/PBR-Guide-Vol1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/PBR-Guide-Vol1/" class="post-title-link" itemprop="url">【基于物理的渲染（PBR）白皮书】（一）开篇：PBR核心知识体系总结与概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-14 19:46:49" itemprop="dateCreated datePublished" datetime="2018-05-14T19:46:49+08:00">2018-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="光与物质"><a href="#光与物质" class="headerlink" title="光与物质"></a>光与物质</h3><p>光与物质：基于物理的渲染与着色理论<br>光是一种复杂的现象，它同时展现出波与粒子两种特性。于是，为了描述光的表现特性，人们建立了各种模型。<br>作为材质艺术家，我们感兴趣的是光线模型（Light Ray Model）因为它描述了光与物质的交互作用。<br>对我们来说，理解光线如何与物质表面交互非常重要，因为我们的工作是创作描述物体表面的材质。<br>我们创作出的纹理与材质再虚拟世界中与光交互，对光线表现特效理解的越多，创作出的材质就会更好。<br>再这篇指南中，我们会讨论物理理论，而基于物理的渲染(physically-based rendering)(PBR)模型正是建立在其上的。<br>我们从光线开始，逐步讲解PBR中的关键点。</p>
<h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><p>光线模型阐明，光线在均匀透明介质（如空气）中的轨迹为直线。光线模型同时也阐明，当光传播遇到表面是，例如遇到不透明物体或穿过不同介质如从空气折射入水中，光的表现是可预测的。这样，当光从一个起点传播到某点最终转换为其他形式例如热时，我们可以将它的轨迹视觉化。<br>击中一个表面的光线成为入射光，而它击中的角度称为入射角，如图01所示。<br>一条光线射入两个不同介质间的平面交界面。<br>先放出PBR知识体系的架构图：<br><img src="/2018/05/14/PBR-Guide-Vol1/1.jpg"></p>
<h1 id="系列文章前言"><a href="#系列文章前言" class="headerlink" title="系列文章前言"></a>系列文章前言</h1><p>基于物理的渲染（Physically Based Rendering，PBR）技术，自迪士尼SIGGRAPH 2012上提出了著名的“迪士尼原则的BRDF（Disney Principled BRDF）”之后，由于其高度的易用性以及方便的工作流，已经被电影和游戏业界广泛的使用。<br><a href="http://renderwonk.com/publications/s2010-shading-course/" target="_blank" rel="noopener">http://renderwonk.com/publications/s2010-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2012-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2012-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2013-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2013-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2014-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2014-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2015-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2015-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2016-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2016-shading-course/</a><br><a href="https://blog.selfshadow.com/publications/s2017-shading-course/" target="_blank" rel="noopener">https://blog.selfshadow.com/publications/s2017-shading-course/</a><br>《Physically Based Rendering:From Theory to Implementation,Third Edition》这本书专注离线渲染，实时渲染只能用到里面很少的一部分。<br><a href="http://www.pbr-book.org/3ed-2018/contents.html" target="_blank" rel="noopener">http://www.pbr-book.org/3ed-2018/contents.html</a><br>《Real-Time Rendering 4th》中PBR的相关章节<br>《Physically Based Shader Development for Unity》，主要是PBR在Unity引擎中的使用，而且是以Surface Shader的方式，准入门级，比较浅。</p>
<h1 id="PBR知识体系概览"><a href="#PBR知识体系概览" class="headerlink" title="PBR知识体系概览"></a>PBR知识体系概览</h1><p>这篇文章接下来的部分，是这个系列文件PBR知识体系的精华浓缩版。涉及八个部分的内容：</p>
<ul>
<li>核心PBR理论</li>
<li>渲染方程与BxDF</li>
<li>迪士尼原则的BxDF（Disney Principled BxDF）</li>
<li>漫反射BRDF模型（Diffuse BRDF）</li>
<li>镜面反射BRDF模型（Specular BRDF）</li>
<li>基于物理的环境光照（Physically Based Environment Lighting）</li>
<li>离线渲染相关（Offline Rendering Related）</li>
<li>进阶渲染主题（Advanced Rendering Topics）</li>
</ul>
<h1 id="PBR核心理论与渲染原理"><a href="#PBR核心理论与渲染原理" class="headerlink" title="PBR核心理论与渲染原理"></a>PBR核心理论与渲染原理</h1><p>PBR核心知识体系的第一部分自然是PBR的核心理论以及相关的渲染原理。</p>
<img src="/2018/05/14/PBR-Guide-Vol1/2.jpg">
<p>基于物理的渲染（Physically Based Rendering，PBR）是指使用基于物理原理和微平面理论建模的着色/光照模型，以及使用从现实中测量的表面参数来准确表示真实世界材质的渲染理念。<br><img src="/2018/05/14/PBR-Guide-Vol1/3.jpg"><br>以下是对PBR基础理念的概括：</p>
<ul>
<li>微平面理论（Microfacet Theory）。微平面理论是将物体表面建模成无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。在实际的PBR工作流中，这种物体表面的不规则性用粗糙度贴图或者高光贴图来表示。</li>
<li>能量守恒（Energy Conservation）。出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。</li>
<li>菲涅尔反射（Fresnel Reflectance）。光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0是即0度角入射的菲涅尔反射。大多数非金属的F0范围是0.02~0.04，大多数金属的F0范围是0.7~1.0。</li>
<li>线性空间（Liner Space）。光照计算必须在线性空间完成，shader中输入的gamma空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。</li>
<li>色调映射（Tone Mapping）。也称色调复制（tone reproduction），是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于HDR渲染出来的亮度值会超过显示器能够现实最大亮度，所以需要使用色调映射，将光照结果从HDR转换微显示器能够正常显示的LDR。</li>
<li>物质的光学特性（Substance Optical Properties）。现实世界中有不同类型的物质可分为三大类：绝缘体（Insulators），半导体（semi-conductors）和导体（conductors）。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色/灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。即非金属的F0是一个float。而金属的F0是一个float3，如下图。<img src="/2018/05/14/PBR-Guide-Vol1/4.jpg" title="金属和非金属材质的F0范围">
</li>
</ul>
<h2 id="光与非光学平坦表面的交互原理"><a href="#光与非光学平坦表面的交互原理" class="headerlink" title="光与非光学平坦表面的交互原理"></a>光与非光学平坦表面的交互原理</h2><p>光在与非光学平坦表面（Non-Optically-Flat Surfaces）的交互时，非光学平坦表面表现得像一个微小的光学平面表面的大集合。表面上的每个点都会以略微不同的方向对入射光反射，而最终的表面外观是许多具有不同表面取向的点的聚合结果。<br><img src="/2018/05/14/PBR-Guide-Vol1/5.jpg" title="来自非光学平坦表面的可见光反射是来自具有不同方向的许多表面点的反射的总体结果"><br>在微观尺度上，表面越粗糙，反射越模糊，因为表面取向与整个宏观表面取向的偏离更强。<br><img src="/2018/05/14/PBR-Guide-Vol1/6.jpg"><br>图片顶部所示的表面，表面相对光滑；表面取向仅略有变化，从而产生更清晰的反射。图片底部所示的表面较粗糙；表面上的不同点具有广泛变化的方向取向，导致反射光方向的高度变化，并因此导致模糊的反射。注意，两个表面在肉眼可见尺度下看起来是光滑的，粗糙度差异仅在微观尺度上。<br>出于着色的目的，我们通常会去用统计方法处理这种微观几何现象，并将表面视为在每个点处在多个方向上反射（和折射）光。<br><img src="/2018/05/14/PBR-Guide-Vol1/7.jpg" title="从宏观上看，非光学平面可以被视为多个方向上反射（和折射）光"><br>从表面反射的光的行为很好理解，那么，从表面折射的光会发生什么变化？这取决于对象本身的特性：</p>
<ul>
<li>对于金属，折射会立刻被吸收-能量被自由电子立即吸收。</li>
<li>对于非金属（也成为电介质或绝缘体），一旦光在其内部折射，就表现为常规的参与介质，表现出吸收和散射两种行为。</li>
</ul>
<img src="/2018/05/14/PBR-Guide-Vol1/8.jpg" title="在金属中，所有折射的光能立即被自由电子吸收">
<img src="/2018/05/14/PBR-Guide-Vol1/9.jpg" title="在非金属中，折射的光会进行散射，直到从表面重新射出，而这通常会在经过部分吸收之后">
<h2 id="漫反射和次表面散射本质相同"><a href="#漫反射和次表面散射本质相同" class="headerlink" title="漫反射和次表面散射本质相同"></a>漫反射和次表面散射本质相同</h2><p>另外，漫反射和次表面散射其实是相同的物理现象，本质都是折射光的次表面散射的结果。唯一的区别是相对于观察尺度的散射距离。散射距离相较于像素来说微不足道，次表面散射便可以近似为漫反射。也就是说，光的折射现象，建模为漫反射还是次表面散射，取决于观察的尺度，如下图。<br><img src="/2018/05/14/PBR-Guide-Vol1/10.jpg"><br>在左上角，像素（带有红色边框的绿色圆形）大于光想离开表面之前所经过的距离。在这种情况下，可以假设出射光从入口点（右上）射出，可以当作漫反射，用局部着色模型处理。在底部，像素小于散射距离；如果需要更真实的着色效果，则不能忽略这些距离的存在，需当作次表面散射现象进行处理。</p>
<h2 id="一、PBR的范畴（Scope-of-PBR）"><a href="#一、PBR的范畴（Scope-of-PBR）" class="headerlink" title="一、PBR的范畴（Scope of PBR）"></a>一、PBR的范畴（Scope of PBR）</h2><p>寒霜（Frostbite）引擎在SIGGRAPH 2014的分享《Moving Frostbite to PBR》中提出，基于物理的渲染的范畴，由三部分组成：</p>
<ul>
<li>基于物理的材质（Material）</li>
<li>基于物理的光照（Lighting）</li>
<li>基于物理适配的摄像机（Camera）<img src="/2018/05/14/PBR-Guide-Vol1/11.jpg">
完整的这三者，才是真正完整的基于物理的渲染系统。而很多同学一提到PBR，就说PBR就是镜面反射采用微平面Cook-Torrance模型，其实是不太严谨的。<h2 id="二、渲染方程与BxDF"><a href="#二、渲染方程与BxDF" class="headerlink" title="二、渲染方程与BxDF"></a>二、渲染方程与BxDF</h2>PBR核心知识体系的第二部分是渲染方程与BxDF。渲染方程作为渲染领域中的重要理论，将BxDF代入渲染方程是求解渲染问题的一般方法。<img src="/2018/05/14/PBR-Guide-Vol1/12.jpg">
<h3 id="2-1渲染方程与反射方程"><a href="#2-1渲染方程与反射方程" class="headerlink" title="2.1渲染方程与反射方程"></a>2.1渲染方程与反射方程</h3>渲染方程（The Rendering Equation）作为渲染领域中的重要理论，其描述了光能在场景中的流动，是渲染中不可感知方面的最抽象的正式表示。根据光学的物理学原理，渲染方程在理论上给出了一个完美的结果，而各种各样的渲染技术，知识这个理想结果的一个近似。</li>
</ul>
<p>渲染方程的物理基础是能量守恒定律。在一个特定的位置和方向，出射光$L_o$是自发光$L_e$与反射光线之和，反射光线本身是各个方向的入射光Li之和诚意表面反射率及入射角。</p>
<p>这个方程金国交叉点将出射光线与入射光线联系在一起，它代表了场景中全部的光线传输。所有更加完善的算法都可以看作是这个方程的特殊形式的解。</p>
<p>某一点p的渲染方程，可以表示为：<br>$L<em>o=L_e + $<font size="5">$\int</font></em>\Omega $&lt;/font&gt;${f_r\cdot L_i \cdot (w_i\cdot n)\cdot dw_i}$<br>其中：</p>
<ul>
<li>$L_o$是p点的出射光亮度。</li>
<li>$L_e$是p点的发出的光亮度。</li>
<li>$f_r$是p点入射方向到出射方向光的反射比例，即BxDF，一般为BRDF。</li>
<li>$L_i$是p点入射光亮度。</li>
<li>$(w_i\cdot n)$是入射角带来的入射光衰减。</li>
<li><font size="5">$\int_\Omega $</font>$…dw_i$是入射方向半球积分（可以理解为无穷小的累加和）。</li>
</ul>
<img src="/2018/05/14/PBR-Guide-Vol1/13.jpg">
<p>而在实时渲染中，我们常用的反射方程（The Reflctance Equation），则是渲染方程的简化的版本，或者说是一个特例：<br>$L<em>o=L_e + $<font size="5">$\int</font></em>\Omega $&lt;/font&gt;${f_r\cdot L_i \cdot (w_i\cdot n)\cdot dw_i}$<br>同样，其中：</p>
<ul>
<li>$L_o$是p点的出射光亮度。</li>
<li>$f_r$是p点入射方向到出射方向光的反射比例，即BxDF，一般为BRDF。</li>
<li>$L_i$是p点入射光亮度。</li>
<li>$(w_i\cdot n)$是入射角带来的入射光衰减。</li>
<li><font size="5">$\int_\Omega $</font>$…dw_i$是入射方向半球积分（可以理解为无穷小的累加和）。</li>
</ul>
<h2 id="2-2-BxDF"><a href="#2-2-BxDF" class="headerlink" title="2.2 BxDF"></a>2.2 BxDF</h2><p>BxDF一般而言是对BRDF、BTDF、BSDF、BSSRDF等几种双向反射分布函数的一个统一的表示。<br>其中，BSDF可以看作BRDF和BTDF更一般的形式，而且BSDF=BRDF+BTDF。<br>而BSSRDF和BRDF的不同之处在于，BSSRDF可以指定不同的光线入射位置和出射位置。<br>在上述这些BxDF中，BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。<br><img src="/2018/05/14/PBR-Guide-Vol1/14.jpg" title="BSDF:BRDF+BTDF"><br>我们时常讨论的PBR中的BxDF，一般都为BRDF，对于进阶的一些材质的渲染，才会讨论BSDF等其它三种BxDF。<br>另外，BxDF即上文所示渲染方程以及反射方程中的$f_r$项。</p>
<h2 id="2-3-BRDF的分类"><a href="#2-3-BRDF的分类" class="headerlink" title="2.3 BRDF的分类"></a>2.3 BRDF的分类</h2><img src="/2018/05/14/PBR-Guide-Vol1/15.jpg">
<h1 id="三、迪士尼原则的BxDF（Disney-Principled-BxDF）"><a href="#三、迪士尼原则的BxDF（Disney-Principled-BxDF）" class="headerlink" title="三、迪士尼原则的BxDF（Disney Principled BxDF）"></a>三、迪士尼原则的BxDF（Disney Principled BxDF）</h1><p>PBR核心知识体系的第三部分是迪士尼原则的BxDF。迪士尼动画工作室在SIGGRAPH 2012上著名的talk《Physically-based shading at Disney》中提出了迪士尼原则的BRDF（Disney Principled BRDF）,奠定了后续游戏行业和电影行业PBR的方向和标准。了解Disney Principled BxDF，是深入理解PBR的重要一环。<br><img src="/2018/05/14/PBR-Guide-Vol1/16.jpg"><br>基于物理的渲染，其实早在20世纪就已经在图形学业界有了一些套路怒，2010年在SIGGRAPH上就已经有公开讨论的Course《SIGGRAPH 2010 Course:Physically-Based Shading Models in File and Game Production》，而直到2012~2013年，才正式进入大宗的视野，渐渐被电影和游戏业界广泛使用。</p>
<p>迪士尼动画工作室则是这次PBR革命的重要推动者。迪士尼的Brent Burley与SIGGRAPH 2012上进行了著名的talk《Physically-based shading at Disney》，提出了迪士尼原则的BRDF（Disney Principled BRDF），由于其高度的通用性，将材质复杂的物理属性，用非常直观的少量变量表达了出来（如金属度metallic和粗糙度roughness），在电影业界和游戏业界引起了不小的轰动。从此，基于物理的渲染正式进入大众的视野。<br><img src="/2018/05/14/PBR-Guide-Vol1/17.jpg" title="SIGGRAPH 2012 《Physically-based shading at Disney》"></p>
<p>在2012年受到Diney的启发后，以下是主流游戏引擎从传统渲染转移到基于物理的渲染时间节点：</p>
<ul>
<li>[SIGGRAPH 2013]UE4 : [Real shading in unreal engine 4]</li>
<li>[SIGGRAPH 2014] Frostbite （寒霜）:[Moving Frostbite to PBR]</li>
<li>[GDC 2014] Unity : [Physically Based Shading in Unity]</li>
</ul>
<h2 id="3-1-迪士尼原则的BRDF（Disney-Principled-BRDF）"><a href="#3-1-迪士尼原则的BRDF（Disney-Principled-BRDF）" class="headerlink" title="3.1 迪士尼原则的BRDF（Disney Principled BRDF）"></a>3.1 迪士尼原则的BRDF（Disney Principled BRDF）</h2><h3 id="3-1-1-Disney-Principled-BRDF核心理念"><a href="#3-1-1-Disney-Principled-BRDF核心理念" class="headerlink" title="3.1.1 Disney Principled BRDF核心理念"></a>3.1.1 Disney Principled BRDF核心理念</h3><p>在2012年迪士尼原则的BRDF被提出之前，基于物理的渲染都需要大量复杂而不直观的参数，此时PBR的优势，并没有那么明显。</p>
<p>在2012年迪士尼提出，他们的着色模型是艺术导向（Art Directable）的，而不一定要是完全物理正确（physically correct）的，并且对为平面BRDF的各项都进行了严谨的调查，并提出了清晰明确而简单的解决方案。</p>
<p>迪士尼的理念是开发一种“原则性”的易用模型，而不是严格的物理模型。正因为这种艺术导向的易用性，能让美术同学非常直观的使用少量参数，以及非常标准化的工作流，就能快速实现涉及大量不同材质的真实感的渲染工作。而这对于传统的着色模型来说，是不可能完成的任务。</p>
<p>迪士尼原则的BRDF（Disney Principled BRDF）核心理念如下：</p>
<ol>
<li>应使用直观的参数，而不是物理类的晦涩参数。</li>
<li>参数应尽可能少。</li>
<li>参数在其合理范围内应该为0到1。</li>
<li>允许参数在有意义时超出正常的合理范围。</li>
<li>所有参数组合应尽可能健壮和合理。</li>
</ol>
<p>以上五条原则，很好地保证了迪士尼原则的BRDF的易用性。</p>
<h3 id="3-1-2-Disney-Principled-BRDF参数"><a href="#3-1-2-Disney-Principled-BRDF参数" class="headerlink" title="3.1.2 Disney Principled BRDF参数"></a>3.1.2 Disney Principled BRDF参数</h3><p>以上理念为基础，迪士尼动画工作室对每个参数的添加进行了把关，最终得到了颜色参数（baseColor）和下面描述的是个标量参数：</p>
<ul>
<li><strong>baseColor（基础色）</strong>：表面颜色，通常由纹理贴图提供。</li>
<li><strong>subsurface（次表面）</strong>：使用次表面近似控制漫反射形状。</li>
<li><strong>metallic（金属度）</strong>：金属（0=电介质，1=金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色着色入射镜面反射。</li>
<li><strong>specular（镜面反射强度）</strong>：入射镜面反射两。用于取代折射率。</li>
<li><strong>specularTint（镜面反射颜色）</strong>：对美术控制的让步，用于对基础色（base color）的入射镜面反射进行颜色控制。掠射镜面反射仍然时非彩色的。</li>
<li><strong>roughness（粗糙度）</strong>：表面粗糙度，控制漫反射和镜面反射。</li>
<li><strong>anisotropic（各向异性强度）</strong>：各向异性强度。用于控制镜面反射高光的纵横比。（0=各向同性，1=最大各向异性）</li>
<li><strong>sheen（光泽度）</strong>：一种额外的掠射分量（grazing component），主要用于布料。</li>
<li><strong>sheenTine（光泽颜色）</strong>：对sheen（光泽度）的颜色控制。</li>
<li><strong>clearcoat（清漆强度）</strong>：有特殊用途的第二个镜面波瓣（specular lobe）。</li>
<li><strong>clearcoatGloss（清漆光泽度）</strong>：控制透明涂层光泽度，0=“缎面（satin）”外观，1=“光泽（gloss）”外观。</li>
</ul>
<p>每个参数的效果的渲染示例如下图所示。<br><img src="/2018/05/14/PBR-Guide-Vol1/18.jpg" title="Disney Principled BRDF，每行的参数从0到1变化，其他参数保持不变"></p>
<h2 id="3-2-迪士尼原则的BSDF（Disney-Principled-BSDF）"><a href="#3-2-迪士尼原则的BSDF（Disney-Principled-BSDF）" class="headerlink" title="3.2 迪士尼原则的BSDF（Disney Principled BSDF）"></a>3.2 迪士尼原则的BSDF（Disney Principled BSDF）</h2><p>随后的2015年，迪士尼动画工作室在Disney Principled BRDF的基础上进行了修订，提出了Disney Principled BSDF [Extenting the Disney BRDF to a BSDF with Integrated Subsurface Scattering,2015]</p>
<p>以下是开源三维动画软件Blender实现的Disney Principled BSDF的图示：<br><img src="/2018/05/14/PBR-Guide-Vol1/19.jpg" title="Disney Principled BSDF"></p>
<h1 id="四、漫反射BRDF模型（Diffuse-BRDF）"><a href="#四、漫反射BRDF模型（Diffuse-BRDF）" class="headerlink" title="四、漫反射BRDF模型（Diffuse BRDF）"></a>四、漫反射BRDF模型（Diffuse BRDF）</h1><p>为了求解渲染方程，需要分别求解Diffuse BRDF和Specular BRDF。所以PBR核心知识体系的第四部分是Diffuse BRDF。<br><img src="/2018/05/14/PBR-Guide-Vol1/20.jpg"><br>Diffuse BRDF可以分为传统型和基于物理型两大类。其中，传统型主要是总所周知的Lambert。<br>而基于物理型，从1994年的Oren Nayar开始，这里一直统计到今年（2019年）。<br>其中较新的有GDC 2017上提出的适用于GGX+Smith的基于物理的漫反射模型（PBR diffuse for GGX+Smith），也包含了最近在SIGGRAPH2018上提出的，来自《使命召唤：二战》的多散射漫反射BRDF（MultiScattrering Diffuse BRDF）：</p>
<ul>
<li>Oren Nayar[1994]</li>
<li>Simplified Oren-Nayar[2012]</li>
<li>Disney Diffuse[2012]</li>
<li>Renormalized Disney Diffuse[2014]</li>
<li>Gotanda Diffuse[2014]</li>
<li>PBR diffuse for GGX+Smith[2017]</li>
<li>MultiScattrering Diffuse BRDF[2018]</li>
</ul>
<h1 id="五、镜面反射BRDF模型（Specular-BRDF）"><a href="#五、镜面反射BRDF模型（Specular-BRDF）" class="headerlink" title="五、镜面反射BRDF模型（Specular BRDF）"></a>五、镜面反射BRDF模型（Specular BRDF）</h1><p>PBR核心知识提醒的第五部分是Specular BRDF。这也是基于物理的渲染领域中最活跃，最主要的部分。<br><img src="/2018/05/14/PBR-Guide-Vol1/21.jpg"><br>上图中加粗部分为目前业界较为主流的模型。</p>
<p>游戏业界目前最主流的基于物理的镜面反射BRDF模型是基于微平面理论（microfacet theory）的Microfacet Cook-Torrance BRDF。</p>
<p>而微平面理论（microfacet theory）源自将微观几何（microgeometry）建模为微平面（microfacets）的集合思想，一般用于描述来自非光学平坦（non-optically flat）表面的表面反射。</p>
<p>微平面理论的基本假设是微观几何（microgeometry）的存在，微观几何的尺度小于观察尺度（例如着色分辨率），但大于可见光波长的尺度（因此应用几何光学如衍射一样的波效应等可以忽略）。且微平面理论在2013年和以前时仅用于推导单反射（single-bounce）表面反射的表达式；而随着领域的深入，最近几年也出现了使用microfacet理论对多次反弹表面的一些探讨。</p>
<p>由于假设微观几何尺度明显大于可见光波长，因此可以将每个表面点视为光学平坦的。如上文所述，光学平坦表面将光线分成两个方向：反射和折射。</p>
<p>每个表面点将来自给定进入方向的光反射到单个出射方向，该方向取决于微观几何法线（microgeometry normal）m的方向。在计算BRDF项时，指定光方向I和视图方向<strong>v</strong>。这意味着所有表面点，只有那些恰好正确朝向可以将<strong>I</strong>反射到<strong>v</strong>的那些小平面可能有助于BRDF值（其他方向有正有负，积分之后，相互抵消）。</p>
<p>在下图中，我们可以看到这些“正确朝向”的表面点的表面法线<strong>m</strong>正好位于<strong>I</strong>和<strong>v</strong>之间的中间位置。<strong>I</strong>和<strong>v</strong>之间的矢量成为半矢量（half-vector）或半角矢量（half-angle vector）；我们将其表示为<strong>h</strong>。<br><img src="/2018/05/14/PBR-Guide-Vol1/22.jpg" title="仅m=h的表面点的朝向才会将光线I反射到视线v的方向，其他表面点对BRDF没有贡献。"></p>
<p>并非所有的<strong>m = h</strong>的表面点都会积极地对反射做出共享；一个被<strong>I</strong>方向（阴影shadowing），v方向（掩蔽masking）或两者的其他表面区域阻挡。Microfacet理论假设所有被遮蔽的光（shadowed light）都从镜面反射项中消失；实际上，由于多次表面反射，其中一些最终将是可见的，但这在目前常见的微平面理论中一般并未去考虑，各种类型的光表面相互作用如下图所示。<br><img src="/2018/05/14/PBR-Guide-Vol1/23.jpg"><br>上图在左侧，我们看到一些表面点从I的方向被遮挡，因为它们被遮挡并且不接受光（因此它们不能反射任何）。在中间，我们看到从视图方向v看不到一些表面点，因此当然不会看到从它们反射的任何光。在这两种情况下，这些表面点对BRDF没有共享。实际上，虽然阴影区域没有接受从I接受任何直射光，但它们确实接受（并因此反射）从其他表面区域反射的光（如右图所示）。microfacet理论忽略了这些互相反射。</p>
<h2 id="5-1-从物理现象到BRDF"><a href="#5-1-从物理现象到BRDF" class="headerlink" title="5.1 从物理现象到BRDF"></a>5.1 从物理现象到BRDF</h2><p>利用这些假设（局部光学平坦表面，没有相互反射），可以很容易推导出一个被成为Microfacet Cook-Torrnace BRDF的一般形式的Specular BRDF项。此Specular BRDF具有以下形式：</p>
<p>$f(l,v)={D(h)F(v,h)G(l,v,h)\over 4(n\cdot l)(n \cdot v)}$</p>
<p>其中：</p>
<ul>
<li><strong>D(h)</strong>:法线分布函数（Normal Distribution Function），描述微面元发现分布的概率，即正确朝向的发现的浓度。即具有正确朝向，能够将来自<strong>I</strong>的光反射到v的表面点的相对于表面面积的浓度。</li>
<li><strong>F(I,h)</strong>:菲涅尔方程（Fresnel Equation），描述不同的表面角下表面所反射的光线所占的比率。</li>
<li><strong>G(l,v,h)</strong>:几何函数（Geometry Function），描述微平面自成阴影的属性，即m=h的未被遮蔽的表面点的百分比。</li>
<li><strong>分母4(n\cdot l)(n \cdot v)</strong>:校正因子（correctionfactor），作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。</li>
</ul>
<p>关于Cook-Torrance BRDF，需要强调的两点注意事项：</p>
<ul>
<li>对于分母中的点击，仅仅避免负值时不够的，也必须避免零值。通常通过在常规的clamp或绝对值操作之后添加非常小的正值来完成。</li>
<li><strong>Microfacet Cook-Torrance BRDF是实践中使用最广泛的模型，实际上也是人们可以想到的最简单的微平面模型。它仅对几何光学系统中的单层为表面上的单个散射进行建模，没有考虑多次散射，分层材质，以及衍射。Microfacet模型，实际上还有很长的路要走。</strong></li>
</ul>
<p>下面对Microfacet Cook-Torrance BRDF中的D、F、G项分别进行简单说明。</p>
<h2 id="5-2-Specular-D"><a href="#5-2-Specular-D" class="headerlink" title="5.2 Specular D"></a>5.2 Specular D</h2><p>法线分布函数（Normal Distribution Function, NDF）D的常见模型可以总结如下：</p>
<ul>
<li>Beckmann[1963]</li>
<li>Blinn-Phong[1977]</li>
<li>GGX[2007]/Trowbridge-Reitz[1975]</li>
<li>Generalized-Trowbridge-Reitz(GTR)[2012]</li>
<li>Anisotropic Beckmann[2012]</li>
<li>Anisotropic GGX[20115]</li>
</ul>
<p>其中，业界较为主流的法线分布函数是GGX（Trowbridge-Reitz），因为具有更好的高光长尾：</p>
<font size="5">$D_{GGX} = {\alpha \over (\pi(n \cdot m)^2(\alpha^2 - 1) + 1)^2}$</font>

<img src="/2018/05/14/PBR-Guide-Vol1/24.jpg">
<p>另外，需要强调一点。<strong>Normal Distribution Function</strong>正确的翻译是法线分布函数，而不是正太分布函数。google翻译等翻译软件会将Normal Distribution Function翻译成正态分布函数，而不少中文资料就跟着翻译成正态分布函数，这是错误的。</p>
<p>其实，一些参考文献会使用术语“法线分布（distribution of normals）”来避免与高斯正太分布(Gaussian normal distribution)混淆。</p>
<h2 id="5-3-Specular-F"><a href="#5-3-Specular-F" class="headerlink" title="5.3 Specular F"></a>5.3 Specular F</h2><p>对于菲涅尔（Fresnel）项，业界方案一般都采用Schlick的Fresnel近似，因为计算成本低廉，而且精度足够：</p>
<p>$F_{Schlick}(v,h)=F_0 + (1 - F_0)(1 - (v \cdot h))^5$</p>
<p>菲涅尔项的常见模型可以总结如下：</p>
<ul>
<li>Cook-Torrance[1982]</li>
<li>Schlick[1994]</li>
<li>Gotanta[2014]</li>
</ul>
<h2 id="5-4-Specular-G"><a href="#5-4-Specular-G" class="headerlink" title="5.4 Specular G"></a>5.4 Specular G</h2><p>几何项G的常见模型可以总结如下：</p>
<ul>
<li>Smith[1967]</li>
<li>Cook-Torrance[1982]</li>
<li>Neumann[1999]</li>
<li>Kelemen[2001]</li>
<li>Implicit[2013]</li>
</ul>
<p>另外，Eric Heitz在[Heitz14]中展示了Smith几何阴影函数是正确且更准确的G项，并将其扩展为Smith联合遮蔽函数(Smith Joint Masking-Shadowing Function)，该函数具有四种形式：</p>
<ul>
<li>分离遮蔽阴影型（Separable Masking and Shadowing）</li>
<li>高度相关遮蔽阴影型（Height-Correlated Masking and Shadowing）</li>
<li>方向相关遮蔽阴影型（Direction-Correlated Masking and Shadowing）</li>
<li>高度-方向相关遮蔽阴影型（Height-Direction-Correlated Masking and Shadowing）</li>
</ul>
<p>目前较为常用的是最为简单的形式，分离遮蔽阴影（Separable Masking and Shadowing Function）。</p>
<p>该形式将几何项G分为两个独立的部分：光线方向（light）和视线方向（view），并对两者用相同的分布函数描述。根据这种思想，结合法线分布函数（NDF）与Smith几何阴影函数，于是有了以下新的Smith几何项：</p>
<ul>
<li>Smith-GGX</li>
<li>Smith-Beckmann</li>
<li>Smith-Schlick</li>
<li>Schlick-Beckmann</li>
<li>Schlick-GGx</li>
</ul>
<p>其中UE4的方案是上面列举中的”Schlick-GGX”，即基于Schlick近似，将K映射为$k = {\alpha \over 2}$，去匹配GGX Smith方程：</p>
<p>$k = {\alpha \over 2}$<br>$\alpha = roughness^2$<br>$G_1(v)={(n\cdot v)\over {(n\cdot v)(1-k)+k}}$<br>$G(l,v,h)=G_1(l)G_1(v)$</p>
<h1 id="六、基于物理的环境光照（Physically-Based-Environment-Lighting）"><a href="#六、基于物理的环境光照（Physically-Based-Environment-Lighting）" class="headerlink" title="六、基于物理的环境光照（Physically Based Environment Lighting）"></a>六、基于物理的环境光照（Physically Based Environment Lighting）</h1><p>有了直接光部分，我们也需要环境光。所以PBR核心知识体系的第六部分是基于物理的环境光照，一般大家也直接默认环境光照的技术方案是基于图像的光照（Image Based Lighting, IBL)。这也是真正让基于物理的渲染画质提升的主要贡献者。<br><img src="/2018/05/14/PBR-Guide-Vol1/25.jpg"><br>漫反射环境光照部分一般采用传统IBL中辉度环境映射（Irradiance Environment Mapping）技术，并不是基于物理的特有方案，这里暂不讨论。</p>
<p>而基于物理的镜面反射（Specular）环境光照，业界中一般会采用基于图像的光照（IBL）的方案。要将基于物理的BRDF模型与基于图像的光照（IBL）一起使用，需要求解光照亮度积分（Radiance Integral），而求解光亮度积分通常会使用重要性采样（Importance Sample）。</p>
<p>重要性采样（Importance Sample）即通过现有的一些已知条件（分布函数），想办法集中于被积函数分布可能性较高的区域（重要的区域）进行采样，进而可高效和准确的计算。</p>
<h2 id="6-1-分解求和近似（Split-Sum-Approximation）"><a href="#6-1-分解求和近似（Split-Sum-Approximation）" class="headerlink" title="6.1 分解求和近似（Split Sum Approximation）"></a>6.1 分解求和近似（Split Sum Approximation）</h2><p>基于重要性采样的思路，将蒙特卡洛积分公式代入渲染方程可得：<br><img src="/2018/05/14/PBR-Guide-Vol1/26.jpg"></p>
<p>$$</p>
<h3 id="6-3-1-流派1：2D-LUT"><a href="#6-3-1-流派1：2D-LUT" class="headerlink" title="6.3.1 流派1：2D LUT"></a>6.3.1 流派1：2D LUT</h3><p>UE4在[Real Shading in Unreal Engine 4,2013]中提出，第二个求和项，使用Schlick近似后，$F<em>0$可以从积分中分出来：<br>$\int</em>\Omega{L<em>i(l)f(l,v)cos\theta_l\cdot dl} = F_0\int</em>\Omega{f(l,v)\over F(v,h)}(1-(1-v\cdot h)^5)cos\theta<em>ldl+\int</em>\Omega{f(l,v)\over F(v,h)}(1-v\cdot h)^5cos\theta_ldl$<br>上式留下了两个输入(Roughness和$cos\theta$v)和两个输出(缩放和向$F_0$的偏差(a scale and bias to $F_0$))，即把上述方程看成是$F_0 \cdot Scale + Offset$的形式。我们预先计算此函数的结果并将其存储在2D查找纹理(LUT,look-up texture)中。<br><img src="/2018/05/14/PBR-Guide-Vol1/26.jpg"><br>这张红绿色的贴图，输入roughtness、$cos\theta$，输出环境BRDF镜面反射的强度。是关于roughness、$cos\theta$与环境BRDF镜面反射强度的固有映射关系。可以离线预计算。<br>具体的取出方式为：</p>
<p><font size="5">${1\over N}\sum<em>{k=1}^N {f(l_k,v)cos\theta</em>{l_k}\over p(l_k,v)}=LUT.r * F_0 + LUT.g$</font><br>即UE4是通过把Fresnel公式的F0提出来，组成F0*Scale+Offset的方式，再将Scale和Offset的索引存到一张2D LUT上。靠roughness和NdotV进行查找。</p>
<h3 id="6-3-2-流派2：解析拟合"><a href="#6-3-2-流派2：解析拟合" class="headerlink" title="6.3.2 流派2：解析拟合"></a>6.3.2 流派2：解析拟合</h3><p>COD: Black Ops 2的做法，是通过数学工具Mathematica(<a href="http://www.wolfram.com/mathematica/)中的数值积分拟合出曲线，即将UE4离线计算的这张2D" target="_blank" rel="noopener">http://www.wolfram.com/mathematica/)中的数值积分拟合出曲线，即将UE4离线计算的这张2D</a> LUT用如下函数进行了拟合：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">EnvironmentBRDF</span><span class="params">(<span class="keyword">float</span> g, <span class="keyword">float</span> NoV, float3 rf0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   float4 t = float4(<span class="number">1</span>/<span class="number">0.96</span>, <span class="number">0.475</span>, (<span class="number">0.0275</span> - <span class="number">0.25</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="七、离线渲染相关（Offline-Rendering-Related）"><a href="#七、离线渲染相关（Offline-Rendering-Related）" class="headerlink" title="七、离线渲染相关（Offline Rendering Related）"></a>七、离线渲染相关（Offline Rendering Related）</h1><p>虽然我们目前主要关注的是实时渲染（实时光栅图形学相关，暂时不关注实时光线追踪）领域，但很多时候，实时渲染也需要涉及到预计算，尤其是IBL相关的预计算，所以或多或少会用到离线渲染相关的知识。所以PBR核心知识体系的第七部分是离线渲染相关的主题。<br><img src="/2018/05/14/PBR-Guide-Vol1/27.jpg"><br>以下是与实时渲染结合相对紧密的离线渲染的核心主题以及概括总结（主要是统计学与概览相关）：</p>
<ul>
<li>重要性采样（Importance Sample）：蒙特卡洛积分的一种采样策略。思路是基于分布函数，尽量对被积函数分布可能性较高的区域进行采样。</li>
<li>多重要性采样（Muti Importance Sampling，MIS）：估算某一积分时，基于多个分布函数获取采样，并期望至少某一分布与被积函数形状适配。即根据各种技术对采样进行加权计算，进而消除近似于它的概览。即偶然中包含着某种必然。</li>
<li>蒙特卡洛方法（Monte Carlo Methods）：一种以概率统计理论为指导的数值计算方法。是指使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。</li>
<li>低偏差序列（Low-discrepancy sequence）：一种确定生成的超均匀分布列，也成为随机列、次随机列，常见低偏差序列有Hammersley，Halton等。</li>
<li>拟蒙特卡罗方法（Quasi-Monte Carlo Method）：使用低差异来进行数值积分和研究其它一些数值问题的方法。</li>
</ul>
<h1 id="八、进阶渲染主题（Advanced-Rendering-Topics）"><a href="#八、进阶渲染主题（Advanced-Rendering-Topics）" class="headerlink" title="八、进阶渲染主题（Advanced Rendering Topics）"></a>八、进阶渲染主题（Advanced Rendering Topics）</h1><p>前面的核心PBR主题都讨论完以后，会有更多进阶的内容浮出水面，它们共同组成了PBR核心知识体系的第八部分。<br><img src="/2018/05/14/PBR-Guide-Vol1/28.jpg"><br>以下是一个列举：</p>
<ul>
<li>进阶着色模型<ul>
<li>布料BRDF(Cloth BRDF)</li>
<li>清漆着色模型(Clear Coat Model)</li>
<li>次表面散射BRDF模型(Subsurface Scattering BRDF Model)</li>
</ul>
</li>
<li>进阶材质功能<ul>
<li>全能材质(Uber Shader)</li>
<li>分层材质(Layered Materials)</li>
<li>分层全能材质(Layered Uber Shader)</li>
<li>混合材质(Blending Material)</li>
<li>过滤材质(Filtering Materials)</li>
</ul>
</li>
<li>进阶理论<ul>
<li>物理光学(Physics of Light)</li>
<li>波动光学(Wave Optics)</li>
<li>基于物理的摄像机(Physical Based Camera)</li>
<li>基于物理的光源(Physical Based Light)</li>
<li>白炉测试(White Furnace Test)</li>
</ul>
</li>
<li>进阶BxDF<ul>
<li>BSDF</li>
<li>BTDF</li>
<li>BSSRDF</li>
</ul>
</li>
<li>进阶材质渲染<ul>
<li>皮肤渲染(Skin Rendering)</li>
<li>布料渲染(Cloth Rendering)</li>
<li>半透明表面渲染(Translucent Surfaces Rendering)</li>
<li>头发渲染(Hair Rendering)</li>
<li>毛发渲染(Fur Rendering)</li>
<li>车漆渲染(Car Paint Rendering)</li>
<li>水体渲染(Water Rendering)</li>
<li>湿润表面渲染(Wet Surface Rendering)</li>
<li>天空与大气渲染(Sky and Atmosphere Rendering)</li>
<li>薄表面材质渲染(Thin Surface Rendering)</li>
<li>体积渲染(Volumetric Rendering)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/05/14/d3d11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/d3d11/" class="post-title-link" itemprop="url">Direct3D 11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-14 08:50:27" itemprop="dateCreated datePublished" datetime="2018-05-14T08:50:27+08:00">2018-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>点积(dot product)计算结果是标量值；也叫标量积(scalar product)。等于两个向量对应分量的乘积之和。</li>
</ol>
<p>$\mathbf{u \cdot v} = u_xv_x+u_yv_y+u_zv_z$</p>
<h2 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a>4.1 准备工作</h2><h3 id="4-1-4-交换链和页面翻转"><a href="#4-1-4-交换链和页面翻转" class="headerlink" title="4.1.4 交换链和页面翻转"></a>4.1.4 交换链和页面翻转</h3><p>为了避免在动画中出现闪烁，最好的做法是在一个离屏（off-screen）纹理中执行所有的动画帧绘制工作，这个离屏纹理成为后台缓存区(back buffer)。当我们在后台缓冲区中完成给定帧的绘制工作后，便可以将后台缓冲区作为一个作为一个完整的帧显示在屏幕上；使用这种方法，用户不会感觉到帧的绘制过程，只会看到完整的帧。从理论上讲，将一帧显示到屏幕上所消耗的时间小于屏幕的垂直刷新时间。硬件会自动维护两个内置的纹理缓冲区来实现这一功能，这两个缓冲区分别成为前台缓冲区(front buffer)和后台缓冲区。前台缓冲区存储了当前显示在屏幕上的图像数据，而动画的下一帧会在后台缓冲区中执行绘制。当后台缓冲区的绘制工作完成之后，前后两个缓冲区的做哟个会发生翻转；后台缓冲区会变为前台huan’ch</p>
<h3 id="4-1-5-深度缓冲区"><a href="#4-1-5-深度缓冲区" class="headerlink" title="4.1.5 深度缓冲区"></a>4.1.5 深度缓冲区</h3><p><strong>深度缓冲区(depth buffer)</strong>是一个不包含图像数据的纹理对象。在一定程度上，深度信息可以被认为是一种特殊的像素。常见的深度值范围在0.0到1.0之间，其中0.0表示离观察者最近的物体，1.0表示离观察者最远的物体。深度缓冲区中的每个元素与后台缓冲区中的每个像素一一对那个（即，后台缓冲区的第ij个元素对应于深度缓冲区第ij个元素）。所以，当后台缓冲区的分辨率为1280x1024时，在深度缓冲区中有1280x1024个深度元素。</p>
<h3 id="4-1-6-纹理资源视图"><a href="#4-1-6-纹理资源视图" class="headerlink" title="4.1.6 纹理资源视图"></a>4.1.6 纹理资源视图</h3><p>纹理可以被绑定到<strong>渲染管线（rendering pipeline）</strong>的不同<strong>阶段(stage)</strong>;例如，比较常见的情况是将纹理作为渲染目标（即，Direct3D渲染到纹理）或着色器资源（即，在着色器中对纹理进行采样）。当创建用于这两种目的的纹理资源时，应使用绑定标记值：<br>    D3D11_BIND_RENDER_TARGET|D3D10_BIND_SHADER_RESOURCE<br>指定纹理所要绑定的两个管线阶段。其实，资源不能被直接绑定到一个管线阶段；我们只能把与资源关联的资源试图绑定到不同的管线阶段。无论以哪种方式使用纹理，Direct3D始终要求我们在初始化时为纹理创建相关的<strong>资源视图(resource view)</strong>。这样有助于提供运行效率，正如SDK文档指出的那样：“运行时环境与驱动程序可以在视图创建执行相应的验证和映射，减少绑定时的类型检查”。所以，当把纹理作为一个渲染目标和着色器资源时，我们要为它创建两种试图：<strong>渲染目标试图 (ID3D11RenderTargetView)</strong>和<strong>着色器资源视图 (ID3D11ShaderResourceView)</strong>。资源视图主要有两个功能：（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）；</p>
<h3 id="4-1-7-多重采样"><a href="#4-1-7-多重采样" class="headerlink" title="4.1.7 多重采样"></a>4.1.7 多重采样</h3><p>因为计算机显示器上的像素分辨率有限，所以当我们绘制一条任意直线时，该直线很难精确地显示在屏幕上。<br>当无法提高显示器的分辨率，缩小像素尺寸，也可以有效地缓解这一问题，使阶梯效应明显降低。<br>当无法提高显示器分辨率或分辨率不够高时，我们可以使用<strong>抗锯齿 (antialiasing)技术</strong>。其中的一种技术叫做<strong>超级采样（supersampling）</strong>，它把后台缓冲和深度缓冲的大小提高到屏幕分辨率的4倍。</p>
<h3 id="4-1-8-Direct3D中的多重采样"><a href="#4-1-8-Direct3D中的多重采样" class="headerlink" title="4.1.8 Direct3D中的多重采样"></a>4.1.8 Direct3D中的多重采样</h3><h2 id="4-2-对Direct3D进行初始化"><a href="#4-2-对Direct3D进行初始化" class="headerlink" title="4.2 对Direct3D进行初始化"></a>4.2 对Direct3D进行初始化</h2><ol>
<li>ID3D11Device接口用于检测显示适配器功能和分配资源。</li>
<li>ID3D11DeviceContext接口用于设置管线状态、将资源绑定到图形管线和生成渲染命令。</li>
</ol>
<h3 id="4-2-2-检测4X多重采样质量支持"><a href="#4-2-2-检测4X多重采样质量支持" class="headerlink" title="4.2.2 检测4X多重采样质量支持"></a>4.2.2 检测4X多重采样质量支持</h3><p>创建了设备后，我们就可以检查4X多重采样质量等级了。所有支持Direct3D 11的设备都支持所有渲染目标格式的4X MSAA（支持的质量等级可能并不相同）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UINT m4xMsaaQuality;</span><br><span class="line">HR(md3dDevice-&gt;CheckMultisampleQualityLevels(DXGI_FORMAT_R8G8B8AB_UNORM, <span class="number">4</span>, &amp;m4xMassQuality));</span><br><span class="line">assert(m4xMsaaQuality&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>因为4X MSAA总是被支持的，所以返回的质量等级总是大于0。</p>
<h3 id="4-2-3-描述交换链"><a href="#4-2-3-描述交换链" class="headerlink" title="4.2.3 描述交换链"></a>4.2.3 描述交换链</h3><p>下一步是创建交换链，首先需要填充一个DXGI_SWAP_CHAIN_DESC结构体来描述我们将要创建的交换链的特性。该结构体的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_SWAP_CHAIN_DESC</span>&#123;</span></span><br><span class="line">    DXGI_MODE_DESC BufferDesc;</span><br><span class="line">    DXGI_SAMPLE_DESC SampleDesc;</span><br><span class="line">    DXGI_USAGE BufferUsage;</span><br><span class="line">    UINT BufferCount;</span><br><span class="line">    HWND OutputWindow;</span><br><span class="line">    BOOL Windowed;</span><br><span class="line">    DXGI_SWAP_EFFECT SwapEffect;</span><br><span class="line">    UINT Flags;</span><br><span class="line">&#125;DXGI_SWAP_CHAIN_DESC;</span><br></pre></td></tr></table></figure></p>
<p><strong>DXGI_MODE_DESC</strong>类型是另一个结构体，其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_MODE_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT Width;					<span class="comment">// 后台缓冲区宽度</span></span><br><span class="line">    UINT Height;				<span class="comment">// 后台缓冲区高度</span></span><br><span class="line">    DXGI_RATIONAL RefreshRate; 	<span class="comment">// 显示刷新率</span></span><br><span class="line">    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; <span class="comment">// display scanline mode</span></span><br><span class="line">    DXGI_MODE_SCALING Scaling; <span class="comment">// display scaling mode </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>在下面的数据成员描述中，我们只覆盖了一些常用的标记值和选项，它们对于初学者来说非常重要。对于其他标志值和选项的描述，请参阅SDK文档。</p>
<ol>
<li><strong>BufferDesc:</strong>该结构体描述了我们所要创建的后台缓冲区的属性。我们主要关注的属性有：宽度、高度和像素骼时；其他属性的详情请参阅SDK文档。</li>
<li><strong>SampleDesc:</strong></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
