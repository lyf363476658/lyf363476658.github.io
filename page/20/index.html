<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/20/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/22/Unity-Shader-IntrodutionToTopic-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/22/Unity-Shader-IntrodutionToTopic-2/" class="post-title-link" itemprop="url">Unity Shader第三部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-22 18:12:38" itemprop="dateCreated datePublished" datetime="2018-10-22T18:12:38+08:00">2018-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h1><p>透明是游戏中经常要使用的一种效果。在实时渲染中要实现透明效果，通常会在渲染模型时控制它的<strong>透明通道（Alpha Channel）</strong>。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有透明度。当透明度为1时，表示该像素是完全不透明的，而当其为0时，则表示该像素完全不会显示。<br>在Unity中，我们通常使用两种方法来实现透明效果：第一种是使用<strong>透明度测试（Alpha Test）</strong>，这种效果其实无法得到真正的半透明效果；另一种是<strong>透明度混合（Alpha Blending）</strong>。<br>在之前的学习中，我们从没有强调过渲染顺序的问题。也就是说，当场景中包含很多模型时，我们并没有考虑是先渲染A，在渲染B，最后在渲染C，还是按照其他的顺序来渲染。事实上，对于不透明（opaque）物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于强大的深度缓冲（depth buffer，也被称为z-buffer）的存在。在实时渲染中，深度缓冲是用于解决可见性（visibility）问题的，它可以决定哪个物体的哪些部分会被渲染在前面，而哪些部分会被其他物体遮挡。它的基本思想是：根据深度缓冲中的值来判断该片元距离摄像机的距离，当渲染一个片元时，需要把它的深度值和已经存在于深度缓冲中的值进行比较（如果开启了深度测试），如果它的值距离摄像机更远，那么说明这个片元不应该被渲染到屏幕上（有物体遮挡住了它）；否则，这个片元应该覆盖掉此时颜色缓冲中的像素值，并把它的深度值更新到深度缓冲中（如果开启了深度写入）。</p>
<h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>透明度混合的实现要比透明度测试复杂一些，这是因为我们在处理透明度测试时，实际上跟对待普通的不透明物体几乎是一样的，只是在片元着色器中增加了对透明度判断并裁剪片元的代码。而想要实现透明度混合就没这么简单了。我们回顾之前提到的透明度混合的原理。<br><strong>透明度混合：</strong>这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲区种的颜色进行混合，得到新的颜色。但是，<font color="red"><strong>透明度混合需要关闭深度写入</strong></font>，这使得我们要非常小心物体的渲染顺序。<br>为了进行混合，我们需要使用Unity提供的混合命令Blend。Blend是Unity提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲区种的颜色值进行混合，混合时使用的函数就是由该指令决定的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Blend Off</td>
<td>关闭混合</td>
</tr>
<tr>
<td>Blend SrcFactor DstFactor</td>
<td>开启混合，并设置混合因子。源颜色（该片元产生的颜色）会乘以SrcFactor，而目标颜色（已经存在于颜色缓存的颜色）会乘以DstFactor，然后把两者相加后在存入颜色缓冲中</td>
</tr>
<tr>
<td>Blend SrcFactor DstFactor, SrcFactorA DstFractorA</td>
<td>和上面一样，只是使用不同的因子来混合透明通道</td>
</tr>
<tr>
<td>BlendOp BlendOperation</td>
<td>并非是把源颜色和目标颜色简单相加后混合，而是使用BlendOperation对它们进行其他操作</td>
</tr>
</tbody>
</table>
</div>
<p>我们介绍第二种语义，即Blend SrcFactor DstFactor来进行混合。需要注意的是，这个命令在设置混合因子的同时也开启了混合模式。这是因为，只有开启了混合之后，设置片元的透明通道才有意义，而Unity在我们使用Blend命令的时候就自动帮我们打开了。很多初学者抱怨为什么自己的模型没有任何透明效果，这往往是因为他们没有在Pass中使用Blend命令，一方面是没有设置混合因子，更重要的是没有打开混合模式。我们会把源颜色的混合因子SrcFactor设为SrcAlpha，而目标颜色的混合因子DstFactor设为OneMinusSrcAlpha。这意味着，经过混合后新的颜色是：</p>
<p>$DstColor<em>{new} = SrcAlpha<em>SrcColor+(1-SrcAlpha)</em>DstColor</em>{old}$</p>
<h3 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h3><h3 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a>ShaderLab的混合命令</h3><h4 id="混合等式和参数"><a href="#混合等式和参数" class="headerlink" title="混合等式和参数"></a>混合等式和参数</h4><h4 id="混合操作"><a href="#混合操作" class="headerlink" title="混合操作"></a>混合操作</h4><h4 id="常见和混合类型"><a href="#常见和混合类型" class="headerlink" title="常见和混合类型"></a>常见和混合类型</h4><h3 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h3><h4 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h4><h4 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h4><h2 id="渲染路径Rendering-Path"><a href="#渲染路径Rendering-Path" class="headerlink" title="渲染路径Rendering Path"></a>渲染路径Rendering Path</h2><div class="table-container">
<table>
<thead>
<tr>
<th>LightMode</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Always</td>
<td>不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照</td>
</tr>
<tr>
<td>ForwardBase</td>
<td>用于前向渲染。该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps</td>
</tr>
<tr>
<td>ForwardAdd</td>
<td>用于前向渲染。该Pass会计算额外的逐像素光源，每个Pass对应一个光源</td>
</tr>
<tr>
<td>Deferred</td>
<td>用于延迟渲染。该Pass会渲染G缓冲（G-buffer）</td>
</tr>
<tr>
<td>ShadowCaster</td>
<td>把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中</td>
</tr>
<tr>
<td>PrepassBase</td>
<td>用于遗留的延迟渲染。该Pass会渲染法线和高光反射的指数部分</td>
</tr>
<tr>
<td>PrepassFinal</td>
<td>用于遗留的延迟渲染。该Pass通过合并纹理、光照和自发光来渲染得到最后的颜色</td>
</tr>
<tr>
<td>Vertex、VertexLMRGBM和VertexLX</td>
<td>用于遗留的顶点照明渲染</td>
</tr>
</tbody>
</table>
</div>
<p>Unity在处理多光源的情况时为我们提供了三种模式；修改的地方在Edit-&gt;Project Settings—Player—Other Settings—Redering Path</p>
<ul>
<li>顶点光Vertex Lit</li>
<li>方向性Forward(默认)</li>
<li>延迟照明 Deferred Lighting</li>
</ul>
<p>shader默认使用Forward</p>
<h4 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h4><p>每进行一次完整的前向渲染，需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区，一个是深度缓冲区。利用深度缓冲区来决定一个片元是否可见，如果可见就更新颜色缓冲区的的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Pass </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (each primitive in <span class="keyword">this</span> model) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed in depth test)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果没有通过深度测试，说明该片元是不可见的</span></span><br><span class="line">            discard;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果该片元可见</span></span><br><span class="line">            <span class="comment">// 就进行光照计算</span></span><br><span class="line">            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">// 更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(fragment, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有N个物体，每个物体物体受M个光源的影响，那么要渲染整个场景一共需要N*M个Pass。可以看出，如果有大量逐像素光照，那么需要执行的Pass数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p>
<h5 id="Unity中的前向渲染"><a href="#Unity中的前向渲染" class="headerlink" title="Unity中的前向渲染"></a>Unity中的前向渲染</h5><p>事实上，一个Pass不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当渲染一个物体时，Unity会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。<br>在Unity中，前向渲染路径有3种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理，球谐函数（Spherical Harmonics, SH）处理。</p>
<h4 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h4><h4 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h4><p>这是一种可以按照你的需求在场景中使用任意数目的光源的方法，而且这个方法还能同时保证性能仍然保持在一个合理的范围。它也不限制阴影的数量，如果场景中的对象实在光照范围之内的话，也不会增加额外的渲染批次（如果对象投影阴影的话则是例外）。</p>
<p>在游戏中的实时光照，一般有三种常用的方法</p>
<ol>
<li>一遍渲染多个光源：所有光源都在一个着色器中进行。但一个着色器指令数量有限，所以这个技术只适用于光源数量较少的情况。</li>
<li>多遍渲染多光源</li>
<li>延迟渲染</li>
</ol>
<h3 id="广告牌"><a href="#广告牌" class="headerlink" title="广告牌"></a>广告牌</h3><p>广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要3个基向量。广告牌技术使用的基向量通常就是<strong>表面法线（normal）、指向上的方向（up）以及指向右的方向（right）</strong>。除此之外，我们还需要指定一个<strong>锚点（anchor location）</strong>，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。<br>广告牌技术的难点在于，如何根据需求构建3个相互正交的基向量。计算过程通常是，<br>CPU写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Vector3 Normal;</span><br><span class="line">Quaternion direction;</span><br><span class="line">void Start () &#123;</span><br><span class="line">    direction = Quaternion.FromToRotation(new Vector3(0, 0, 1), Normal);</span><br><span class="line">&#125;</span><br><span class="line">void Update () &#123;</span><br><span class="line">    transform.rotation = Camera.main.transform.rotation * direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="屏幕后处理效果"><a href="#屏幕后处理效果" class="headerlink" title="屏幕后处理效果"></a>屏幕后处理效果</h2><h3 id="建立一个基本的屏幕后处理脚本系统"><a href="#建立一个基本的屏幕后处理脚本系统" class="headerlink" title="建立一个基本的屏幕后处理脚本系统"></a>建立一个基本的屏幕后处理脚本系统</h3><pre><code>MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest);
</code></pre><p>当在脚本中声明该函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，把第二参数对应的渲染纹理显示到屏幕上。</p>
<pre><code>public static void Blit(Texture src, RenderTexture dest);
public static void Blit(Texture src, RenderTextrue dest, Material mat, int pass = -1);
public static void Blit(Texture src, Material mat, int pass = -1);
</code></pre><p>参数pass的默认值胃-1，表示将会依次调用Shader内的所有Pass。否则，只会调用给定索引的Pass。</p>
<h2 id="使用深度和法线纹理"><a href="#使用深度和法线纹理" class="headerlink" title="使用深度和法线纹理"></a>使用深度和法线纹理</h2><h3 id="消融"><a href="#消融" class="headerlink" title="消融"></a>消融</h3><p>噪声纹理+透明度测试，我们使用对噪声纹理采样的结果和某个控制消融程度的阀值比较，如果小于阀值，就使用clip函数把它对应的像素裁减掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Test&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _BurnAmount(&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0 // 控制消融程度，0为正常，1完全消融</span><br><span class="line">        _LineWith(&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1 // 模拟烧焦效果的线宽，值越大，火焰边缘的蔓延范围越宽</span><br><span class="line">        _MainText (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125; // 漫反射纹理</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125; // 法线纹理</span><br><span class="line">        _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色</span><br><span class="line">        _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色</span><br><span class="line">        _BurnMap(&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123;&#125; // 消融纹理</span><br><span class="line">    &#125;   </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma vertex frag</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="水波效果"><a href="#水波效果" class="headerlink" title="水波效果"></a>水波效果</h3><p>在模拟实时水面的过程中，往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，在进行正常的反射+折射计算，得到最后的水面波动效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot;&#125;</span><br><span class="line">    GrabPass &#123;&quot;_RefractionTex&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先把SubShader的标签中渲染队列设置成Transparent，并把后面的RenderType设置为Opaque。把Queue设置成Transparent可以确保该物体渲染时，其他所有不透明的物体都已经被渲染到屏幕上了，否则就可能无法正确得到“透过水面看到的图像”。而设置RenderType则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/21/Unity-Shader-IntroductionToTopic1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/21/Unity-Shader-IntroductionToTopic1/" class="post-title-link" itemprop="url">Unity Shader第二部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-21 15:10:53" itemprop="dateCreated datePublished" datetime="2018-10-21T15:10:53+08:00">2018-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>在光学里，我们使用辐照度（irradiance）来量化光。对于平行光来说，它的辐照度可通过计算在垂直于l的单位平面上的单位时间内穿过的能量来得到。</p>
<h4 id="吸收和散射"><a href="#吸收和散射" class="headerlink" title="吸收和散射"></a>吸收和散射</h4><p>光线由光源发射出来后，就会与一些物体相交。通常，相交的结构有两个：散射（scattering）和吸收（absorption）。<br>散射只改变光线的方向，但不改变光线的密度和颜色。而吸收只改变光线的密度和颜色，但不改变光线的方向。</p>
<h4 id="BRDF光照模型"><a href="#BRDF光照模型" class="headerlink" title="BRDF光照模型"></a>BRDF光照模型</h4><p>我们已经了解了光线在和物体表面相交时会发生哪些现象。当已知光源位置和方向、视角方向时，我们就需要知道一个表面是和光照进行交互的。例如，当光线从某个方向照射到一个表面时，有多少光线被反射？反射的方向有哪些？而BRDF（Bidirectional Reflectance Distribution Function）就是用来回答这些问题的。当给定模型表面上的一个点时，BRDF包含了对该点外观的完整的描述。在图形学种，BRDF大多使用一个数学公式来表示，并且提供了一些参数来调整材质属性。通俗来讲，当给定入射光线的方向和辐照度后，BRDK可以给出某个出射方向上的光照能量分布。本章涉及的BRDF都是对真实场景进行理想化和简化后的模型，也就是说，它们并不能真实地反映物体和光线之间地交互，这些光照模型被成为是经验模型。尽管如此，这些经验模型仍然在实时渲染领域被应用了多年。</p>
<h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p>基本方法是，把进入到摄像机的光线分为4部分，每个部分使用一种方法来计算它的贡献度</p>
<ul>
<li>自发光(emissive)</li>
<li>高光反射(specular)</li>
<li>漫反射(diffuse)</li>
<li>环境光(ambient)</li>
</ul>
<h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><p>在标准光照模型中，使用一种被称为环境光的部分来近似模拟间接光照。环境光的计算非常简单，它通常是一个全局变量，即场景中的所有物体都使用这个环境光。下面的等式给出了计算环境光的部分：</p>
<p>$c<em>{ambient}=g</em>{ambient}$</p>
<h4 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h4><p>光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。标准光照模型使用自发光来计算这个部分的贡献度。它的计算也很简单，就是直接使用了该材质的自发光颜色：</p>
<p>$c<em>{emissive}=m</em>{emissive}$</p>
<p>通常在实时渲染中，自发光的表面往往并不会照亮周围的表面，也就是说，这个物体并不会被当成一个光源。</p>
<h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。<br>漫反射光照符合<strong>兰伯特定律（Lambert’s law）</strong>：反射光线的强度与表面发现和光源方向之间夹角的余弦值成正比。因此，漫反射部分的计算如下：</p>
<p>$c<em>{diffuse} = (c</em>{light} \cdot m_{diffuse})max(0, n \cdot I)$</p>
<h4 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h4><p>这里的高光反射是一种经验模型，也就是说，它并不完全符合真实世界中的高光反射现象。它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。<br>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。<br>反射计算公式：<br>$r = 2(\vec{n} \cdot I)\vec{n} - I$<br>推导公式见Light Reflect<br>这样，我们就可以利用Phong模型来计算高光反射的部分：</p>
<p><font size="4">$c<em>{spscular} = (c</em>{light} \cdot m<em>{specular})max(0, \vec{v} \cdot r)^{m</em>{glass}}$</font><br>其中，$m<em>{gloss}$是材质的<strong>光泽度（gloss）</strong>，也被称为<strong>反光度（shinness）</strong>。它用于控制高光区域的“亮点”有多宽，$m</em>{gloss}$越大，亮点就越小。$m<em>{spscular}$是材质的高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c</em>{light}则是光源的颜色和强度。$</p>
<h4 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a>单张纹理</h3><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><h4 id="纹理的属性"><a href="#纹理的属性" class="headerlink" title="纹理的属性"></a>纹理的属性</h4><h3 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h3><h4 id="高度纹理"><a href="#高度纹理" class="headerlink" title="高度纹理"></a>高度纹理</h4><h4 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h4><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><h4 id="法线纹理类型"><a href="#法线纹理类型" class="headerlink" title="法线纹理类型"></a>法线纹理类型</h4><h3 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h3><h3 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h3><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><h4 id="其他遮罩纹理"><a href="#其他遮罩纹理" class="headerlink" title="其他遮罩纹理"></a>其他遮罩纹理</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/20/Unity-Shader-IntroductionToTopic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/20/Unity-Shader-IntroductionToTopic/" class="post-title-link" itemprop="url">Unity Shader第一部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-20 17:48:36" itemprop="dateCreated datePublished" datetime="2018-10-20T17:48:36+08:00">2018-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="像素光-Pixel-Light"><a href="#像素光-Pixel-Light" class="headerlink" title="像素光 Pixel Light"></a>像素光 Pixel Light</h2><p>Unity中将平行光称作为像素光，第一个像素光是基础平行光，以LightMode=ForwardBase标签修饰，每多一个像素光都以LightMode=ForwardAdd标签修饰。<br>并不是所有的光源在运行时都会反射到物体上，而是根据Project的Quality中设置的像素光数量来渲染的。<br>默认的像素光的数量应该是2，我们有更多的平行光照在物体上，就需要在Edit-&gt;Project Setting-&gt;Quality中去调节像素光的数量Pixel Light Count<br>当场景中的实际像素光数量超过这个设定值的时候，Unity只会渲染最重要的光。</p>
<h2 id="关于像素光的叠加原理"><a href="#关于像素光的叠加原理" class="headerlink" title="关于像素光的叠加原理"></a>关于像素光的叠加原理</h2><p>片段着色器是要将mesh组件传递的信息最终计算为颜色(或者深度)存储在帧缓存(Frame Buffer)中。<br>每个Pass之间输出的颜色通过一定的公式进行混合。<br>在这里我们简单使用一比一的模式进行颜色混合，即混合指令为：<br><code>Blend One One</code><br>第二个Pass的代码同样的也直接复制第一个Pass即可，相应的将Tags标签中LightMode=ForwardBase修改为LightMode=ForwordAdd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Multi-Light Diffuse&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        // 材料颜色默认为黑色，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p>渲染流水线的工作任务在于由一个三维场景触发、生成（或者说渲染）一张二维图像。换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。<br>《Render-Time Rendering, Third Edition》将一个渲染流程分成3个阶段：<strong>应用阶段(Application Stage)、几何阶段(Geometry Stage)、光栅化阶段(Rasterizer Stage)</strong>。<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/shader.webp" title="渲染流水线"></p>
<h4 id="应用阶段（CPU处理）"><a href="#应用阶段（CPU处理）" class="headerlink" title="应用阶段（CPU处理）"></a>应用阶段（CPU处理）</h4><p>这一阶段是由开发者主导的，在这一阶段中开发都有3个主要的任务：<br>首先，需要准备好场景数据（摄像机位置，视锥体，模型和光源等）<br>接着，还需要做粗粒度的剔除工作<br>最后，需要设置好每个模型的渲染状态（使用的材质，使用的纹理，使用的Shader等）<br>这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，渲染图元可以是点，线，三角面等。</p>
<h4 id="几何阶段（GPU处理）"><a href="#几何阶段（GPU处理）" class="headerlink" title="几何阶段（GPU处理）"></a>几何阶段（GPU处理）</h4><p>几何阶段主要用于处理所有和我们绘制的几何相关的事情。几何阶段负责和每个渲染图元打交道，进行逐顶点，逐多边形的操作。这个阶段可以进一步分成更小的流水线阶段。<br>几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。<br>总结：输入的渲染图元-&gt;屏幕空间的二维顶点坐标、每个顶点对应深度、着色等信息</p>
<h3 id="光栅化阶段（GPU处理）"><a href="#光栅化阶段（GPU处理）" class="headerlink" title="光栅化阶段（GPU处理）"></a>光栅化阶段（GPU处理）</h3><p>将会使用上一个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。主要任务是决定每个渲染图元中的那些像素应该被绘制在屏幕上。<br><strong>顶点着色器（Vertex Shader）</strong>是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。<strong>曲面细分着色器（Tessellation Shader）</strong>是一个可选的着色器，<strong>几何着色器（Geometry Shader）</strong>同样是一个可选的着色器，它可以被用于执行逐图元（Per-Pimitive）的着色操作，或者被用于产生更多的图元。下一个流水线是<strong>裁剪（Clipping）</strong>，这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。这个阶段是可配置的。例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。几何概念阶段的最后一个流水线阶段是<strong>屏幕映射（Screen Mapping）</strong>。这一阶段是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中。<br>光栅化概念阶段中的<strong>三角形设置（Triangle Setup）</strong>和<strong>三角形遍历（Triangle Traversal）</strong>阶段也都是固定函数（Fixed-Function）的阶段。接下来的<strong>片元着色器（Fragment Shader）</strong>，则是完全可编程的，它用于实现逐片元（Per-Fragment）的着色操作。最后，<strong>逐片元操作（Per-Fragment Operations）</strong>阶段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，它不是可编程，但具有很高的可配置型。<br>Unity内置的DiffuseShader,也就是说我们创建一个Material出来时默认的Shader也是多光源的，所以这篇文章完成的Shader与默认的diffuse shader基本效果一致。</p>
<h2 id="2-2-CPU与GPU之间的通信"><a href="#2-2-CPU与GPU之间的通信" class="headerlink" title="2.2 CPU与GPU之间的通信"></a>2.2 CPU与GPU之间的通信</h2><p>渲染流水线的起点是CPU，即应用阶段。应用阶段可以分为下面3个阶段：</p>
<ul>
<li>把数据加载到显存中</li>
<li>设置渲染状态</li>
<li>调用Draw Call</li>
</ul>
<h3 id="2-2-1-把数据加载到显存中"><a href="#2-2-1-把数据加载到显存中" class="headerlink" title="2.2.1 把数据加载到显存中"></a>2.2.1 把数据加载到显存中</h3><p>基本步骤就是纹理、网格等数据从硬盘加载到系统内存在加载到显存中。数据记载到显存后系统内存中的数据就可以被移除了，但是对于一些数据来说CPU需要访问他们，例如用于碰撞检测用的网格数据，这些数据则会被保留。</p>
<h3 id="2-2-3-设置渲染状态"><a href="#2-2-3-设置渲染状态" class="headerlink" title="2.2.3 设置渲染状态"></a>2.2.3 设置渲染状态</h3><p>渲染状态指的是场景中的网格是如何被渲染的，例如使用哪个Vertex Shader或者哪个Fragment Shader、光源属性、材质等。</p>
<h3 id="2-2-3-调用Draw-Call"><a href="#2-2-3-调用Draw-Call" class="headerlink" title="2.2.3 调用Draw Call"></a>2.2.3 调用Draw Call</h3><p>Draw Call指的是一个命令，发起方为CPU，接收方为GPU。当给定了一个Draw Call时，GPU会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。而这个计算过程，就是我们下一节要讲的GPU流水线。</p>
<h2 id="2-3-GPU流水线"><a href="#2-3-GPU流水线" class="headerlink" title="2.3 GPU流水线"></a>2.3 GPU流水线</h2><p>当GPU从CPU那里得到渲染命令后，就会进行一系列流水线操作，最终把图元渲染到屏幕上。</p>
<h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><p>在上一节中，我们解释了在应用阶段，CPU是如何和GPU通信，并通过调用Draw Call来命令GPU进行渲染。GPU渲染的过程就是GPU流水线。</p>
<p>对于概念阶段的后两个阶段，即几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过实现流水线化，大大加快了渲染速度。虽然我们无法完全控制这两个阶段的实现细节，但GPU向开发者开放了很多控制权。在这一节中，我们将具体了解GPU是如何实现这两个概念阶段的。</p>
<p>几何阶段和光栅化阶段可以分为若干更小的流水线阶段，这些流水线阶段由GPU来实现，每个阶段GPU提供了不同的可配置性或可编程性。</p>
<h3 id="从应用程序阶段模型数据给顶点着色器时支持的语义"><a href="#从应用程序阶段模型数据给顶点着色器时支持的语义" class="headerlink" title="从应用程序阶段模型数据给顶点着色器时支持的语义"></a>从应用程序阶段模型数据给顶点着色器时支持的语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">POSITION</td>
<td style="text-align:left">模型空间的顶点位置，通常是float4类型</td>
</tr>
<tr>
<td style="text-align:left">NORMAL</td>
<td style="text-align:left">顶点法线，通常是float3类型</td>
</tr>
<tr>
<td style="text-align:left">TANGENT</td>
<td style="text-align:left">顶点切线，通常是float4类型</td>
</tr>
<tr>
<td style="text-align:left">TEXCOORDn,如TEXCOORD0、TEXCOORD1</td>
<td style="text-align:left">该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依次类推，通常是float2或float4类型</td>
</tr>
</tbody>
</table>
</div>
<p>其中TEXCOORDn中的数目是和Shader Model有关的，例如一般在Shader Model 2(即Unity默认编译到的Shader Model版本)和Shader Model 3中，n等于8，而在Shader Model 4 和Shader Model 5中，n等于16.通常情况下，一个模型的纹理坐标数组一般不超过2，即我们往往只只用TEXCOORD0和TEXCOORD1。在Unity内置的数据结构体appdata_full中，它最多使用了6个坐标纹理。</p>
<h3 id="从顶点着色器传递数据给片元着色器时的语义"><a href="#从顶点着色器传递数据给片元着色器时的语义" class="headerlink" title="从顶点着色器传递数据给片元着色器时的语义"></a>从顶点着色器传递数据给片元着色器时的语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SV_POSITION</td>
<td style="text-align:left">裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于Direct9中的POSITION，但最好使用SV_POSITION</td>
</tr>
<tr>
<td style="text-align:left">COLOR0</td>
<td style="text-align:left">通常用于输出第一组顶点颜色，但不是必须的</td>
</tr>
<tr>
<td style="text-align:left">COLOR1</td>
<td style="text-align:left">通常用于输出第二组顶点颜色，但不是必须的</td>
</tr>
<tr>
<td style="text-align:left">TEXCOORD0~TEXCOORD7</td>
<td style="text-align:left">通常用于输出纹理坐标，但不是必须的</td>
</tr>
</tbody>
</table>
</div>
<p>上面的语义中，除了SV_POSITION是有特别含意外，其他语义对变量的含义没有明确要求，也就是说，我们可以存储任意值到这些描述变量中。</p>
<h3 id="片元着色器输出时Unity支持的常用语义"><a href="#片元着色器输出时Unity支持的常用语义" class="headerlink" title="片元着色器输出时Unity支持的常用语义"></a>片元着色器输出时Unity支持的常用语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="点和矢量的区别"><a href="#点和矢量的区别" class="headerlink" title="点和矢量的区别"></a>点和矢量的区别</h4><p>点是一个没有大小之分的空间中的位置，而矢量是一个有模和方向但是没有位置的量。</p>
<h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>对于一个点，从三维坐标转换成齐次坐标是把w分量设为1，而对于方向矢量来说，需要把w分量设为0。</p>
<h4 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h4><p>我们可以使用矩阵乘法来表示对一个点进行平移变换：</p>
<p>$\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t<em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t</em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t<em>{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{1}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{x+t</em>{x}}\<br>{y+t<em>{y}}\<br>{z+t</em>{z}}\<br>{1}\<br>\end{bmatrix}$</p>
<p>从结果来看我们可以很容易看出为什么这个矩阵有平移的效果：点的x、y、z分量分别增加了一个位置偏移。在3D中的可视化效果是，把点$(x,y,z)$在空间中平移了$(t<em>{x},t</em>{y},t_{z})$。<br>如果我们对一个方向矢量进行平移变换，结果如下：</p>
<p>$\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t<em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t</em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t_{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{0}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{0}\<br>\end{bmatrix}$<br>可以发现，平移变换不会对方向矢量产生任何影响。因为矢量没有位置属性，也就是说它可以位于空间中的任意一点，因此对位置的改变不应该对四维矢量产生影响。</p>
<h4 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h4><p>我们可以对一个模型沿空间的x轴、y轴和z轴进行缩放。</p>
<p>$\begin{bmatrix}<br>{k<em>{x}}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{k</em>{y}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{k<em>{z}}&amp;{0}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{1}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{k</em>{x}x}\<br>{k<em>{y}y}\<br>{k</em>{z}z}\<br>{1}\<br>\end{bmatrix}$</p>
<p>如果缩放系数$k<em>{x}=k</em>{y}=k_{z}$，我们把这样的缩放称为统一缩放（uniform scale），否则称为非同一缩放（nonuniform scale）。从外观看，统一缩放是扩大整个模型，而非同一缩放会拉伸或挤压模型。更重要的是，统一缩放不会改变角度和比例信息。</p>
<h4 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h4><p>在绝大多数情况下，我们约定变换的顺序就是先缩放，再旋转，最后平移。<br>变换矩阵如下：(注意，矩阵是从右往左算的)<br>$<br>M<em>{translation}M</em>{rotation}M<em>{scale} =<br>\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t</em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t<em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t</em>{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>$<br>当我们直接给出$(\theta<em>{x}, \theta</em>{y}, \theta_{z})$这样的旋转角度时，需要定义一个旋转顺序。在Unity中，这个旋转顺序是zxy。</p>
<h3 id="顶点的坐标空间变化"><a href="#顶点的坐标空间变化" class="headerlink" title="顶点的坐标空间变化"></a>顶点的坐标空间变化</h3><p>在渲染流水线中，一个顶点要经过多个坐标空间的变换才能最终被画在屏幕上。一个顶点最开始是在模型空间中定义的，最后它将会变换到屏幕空间中，得到真正的屏幕像素坐标。</p>
<h4 id="模型空间"><a href="#模型空间" class="headerlink" title="模型空间"></a>模型空间</h4><p><strong>模型空间（model space）</strong>，是和某个模型或者说是对象有关的。有时模型空间也被称为<strong>对象空间（object space）</strong>或<strong>局部空间（local space）</strong>。每个模型都有自己独立的坐标空间，当它移动或旋转的时候，模型空间也会跟着它移动和旋转。<br>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做模型变换（model transform）。</p>
<h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做<strong>模型变换（model transform）</strong>。<br>变换矩阵如下：<br>$M<em>{model} = \begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t</em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t<em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t</em>{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{cos\theta}&amp;{0}&amp;{sin\theta}&amp;{0}\<br>{0}&amp;{1}&amp;{0}&amp;{0}\<br>{-sin\theta}&amp;{0}&amp;{cos\theta}&amp;{0}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{k<em>{x}}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{k</em>{y}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{k<em>{z}}&amp;{0}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{k</em>{x}cos\theta}&amp;{0}&amp;{k<em>{z}sin\theta}&amp;{t</em>{x}}\<br>{0}&amp;{k<em>{y}}&amp;{0}&amp;{t</em>{y}}\<br>{-k<em>{x}sin\theta}&amp;{0}&amp;{k</em>{z}cos\theta}&amp;{-t_{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}$<br>注意：上述变换顺序是不能互换的，即先进行缩放，在进行旋转，最后是平移。<br>因为每个Transform的平移旋转缩放都是不一样的，所以他们的矩阵也是不一样的。</p>
<h4 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h4><p>观察空间（view space）也被称为摄像机空间（camera space）。顶点变换的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换叫做观察变换（view transform）。</p>
<h4 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h4><p>裁剪空间（clip space，也称齐次裁剪空间），这个用于变换的矩阵叫做裁剪矩阵（clip matrix），也称为投影矩阵（projection matrix）。<br>裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。这块空间是由视锥体来决定的。<br>视锥体指的是空间中的一块区域，这块区域决定了摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为<strong>裁剪平面（clip planes）</strong>。视锥体有两种类型，一种是<strong>正交投影（orthographic projection）</strong>，一种是<strong>透视投影（perspective projection）</strong>。<br>在视锥体的6块裁剪平面中，有两块裁剪平面比较特殊，它们分别被称为<strong>近裁剪平面（near clip plane）</strong>和<strong>远裁剪平面（far clip plane）</strong>。它们决定了摄像机可以看到的深度范围。</p>
<h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><p>视锥体的意义在于定了场景中的一块三维空间。所有位于这块空间内的物体将会被渲染，否则就会被剔除或裁剪。这块区域是由6个裁剪平面组成，在Unity中，它们由Camera组件中的参数和Game视图中横纵比共同决定<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/3.jpg"><br>Camera组件的Field of View（简称FOV）属性来改变视锥体竖直方向的张开角度，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。<br>这样，我们可以求出视锥体近裁剪面和远裁剪面的高度</p>
<p>$nearClipPlaneHeight = 2 \cdot Near \cdot tan {FOV \over 2}$</p>
<p>$farClipPlaneHeight = 2 \cdot Far \cdot tan {FOV \over 2}$</p>
<p>透视投影的横向信息，可以通过相机的横纵比得到。在Unity中，一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定（实际上，Unity允许我们在脚本里通过Camera.aspect进行更改）。假设，当前相机的横纵比为Aspect，则：</p>
<p>$Aspect = {nearClipPlaneWidth \over nerClipPlaneHeight}$</p>
<p>$Aspect = {farClipPlaneWidth \over farClipPlaneHeight}$    </p>
<p>现在，我们可以根据已知的Near、Far、FOV和Aspect的值来确定透视投影的投影矩阵。如下：</p>
<p>$<br>M<em>{frustum} = \begin{bmatrix}<br>{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\<br>{0}&amp;{0}&amp;{-1}&amp;{0}\<br>\end{bmatrix}<br>$<br>这里针对的是观察空间是右手坐标系，使用列矩阵在矩阵右侧相乘的，且变换后z分量范围在[-w,w]之间的情况。<br>而一个顶点和上述投影矩阵相乘后，可以由观察空间变换到裁剪空间中，结果如下<br>$<br>P</em>{clip} = M<em>{frustum}P</em>{view} =<br>\begin{bmatrix}<br>{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\<br>{0}&amp;{0}&amp;{-1}&amp;{0}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\{y}\{z}\{1}\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>{x{cot{FOV \over 2} \over Aspect}}\{y{cot{FOV \over 2}}}\{-z{Far+Near \over Far-Near}-{2 \cdot Near \cdot Far \over Far-Near}}\{-z}\<br>\end{bmatrix}<br>$<br>从这个结果来看，这个投影矩阵本质就是对x、y和z分量进行了不同程度的缩放（z分量还有一个平移），缩放的目的是为了方便裁剪。此时顶点的w分量不再是1，而是原先z分量的取反结果。<br>现在，我们就可以按如下不等式来判断一个变换后的顶点是否位于视锥体内。如果一个顶点在视锥体内，那么它变换后的坐标必须满足：<br>$-w \le x \le w$<br>$-w \le y \le w$<br>$-w \le z \le w$<br>任何不满足上述条件的图元都需要被剔除或者裁剪。下图显示了经过上述投影矩阵后，视锥体的变化。<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/4.jpg" title="在透视投影中，投影矩阵对顶点进行了缩放。"><br>从上图还可以注意到，裁剪矩阵会改变空间的旋向行；空间从右手坐标系变换到了左手坐标系。这意味着，离摄像机越远，z值将越大。</p>
<h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/5.jpg" title="正交相机的参数对正交投影视锥体的影响">
<p>正交投影的6个裁剪面和透视投影类似，在Unity中，它们也是由Camera组件中的参数和Game视图的横纵比共同决定。<br>正交投影的视锥体是一个长方体，因此计算上相比透视投影来说更加简单。由图可以看出，我们可以通过Camera组件的Size属性来改变视锥体竖直方向上高度的一般，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。这样，可以求出视锥体近裁剪面和远裁剪面的高度，也就是：<br>$newClipPlaneHeight=2 \cdot Size$<br>$farClipPlaneHeight=nearClipPlaneHeight$</p>
<p>现在我们还缺乏横向的信息。同样，我们可以通过摄像机的横纵比得到。假设，当前摄像机的横纵比为Aspect，那么：<br>$nearClipPlaneWidth=Aspect \cdot nearClipPlaneHeight$<br>$farClipPlaneWidth=nearClipPlaneWidth$<br>现在，我们可以根据已知的Near、Far、Size和Aspect的值来确定正交投影的裁剪矩阵。如下：<br>$M_{prtho} =<br>\begin{bmatrix}<br>{1 \over Aspect \cdot Size}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{1 \over Size}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{-{2 \over Far-Near}}&amp;{-{Far+Near} \over {Far-Near}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}$</p>
<h4 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h4><p>经过投影矩阵的变换后，我们可以进行裁剪操作。当完成了所有的裁剪工作后，就需要进行真正的投影了，也就是说，我们需要把视锥体投影到<strong>屏幕空间（screen space）</strong>中。经过这一步变换，我们会得到真正的像素位置，而不是虚拟的三维坐标。<br>屏幕空间是一个二维空间，因此，我们必须把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标。这个过程可理解成有两个步骤。<br>首先，我们需要进行标准<strong>齐次除法（homogeneous division）</strong>，也被称为<strong>透视除法（perspective division）</strong>。虽然这个步骤听起来很陌生，但是它实际上非常简单，就是用齐次坐标系的w分量去除以x、y、z分量。在OpenGL中，我们把这一步得到的坐标叫做<strong>归一化的设备坐标（Normalized Device Coordinates，NDC）</strong>。经过这一步，我们可以把坐标从齐次裁剪坐标空间转换到NDC中。经过透视投影变换后的裁剪空间，经过齐次除法会变换到一个立方体内。按照OpenGL的传统，这个立方体的x、y、z分量的范围都是[-1,1]。但在DirectX这样的API中，z分量的范围会是[0,1]。而Unity选择了OpenGL这样的齐次裁剪空间。</p>
<img src="/2018/10/20/Unity-Shader-IntroductionToTopic/1.jpg" class="7.jpg% 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体} #### 总结 顶点着色器的最基本的任务就是把顶点坐标从模型空间转换到裁剪空间中。 {% asset_img" title="渲染流水线中顶点的空间变化过程"> 
<img src="/2018/10/20/Unity-Shader-IntroductionToTopic/2.jpg" title="Unity中各个坐标空间的旋向性">
<h3 id="一个最简单的顶点-片元着色器"><a href="#一个最简单的顶点-片元着色器" class="headerlink" title="一个最简单的顶点/片元着色器"></a>一个最简单的顶点/片元着色器</h3><h4 id="顶点-片元着色器的基本结构"><a href="#顶点-片元着色器的基本结构" class="headerlink" title="顶点/片元着色器的基本结构"></a>顶点/片元着色器的基本结构</h4><p>Unity Shader的基本结构包含了Shader、Properties、SubShader、Fallback等语义块。顶点/片元着色器的结构与之大体类似，它的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;MyShaderName&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        // 属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        // 针对显卡A的SubShader</span><br><span class="line">        Pass &#123;</span><br><span class="line">            // 设置渲染状态和标签</span><br><span class="line"></span><br><span class="line">            // 开始CG代码片段</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            // 该片段的编译指令，例如:</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            // CG代码写在这里</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">            // 其他设置</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他需要的Pass</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        // 针对显卡B的SubShader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 上述SubShader都失败后用于回调的Unity Shader</span><br><span class="line">    Fallback &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，最重要的部分是Pass语义块，我们绝大部分的代码都是写在这个语义块里面的。下面我们就来创建一个最简单的顶点/片元着色器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Shader/Simple&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITION &#123;</span><br><span class="line">                return UnityObjectToClipPos(v);</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag() : SV_Target&#123;</span><br><span class="line">                return fixed4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Shader/Simple1&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pargma fragment frag</span><br><span class="line">            // 使用一个结构体来定义顶点着色器的输入</span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                // POSITION语义告诉Unity，用模型空间的顶点坐标填充vertex变量</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模型数据从哪里来"><a href="#模型数据从哪里来" class="headerlink" title="模型数据从哪里来"></a>模型数据从哪里来</h4><h4 id="顶点着色器和片元着色器之间如何通信"><a href="#顶点着色器和片元着色器之间如何通信" class="headerlink" title="顶点着色器和片元着色器之间如何通信"></a>顶点着色器和片元着色器之间如何通信</h4><h4 id="如何使用属性"><a href="#如何使用属性" class="headerlink" title="如何使用属性"></a>如何使用属性</h4><h3 id="Unity提供的内置文件和变量"><a href="#Unity提供的内置文件和变量" class="headerlink" title="Unity提供的内置文件和变量"></a>Unity提供的内置文件和变量</h3><h4 id="内置的包含文件"><a href="#内置的包含文件" class="headerlink" title="内置的包含文件"></a>内置的包含文件</h4><h4 id="内置的变量"><a href="#内置的变量" class="headerlink" title="内置的变量"></a>内置的变量</h4><h3 id="Unity提供的CG-HLSL语义"><a href="#Unity提供的CG-HLSL语义" class="headerlink" title="Unity提供的CG/HLSL语义"></a>Unity提供的CG/HLSL语义</h3><h3 id="Unity支持的语义"><a href="#Unity支持的语义" class="headerlink" title="Unity支持的语义"></a>Unity支持的语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th>语义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSITION</td>
<td>模型空间的顶点位置，通常是float4类型</td>
</tr>
<tr>
<td>NORMAL</td>
<td>顶点法线，通常是float3类型</td>
</tr>
<tr>
<td>TANGENT</td>
<td>顶点切线，通常是float4类型</td>
</tr>
<tr>
<td>$TEXCOORD_{n}$，如TEXCOORD0、TEXCOORD1</td>
<td>该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依此类推。通常是float2或float4类型</td>
</tr>
<tr>
<td>COLOR</td>
<td>顶点颜色，通常是fixed4或float4类型</td>
</tr>
</tbody>
</table>
</div>
<h4 id="如何定义复杂的变量类型"><a href="#如何定义复杂的变量类型" class="headerlink" title="如何定义复杂的变量类型"></a>如何定义复杂的变量类型</h4><h4 id="使用假彩色图形"><a href="#使用假彩色图形" class="headerlink" title="使用假彩色图形"></a>使用假彩色图形</h4><h4 id="float、half还是fixed"><a href="#float、half还是fixed" class="headerlink" title="float、half还是fixed"></a>float、half还是fixed</h4><p>在本书中，我们使用CG/HLSL来编写Unity Shader中的代码。而在CG/HLSL中，有3中精度的数值类型：float、half和fixed。这些精度将决定计算结果的数值范围。表5.8给出了这3中精度在通常情况下的数值范围。</p>
<p>CG/HLSL中3种精度的数值类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">最高精度的浮点值。通常使用32位来存储</td>
</tr>
<tr>
<td style="text-align:left">half</td>
<td style="text-align:left">中等精度的浮点值。通常用16位来存储，精度范围是-60000~+60000</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">最低精度的浮点值。通常使用11位来存储，精度方位是-2.0~+2.0</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/15/Unity-Shader-Manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/Unity-Shader-Manual/" class="post-title-link" itemprop="url">Unity Shader Manual</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 13:20:27" itemprop="dateCreated datePublished" datetime="2018-10-15T13:20:27+08:00">2018-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderLab Tutorials/TestShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Range (&quot;My Range&quot;, Range(0.02, 0.15)) = 0.07 // sliders</span><br><span class="line">        _Color (&quot;My Color&quot;, Color) = (.34, .85, .92, 1) // color</span><br><span class="line">        _2D (&quot;My Texture 2D&quot;, 2D) = &quot;&quot; &#123;&#125; // texture</span><br><span class="line">        _Rect (&quot;My Rectangle&quot;, Rect) = &quot;name&quot; &#123;&#125;</span><br><span class="line">        _Cube (&quot;My Cubemap&quot;, Cube) = &quot;name&quot; &#123;&#125;</span><br><span class="line">        _Float (&quot;My Float&quot;, Float) = 1</span><br><span class="line">        _Vector (&quot;My Vector&quot;, Vector) = (1,2,3,4)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Shader在Unity编辑器暴露给美术的参数，通过Properties来实现。</li>
<li>所有可能的参数如上所示。主要也就是Float、Vector和Texture这3类。</li>
<li>除了通过编辑器编辑Properties，脚本也可以通过Material的接口（比如SetFloat、SetTexture编辑）</li>
<li>之后的Shader程序通过[name]（固定管线）或者直接name（可编程Shader）访问这些属性。</li>
<li>在每一个Property前面也能类似C#那样添加Attribute，以达到额外UI功能。详见<h1 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h1><h1 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h1><h2 id="Tags-“TagName1”-”Value1”-“TagName2”-”Value2”"><a href="#Tags-“TagName1”-”Value1”-“TagName2”-”Value2”" class="headerlink" title="Tags{“TagName1”=”Value1” “TagName2”=”Value2”}"></a>Tags{“TagName1”=”Value1” “TagName2”=”Value2”}</h2>Tag的语法结构，通过Tags{}来表示需要添加的标识，大括号可以添加多组Tag（所以才叫Tags嘛），名称(TagName)和值（Value）是成对出现的，并且全部用字符串表示。</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>渲染队列直接影响性能中的重复绘制，合理的队列可极大的提升渲染效率。<br>渲染队列数目小于2500的对象都被认为是不透明的物体（从前往后渲染），高于2500的被任务是半透明物体（后后往前渲染）。<br>“Queue”=”Geometry+1”可通过值后加数字的方式来改变队列。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Queue标签</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>“Queue”=”Background”</td>
<td>值为1000，此队列的对象最先进行渲染</td>
</tr>
<tr>
<td>“Queue”=”Geometry”</td>
<td>默认值，值为2000，通常用于不透明对象，比如场景中的物体与角色等</td>
</tr>
<tr>
<td>“Queue”=”AlphaTest”</td>
<td>值为2450，要么完全透明要么完全不透明，多用于利用贴图来实现边缘透明的效果，也就是美术常说的透贴</td>
</tr>
<tr>
<td>“Queue”=”Transparent”</td>
<td>值为3000，常用于半透明对象，渲染时从后往前进行渲染，建议需要混合的对象放入此队列</td>
</tr>
<tr>
<td>“Queue”=”Overlay”</td>
<td>值为4000，此渲染队列用于叠加选过。最后渲染的东西应该放在这里（例如镜头光晕等）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="RenderType"><a href="#RenderType" class="headerlink" title="RenderType"></a>RenderType</h2><p>用来区分这个Shader要渲染的对象是属于什么类型的，你可以想象成事我们把不同的物体按我们需要的类型来进行分类一样。<br>当然你也可以根据需要改成自定义的名称，这样并不会影响到Shader的选过。<br>此Tag多用于摄像机的替换材质功能（Camera.SetReplacementShader）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“RenderType”=”Opaque”</td>
<td>大多数不透明着色器</td>
</tr>
<tr>
<td>“RenderType”=”Transparent”</td>
<td>大多数半透明着色器，比如粒子、特效、字体等。</td>
</tr>
<tr>
<td>“RenderType”=”TransparentCutout”</td>
<td>透贴着色器，多用于植被等。</td>
</tr>
<tr>
<td>“RenderType”=”Background”</td>
<td>多用于天空盒着色器。</td>
</tr>
<tr>
<td>“RenderType”=”Overlay”</td>
<td>GUI、光晕着色器等。</td>
</tr>
<tr>
<td>“RenderType”=”TreeOpaque”</td>
<td>Terrain地形中的树干。</td>
</tr>
<tr>
<td>“RenderType”=”TreeTransparentCutout”</td>
<td>Treeain地形中的树叶。</td>
</tr>
<tr>
<td>“RenderType”=”TreeBillboard”</td>
<td>Terrain地形中的永对面树。</td>
</tr>
<tr>
<td>“RenderType”=”Grass”</td>
<td>Terrain地形中的草。</td>
</tr>
<tr>
<td>“RenderType”=”GrassBillboard”</td>
<td>Terrain地形中的用对面草。</td>
</tr>
</tbody>
</table>
</div>
<p>指定RenderType的名称，主要是为了配合使用替代渲染的方法。</p>
<pre><code>Camera.SetReplacementShader(&quot;shader&quot;, &quot;RenderType&quot;)
</code></pre><h2 id="DisableBatching"><a href="#DisableBatching" class="headerlink" title="DisableBatching"></a>DisableBatching</h2><p>在利用Shader在模型的定点本地坐标下做一些位移动画，而当此模型有批处理时会出现效果不正确的情况，这是因为批处理将所有模型转换为世界坐标空间，因为”本地坐标空间”将丢失。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>批处理标签</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>“DisableBatching”=”True”</td>
<td>禁止批处理</td>
</tr>
<tr>
<td>“DisableBatching”=”False”</td>
<td>不禁用批处理</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="dot-a-b"><a href="#dot-a-b" class="headerlink" title="dot(a,b)"></a>dot(a,b)</h2><p>点乘，a和b必须为三维向量或者四维向量，其计算结果是两个向量夹角的余弦值，相当于a.x*b.x+a.y*b.y+a.z*b.z<br>a和b的位置无所谓前后，结果都是一样的</p>
<h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><pre><code>float3 objCenterPos = mul(unity_ObjectToWorld, float4(0,0,0,1)).xyz;
</code></pre><p>在Shader中获取当前模型的中心点，其实就是将(0,0,0)点从本地坐标转换到世界空间坐标下即可。</p>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(x)</td>
<td>Absolute value (per component)(每个组件).</td>
</tr>
<tr>
<td>acos(x)</td>
<td>Returns the arccosine(反余弦) of each component of x.</td>
</tr>
<tr>
<td>ceil(x)</td>
<td>Returns the smallest integer(最小整数) which is greater(大于) than or equal to x.</td>
</tr>
<tr>
<td>clip(x)</td>
<td>Discards(抛弃) the current pixel,if any component of x is less than zero.</td>
</tr>
<tr>
<td>cross(x,y)</td>
<td>x向量和y向量的向量积（叉积）</td>
</tr>
<tr>
<td>frac(x)</td>
<td>返回x的小数部分</td>
</tr>
<tr>
<td>lerp(x,y,s)</td>
<td>Returns x + s(y-x)</td>
</tr>
<tr>
<td>noise(x)</td>
<td>Generates a random value using the Perlin-noise algorithm.</td>
</tr>
<tr>
<td>pow(x,y)</td>
<td>Returns $x^y$</td>
</tr>
<tr>
<td>saturate(x)</td>
<td>x: 为用于操作的标量或矢量，可以是float、float2、float3等类型。把x截取在[0,1]范围内，如果x是一个矢量，那么会对它的每一个分量进行这样的操作。</td>
</tr>
<tr>
<td>smoothstep(min,max,x)</td>
<td>如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min,max]中，则返回0和1之间的值（返回值在min和max间的比例）。</td>
</tr>
<tr>
<td>step(a,b)</td>
<td>Returns (b&gt;=a)?1:0 (一般用这个取代if else)</td>
</tr>
<tr>
<td>tex2D(s, t)</td>
<td>2D texture lookup.</td>
</tr>
<tr>
<td>reflect(I,N)</td>
<td>根据入射光方向向量I，和顶点法向量N，计算反射光方向向量。其中I和N必须被归一化，需要非常注意的是，这个I是指向顶点的；函数只对三元向量有效</td>
</tr>
<tr>
<td>Tex2DProj(sampler2D tex, float3 sq)</td>
<td>二维投影纹理查询</td>
</tr>
<tr>
<td>Tex2DProj(sampler2D tex, float4 szq)</td>
<td>二维投影纹理查询，并进行深度值比较</td>
</tr>
</tbody>
</table>
</div>
<h1 id="pragma-fragementoption-ARB-precision-hint-fastest"><a href="#pragma-fragementoption-ARB-precision-hint-fastest" class="headerlink" title="#pragma fragementoption ARB_precision_hint_fastest"></a>#pragma fragementoption ARB_precision_hint_fastest</h1><p>ARB_precision_hint_fastest 是用最快的方式，以最低的精度运行，提升片段着色器的运行速度，减少时间。（通常是指FP16,16bit，半精度）牺牲表现换取运行速度。</p>
<h1 id="UnpackNormal"><a href="#UnpackNormal" class="headerlink" title="UnpackNormal"></a>UnpackNormal</h1><p><code>half3 normal = UnpackNormal(tex2D(_NormalMap, IN.uv_NormalMap));</code><br>UnpackNormal是定义在UnityCG.cginc文件中的方法，UnpackNormal接受一个fixed4的输入，并将其转换为所对应的法线值(fixed3)。</p>
<h1 id="TANGENT-SPACE-ROTATION"><a href="#TANGENT-SPACE-ROTATION" class="headerlink" title="TANGENT_SPACE_ROTATION"></a>TANGENT_SPACE_ROTATION</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 binormal = cross(v.normal,v.tangent.xyz)*v.tangent.w;</span><br><span class="line">flaot3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal);</span><br></pre></td></tr></table></figure>
<p>也就是构造出tangent space的坐标系，定义转换world space的向量到tangent space的rotation矩阵。</p>
<h1 id="UNITY-MATRIX-IT-MV"><a href="#UNITY-MATRIX-IT-MV" class="headerlink" title="UNITY_MATRIX_IT_MV"></a>UNITY_MATRIX_IT_MV</h1><p>专门用于将发现从模型空间变换到观察空间，为UNITY_MATRIX_MV的逆转置矩阵，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/09/21/TSF4G/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/21/TSF4G/" class="post-title-link" itemprop="url">TSF4G</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-21 13:40:15" itemprop="dateCreated datePublished" datetime="2018-09-21T13:40:15+08:00">2018-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/johnnyluo586/TSF4G.git" target="_blank" rel="noopener">https://github.com/johnnyluo586/TSF4G.git</a></p>
<h1 id="Tbus简介"><a href="#Tbus简介" class="headerlink" title="Tbus简介"></a>Tbus简介</h1><p>Tbus是tsf4g(Tencent ServiceFramework for Game,腾讯游戏服务框架)中的基础组件之一，主要的目的是为上层业务提供统一的线程或进程间通信接口，屏蔽本地进程间通信以及远程进程通信的细节，让开发人员可以集中精力关注业务逻辑，是tsf4g重要组成部分。</p>
<h1 id="Tbus原理"><a href="#Tbus原理" class="headerlink" title="Tbus原理"></a>Tbus原理</h1><p> Tbus基于共享内存构建无锁双通循环消息队列，发送的双方通过专用的读写队列完成数据收发，实现本地进程或者远程进程间通信。通信双方使用的两个队列称之为tbus通道(channel)，每一组通讯的双方就需要有一个tbus通道。</p>
<p> 进程A发送消息后，消息被存储到Host A的发送队列中，部署于Host A的tbusd发现队列中存在消息，则从队列中把消息取出，通过tcp发送到Host B上。Host B上的tbusd接收到消息后，把消息写入本地的接收队列，以供进程B读取。</p>
<p> 为了能完成通信，Tbus还有以下几个特点：<br> 通信双方具备全局唯一的tbus通信地址，该地址是一个点分十进制的字符串，与IP地址类型，总长度为32bit，分为4段，每段bit位数可以自定义，总长度不超过32bit。例如：128.1.100.1,5.0.200.1。</p>
<p> Tbus通道以及消息是存储在共享内存中，必须要使用相应的工具提前创建，进程才能绑定与使用。而当业务进程异常退出后，由于消息是存储在共享内存中，只要不主动清理共享内存、重启服务器或损坏共享内存，通道的消息就不会丢失。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/09/18/Unity-Lua-Manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/18/Unity-Lua-Manual/" class="post-title-link" itemprop="url">Unity-Lua-Manual</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-18 12:10:28" itemprop="dateCreated datePublished" datetime="2018-09-18T12:10:28+08:00">2018-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h2><h3 id="GO-name"><a href="#GO-name" class="headerlink" title="GO_name"></a>GO_name</h3><pre><code>gameObject.GO_name = &quot;name&quot;
</code></pre><p>设置或者获取游戏对象的名字</p>
<h3 id="GO-self"><a href="#GO-self" class="headerlink" title="GO_self"></a>GO_self</h3><pre><code>gameObject.GO_self
</code></pre><p>绑定到自己身上的Lua模块指针</p>
<h3 id="GO-active"><a href="#GO-active" class="headerlink" title="GO_active"></a>GO_active</h3><pre><code>gameObject.GO_active = true/false
</code></pre><p>设置游戏对象的显式或者隐藏</p>
<h3 id="GO-parent"><a href="#GO-parent" class="headerlink" title="GO_parent"></a>GO_parent</h3><pre><code>gameObject.GO_parent = parent
</code></pre><p>设置游戏对象的父节点</p>
<h3 id="GO-childCount"><a href="#GO-childCount" class="headerlink" title="GO_childCount"></a>GO_childCount</h3><pre><code>gameObject.GO_childCount
</code></pre><p>获取游戏对象的子节点对象，不递归</p>
<h3 id="GO-AddComponent"><a href="#GO-AddComponent" class="headerlink" title="GO_AddComponent"></a>GO_AddComponent</h3><pre><code>gameObject:GO_AddComponent(“UILabel&quot;)
</code></pre><p>给游戏对象添加组件</p>
<h3 id="GO-GetComponent"><a href="#GO-GetComponent" class="headerlink" title="GO_GetComponent"></a>GO_GetComponent</h3><pre><code>gameObject:GO_GetComponent(&quot;UILabel&quot;)
gameObject:GO_GetComponent(&quot;UILabel&quot;, &quot;Sprite/Label&quot;)
</code></pre><p>方法一：获取游戏对象的组件<br>方法二：获取子节点上的组件，参数二表示相对于父节点的路径</p>
<h3 id="GO-Find"><a href="#GO-Find" class="headerlink" title="GO_Find"></a>GO_Find</h3><pre><code>gameObject:GO_Find(&quot;Sprite/Label&quot;)
</code></pre><p>获取子节点对象</p>
<h3 id="GO-AddChild"><a href="#GO-AddChild" class="headerlink" title="GO_AddChild"></a>GO_AddChild</h3><pre><code>gameObject:GO_AddChild(&quot;UI/ui_node&quot;)
gameObject:GO_AddChild(ui_node)
</code></pre><p>方法一：通过相对于Resources下的路径来给游戏对象添加子节点<br>方法二：通过实例对象来给游戏对象添加子节点<br>如果是UI节点，请使用<strong><em>UI_AddChild</em></strong></p>
<h3 id="UI-AddChild"><a href="#UI-AddChild" class="headerlink" title="UI_AddChild"></a>UI_AddChild</h3><pre><code>gameObject:UI_AddChild(&quot;UI/ui_node&quot;)
gameObject:UI_AddChild(ui_node)    
</code></pre><p>方法一：通过相对于Resources下的路径来给游戏对象添加子节点<br>方法二：通过实例对象来给游戏对象添加子节点</p>
<h3 id="GO-DelChild"><a href="#GO-DelChild" class="headerlink" title="GO_DelChild"></a>GO_DelChild</h3><pre><code>gameObject:GO_DelChild(idx)
</code></pre><p>删除游戏对象的子节点，idx是下标从0开始的索引（顺序是检视面板显示的顺序）</p>
<h3 id="GO-DestroySelf"><a href="#GO-DestroySelf" class="headerlink" title="GO_DestroySelf"></a>GO_DestroySelf</h3><pre><code>gameObject:GO_DestroySelf()
</code></pre><p>销毁自己</p>
<h3 id="GO-RemoveAllChildren"><a href="#GO-RemoveAllChildren" class="headerlink" title="GO_RemoveAllChildren"></a>GO_RemoveAllChildren</h3><pre><code>gameObject:GO_RemoveAllChildren()
</code></pre><p>销毁所有的子节点</p>
<h3 id="GO-ShowAllChildren"><a href="#GO-ShowAllChildren" class="headerlink" title="GO_ShowAllChildren"></a>GO_ShowAllChildren</h3><pre><code>gameObject:GO_ShowAllChildren(ture/false)
</code></pre><p>显示或者隐藏自己所有的子节点</p>
<h3 id="GO-GetLocalPosition"><a href="#GO-GetLocalPosition" class="headerlink" title="GO_GetLocalPosition"></a>GO_GetLocalPosition</h3><pre><code>local x,y,z = gameObject:GO_GetLocalPosition()
</code></pre><p>获取自己的localPosition</p>
<h3 id="GO-SetLocalPosition"><a href="#GO-SetLocalPosition" class="headerlink" title="GO_SetLocalPosition"></a>GO_SetLocalPosition</h3><pre><code>gameObject:GO_SetLocalPosition(x,y [,z])
</code></pre><p>设置自己的localPosition,[] 表示可选参数,当未指定时表示使用之前的z</p>
<h3 id="GO-GetLocalRotation"><a href="#GO-GetLocalRotation" class="headerlink" title="GO_GetLocalRotation"></a>GO_GetLocalRotation</h3><pre><code>local x,y,z = gameObject:GO_GetLocalRotation()
</code></pre><p>获取自己的localRotation</p>
<h3 id="GO-SetLocalRotation"><a href="#GO-SetLocalRotation" class="headerlink" title="GO_SetLocalRotation"></a>GO_SetLocalRotation</h3><pre><code>gameObject:GO_SetLocalRotation(x,y [,z])
</code></pre><p>设置自己的localRotation,[]表示可选参数,当未指定时表示使用之前的z</p>
<h3 id="GO-SetLocalScale"><a href="#GO-SetLocalScale" class="headerlink" title="GO_SetLocalScale"></a>GO_SetLocalScale</h3><pre><code>gameObject:GO_SetLocalScale(x,y,z)
</code></pre><p>设置自己的localScale</p>
<h3 id="GO-UpdateAllAnchors"><a href="#GO-UpdateAllAnchors" class="headerlink" title="GO_UpdateAllAnchors"></a>GO_UpdateAllAnchors</h3><pre><code>gameObject:GO_UpdateAllAnchors()
</code></pre><p>手动刷新自身的锚点</p>
<h3 id="UI-active"><a href="#UI-active" class="headerlink" title="UI_active"></a>UI_active</h3><pre><code>gameObject.UI_active = true/false
</code></pre><p>递归刷新自己和子节点的显示和隐藏，如无特殊要求请使用<strong><em>GO_active</em></strong></p>
<h3 id="UI-onClick"><a href="#UI-onClick" class="headerlink" title="UI_onClick"></a>UI_onClick</h3><pre><code>gameObject.UI_onClick = function()
end
</code></pre><p>添加点击事件，游戏对象需要添加boxcollider2D</p>
<h3 id="UIToggle-onChange"><a href="#UIToggle-onChange" class="headerlink" title="UIToggle_onChange"></a>UIToggle_onChange</h3><pre><code>gameObject.UIToggle_onChange = function()
end
</code></pre><p>添加Toggle状态改变的回调函数，游戏对象需要添加UIToggle</p>
<h3 id="UILabel-text"><a href="#UILabel-text" class="headerlink" title="UILabel_text"></a>UILabel_text</h3><pre><code>gameObject.UILabel_text = &quot;Hello, World!&quot;
</code></pre><p>设置或者读取游戏对象的UILabel文本，游戏对象需要添加UILabel</p>
<h3 id="UILabel-color"><a href="#UILabel-color" class="headerlink" title="UILabel_color"></a>UILabel_color</h3><pre><code>gameObject.UILabel_color = Color.FromHex(&quot;C4C4C4FF&quot;)
</code></pre><p>设置或者读取文本颜色，返回值是Color</p>
<h3 id="UISprite-spriteName"><a href="#UISprite-spriteName" class="headerlink" title="UISprite_spriteName"></a>UISprite_spriteName</h3><pre><code>gameObject.UISprite_spriteName = &quot;btn_blue&quot;
</code></pre><p>设置或者读取精灵的名字，游戏对象需要添加UISprite组件</p>
<h3 id="UISprite-color"><a href="#UISprite-color" class="headerlink" title="UISprite_color"></a>UISprite_color</h3><pre><code>gameObject.UISprite_color = Color.FormHex(&quot;6f4f3fff&quot;)
</code></pre><p>设置或者读取精灵的颜色，游戏对象需要添加UISprite组件</p>
<h3 id="UIToggle-value"><a href="#UIToggle-value" class="headerlink" title="UIToggle_value"></a>UIToggle_value</h3><pre><code>gameObject.UIToggle_value = true/false
</code></pre><p>设置UIToggle的值</p>
<h3 id="UIWidget-color"><a href="#UIWidget-color" class="headerlink" title="UIWidget_color"></a>UIWidget_color</h3><pre><code>gameObject.UIWidget_color = Color.FormHex(&quot;6f4f3fff&quot;)
</code></pre><p>设置UIWidget或者继承他的子类（UILabel,UISprite)的颜色</p>
<h3 id="UIWidget-width"><a href="#UIWidget-width" class="headerlink" title="UIWidget_width"></a>UIWidget_width</h3><pre><code>gameObject.UIWidget_width = 100
</code></pre><p>设置UIWidget或者继承他的子类（UILabel,UISprite)的宽度</p>
<h3 id="UIWidget-height"><a href="#UIWidget-height" class="headerlink" title="UIWidget_height"></a>UIWidget_height</h3><pre><code>gameObject.UIWidget_height = 100
</code></pre><p>设置UIWidget或者继承他的子类的高度</p>
<h3 id="UIGrid-Reposition"><a href="#UIGrid-Reposition" class="headerlink" title="UIGrid_Reposition"></a>UIGrid_Reposition</h3><pre><code>gameObject:UIGrid_Reposition()
</code></pre><p>使Grid重新排序，一般给Grid添加了子节点后使用</p>
<h3 id="Tween-Play"><a href="#Tween-Play" class="headerlink" title="Tween_Play"></a>Tween_Play</h3><pre><code>gameObject:Tween_Play()
</code></pre><p>播放Tween动画</p>
<h2 id="MB"><a href="#MB" class="headerlink" title="MB"></a>MB</h2><h3 id="MB-Log"><a href="#MB-Log" class="headerlink" title="MB.Log"></a>MB.Log</h3><pre><code>MB.Log(&quot;Hello,World!&quot;)
</code></pre><p>打印日志</p>
<h3 id="MB-PCall"><a href="#MB-PCall" class="headerlink" title="MB.PCall"></a>MB.PCall</h3><pre><code>MB.PCall(function()
end)
</code></pre><p>安全的调用函数，当函数内部发生错误的时候，不会中断当前执行环境</p>
<h3 id="MB-LoadModule"><a href="#MB-LoadModule" class="headerlink" title="MB.LoadModule"></a>MB.LoadModule</h3><pre><code>MB.LoadModule(&quot;ui_task&quot;)
</code></pre><p>加载一个lua模块</p>
<h3 id="MB-ShowTheTip"><a href="#MB-ShowTheTip" class="headerlink" title="MB.ShowTheTip"></a>MB.ShowTheTip</h3><pre><code>MB.ShowTheTip(&quot;Hello,World!&quot;, 2)
</code></pre><p>弹出Tips，第二个参数表示时长单位是秒</p>
<h3 id="String-CSFormat"><a href="#String-CSFormat" class="headerlink" title="String.CSFormat"></a>String.CSFormat</h3><pre><code>String.CSFormat(&quot;id={0},name={1}&quot;,10,&quot;test&quot;)
</code></pre><p>调用C#的格式化函数</p>
<h3 id="MB-GetStringX"><a href="#MB-GetStringX" class="headerlink" title="MB.GetStringX"></a>MB.GetStringX</h3><pre><code>MB.GetStringX(bytes[], 10, &quot;test&quot;)
</code></pre><p>调用C#的格式化函数，第一个参数是byte数组，一般来说表格中的字段用它</p>
<h3 id="MB-GetExcelList"><a href="#MB-GetExcelList" class="headerlink" title="MB.GetExcelList"></a>MB.GetExcelList</h3><pre><code>MB.GetExcelList(&quot;NewTaskResConf&quot;)
</code></pre><p>读取表格</p>
<h3 id="MB-GO-GetResource"><a href="#MB-GO-GetResource" class="headerlink" title="MB.GO_GetResource"></a>MB.GO_GetResource</h3><pre><code>self.u_testSprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;)
</code></pre><p>获取资源 参数表示相对于Resources的路径，返回的是GameObject</p>
<h2 id="UITexture"><a href="#UITexture" class="headerlink" title="UITexture"></a>UITexture</h2><h3 id="SetTexturePath"><a href="#SetTexturePath" class="headerlink" title="SetTexturePath"></a>SetTexturePath</h3><pre><code>texture:SetTexturePath(&quot;Texture/UI/Chapter1&quot;)
</code></pre><p>设置texture的资源路径，路径相对于Resources，texture是通过gameObject获取的组件</p>
<h3 id="SetMat"><a href="#SetMat" class="headerlink" title="SetMat"></a>SetMat</h3><pre><code>texture:SetMat(path)
</code></pre><p>设置texture的材质，path表示相对Resources路径</p>
<h2 id="UILable"><a href="#UILable" class="headerlink" title="UILable"></a>UILable</h2><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><pre><code>label.text = &quot;Hello, World！&quot;
</code></pre><p>设置或者读取Label的文本</p>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><pre><code>label.color = Color.FromHex(&quot;6F4F3FFF&quot;)
</code></pre><p>设置或者读取Label的颜色</p>
<h3 id="effectColor"><a href="#effectColor" class="headerlink" title="effectColor"></a>effectColor</h3><pre><code>label.effectColor = Color.FromHex(&quot;6F4F3FFF&quot;)
</code></pre><p>设置或者读取Label的效果颜色</p>
<h3 id="fontSize"><a href="#fontSize" class="headerlink" title="fontSize"></a>fontSize</h3><pre><code>label.fontSize = 20
</code></pre><p>设置或者读取字体的大小</p>
<h2 id="UISprite"><a href="#UISprite" class="headerlink" title="UISprite"></a>UISprite</h2><h3 id="spriteName"><a href="#spriteName" class="headerlink" title="spriteName"></a>spriteName</h3><pre><code>sprite.spriteName = &quot;btn_red&quot;
</code></pre><p>设置或者读取Sprite的名字（图集中的）</p>
<h3 id="width"><a href="#width" class="headerlink" title="width"></a>width</h3><pre><code>sprite.width = 100
</code></pre><p>设置或者读取Sprite的宽度</p>
<h3 id="height"><a href="#height" class="headerlink" title="height"></a>height</h3><pre><code>sprite.height = 100
</code></pre><p>设置或者读取Sprite的高度</p>
<h3 id="atlas"><a href="#atlas" class="headerlink" title="atlas"></a>atlas</h3><pre><code>sprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;)
</code></pre><p>设置或者读取图集</p>
<h2 id="LuaEvent"><a href="#LuaEvent" class="headerlink" title="LuaEvent"></a>LuaEvent</h2><p>C#中</p>
<pre><code>LuaEvent.CallEvent((int)eLuaEvnet.eLuaEvent_PlayerTaskUpdate, param1, param2, param3);
</code></pre><p>lua中</p>
<pre><code>lua_event.InvokeEvent(lua_def.eLuaEvent_PlayerTaskUpdate, param1, param2, param3)

lua_event.InsertEvent(lua_def.eLuaEvent_PlayerTaskUpdate, callback, name, 0)
function callback(param1, param2, param3)

end
</code></pre><p>CallEvent表示C#事件通知Lua<br>InvokeEvent表示Lua事件通知Lua<br>LuaEvent.CallEvent中的第一个参数表示类型在obj_def.cs中定义，后面是需要传递给lua的参数</p>
<h2 id="lua-net"><a href="#lua-net" class="headerlink" title="lua_net"></a>lua_net</h2><h3 id="SendBin"><a href="#SendBin" class="headerlink" title="SendBin"></a>SendBin</h3><pre><code>lua_net.SendBin(lua_def.CS_CMD_GET_TASK_LIST_REQ, {Page = 1, Type = 4}, callback)
function callback(msg)
end
</code></pre><p>发送二进制包，第一个参数是消息ID，第二个参数是相对于数据结构类型，callback是回调函数，可选类型<br>回调函数中的msg表示一个json的xml中结构。</p>
<h3 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h3><pre><code>lua_net.Send(lua_def.eCTS_UI_Task, {op = &quot;get&quot;})
</code></pre><p>发送JSON包，第一个参数是cts_def.cs中定义的消息，第二个参数是lua table</p>
<h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><pre><code>lua_net.Register(lua_def.eSTC_UI_Task, OnUITaskHandle, signal, -1)
function OnUITaskHandler(msg)
end
lua_net.Register(lua_def.CS_CMD_GET_TASK_LIST_RES, OnGetTaskListRes, signal, -1)
function OnGetTaskListRes(msg) -- msg是xml生成的数据结构，传到lua里面是一个json table
end
</code></pre><p>注册一个消息回调，signal表示一个回调的唯一句柄，-1表示调用该回调函数的顺序，默认是0</p>
<h2 id="lua-timer"><a href="#lua-timer" class="headerlink" title="lua_timer"></a>lua_timer</h2><pre><code>lua_timer.Timer(self.gameObject, span, onTick, count, name)
</code></pre><p>— 创建Timer对象<br>— go : 指定挂到某个gameObject上<br>— span : 时间间隔，毫秒<br>— onTick : 回调函数(timer, dt)，回调的dt参数是超时的时间，一般也用不上<br>— count : 重复次数，缺省是1，如果是-1则无限循环。<br>— <em>return</em> : 返回一个lua table作为Timer</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/09/10/luajit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/10/luajit/" class="post-title-link" itemprop="url">luajit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-10 11:20:52" itemprop="dateCreated datePublished" datetime="2018-09-10T11:20:52+08:00">2018-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JIT = Just In Time<br>IOS中禁止使用（不让自主申请内存）</p>
<h2 id="解释执行："><a href="#解释执行：" class="headerlink" title="解释执行："></a>解释执行：</h2><ul>
<li>效率低</li>
<li>代码暴露</li>
</ul>
<h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><ul>
<li>不够灵活，无法热更新</li>
<li>平台兼容性差</li>
</ul>
<h2 id="JIT："><a href="#JIT：" class="headerlink" title="JIT："></a>JIT：</h2><ul>
<li>效率：高于解释执行，低于静态编译。</li>
<li>安全性：一般都先转换成字节码</li>
<li>热更新：无论源码还是字节码本质都是自愿文件。</li>
<li>兼容性：虚拟机会处理平台差异，对用户透明。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/07/21/Android-NDK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/21/Android-NDK/" class="post-title-link" itemprop="url">Andorid NDK</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-21 18:52:00" itemprop="dateCreated datePublished" datetime="2018-07-21T18:52:00+08:00">2018-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>JNI的全称是Java Native Interface，Java原生接口。提供别的代码调用的一组函数。首先使用C++写出了一些函数，然后将这些函数在Java类中再声明一次（加上关键字native），这样Java类中的函数和C++中的函数就匹配到一起了，我们使用Java类中的函数，其实就是使用C++中的函数。这个在Java类中声明的函数就是一个JNI。</p>
<h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><p>NDK的全称是Native Development Kit，原生开发工具包。</p>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>交叉编译就是在一个平台上生成另一个平台上的可执行代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/07/21/AndroidManifest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/21/AndroidManifest/" class="post-title-link" itemprop="url">Android Manual</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-21 17:35:00" itemprop="dateCreated datePublished" datetime="2018-07-21T17:35:00+08:00">2018-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AndroidManifest"><a href="#AndroidManifest" class="headerlink" title="AndroidManifest"></a>AndroidManifest</h1><ul>
<li>为应用的JAVA软件包命名。软件包名称充当应用的唯一标识符</li>
<li>描述应用的各个组件，包括构成应用的Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理Intent消息。这些声明向Android系统告知有关组件以及可以启动这些组件的条件的信息。</li>
<li>确定托管应用组件的进程。</li>
<li>声明应用必须具备哪些权限才能访问API中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。</li>
<li>列出Instrumentation类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前会将移除。</li>
<li>声明应用所需的最低Android API级别。</li>
<li>列出应用必须链接到的库</li>
</ul>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a><manifest>元素</manifest></h3><p>首先，所有的xml都必须包含<code>&lt;manifest&gt;</code>元素。这是文件的根节点。它必须要包含<code>&lt;application&gt;</code>元素，并且指明xmlns:android和package属性。</p>
<p>xmlns:android<br>这个属性定义了Android命名空间。必须设置成”<a href="http://schemas.android.com/apk/res/android&quot;。不要手动修改。" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;。不要手动修改。</a></p>
<p>package<br>这是一个完整的Java语言风格包名。包名由英文字母（大小写均可）、数字和下划线组成。每个独立的名字必须以字母开头。</p>
<p>构建APK的时候，构建系统使用这个属性来做两件事：<br>生成R.java类时用这个名字作为命名空间（用于访问APP的资源）比如：package被设置成net.pixelgame.unity3d</p>
<p>android:name<br>该属性以字符串形式指定了APP要用的硬件或软件功能。</p>
<p>android:required</p>
<p>andorid:glEsVersion</p>
<p><code>&lt;application&gt;</code>元素</p>
<p>此元素描述了应用的配置。这是一个必备的元素，它包含了很多子元素来描述应用的组件，它的属性影响到所有的子组件。</p>
<h1 id="Android-Studio快捷键"><a href="#Android-Studio快捷键" class="headerlink" title="Android Studio快捷键"></a>Android Studio快捷键</h1><ol>
<li>在当前窗口查找文本Ctrl+F</li>
<li>在当前窗口查找文本Ctrl+Shift+F</li>
<li>查找类Ctrl+N</li>
<li>查找文件Ctrl+Shitf+N</li>
<li>查找项目中的方法或变量Ctrl+Shitf+Alt+N</li>
<li>查找类/方法/变量引用的地方,先定位光标,右键选择”Find Usages”(或者快捷键Alt+F7)</li>
<li>Ctrl+o查看所有可以重写的地方</li>
<li>在类中快速定位某个方法或属性Ctrl+F12</li>
</ol>
<h1 id="Android分辨率"><a href="#Android分辨率" class="headerlink" title="Android分辨率"></a>Android分辨率</h1><p>2018.1月手机分辨率<br>2560<em>1440<br>1920</em>1080(16:9)<br>1280<em>720 (16:9)<br>2960</em>1440<br>2040*1080</p>
<h1 id="如何连接木木模拟器并查看log"><a href="#如何连接木木模拟器并查看log" class="headerlink" title="如何连接木木模拟器并查看log"></a>如何连接木木模拟器并查看log</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:7555 # 连接木木模拟器</span><br><span class="line">adb connect 127.0.0.1:62001 # 连接夜神模拟器</span><br><span class="line">adb shell</span><br><span class="line">logcat</span><br><span class="line">-----</span><br><span class="line">adb devices</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/07/21/Protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/21/Protocol/" class="post-title-link" itemprop="url">Protocol Buffer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-21 14:18:00" itemprop="dateCreated datePublished" datetime="2018-07-21T14:18:00+08:00">2018-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>高效的二进制方式存储<br>Varint是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越少的数字使用越少的字节数。<br>采用这种Key-Pair结构无需使用分隔符来分割不同的Field。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Meaning</th>
<th style="text-align:left">Used For</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">Varint</td>
<td style="text-align:left">int32,int64,uint32,uint64,sint32,sint64,bool,enum</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">64-bit</td>
<td style="text-align:left">fixed64</td>
<td>sfixed64,double</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Length-delimi</td>
<td style="text-align:left">string,bytes,embedded messages,packed repeated fields</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Start group</td>
<td style="text-align:left">Groups(deprecated)</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">End group</td>
<td style="text-align:left">Groups(deprecated)</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">32-bit</td>
<td style="text-align:left">fixed32,sfixed32,float</td>
</tr>
</tbody>
</table>
</div>
<p>在计算机内，一个负数一般会被表示一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用Varint表示一个负数，那么一定需要5个byte。为此Google Protocol Buffer定义了sint32这种类型，采用zigzag编码。</p>
<p>Zigzag编码用无符号来表示有符号数字，正数和负数交错，这就是zigzag这个词的含义了。</p>
<p><img src="http://oxcvfpext.bkt.clouddn.com/Protocol-1.jpg"></p>
<p>使用zigzag编码，绝对值小的数字，无论正负都可以采用较少的byte来表示，充分利用了Varint这种技术。</p>
<p>其他的数据类型，比如字符串则采用类似数据库中的varchar的表示方法，即用一个varint表示长度，然后其余部分紧跟在这个长度部分之后即可。</p>
<h3 id="封解包的速度"><a href="#封解包的速度" class="headerlink" title="封解包的速度"></a>封解包的速度</h3><p>首先来了解一下XML的封解包过程。XML需要从文件中读取字符串，再转换为XML文档对象结构模型。之后，再从XML文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将XML文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗CPU的复杂计算。</p>
<p>反观Protobuf，它只需要简单地将一个二进制序列，按照指的格式读取到C++对应的结构类型中就可以了。从上一节的描述可以看到消息的decoding过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。</p>
<h3 id="T-L-V的数据存储方式"><a href="#T-L-V的数据存储方式" class="headerlink" title="T-L-V的数据存储方式"></a>T-L-V的数据存储方式</h3><p>Tag-Lenght-Value,标识-长度-字段值存储方式</p>
<p>标识-长度-字段值表示单个数据，最终将所有数据拼接成一个字节流，从而实现数据存储的功能</p>
<ul>
<li>其中Length可选存储，如存储Varint编码数据就不需要存储Length</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
