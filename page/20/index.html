<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/20/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/02/25/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/C++/" class="post-title-link" itemprop="url">C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-25 18:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T18:00:00+08:00">2019-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul>
<li>对于一个class，产生一堆指向virtual functions的指针，虚函数表指针通常放在对象实例的最前面的位置。编译报错的时候没有vtable，表示该纯虚函数没有实现。</li>
<li>每一个对象添加一个指针，指向相关的virtual table。这个指针被称作虚函数表指针。</li>
</ul>
<h1 id="C-C-中static关键字作用总结"><a href="#C-C-中static关键字作用总结" class="headerlink" title="C/C++中static关键字作用总结"></a>C/C++中static关键字作用总结</h1><h2 id="先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"><a href="#先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）" class="headerlink" title="先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"></a>先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</h2><p>当同事编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br><span class="line">    (<span class="keyword">void</span>)msg();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序运行结果是：<br>A Hello<br>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上了static，main.c就看不到它们了。利用这一特性可以再不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。</p>
<h2 id="static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）"><a href="#static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）" class="headerlink" title="static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）"></a>static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）</h2><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的，虽然这种用法不常见<br>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p>
<p>程序举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a就不会再次被初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量；</span></span><br><span class="line">    <span class="keyword">return</span> count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;=<span class="number">10</span>;++count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>,count,fun());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static这个说明符在不同的地方所起的作用是不同的。</p>
<h2 id="static的第三个作用是默认初始化为0（static变量）"><a href="#static的第三个作用是默认初始化为0（static变量）" class="headerlink" title="static的第三个作用是默认初始化为0（static变量）"></a>static的第三个作用是默认初始化为0（static变量）</h2><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏举证，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’；太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’;</p>
<p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。</p>
<h2 id="static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）"><a href="#static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）" class="headerlink" title="static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）"></a>static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）</h2><p>在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：<br>（1）类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。<br>（2）不能将静态成员函数定义为虚函数。<br>（3）由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个”nonmember函数指针”。<br>（4）由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based XWindow系统结合，同时也成功的应用于线程函数身上。（这条没遇见过）<br>（5）static并没有增加程序的时空开销，相反它还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。<br>（6）静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>（7）静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是Link时会报错误）<br>（8）静态成员初始化与一般数据成员初始化不同：<br>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private,public等；<br>初始化时使用作用域来标明它所属类；<br>所以我们得出静态数据成员初始化的格式：<br>&lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;<br>（9）为了防止父类的影响，可以在子类定一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling用以生成唯一的标志。</p>
<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象</p>
<h1 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h1><p>通过一张虚函数表（Virtual Table）来实现<br>sizeof不统计虚函数表</p>
<h1 id="C-C-内存对齐"><a href="#C-C-内存对齐" class="headerlink" title="C/C++内存对齐"></a>C/C++内存对齐</h1><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>32位系统下，int占4byte，char占1byte，那么将它们放到一个结构体中实际上占8byte，这就是内存对齐导致的。</p>
<h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><h2 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h2><p>内联函数是指那些定义在类体内部的成员函数，即该函数的函数体放在类体内。<br>一般来说，inline适用的函数有两种，一种是类内定义的成员函数，另一种是类内声明，类外定义的成员函数，对于这两种情况inline的使用有一些不同；</p>
<h2 id="内联函数的优缺点："><a href="#内联函数的优缺点：" class="headerlink" title="内联函数的优缺点："></a>内联函数的优缺点：</h2><p>优点：<br>1.inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。<br>2.inline也是真正的函数，编辑器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个正在的函数一样。这样就消除了它的隐患和局限性。（宏替换不会检查参数类型，安全隐患较大）<br>缺点：<br>1.内联函数具有一定的局限性，inline函数的函数体一般来说不能太大，如果太大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。（换句话说，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请），这样，内联和普通函数执行效率一样了。<br>2.inline对编译器来说只是一种简易，编译器可以选择忽略这个建议。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.内联函数不能宝库欧复杂的控制语句，如循环语句和switch语句；</p>
<h1 id="接口（抽象类）"><a href="#接口（抽象类）" class="headerlink" title="接口（抽象类）"></a>接口（抽象类）</h1><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><ol>
<li>C语言</li>
<li>面向对象</li>
<li>C++模版</li>
<li>STL容器</li>
</ol>
<h1 id="尽量用const，enum，inline替换-define"><a href="#尽量用const，enum，inline替换-define" class="headerlink" title="尽量用const，enum，inline替换#define"></a>尽量用const，enum，inline替换#define</h1><ol>
<li>const的好处：define直接常量替换，出现编译错误不易定位（不知道常量是哪个变量，这个其实还好，工程规范点的都不存在这个问题）；define没有作用域，const有作用域提供了封装性（这个同上，不过这两点都是人为的避开了）</li>
<li>enum的好处：提供了封装性，编译器肯定不会分配额外的内存空间（其实const也不会，难道define会？至于封装性，undef，所以这么多年了，虽然说避免，但是工程上用的还是比较多的）</li>
<li>inline的好处：define宏函数容易造成误用</li>
</ol>
<p>宏实现工厂设计模式</p>
<ol>
<li>需要一个全局map用于存储类的信息以及创建实例的函数</li>
<li>需要调用全局对象的构造函数用于注册</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef void *(*register_fun)();</span><br><span class="line"></span><br><span class="line">class CCFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void *NewInstance(string class_name)</span><br><span class="line">    &#123;</span><br><span class="line">        auto it = map_.find(class_name);</span><br><span class="line">        if (it == map_.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return it-&gt;second();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Register(string class_name, register_fun func)</span><br><span class="line">    &#123;</span><br><span class="line">        map_[class_name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static map&lt;string, register_fun&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, register_fun&gt; CCFactory::map_; // 体外初始化</span><br><span class="line"></span><br><span class="line">#define REGISTER_CLASS(class_name); \</span><br><span class="line">    CCFactory::Register(#class_name, []()-&gt;void *&#123;return (new class_name);&#125;);</span><br><span class="line"></span><br><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Say() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Register : public Product // 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Say()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Say What?\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">    REGISTER_CLASS(Register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Release()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    Register* a = (Register*)CCFactory::NewInstance(&quot;Register&quot;);</span><br><span class="line">    a-&gt;Say();</span><br><span class="line">    Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没写完，但是感觉做个池还是挺好玩的。</p>
<h1 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h1><ol>
<li>const定义接口，防止误用</li>
<li>const成员函数，代表这个成员函数承诺不会改变对象值（const成员只能调用const成员函数(加-fpermissive编译选项就可以了)，非const成员可以调用所有成员函数）</li>
</ol>
<h1 id="确定对象使用前被初始化"><a href="#确定对象使用前被初始化" class="headerlink" title="确定对象使用前被初始化"></a>确定对象使用前被初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef void *(*register_fun)();</span><br><span class="line"></span><br><span class="line">class CCFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void *NewInstance(string class_name)</span><br><span class="line">    &#123;</span><br><span class="line">        auto it = map_.find(class_name);</span><br><span class="line">        if (it == map_.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return it-&gt;second();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Register(string class_name, register_fun func)</span><br><span class="line">    &#123;</span><br><span class="line">        map_[class_name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static map&lt;string, register_fun&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, register_fun&gt; CCFactory::map_; // 体外初始化</span><br><span class="line"></span><br><span class="line">#define REGISTER_CLASS(class_name); \</span><br><span class="line">    CCFactory::Register(#class_name, []()-&gt;void *&#123;return (new class_name(#class_name));&#125;);</span><br><span class="line"></span><br><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Say() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Register : public Product // 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Say()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; name.c_str() &lt;&lt; &quot;: Say What?\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void Run() const // 表明这个函数不会对类对象的数据成员（准确地说是非静态数据成员）作任何改变</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int b;</span><br><span class="line">    const string name; // 必须在初始化的时候赋值</span><br><span class="line">    Register(string _y) : name(_y)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">    REGISTER_CLASS(Register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Release()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    Register* a = (Register*)CCFactory::NewInstance(&quot;Register&quot;);</span><br><span class="line">    a-&gt;Say();</span><br><span class="line">    Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造、析构、赋值运算"><a href="#构造、析构、赋值运算" class="headerlink" title="构造、析构、赋值运算"></a>构造、析构、赋值运算</h1><p>如果类中没有定义，程序却调用了，编译器会产生一些函数</p>
<ol>
<li>一个default的构造函数</li>
<li>一个copy构造函数</li>
<li>一个copy assignment 操作符</li>
<li>一个析构函数(non virtual)</li>
</ol>
<ul>
<li>如果自己构造了带参数的构造函数，编译器不会产生default构造函数</li>
<li>base class如果把拷贝构造函数或者复制操作符设置为private，不会产生这两个函数</li>
<li>含有引用成员变量或者const成员变量不产生复制操作符</li>
</ul>
<h1 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h1><p>将默认生成的函数声明为private，或者C++ 11新特性”=delete”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UncopyTable</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    UncopyTable(const UncopyTable&amp;);</span><br><span class="line">    UncopyTable&amp; operator=(const UncopyTable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h1><p>上下文无关，在编译时就可以确定其类型。</p>
<h1 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h1><p>基类指针指向的对象在编译的时候无法确定</p>
<h1 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h1><p>静态绑定：编译时绑定，通过对象调用<br>动态绑定：运行时绑定，通过地址实现</p>
<p>要触发动态绑定，需满足两个条件</p>
<ol>
<li>只有虚函数才能惊醒动态绑定，非虚函数不能进行动态绑定</li>
<li>必须通过基类类型的引用或指针进行函数调用</li>
</ol>
<h1 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h1><ol>
<li>给多态基类应该主动声明virtual析构函数</li>
<li>非多态基类，没有virtual函数，不要声明virtual析构函数</li>
</ol>
<h1 id="复制对象时勿忘其每个成分"><a href="#复制对象时勿忘其每个成分" class="headerlink" title="复制对象时勿忘其每个成分"></a>复制对象时勿忘其每个成分</h1><ol>
<li>实现拷贝构造函数和赋值操作符的时候，调用base的相关函数</li>
<li>可以让拷贝构造函数和赋值操作符调用一个共同的函数，比如Init</li>
</ol>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><ol>
<li>为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源</li>
<li>shared_ptr，unique_lock都是RAII对象</li>
</ol>
<h2 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h2><ul>
<li>常见的RAII对象copy行为<ul>
<li>禁止copy</li>
<li>引用计数</li>
<li>深度赋值</li>
<li>转移资源拥有权</li>
</ul>
</li>
</ul>
<h1 id="头文件搜索目录"><a href="#头文件搜索目录" class="headerlink" title="头文件搜索目录"></a>头文件搜索目录</h1><pre><code>#include &quot;headfile.h&quot;
</code></pre><p>搜索顺序为：</p>
<ol>
<li>当前目录</li>
<li>-I指定目录</li>
<li>gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH）</li>
<li>gcc内定目录<br>/usr/include<br>/usr/local/include<br>/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/12/09/fiction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/09/fiction/" class="post-title-link" itemprop="url">序章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-09 16:37:36" itemprop="dateCreated datePublished" datetime="2018-12-09T16:37:36+08:00">2018-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>芩也不是一开始就知道这个世界是黑白的，是他的父亲告诉他的。父亲说，芩，你长大了，父亲要走了。芩问，父亲你去哪里？父亲说，我也不知道，我总觉得有人在召唤我，我该上路了。我们每个人都会上路的，包括你，芩。芩说，父亲，我可以陪你一起上路吗？父亲回答，我们每个人的路都是不一样的，你以后会有你自己的路走的，或许是明天，或许是明年，或许是更久。芩没说话，六岁的他不知道该说什么，也不太明白父亲对他说的话。他只知道，父亲要走了。要去很远的地方，一个他找不到的地方。而他，再也见不到父亲了。<br>从那天起，我的天空里再也没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/11/23/PowerVR-Performance-Recommendations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/23/PowerVR-Performance-Recommendations/" class="post-title-link" itemprop="url">PowerVR Performance Recommendations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-23 14:43:57" itemprop="dateCreated datePublished" datetime="2018-11-23T14:43:57+08:00">2018-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>PowerVR SGX and PowerVR Rogue are Graphics Core architectures from Imagination Technologies designed specifically for shader-based APIs such as OpenGL ES 2.0,3.x,and Vulkan.Due to their scalable architectures,the PowerVR family spans a huge performance range.</p>
<h2 id="Document-Overview"><a href="#Document-Overview" class="headerlink" title="Document Overview"></a>Document Overview</h2><p>This purpose of this document is to serve as recommendation and advice for developers who wish to get the best graphics performance from a PowerVR SGX or PowerVR Rogue enabled device. Throughout the document, the specific recommendations for PowerVR SGX and PowerVR Rogue are marked as appropriate.</p>
<h2 id="The-Golden-Rules"><a href="#The-Golden-Rules" class="headerlink" title="The Golden Rules"></a>The Golden Rules</h2><p>The Golden Rules are a set of more generic performance recommendations that developers should seek to implement,as well as observe as many of the techniques and principles mentioned.This should help produce well-behaved,high performance graphics applications.These rules are detailed in the document entitled “PowerVR Performance Recommendations: The Golden Rules”,which is supplied with the PowerVR SDK.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/22/Unity-Shader-IntrodutionToTopic-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/22/Unity-Shader-IntrodutionToTopic-2/" class="post-title-link" itemprop="url">Unity Shader第三部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-22 18:12:38" itemprop="dateCreated datePublished" datetime="2018-10-22T18:12:38+08:00">2018-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h1><p>透明是游戏中经常要使用的一种效果。在实时渲染中要实现透明效果，通常会在渲染模型时控制它的<strong>透明通道（Alpha Channel）</strong>。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有透明度。当透明度为1时，表示该像素是完全不透明的，而当其为0时，则表示该像素完全不会显示。<br>在Unity中，我们通常使用两种方法来实现透明效果：第一种是使用<strong>透明度测试（Alpha Test）</strong>，这种效果其实无法得到真正的半透明效果；另一种是<strong>透明度混合（Alpha Blending）</strong>。<br>在之前的学习中，我们从没有强调过渲染顺序的问题。也就是说，当场景中包含很多模型时，我们并没有考虑是先渲染A，在渲染B，最后在渲染C，还是按照其他的顺序来渲染。事实上，对于不透明（opaque）物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于强大的深度缓冲（depth buffer，也被称为z-buffer）的存在。在实时渲染中，深度缓冲是用于解决可见性（visibility）问题的，它可以决定哪个物体的哪些部分会被渲染在前面，而哪些部分会被其他物体遮挡。它的基本思想是：根据深度缓冲中的值来判断该片元距离摄像机的距离，当渲染一个片元时，需要把它的深度值和已经存在于深度缓冲中的值进行比较（如果开启了深度测试），如果它的值距离摄像机更远，那么说明这个片元不应该被渲染到屏幕上（有物体遮挡住了它）；否则，这个片元应该覆盖掉此时颜色缓冲中的像素值，并把它的深度值更新到深度缓冲中（如果开启了深度写入）。</p>
<h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>透明度混合的实现要比透明度测试复杂一些，这是因为我们在处理透明度测试时，实际上跟对待普通的不透明物体几乎是一样的，只是在片元着色器中增加了对透明度判断并裁剪片元的代码。而想要实现透明度混合就没这么简单了。我们回顾之前提到的透明度混合的原理。<br><strong>透明度混合：</strong>这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲区种的颜色进行混合，得到新的颜色。但是，<font color="red"><strong>透明度混合需要关闭深度写入</strong></font>，这使得我们要非常小心物体的渲染顺序。<br>为了进行混合，我们需要使用Unity提供的混合命令Blend。Blend是Unity提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲区种的颜色值进行混合，混合时使用的函数就是由该指令决定的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Blend Off</td>
<td>关闭混合</td>
</tr>
<tr>
<td>Blend SrcFactor DstFactor</td>
<td>开启混合，并设置混合因子。源颜色（该片元产生的颜色）会乘以SrcFactor，而目标颜色（已经存在于颜色缓存的颜色）会乘以DstFactor，然后把两者相加后在存入颜色缓冲中</td>
</tr>
<tr>
<td>Blend SrcFactor DstFactor, SrcFactorA DstFractorA</td>
<td>和上面一样，只是使用不同的因子来混合透明通道</td>
</tr>
<tr>
<td>BlendOp BlendOperation</td>
<td>并非是把源颜色和目标颜色简单相加后混合，而是使用BlendOperation对它们进行其他操作</td>
</tr>
</tbody>
</table>
</div>
<p>我们介绍第二种语义，即Blend SrcFactor DstFactor来进行混合。需要注意的是，这个命令在设置混合因子的同时也开启了混合模式。这是因为，只有开启了混合之后，设置片元的透明通道才有意义，而Unity在我们使用Blend命令的时候就自动帮我们打开了。很多初学者抱怨为什么自己的模型没有任何透明效果，这往往是因为他们没有在Pass中使用Blend命令，一方面是没有设置混合因子，更重要的是没有打开混合模式。我们会把源颜色的混合因子SrcFactor设为SrcAlpha，而目标颜色的混合因子DstFactor设为OneMinusSrcAlpha。这意味着，经过混合后新的颜色是：</p>
<p>$DstColor<em>{new} = SrcAlpha<em>SrcColor+(1-SrcAlpha)</em>DstColor</em>{old}$</p>
<h3 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h3><h3 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a>ShaderLab的混合命令</h3><h4 id="混合等式和参数"><a href="#混合等式和参数" class="headerlink" title="混合等式和参数"></a>混合等式和参数</h4><h4 id="混合操作"><a href="#混合操作" class="headerlink" title="混合操作"></a>混合操作</h4><h4 id="常见和混合类型"><a href="#常见和混合类型" class="headerlink" title="常见和混合类型"></a>常见和混合类型</h4><h3 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h3><h4 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h4><h4 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h4><h2 id="渲染路径Rendering-Path"><a href="#渲染路径Rendering-Path" class="headerlink" title="渲染路径Rendering Path"></a>渲染路径Rendering Path</h2><div class="table-container">
<table>
<thead>
<tr>
<th>LightMode</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Always</td>
<td>不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照</td>
</tr>
<tr>
<td>ForwardBase</td>
<td>用于前向渲染。该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps</td>
</tr>
<tr>
<td>ForwardAdd</td>
<td>用于前向渲染。该Pass会计算额外的逐像素光源，每个Pass对应一个光源</td>
</tr>
<tr>
<td>Deferred</td>
<td>用于延迟渲染。该Pass会渲染G缓冲（G-buffer）</td>
</tr>
<tr>
<td>ShadowCaster</td>
<td>把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中</td>
</tr>
<tr>
<td>PrepassBase</td>
<td>用于遗留的延迟渲染。该Pass会渲染法线和高光反射的指数部分</td>
</tr>
<tr>
<td>PrepassFinal</td>
<td>用于遗留的延迟渲染。该Pass通过合并纹理、光照和自发光来渲染得到最后的颜色</td>
</tr>
<tr>
<td>Vertex、VertexLMRGBM和VertexLX</td>
<td>用于遗留的顶点照明渲染</td>
</tr>
</tbody>
</table>
</div>
<p>Unity在处理多光源的情况时为我们提供了三种模式；修改的地方在Edit-&gt;Project Settings—Player—Other Settings—Redering Path</p>
<ul>
<li>顶点光Vertex Lit</li>
<li>方向性Forward(默认)</li>
<li>延迟照明 Deferred Lighting</li>
</ul>
<p>shader默认使用Forward</p>
<h4 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h4><p>每进行一次完整的前向渲染，需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区，一个是深度缓冲区。利用深度缓冲区来决定一个片元是否可见，如果可见就更新颜色缓冲区的的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Pass </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (each primitive in <span class="keyword">this</span> model) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed in depth test)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果没有通过深度测试，说明该片元是不可见的</span></span><br><span class="line">            discard;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果该片元可见</span></span><br><span class="line">            <span class="comment">// 就进行光照计算</span></span><br><span class="line">            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">// 更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(fragment, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有N个物体，每个物体物体受M个光源的影响，那么要渲染整个场景一共需要N*M个Pass。可以看出，如果有大量逐像素光照，那么需要执行的Pass数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p>
<h5 id="Unity中的前向渲染"><a href="#Unity中的前向渲染" class="headerlink" title="Unity中的前向渲染"></a>Unity中的前向渲染</h5><p>事实上，一个Pass不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当渲染一个物体时，Unity会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。<br>在Unity中，前向渲染路径有3种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理，球谐函数（Spherical Harmonics, SH）处理。</p>
<h4 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h4><h4 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h4><p>这是一种可以按照你的需求在场景中使用任意数目的光源的方法，而且这个方法还能同时保证性能仍然保持在一个合理的范围。它也不限制阴影的数量，如果场景中的对象实在光照范围之内的话，也不会增加额外的渲染批次（如果对象投影阴影的话则是例外）。</p>
<p>在游戏中的实时光照，一般有三种常用的方法</p>
<ol>
<li>一遍渲染多个光源：所有光源都在一个着色器中进行。但一个着色器指令数量有限，所以这个技术只适用于光源数量较少的情况。</li>
<li>多遍渲染多光源</li>
<li>延迟渲染</li>
</ol>
<h3 id="广告牌"><a href="#广告牌" class="headerlink" title="广告牌"></a>广告牌</h3><p>广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要3个基向量。广告牌技术使用的基向量通常就是<strong>表面法线（normal）、指向上的方向（up）以及指向右的方向（right）</strong>。除此之外，我们还需要指定一个<strong>锚点（anchor location）</strong>，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。<br>广告牌技术的难点在于，如何根据需求构建3个相互正交的基向量。计算过程通常是，<br>CPU写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Vector3 Normal;</span><br><span class="line">Quaternion direction;</span><br><span class="line">void Start () &#123;</span><br><span class="line">    direction = Quaternion.FromToRotation(new Vector3(0, 0, 1), Normal);</span><br><span class="line">&#125;</span><br><span class="line">void Update () &#123;</span><br><span class="line">    transform.rotation = Camera.main.transform.rotation * direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="屏幕后处理效果"><a href="#屏幕后处理效果" class="headerlink" title="屏幕后处理效果"></a>屏幕后处理效果</h2><h3 id="建立一个基本的屏幕后处理脚本系统"><a href="#建立一个基本的屏幕后处理脚本系统" class="headerlink" title="建立一个基本的屏幕后处理脚本系统"></a>建立一个基本的屏幕后处理脚本系统</h3><pre><code>MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest);
</code></pre><p>当在脚本中声明该函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，把第二参数对应的渲染纹理显示到屏幕上。</p>
<pre><code>public static void Blit(Texture src, RenderTexture dest);
public static void Blit(Texture src, RenderTextrue dest, Material mat, int pass = -1);
public static void Blit(Texture src, Material mat, int pass = -1);
</code></pre><p>参数pass的默认值胃-1，表示将会依次调用Shader内的所有Pass。否则，只会调用给定索引的Pass。</p>
<h2 id="使用深度和法线纹理"><a href="#使用深度和法线纹理" class="headerlink" title="使用深度和法线纹理"></a>使用深度和法线纹理</h2><h3 id="消融"><a href="#消融" class="headerlink" title="消融"></a>消融</h3><p>噪声纹理+透明度测试，我们使用对噪声纹理采样的结果和某个控制消融程度的阀值比较，如果小于阀值，就使用clip函数把它对应的像素裁减掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Test&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _BurnAmount(&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0 // 控制消融程度，0为正常，1完全消融</span><br><span class="line">        _LineWith(&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1 // 模拟烧焦效果的线宽，值越大，火焰边缘的蔓延范围越宽</span><br><span class="line">        _MainText (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125; // 漫反射纹理</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125; // 法线纹理</span><br><span class="line">        _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色</span><br><span class="line">        _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色</span><br><span class="line">        _BurnMap(&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123;&#125; // 消融纹理</span><br><span class="line">    &#125;   </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma vertex frag</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="水波效果"><a href="#水波效果" class="headerlink" title="水波效果"></a>水波效果</h3><p>在模拟实时水面的过程中，往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，在进行正常的反射+折射计算，得到最后的水面波动效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot;&#125;</span><br><span class="line">    GrabPass &#123;&quot;_RefractionTex&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先把SubShader的标签中渲染队列设置成Transparent，并把后面的RenderType设置为Opaque。把Queue设置成Transparent可以确保该物体渲染时，其他所有不透明的物体都已经被渲染到屏幕上了，否则就可能无法正确得到“透过水面看到的图像”。而设置RenderType则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/21/Unity-Shader-IntroductionToTopic1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/21/Unity-Shader-IntroductionToTopic1/" class="post-title-link" itemprop="url">Unity Shader第二部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-21 15:10:53" itemprop="dateCreated datePublished" datetime="2018-10-21T15:10:53+08:00">2018-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>在光学里，我们使用辐照度（irradiance）来量化光。对于平行光来说，它的辐照度可通过计算在垂直于l的单位平面上的单位时间内穿过的能量来得到。</p>
<h4 id="吸收和散射"><a href="#吸收和散射" class="headerlink" title="吸收和散射"></a>吸收和散射</h4><p>光线由光源发射出来后，就会与一些物体相交。通常，相交的结构有两个：散射（scattering）和吸收（absorption）。<br>散射只改变光线的方向，但不改变光线的密度和颜色。而吸收只改变光线的密度和颜色，但不改变光线的方向。</p>
<h4 id="BRDF光照模型"><a href="#BRDF光照模型" class="headerlink" title="BRDF光照模型"></a>BRDF光照模型</h4><p>我们已经了解了光线在和物体表面相交时会发生哪些现象。当已知光源位置和方向、视角方向时，我们就需要知道一个表面是和光照进行交互的。例如，当光线从某个方向照射到一个表面时，有多少光线被反射？反射的方向有哪些？而BRDF（Bidirectional Reflectance Distribution Function）就是用来回答这些问题的。当给定模型表面上的一个点时，BRDF包含了对该点外观的完整的描述。在图形学种，BRDF大多使用一个数学公式来表示，并且提供了一些参数来调整材质属性。通俗来讲，当给定入射光线的方向和辐照度后，BRDK可以给出某个出射方向上的光照能量分布。本章涉及的BRDF都是对真实场景进行理想化和简化后的模型，也就是说，它们并不能真实地反映物体和光线之间地交互，这些光照模型被成为是经验模型。尽管如此，这些经验模型仍然在实时渲染领域被应用了多年。</p>
<h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p>基本方法是，把进入到摄像机的光线分为4部分，每个部分使用一种方法来计算它的贡献度</p>
<ul>
<li>自发光(emissive)</li>
<li>高光反射(specular)</li>
<li>漫反射(diffuse)</li>
<li>环境光(ambient)</li>
</ul>
<h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><p>在标准光照模型中，使用一种被称为环境光的部分来近似模拟间接光照。环境光的计算非常简单，它通常是一个全局变量，即场景中的所有物体都使用这个环境光。下面的等式给出了计算环境光的部分：</p>
<p>$c<em>{ambient}=g</em>{ambient}$</p>
<h4 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h4><p>光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。标准光照模型使用自发光来计算这个部分的贡献度。它的计算也很简单，就是直接使用了该材质的自发光颜色：</p>
<p>$c<em>{emissive}=m</em>{emissive}$</p>
<p>通常在实时渲染中，自发光的表面往往并不会照亮周围的表面，也就是说，这个物体并不会被当成一个光源。</p>
<h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。<br>漫反射光照符合<strong>兰伯特定律（Lambert’s law）</strong>：反射光线的强度与表面发现和光源方向之间夹角的余弦值成正比。因此，漫反射部分的计算如下：</p>
<p>$c<em>{diffuse} = (c</em>{light} \cdot m_{diffuse})max(0, n \cdot I)$</p>
<h4 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h4><p>这里的高光反射是一种经验模型，也就是说，它并不完全符合真实世界中的高光反射现象。它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。<br>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。<br>反射计算公式：<br>$r = 2(\vec{n} \cdot I)\vec{n} - I$<br>推导公式见Light Reflect<br>这样，我们就可以利用Phong模型来计算高光反射的部分：</p>
<p><font size="4">$c<em>{spscular} = (c</em>{light} \cdot m<em>{specular})max(0, \vec{v} \cdot r)^{m</em>{glass}}$</font><br>其中，$m<em>{gloss}$是材质的<strong>光泽度（gloss）</strong>，也被称为<strong>反光度（shinness）</strong>。它用于控制高光区域的“亮点”有多宽，$m</em>{gloss}$越大，亮点就越小。$m<em>{spscular}$是材质的高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c</em>{light}则是光源的颜色和强度。$</p>
<h4 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a>单张纹理</h3><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><h4 id="纹理的属性"><a href="#纹理的属性" class="headerlink" title="纹理的属性"></a>纹理的属性</h4><h3 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h3><h4 id="高度纹理"><a href="#高度纹理" class="headerlink" title="高度纹理"></a>高度纹理</h4><h4 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h4><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><h4 id="法线纹理类型"><a href="#法线纹理类型" class="headerlink" title="法线纹理类型"></a>法线纹理类型</h4><h3 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h3><h3 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h3><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><h4 id="其他遮罩纹理"><a href="#其他遮罩纹理" class="headerlink" title="其他遮罩纹理"></a>其他遮罩纹理</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/20/Unity-Shader-IntroductionToTopic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/20/Unity-Shader-IntroductionToTopic/" class="post-title-link" itemprop="url">Unity Shader第一部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-20 17:48:36" itemprop="dateCreated datePublished" datetime="2018-10-20T17:48:36+08:00">2018-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="像素光-Pixel-Light"><a href="#像素光-Pixel-Light" class="headerlink" title="像素光 Pixel Light"></a>像素光 Pixel Light</h2><p>Unity中将平行光称作为像素光，第一个像素光是基础平行光，以LightMode=ForwardBase标签修饰，每多一个像素光都以LightMode=ForwardAdd标签修饰。<br>并不是所有的光源在运行时都会反射到物体上，而是根据Project的Quality中设置的像素光数量来渲染的。<br>默认的像素光的数量应该是2，我们有更多的平行光照在物体上，就需要在Edit-&gt;Project Setting-&gt;Quality中去调节像素光的数量Pixel Light Count<br>当场景中的实际像素光数量超过这个设定值的时候，Unity只会渲染最重要的光。</p>
<h2 id="关于像素光的叠加原理"><a href="#关于像素光的叠加原理" class="headerlink" title="关于像素光的叠加原理"></a>关于像素光的叠加原理</h2><p>片段着色器是要将mesh组件传递的信息最终计算为颜色(或者深度)存储在帧缓存(Frame Buffer)中。<br>每个Pass之间输出的颜色通过一定的公式进行混合。<br>在这里我们简单使用一比一的模式进行颜色混合，即混合指令为：<br><code>Blend One One</code><br>第二个Pass的代码同样的也直接复制第一个Pass即可，相应的将Tags标签中LightMode=ForwardBase修改为LightMode=ForwordAdd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Multi-Light Diffuse&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        // 材料颜色默认为黑色，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p>渲染流水线的工作任务在于由一个三维场景触发、生成（或者说渲染）一张二维图像。换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。<br>《Render-Time Rendering, Third Edition》将一个渲染流程分成3个阶段：<strong>应用阶段(Application Stage)、几何阶段(Geometry Stage)、光栅化阶段(Rasterizer Stage)</strong>。<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/shader.webp" title="渲染流水线"></p>
<h4 id="应用阶段（CPU处理）"><a href="#应用阶段（CPU处理）" class="headerlink" title="应用阶段（CPU处理）"></a>应用阶段（CPU处理）</h4><p>这一阶段是由开发者主导的，在这一阶段中开发都有3个主要的任务：<br>首先，需要准备好场景数据（摄像机位置，视锥体，模型和光源等）<br>接着，还需要做粗粒度的剔除工作<br>最后，需要设置好每个模型的渲染状态（使用的材质，使用的纹理，使用的Shader等）<br>这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，渲染图元可以是点，线，三角面等。</p>
<h4 id="几何阶段（GPU处理）"><a href="#几何阶段（GPU处理）" class="headerlink" title="几何阶段（GPU处理）"></a>几何阶段（GPU处理）</h4><p>几何阶段主要用于处理所有和我们绘制的几何相关的事情。几何阶段负责和每个渲染图元打交道，进行逐顶点，逐多边形的操作。这个阶段可以进一步分成更小的流水线阶段。<br>几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。<br>总结：输入的渲染图元-&gt;屏幕空间的二维顶点坐标、每个顶点对应深度、着色等信息</p>
<h3 id="光栅化阶段（GPU处理）"><a href="#光栅化阶段（GPU处理）" class="headerlink" title="光栅化阶段（GPU处理）"></a>光栅化阶段（GPU处理）</h3><p>将会使用上一个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。主要任务是决定每个渲染图元中的那些像素应该被绘制在屏幕上。<br><strong>顶点着色器（Vertex Shader）</strong>是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。<strong>曲面细分着色器（Tessellation Shader）</strong>是一个可选的着色器，<strong>几何着色器（Geometry Shader）</strong>同样是一个可选的着色器，它可以被用于执行逐图元（Per-Pimitive）的着色操作，或者被用于产生更多的图元。下一个流水线是<strong>裁剪（Clipping）</strong>，这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。这个阶段是可配置的。例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。几何概念阶段的最后一个流水线阶段是<strong>屏幕映射（Screen Mapping）</strong>。这一阶段是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中。<br>光栅化概念阶段中的<strong>三角形设置（Triangle Setup）</strong>和<strong>三角形遍历（Triangle Traversal）</strong>阶段也都是固定函数（Fixed-Function）的阶段。接下来的<strong>片元着色器（Fragment Shader）</strong>，则是完全可编程的，它用于实现逐片元（Per-Fragment）的着色操作。最后，<strong>逐片元操作（Per-Fragment Operations）</strong>阶段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，它不是可编程，但具有很高的可配置型。<br>Unity内置的DiffuseShader,也就是说我们创建一个Material出来时默认的Shader也是多光源的，所以这篇文章完成的Shader与默认的diffuse shader基本效果一致。</p>
<h2 id="2-2-CPU与GPU之间的通信"><a href="#2-2-CPU与GPU之间的通信" class="headerlink" title="2.2 CPU与GPU之间的通信"></a>2.2 CPU与GPU之间的通信</h2><p>渲染流水线的起点是CPU，即应用阶段。应用阶段可以分为下面3个阶段：</p>
<ul>
<li>把数据加载到显存中</li>
<li>设置渲染状态</li>
<li>调用Draw Call</li>
</ul>
<h3 id="2-2-1-把数据加载到显存中"><a href="#2-2-1-把数据加载到显存中" class="headerlink" title="2.2.1 把数据加载到显存中"></a>2.2.1 把数据加载到显存中</h3><p>基本步骤就是纹理、网格等数据从硬盘加载到系统内存在加载到显存中。数据记载到显存后系统内存中的数据就可以被移除了，但是对于一些数据来说CPU需要访问他们，例如用于碰撞检测用的网格数据，这些数据则会被保留。</p>
<h3 id="2-2-3-设置渲染状态"><a href="#2-2-3-设置渲染状态" class="headerlink" title="2.2.3 设置渲染状态"></a>2.2.3 设置渲染状态</h3><p>渲染状态指的是场景中的网格是如何被渲染的，例如使用哪个Vertex Shader或者哪个Fragment Shader、光源属性、材质等。</p>
<h3 id="2-2-3-调用Draw-Call"><a href="#2-2-3-调用Draw-Call" class="headerlink" title="2.2.3 调用Draw Call"></a>2.2.3 调用Draw Call</h3><p>Draw Call指的是一个命令，发起方为CPU，接收方为GPU。当给定了一个Draw Call时，GPU会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。而这个计算过程，就是我们下一节要讲的GPU流水线。</p>
<h2 id="2-3-GPU流水线"><a href="#2-3-GPU流水线" class="headerlink" title="2.3 GPU流水线"></a>2.3 GPU流水线</h2><p>当GPU从CPU那里得到渲染命令后，就会进行一系列流水线操作，最终把图元渲染到屏幕上。</p>
<h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><p>在上一节中，我们解释了在应用阶段，CPU是如何和GPU通信，并通过调用Draw Call来命令GPU进行渲染。GPU渲染的过程就是GPU流水线。</p>
<p>对于概念阶段的后两个阶段，即几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过实现流水线化，大大加快了渲染速度。虽然我们无法完全控制这两个阶段的实现细节，但GPU向开发者开放了很多控制权。在这一节中，我们将具体了解GPU是如何实现这两个概念阶段的。</p>
<p>几何阶段和光栅化阶段可以分为若干更小的流水线阶段，这些流水线阶段由GPU来实现，每个阶段GPU提供了不同的可配置性或可编程性。</p>
<h3 id="从应用程序阶段模型数据给顶点着色器时支持的语义"><a href="#从应用程序阶段模型数据给顶点着色器时支持的语义" class="headerlink" title="从应用程序阶段模型数据给顶点着色器时支持的语义"></a>从应用程序阶段模型数据给顶点着色器时支持的语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">POSITION</td>
<td style="text-align:left">模型空间的顶点位置，通常是float4类型</td>
</tr>
<tr>
<td style="text-align:left">NORMAL</td>
<td style="text-align:left">顶点法线，通常是float3类型</td>
</tr>
<tr>
<td style="text-align:left">TANGENT</td>
<td style="text-align:left">顶点切线，通常是float4类型</td>
</tr>
<tr>
<td style="text-align:left">TEXCOORDn,如TEXCOORD0、TEXCOORD1</td>
<td style="text-align:left">该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依次类推，通常是float2或float4类型</td>
</tr>
</tbody>
</table>
</div>
<p>其中TEXCOORDn中的数目是和Shader Model有关的，例如一般在Shader Model 2(即Unity默认编译到的Shader Model版本)和Shader Model 3中，n等于8，而在Shader Model 4 和Shader Model 5中，n等于16.通常情况下，一个模型的纹理坐标数组一般不超过2，即我们往往只只用TEXCOORD0和TEXCOORD1。在Unity内置的数据结构体appdata_full中，它最多使用了6个坐标纹理。</p>
<h3 id="从顶点着色器传递数据给片元着色器时的语义"><a href="#从顶点着色器传递数据给片元着色器时的语义" class="headerlink" title="从顶点着色器传递数据给片元着色器时的语义"></a>从顶点着色器传递数据给片元着色器时的语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SV_POSITION</td>
<td style="text-align:left">裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于Direct9中的POSITION，但最好使用SV_POSITION</td>
</tr>
<tr>
<td style="text-align:left">COLOR0</td>
<td style="text-align:left">通常用于输出第一组顶点颜色，但不是必须的</td>
</tr>
<tr>
<td style="text-align:left">COLOR1</td>
<td style="text-align:left">通常用于输出第二组顶点颜色，但不是必须的</td>
</tr>
<tr>
<td style="text-align:left">TEXCOORD0~TEXCOORD7</td>
<td style="text-align:left">通常用于输出纹理坐标，但不是必须的</td>
</tr>
</tbody>
</table>
</div>
<p>上面的语义中，除了SV_POSITION是有特别含意外，其他语义对变量的含义没有明确要求，也就是说，我们可以存储任意值到这些描述变量中。</p>
<h3 id="片元着色器输出时Unity支持的常用语义"><a href="#片元着色器输出时Unity支持的常用语义" class="headerlink" title="片元着色器输出时Unity支持的常用语义"></a>片元着色器输出时Unity支持的常用语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="点和矢量的区别"><a href="#点和矢量的区别" class="headerlink" title="点和矢量的区别"></a>点和矢量的区别</h4><p>点是一个没有大小之分的空间中的位置，而矢量是一个有模和方向但是没有位置的量。</p>
<h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>对于一个点，从三维坐标转换成齐次坐标是把w分量设为1，而对于方向矢量来说，需要把w分量设为0。</p>
<h4 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h4><p>我们可以使用矩阵乘法来表示对一个点进行平移变换：</p>
<p>$\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t<em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t</em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t<em>{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{1}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{x+t</em>{x}}\<br>{y+t<em>{y}}\<br>{z+t</em>{z}}\<br>{1}\<br>\end{bmatrix}$</p>
<p>从结果来看我们可以很容易看出为什么这个矩阵有平移的效果：点的x、y、z分量分别增加了一个位置偏移。在3D中的可视化效果是，把点$(x,y,z)$在空间中平移了$(t<em>{x},t</em>{y},t_{z})$。<br>如果我们对一个方向矢量进行平移变换，结果如下：</p>
<p>$\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t<em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t</em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t_{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{0}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{0}\<br>\end{bmatrix}$<br>可以发现，平移变换不会对方向矢量产生任何影响。因为矢量没有位置属性，也就是说它可以位于空间中的任意一点，因此对位置的改变不应该对四维矢量产生影响。</p>
<h4 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h4><p>我们可以对一个模型沿空间的x轴、y轴和z轴进行缩放。</p>
<p>$\begin{bmatrix}<br>{k<em>{x}}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{k</em>{y}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{k<em>{z}}&amp;{0}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\<br>{y}\<br>{z}\<br>{1}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{k</em>{x}x}\<br>{k<em>{y}y}\<br>{k</em>{z}z}\<br>{1}\<br>\end{bmatrix}$</p>
<p>如果缩放系数$k<em>{x}=k</em>{y}=k_{z}$，我们把这样的缩放称为统一缩放（uniform scale），否则称为非同一缩放（nonuniform scale）。从外观看，统一缩放是扩大整个模型，而非同一缩放会拉伸或挤压模型。更重要的是，统一缩放不会改变角度和比例信息。</p>
<h4 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h4><p>在绝大多数情况下，我们约定变换的顺序就是先缩放，再旋转，最后平移。<br>变换矩阵如下：(注意，矩阵是从右往左算的)<br>$<br>M<em>{translation}M</em>{rotation}M<em>{scale} =<br>\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t</em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t<em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t</em>{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>$<br>当我们直接给出$(\theta<em>{x}, \theta</em>{y}, \theta_{z})$这样的旋转角度时，需要定义一个旋转顺序。在Unity中，这个旋转顺序是zxy。</p>
<h3 id="顶点的坐标空间变化"><a href="#顶点的坐标空间变化" class="headerlink" title="顶点的坐标空间变化"></a>顶点的坐标空间变化</h3><p>在渲染流水线中，一个顶点要经过多个坐标空间的变换才能最终被画在屏幕上。一个顶点最开始是在模型空间中定义的，最后它将会变换到屏幕空间中，得到真正的屏幕像素坐标。</p>
<h4 id="模型空间"><a href="#模型空间" class="headerlink" title="模型空间"></a>模型空间</h4><p><strong>模型空间（model space）</strong>，是和某个模型或者说是对象有关的。有时模型空间也被称为<strong>对象空间（object space）</strong>或<strong>局部空间（local space）</strong>。每个模型都有自己独立的坐标空间，当它移动或旋转的时候，模型空间也会跟着它移动和旋转。<br>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做模型变换（model transform）。</p>
<h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做<strong>模型变换（model transform）</strong>。<br>变换矩阵如下：<br>$M<em>{model} = \begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t</em>{x}}\<br>{0}&amp;{1}&amp;{0}&amp;{t<em>{y}}\<br>{0}&amp;{0}&amp;{1}&amp;{t</em>{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{cos\theta}&amp;{0}&amp;{sin\theta}&amp;{0}\<br>{0}&amp;{1}&amp;{0}&amp;{0}\<br>{-sin\theta}&amp;{0}&amp;{cos\theta}&amp;{0}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{k<em>{x}}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{k</em>{y}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{k<em>{z}}&amp;{0}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{k</em>{x}cos\theta}&amp;{0}&amp;{k<em>{z}sin\theta}&amp;{t</em>{x}}\<br>{0}&amp;{k<em>{y}}&amp;{0}&amp;{t</em>{y}}\<br>{-k<em>{x}sin\theta}&amp;{0}&amp;{k</em>{z}cos\theta}&amp;{-t_{z}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}$<br>注意：上述变换顺序是不能互换的，即先进行缩放，在进行旋转，最后是平移。<br>因为每个Transform的平移旋转缩放都是不一样的，所以他们的矩阵也是不一样的。</p>
<h4 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h4><p>观察空间（view space）也被称为摄像机空间（camera space）。顶点变换的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换叫做观察变换（view transform）。</p>
<h4 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h4><p>裁剪空间（clip space，也称齐次裁剪空间），这个用于变换的矩阵叫做裁剪矩阵（clip matrix），也称为投影矩阵（projection matrix）。<br>裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。这块空间是由视锥体来决定的。<br>视锥体指的是空间中的一块区域，这块区域决定了摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为<strong>裁剪平面（clip planes）</strong>。视锥体有两种类型，一种是<strong>正交投影（orthographic projection）</strong>，一种是<strong>透视投影（perspective projection）</strong>。<br>在视锥体的6块裁剪平面中，有两块裁剪平面比较特殊，它们分别被称为<strong>近裁剪平面（near clip plane）</strong>和<strong>远裁剪平面（far clip plane）</strong>。它们决定了摄像机可以看到的深度范围。</p>
<h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><p>视锥体的意义在于定了场景中的一块三维空间。所有位于这块空间内的物体将会被渲染，否则就会被剔除或裁剪。这块区域是由6个裁剪平面组成，在Unity中，它们由Camera组件中的参数和Game视图中横纵比共同决定<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/3.jpg"><br>Camera组件的Field of View（简称FOV）属性来改变视锥体竖直方向的张开角度，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。<br>这样，我们可以求出视锥体近裁剪面和远裁剪面的高度</p>
<p>$nearClipPlaneHeight = 2 \cdot Near \cdot tan {FOV \over 2}$</p>
<p>$farClipPlaneHeight = 2 \cdot Far \cdot tan {FOV \over 2}$</p>
<p>透视投影的横向信息，可以通过相机的横纵比得到。在Unity中，一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定（实际上，Unity允许我们在脚本里通过Camera.aspect进行更改）。假设，当前相机的横纵比为Aspect，则：</p>
<p>$Aspect = {nearClipPlaneWidth \over nerClipPlaneHeight}$</p>
<p>$Aspect = {farClipPlaneWidth \over farClipPlaneHeight}$    </p>
<p>现在，我们可以根据已知的Near、Far、FOV和Aspect的值来确定透视投影的投影矩阵。如下：</p>
<p>$<br>M<em>{frustum} = \begin{bmatrix}<br>{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\<br>{0}&amp;{0}&amp;{-1}&amp;{0}\<br>\end{bmatrix}<br>$<br>这里针对的是观察空间是右手坐标系，使用列矩阵在矩阵右侧相乘的，且变换后z分量范围在[-w,w]之间的情况。<br>而一个顶点和上述投影矩阵相乘后，可以由观察空间变换到裁剪空间中，结果如下<br>$<br>P</em>{clip} = M<em>{frustum}P</em>{view} =<br>\begin{bmatrix}<br>{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\<br>{0}&amp;{0}&amp;{-1}&amp;{0}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\{y}\{z}\{1}\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>{x{cot{FOV \over 2} \over Aspect}}\{y{cot{FOV \over 2}}}\{-z{Far+Near \over Far-Near}-{2 \cdot Near \cdot Far \over Far-Near}}\{-z}\<br>\end{bmatrix}<br>$<br>从这个结果来看，这个投影矩阵本质就是对x、y和z分量进行了不同程度的缩放（z分量还有一个平移），缩放的目的是为了方便裁剪。此时顶点的w分量不再是1，而是原先z分量的取反结果。<br>现在，我们就可以按如下不等式来判断一个变换后的顶点是否位于视锥体内。如果一个顶点在视锥体内，那么它变换后的坐标必须满足：<br>$-w \le x \le w$<br>$-w \le y \le w$<br>$-w \le z \le w$<br>任何不满足上述条件的图元都需要被剔除或者裁剪。下图显示了经过上述投影矩阵后，视锥体的变化。<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/4.jpg" title="在透视投影中，投影矩阵对顶点进行了缩放。"><br>从上图还可以注意到，裁剪矩阵会改变空间的旋向行；空间从右手坐标系变换到了左手坐标系。这意味着，离摄像机越远，z值将越大。</p>
<h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/5.jpg" title="正交相机的参数对正交投影视锥体的影响">
<p>正交投影的6个裁剪面和透视投影类似，在Unity中，它们也是由Camera组件中的参数和Game视图的横纵比共同决定。<br>正交投影的视锥体是一个长方体，因此计算上相比透视投影来说更加简单。由图可以看出，我们可以通过Camera组件的Size属性来改变视锥体竖直方向上高度的一般，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。这样，可以求出视锥体近裁剪面和远裁剪面的高度，也就是：<br>$newClipPlaneHeight=2 \cdot Size$<br>$farClipPlaneHeight=nearClipPlaneHeight$</p>
<p>现在我们还缺乏横向的信息。同样，我们可以通过摄像机的横纵比得到。假设，当前摄像机的横纵比为Aspect，那么：<br>$nearClipPlaneWidth=Aspect \cdot nearClipPlaneHeight$<br>$farClipPlaneWidth=nearClipPlaneWidth$<br>现在，我们可以根据已知的Near、Far、Size和Aspect的值来确定正交投影的裁剪矩阵。如下：<br>$M_{prtho} =<br>\begin{bmatrix}<br>{1 \over Aspect \cdot Size}&amp;{0}&amp;{0}&amp;{0}\<br>{0}&amp;{1 \over Size}&amp;{0}&amp;{0}\<br>{0}&amp;{0}&amp;{-{2 \over Far-Near}}&amp;{-{Far+Near} \over {Far-Near}}\<br>{0}&amp;{0}&amp;{0}&amp;{1}\<br>\end{bmatrix}$</p>
<h4 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h4><p>经过投影矩阵的变换后，我们可以进行裁剪操作。当完成了所有的裁剪工作后，就需要进行真正的投影了，也就是说，我们需要把视锥体投影到<strong>屏幕空间（screen space）</strong>中。经过这一步变换，我们会得到真正的像素位置，而不是虚拟的三维坐标。<br>屏幕空间是一个二维空间，因此，我们必须把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标。这个过程可理解成有两个步骤。<br>首先，我们需要进行标准<strong>齐次除法（homogeneous division）</strong>，也被称为<strong>透视除法（perspective division）</strong>。虽然这个步骤听起来很陌生，但是它实际上非常简单，就是用齐次坐标系的w分量去除以x、y、z分量。在OpenGL中，我们把这一步得到的坐标叫做<strong>归一化的设备坐标（Normalized Device Coordinates，NDC）</strong>。经过这一步，我们可以把坐标从齐次裁剪坐标空间转换到NDC中。经过透视投影变换后的裁剪空间，经过齐次除法会变换到一个立方体内。按照OpenGL的传统，这个立方体的x、y、z分量的范围都是[-1,1]。但在DirectX这样的API中，z分量的范围会是[0,1]。而Unity选择了OpenGL这样的齐次裁剪空间。</p>
<img src="/2018/10/20/Unity-Shader-IntroductionToTopic/1.jpg" class="7.jpg% 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体} #### 总结 顶点着色器的最基本的任务就是把顶点坐标从模型空间转换到裁剪空间中。 {% asset_img" title="渲染流水线中顶点的空间变化过程"> 
<img src="/2018/10/20/Unity-Shader-IntroductionToTopic/2.jpg" title="Unity中各个坐标空间的旋向性">
<h3 id="一个最简单的顶点-片元着色器"><a href="#一个最简单的顶点-片元着色器" class="headerlink" title="一个最简单的顶点/片元着色器"></a>一个最简单的顶点/片元着色器</h3><h4 id="顶点-片元着色器的基本结构"><a href="#顶点-片元着色器的基本结构" class="headerlink" title="顶点/片元着色器的基本结构"></a>顶点/片元着色器的基本结构</h4><p>Unity Shader的基本结构包含了Shader、Properties、SubShader、Fallback等语义块。顶点/片元着色器的结构与之大体类似，它的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;MyShaderName&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        // 属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        // 针对显卡A的SubShader</span><br><span class="line">        Pass &#123;</span><br><span class="line">            // 设置渲染状态和标签</span><br><span class="line"></span><br><span class="line">            // 开始CG代码片段</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            // 该片段的编译指令，例如:</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            // CG代码写在这里</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">            // 其他设置</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他需要的Pass</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        // 针对显卡B的SubShader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 上述SubShader都失败后用于回调的Unity Shader</span><br><span class="line">    Fallback &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，最重要的部分是Pass语义块，我们绝大部分的代码都是写在这个语义块里面的。下面我们就来创建一个最简单的顶点/片元着色器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Shader/Simple&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITION &#123;</span><br><span class="line">                return UnityObjectToClipPos(v);</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag() : SV_Target&#123;</span><br><span class="line">                return fixed4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Shader/Simple1&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pargma fragment frag</span><br><span class="line">            // 使用一个结构体来定义顶点着色器的输入</span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                // POSITION语义告诉Unity，用模型空间的顶点坐标填充vertex变量</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模型数据从哪里来"><a href="#模型数据从哪里来" class="headerlink" title="模型数据从哪里来"></a>模型数据从哪里来</h4><h4 id="顶点着色器和片元着色器之间如何通信"><a href="#顶点着色器和片元着色器之间如何通信" class="headerlink" title="顶点着色器和片元着色器之间如何通信"></a>顶点着色器和片元着色器之间如何通信</h4><h4 id="如何使用属性"><a href="#如何使用属性" class="headerlink" title="如何使用属性"></a>如何使用属性</h4><h3 id="Unity提供的内置文件和变量"><a href="#Unity提供的内置文件和变量" class="headerlink" title="Unity提供的内置文件和变量"></a>Unity提供的内置文件和变量</h3><h4 id="内置的包含文件"><a href="#内置的包含文件" class="headerlink" title="内置的包含文件"></a>内置的包含文件</h4><h4 id="内置的变量"><a href="#内置的变量" class="headerlink" title="内置的变量"></a>内置的变量</h4><h3 id="Unity提供的CG-HLSL语义"><a href="#Unity提供的CG-HLSL语义" class="headerlink" title="Unity提供的CG/HLSL语义"></a>Unity提供的CG/HLSL语义</h3><h3 id="Unity支持的语义"><a href="#Unity支持的语义" class="headerlink" title="Unity支持的语义"></a>Unity支持的语义</h3><div class="table-container">
<table>
<thead>
<tr>
<th>语义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSITION</td>
<td>模型空间的顶点位置，通常是float4类型</td>
</tr>
<tr>
<td>NORMAL</td>
<td>顶点法线，通常是float3类型</td>
</tr>
<tr>
<td>TANGENT</td>
<td>顶点切线，通常是float4类型</td>
</tr>
<tr>
<td>$TEXCOORD_{n}$，如TEXCOORD0、TEXCOORD1</td>
<td>该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依此类推。通常是float2或float4类型</td>
</tr>
<tr>
<td>COLOR</td>
<td>顶点颜色，通常是fixed4或float4类型</td>
</tr>
</tbody>
</table>
</div>
<h4 id="如何定义复杂的变量类型"><a href="#如何定义复杂的变量类型" class="headerlink" title="如何定义复杂的变量类型"></a>如何定义复杂的变量类型</h4><h4 id="使用假彩色图形"><a href="#使用假彩色图形" class="headerlink" title="使用假彩色图形"></a>使用假彩色图形</h4><h4 id="float、half还是fixed"><a href="#float、half还是fixed" class="headerlink" title="float、half还是fixed"></a>float、half还是fixed</h4><p>在本书中，我们使用CG/HLSL来编写Unity Shader中的代码。而在CG/HLSL中，有3中精度的数值类型：float、half和fixed。这些精度将决定计算结果的数值范围。表5.8给出了这3中精度在通常情况下的数值范围。</p>
<p>CG/HLSL中3种精度的数值类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">最高精度的浮点值。通常使用32位来存储</td>
</tr>
<tr>
<td style="text-align:left">half</td>
<td style="text-align:left">中等精度的浮点值。通常用16位来存储，精度范围是-60000~+60000</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">最低精度的浮点值。通常使用11位来存储，精度方位是-2.0~+2.0</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/10/15/Unity-Shader-Manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/Unity-Shader-Manual/" class="post-title-link" itemprop="url">Unity Shader Manual</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 13:20:27" itemprop="dateCreated datePublished" datetime="2018-10-15T13:20:27+08:00">2018-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderLab Tutorials/TestShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Range (&quot;My Range&quot;, Range(0.02, 0.15)) = 0.07 // sliders</span><br><span class="line">        _Color (&quot;My Color&quot;, Color) = (.34, .85, .92, 1) // color</span><br><span class="line">        _2D (&quot;My Texture 2D&quot;, 2D) = &quot;&quot; &#123;&#125; // texture</span><br><span class="line">        _Rect (&quot;My Rectangle&quot;, Rect) = &quot;name&quot; &#123;&#125;</span><br><span class="line">        _Cube (&quot;My Cubemap&quot;, Cube) = &quot;name&quot; &#123;&#125;</span><br><span class="line">        _Float (&quot;My Float&quot;, Float) = 1</span><br><span class="line">        _Vector (&quot;My Vector&quot;, Vector) = (1,2,3,4)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Shader在Unity编辑器暴露给美术的参数，通过Properties来实现。</li>
<li>所有可能的参数如上所示。主要也就是Float、Vector和Texture这3类。</li>
<li>除了通过编辑器编辑Properties，脚本也可以通过Material的接口（比如SetFloat、SetTexture编辑）</li>
<li>之后的Shader程序通过[name]（固定管线）或者直接name（可编程Shader）访问这些属性。</li>
<li>在每一个Property前面也能类似C#那样添加Attribute，以达到额外UI功能。详见<h1 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h1><h1 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h1><h2 id="Tags-“TagName1”-”Value1”-“TagName2”-”Value2”"><a href="#Tags-“TagName1”-”Value1”-“TagName2”-”Value2”" class="headerlink" title="Tags{“TagName1”=”Value1” “TagName2”=”Value2”}"></a>Tags{“TagName1”=”Value1” “TagName2”=”Value2”}</h2>Tag的语法结构，通过Tags{}来表示需要添加的标识，大括号可以添加多组Tag（所以才叫Tags嘛），名称(TagName)和值（Value）是成对出现的，并且全部用字符串表示。</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>渲染队列直接影响性能中的重复绘制，合理的队列可极大的提升渲染效率。<br>渲染队列数目小于2500的对象都被认为是不透明的物体（从前往后渲染），高于2500的被任务是半透明物体（后后往前渲染）。<br>“Queue”=”Geometry+1”可通过值后加数字的方式来改变队列。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Queue标签</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>“Queue”=”Background”</td>
<td>值为1000，此队列的对象最先进行渲染</td>
</tr>
<tr>
<td>“Queue”=”Geometry”</td>
<td>默认值，值为2000，通常用于不透明对象，比如场景中的物体与角色等</td>
</tr>
<tr>
<td>“Queue”=”AlphaTest”</td>
<td>值为2450，要么完全透明要么完全不透明，多用于利用贴图来实现边缘透明的效果，也就是美术常说的透贴</td>
</tr>
<tr>
<td>“Queue”=”Transparent”</td>
<td>值为3000，常用于半透明对象，渲染时从后往前进行渲染，建议需要混合的对象放入此队列</td>
</tr>
<tr>
<td>“Queue”=”Overlay”</td>
<td>值为4000，此渲染队列用于叠加选过。最后渲染的东西应该放在这里（例如镜头光晕等）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="RenderType"><a href="#RenderType" class="headerlink" title="RenderType"></a>RenderType</h2><p>用来区分这个Shader要渲染的对象是属于什么类型的，你可以想象成事我们把不同的物体按我们需要的类型来进行分类一样。<br>当然你也可以根据需要改成自定义的名称，这样并不会影响到Shader的选过。<br>此Tag多用于摄像机的替换材质功能（Camera.SetReplacementShader）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“RenderType”=”Opaque”</td>
<td>大多数不透明着色器</td>
</tr>
<tr>
<td>“RenderType”=”Transparent”</td>
<td>大多数半透明着色器，比如粒子、特效、字体等。</td>
</tr>
<tr>
<td>“RenderType”=”TransparentCutout”</td>
<td>透贴着色器，多用于植被等。</td>
</tr>
<tr>
<td>“RenderType”=”Background”</td>
<td>多用于天空盒着色器。</td>
</tr>
<tr>
<td>“RenderType”=”Overlay”</td>
<td>GUI、光晕着色器等。</td>
</tr>
<tr>
<td>“RenderType”=”TreeOpaque”</td>
<td>Terrain地形中的树干。</td>
</tr>
<tr>
<td>“RenderType”=”TreeTransparentCutout”</td>
<td>Treeain地形中的树叶。</td>
</tr>
<tr>
<td>“RenderType”=”TreeBillboard”</td>
<td>Terrain地形中的永对面树。</td>
</tr>
<tr>
<td>“RenderType”=”Grass”</td>
<td>Terrain地形中的草。</td>
</tr>
<tr>
<td>“RenderType”=”GrassBillboard”</td>
<td>Terrain地形中的用对面草。</td>
</tr>
</tbody>
</table>
</div>
<p>指定RenderType的名称，主要是为了配合使用替代渲染的方法。</p>
<pre><code>Camera.SetReplacementShader(&quot;shader&quot;, &quot;RenderType&quot;)
</code></pre><h2 id="DisableBatching"><a href="#DisableBatching" class="headerlink" title="DisableBatching"></a>DisableBatching</h2><p>在利用Shader在模型的定点本地坐标下做一些位移动画，而当此模型有批处理时会出现效果不正确的情况，这是因为批处理将所有模型转换为世界坐标空间，因为”本地坐标空间”将丢失。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>批处理标签</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>“DisableBatching”=”True”</td>
<td>禁止批处理</td>
</tr>
<tr>
<td>“DisableBatching”=”False”</td>
<td>不禁用批处理</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="dot-a-b"><a href="#dot-a-b" class="headerlink" title="dot(a,b)"></a>dot(a,b)</h2><p>点乘，a和b必须为三维向量或者四维向量，其计算结果是两个向量夹角的余弦值，相当于a.x*b.x+a.y*b.y+a.z*b.z<br>a和b的位置无所谓前后，结果都是一样的</p>
<h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><pre><code>float3 objCenterPos = mul(unity_ObjectToWorld, float4(0,0,0,1)).xyz;
</code></pre><p>在Shader中获取当前模型的中心点，其实就是将(0,0,0)点从本地坐标转换到世界空间坐标下即可。</p>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(x)</td>
<td>Absolute value (per component)(每个组件).</td>
</tr>
<tr>
<td>acos(x)</td>
<td>Returns the arccosine(反余弦) of each component of x.</td>
</tr>
<tr>
<td>ceil(x)</td>
<td>Returns the smallest integer(最小整数) which is greater(大于) than or equal to x.</td>
</tr>
<tr>
<td>clip(x)</td>
<td>Discards(抛弃) the current pixel,if any component of x is less than zero.</td>
</tr>
<tr>
<td>cross(x,y)</td>
<td>x向量和y向量的向量积（叉积）</td>
</tr>
<tr>
<td>frac(x)</td>
<td>返回x的小数部分</td>
</tr>
<tr>
<td>lerp(x,y,s)</td>
<td>Returns x + s(y-x)</td>
</tr>
<tr>
<td>noise(x)</td>
<td>Generates a random value using the Perlin-noise algorithm.</td>
</tr>
<tr>
<td>pow(x,y)</td>
<td>Returns $x^y$</td>
</tr>
<tr>
<td>saturate(x)</td>
<td>x: 为用于操作的标量或矢量，可以是float、float2、float3等类型。把x截取在[0,1]范围内，如果x是一个矢量，那么会对它的每一个分量进行这样的操作。</td>
</tr>
<tr>
<td>smoothstep(min,max,x)</td>
<td>如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min,max]中，则返回0和1之间的值（返回值在min和max间的比例）。</td>
</tr>
<tr>
<td>step(a,b)</td>
<td>Returns (b&gt;=a)?1:0 (一般用这个取代if else)</td>
</tr>
<tr>
<td>tex2D(s, t)</td>
<td>2D texture lookup.</td>
</tr>
<tr>
<td>reflect(I,N)</td>
<td>根据入射光方向向量I，和顶点法向量N，计算反射光方向向量。其中I和N必须被归一化，需要非常注意的是，这个I是指向顶点的；函数只对三元向量有效</td>
</tr>
<tr>
<td>Tex2DProj(sampler2D tex, float3 sq)</td>
<td>二维投影纹理查询</td>
</tr>
<tr>
<td>Tex2DProj(sampler2D tex, float4 szq)</td>
<td>二维投影纹理查询，并进行深度值比较</td>
</tr>
</tbody>
</table>
</div>
<h1 id="pragma-fragementoption-ARB-precision-hint-fastest"><a href="#pragma-fragementoption-ARB-precision-hint-fastest" class="headerlink" title="#pragma fragementoption ARB_precision_hint_fastest"></a>#pragma fragementoption ARB_precision_hint_fastest</h1><p>ARB_precision_hint_fastest 是用最快的方式，以最低的精度运行，提升片段着色器的运行速度，减少时间。（通常是指FP16,16bit，半精度）牺牲表现换取运行速度。</p>
<h1 id="UnpackNormal"><a href="#UnpackNormal" class="headerlink" title="UnpackNormal"></a>UnpackNormal</h1><p><code>half3 normal = UnpackNormal(tex2D(_NormalMap, IN.uv_NormalMap));</code><br>UnpackNormal是定义在UnityCG.cginc文件中的方法，UnpackNormal接受一个fixed4的输入，并将其转换为所对应的法线值(fixed3)。</p>
<h1 id="TANGENT-SPACE-ROTATION"><a href="#TANGENT-SPACE-ROTATION" class="headerlink" title="TANGENT_SPACE_ROTATION"></a>TANGENT_SPACE_ROTATION</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 binormal = cross(v.normal,v.tangent.xyz)*v.tangent.w;</span><br><span class="line">flaot3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal);</span><br></pre></td></tr></table></figure>
<p>也就是构造出tangent space的坐标系，定义转换world space的向量到tangent space的rotation矩阵。</p>
<h1 id="UNITY-MATRIX-IT-MV"><a href="#UNITY-MATRIX-IT-MV" class="headerlink" title="UNITY_MATRIX_IT_MV"></a>UNITY_MATRIX_IT_MV</h1><p>专门用于将发现从模型空间变换到观察空间，为UNITY_MATRIX_MV的逆转置矩阵，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/09/21/TSF4G/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/21/TSF4G/" class="post-title-link" itemprop="url">TSF4G</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-21 13:40:15" itemprop="dateCreated datePublished" datetime="2018-09-21T13:40:15+08:00">2018-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/johnnyluo586/TSF4G.git" target="_blank" rel="noopener">https://github.com/johnnyluo586/TSF4G.git</a></p>
<h1 id="Tbus简介"><a href="#Tbus简介" class="headerlink" title="Tbus简介"></a>Tbus简介</h1><p>Tbus是tsf4g(Tencent ServiceFramework for Game,腾讯游戏服务框架)中的基础组件之一，主要的目的是为上层业务提供统一的线程或进程间通信接口，屏蔽本地进程间通信以及远程进程通信的细节，让开发人员可以集中精力关注业务逻辑，是tsf4g重要组成部分。</p>
<h1 id="Tbus原理"><a href="#Tbus原理" class="headerlink" title="Tbus原理"></a>Tbus原理</h1><p> Tbus基于共享内存构建无锁双通循环消息队列，发送的双方通过专用的读写队列完成数据收发，实现本地进程或者远程进程间通信。通信双方使用的两个队列称之为tbus通道(channel)，每一组通讯的双方就需要有一个tbus通道。</p>
<p> 进程A发送消息后，消息被存储到Host A的发送队列中，部署于Host A的tbusd发现队列中存在消息，则从队列中把消息取出，通过tcp发送到Host B上。Host B上的tbusd接收到消息后，把消息写入本地的接收队列，以供进程B读取。</p>
<p> 为了能完成通信，Tbus还有以下几个特点：<br> 通信双方具备全局唯一的tbus通信地址，该地址是一个点分十进制的字符串，与IP地址类型，总长度为32bit，分为4段，每段bit位数可以自定义，总长度不超过32bit。例如：128.1.100.1,5.0.200.1。</p>
<p> Tbus通道以及消息是存储在共享内存中，必须要使用相应的工具提前创建，进程才能绑定与使用。而当业务进程异常退出后，由于消息是存储在共享内存中，只要不主动清理共享内存、重启服务器或损坏共享内存，通道的消息就不会丢失。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/09/18/Unity-Lua-Manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/18/Unity-Lua-Manual/" class="post-title-link" itemprop="url">Unity-Lua-Manual</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-18 12:10:28" itemprop="dateCreated datePublished" datetime="2018-09-18T12:10:28+08:00">2018-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h2><h3 id="GO-name"><a href="#GO-name" class="headerlink" title="GO_name"></a>GO_name</h3><pre><code>gameObject.GO_name = &quot;name&quot;
</code></pre><p>设置或者获取游戏对象的名字</p>
<h3 id="GO-self"><a href="#GO-self" class="headerlink" title="GO_self"></a>GO_self</h3><pre><code>gameObject.GO_self
</code></pre><p>绑定到自己身上的Lua模块指针</p>
<h3 id="GO-active"><a href="#GO-active" class="headerlink" title="GO_active"></a>GO_active</h3><pre><code>gameObject.GO_active = true/false
</code></pre><p>设置游戏对象的显式或者隐藏</p>
<h3 id="GO-parent"><a href="#GO-parent" class="headerlink" title="GO_parent"></a>GO_parent</h3><pre><code>gameObject.GO_parent = parent
</code></pre><p>设置游戏对象的父节点</p>
<h3 id="GO-childCount"><a href="#GO-childCount" class="headerlink" title="GO_childCount"></a>GO_childCount</h3><pre><code>gameObject.GO_childCount
</code></pre><p>获取游戏对象的子节点对象，不递归</p>
<h3 id="GO-AddComponent"><a href="#GO-AddComponent" class="headerlink" title="GO_AddComponent"></a>GO_AddComponent</h3><pre><code>gameObject:GO_AddComponent(“UILabel&quot;)
</code></pre><p>给游戏对象添加组件</p>
<h3 id="GO-GetComponent"><a href="#GO-GetComponent" class="headerlink" title="GO_GetComponent"></a>GO_GetComponent</h3><pre><code>gameObject:GO_GetComponent(&quot;UILabel&quot;)
gameObject:GO_GetComponent(&quot;UILabel&quot;, &quot;Sprite/Label&quot;)
</code></pre><p>方法一：获取游戏对象的组件<br>方法二：获取子节点上的组件，参数二表示相对于父节点的路径</p>
<h3 id="GO-Find"><a href="#GO-Find" class="headerlink" title="GO_Find"></a>GO_Find</h3><pre><code>gameObject:GO_Find(&quot;Sprite/Label&quot;)
</code></pre><p>获取子节点对象</p>
<h3 id="GO-AddChild"><a href="#GO-AddChild" class="headerlink" title="GO_AddChild"></a>GO_AddChild</h3><pre><code>gameObject:GO_AddChild(&quot;UI/ui_node&quot;)
gameObject:GO_AddChild(ui_node)
</code></pre><p>方法一：通过相对于Resources下的路径来给游戏对象添加子节点<br>方法二：通过实例对象来给游戏对象添加子节点<br>如果是UI节点，请使用<strong><em>UI_AddChild</em></strong></p>
<h3 id="UI-AddChild"><a href="#UI-AddChild" class="headerlink" title="UI_AddChild"></a>UI_AddChild</h3><pre><code>gameObject:UI_AddChild(&quot;UI/ui_node&quot;)
gameObject:UI_AddChild(ui_node)    
</code></pre><p>方法一：通过相对于Resources下的路径来给游戏对象添加子节点<br>方法二：通过实例对象来给游戏对象添加子节点</p>
<h3 id="GO-DelChild"><a href="#GO-DelChild" class="headerlink" title="GO_DelChild"></a>GO_DelChild</h3><pre><code>gameObject:GO_DelChild(idx)
</code></pre><p>删除游戏对象的子节点，idx是下标从0开始的索引（顺序是检视面板显示的顺序）</p>
<h3 id="GO-DestroySelf"><a href="#GO-DestroySelf" class="headerlink" title="GO_DestroySelf"></a>GO_DestroySelf</h3><pre><code>gameObject:GO_DestroySelf()
</code></pre><p>销毁自己</p>
<h3 id="GO-RemoveAllChildren"><a href="#GO-RemoveAllChildren" class="headerlink" title="GO_RemoveAllChildren"></a>GO_RemoveAllChildren</h3><pre><code>gameObject:GO_RemoveAllChildren()
</code></pre><p>销毁所有的子节点</p>
<h3 id="GO-ShowAllChildren"><a href="#GO-ShowAllChildren" class="headerlink" title="GO_ShowAllChildren"></a>GO_ShowAllChildren</h3><pre><code>gameObject:GO_ShowAllChildren(ture/false)
</code></pre><p>显示或者隐藏自己所有的子节点</p>
<h3 id="GO-GetLocalPosition"><a href="#GO-GetLocalPosition" class="headerlink" title="GO_GetLocalPosition"></a>GO_GetLocalPosition</h3><pre><code>local x,y,z = gameObject:GO_GetLocalPosition()
</code></pre><p>获取自己的localPosition</p>
<h3 id="GO-SetLocalPosition"><a href="#GO-SetLocalPosition" class="headerlink" title="GO_SetLocalPosition"></a>GO_SetLocalPosition</h3><pre><code>gameObject:GO_SetLocalPosition(x,y [,z])
</code></pre><p>设置自己的localPosition,[] 表示可选参数,当未指定时表示使用之前的z</p>
<h3 id="GO-GetLocalRotation"><a href="#GO-GetLocalRotation" class="headerlink" title="GO_GetLocalRotation"></a>GO_GetLocalRotation</h3><pre><code>local x,y,z = gameObject:GO_GetLocalRotation()
</code></pre><p>获取自己的localRotation</p>
<h3 id="GO-SetLocalRotation"><a href="#GO-SetLocalRotation" class="headerlink" title="GO_SetLocalRotation"></a>GO_SetLocalRotation</h3><pre><code>gameObject:GO_SetLocalRotation(x,y [,z])
</code></pre><p>设置自己的localRotation,[]表示可选参数,当未指定时表示使用之前的z</p>
<h3 id="GO-SetLocalScale"><a href="#GO-SetLocalScale" class="headerlink" title="GO_SetLocalScale"></a>GO_SetLocalScale</h3><pre><code>gameObject:GO_SetLocalScale(x,y,z)
</code></pre><p>设置自己的localScale</p>
<h3 id="GO-UpdateAllAnchors"><a href="#GO-UpdateAllAnchors" class="headerlink" title="GO_UpdateAllAnchors"></a>GO_UpdateAllAnchors</h3><pre><code>gameObject:GO_UpdateAllAnchors()
</code></pre><p>手动刷新自身的锚点</p>
<h3 id="UI-active"><a href="#UI-active" class="headerlink" title="UI_active"></a>UI_active</h3><pre><code>gameObject.UI_active = true/false
</code></pre><p>递归刷新自己和子节点的显示和隐藏，如无特殊要求请使用<strong><em>GO_active</em></strong></p>
<h3 id="UI-onClick"><a href="#UI-onClick" class="headerlink" title="UI_onClick"></a>UI_onClick</h3><pre><code>gameObject.UI_onClick = function()
end
</code></pre><p>添加点击事件，游戏对象需要添加boxcollider2D</p>
<h3 id="UIToggle-onChange"><a href="#UIToggle-onChange" class="headerlink" title="UIToggle_onChange"></a>UIToggle_onChange</h3><pre><code>gameObject.UIToggle_onChange = function()
end
</code></pre><p>添加Toggle状态改变的回调函数，游戏对象需要添加UIToggle</p>
<h3 id="UILabel-text"><a href="#UILabel-text" class="headerlink" title="UILabel_text"></a>UILabel_text</h3><pre><code>gameObject.UILabel_text = &quot;Hello, World!&quot;
</code></pre><p>设置或者读取游戏对象的UILabel文本，游戏对象需要添加UILabel</p>
<h3 id="UILabel-color"><a href="#UILabel-color" class="headerlink" title="UILabel_color"></a>UILabel_color</h3><pre><code>gameObject.UILabel_color = Color.FromHex(&quot;C4C4C4FF&quot;)
</code></pre><p>设置或者读取文本颜色，返回值是Color</p>
<h3 id="UISprite-spriteName"><a href="#UISprite-spriteName" class="headerlink" title="UISprite_spriteName"></a>UISprite_spriteName</h3><pre><code>gameObject.UISprite_spriteName = &quot;btn_blue&quot;
</code></pre><p>设置或者读取精灵的名字，游戏对象需要添加UISprite组件</p>
<h3 id="UISprite-color"><a href="#UISprite-color" class="headerlink" title="UISprite_color"></a>UISprite_color</h3><pre><code>gameObject.UISprite_color = Color.FormHex(&quot;6f4f3fff&quot;)
</code></pre><p>设置或者读取精灵的颜色，游戏对象需要添加UISprite组件</p>
<h3 id="UIToggle-value"><a href="#UIToggle-value" class="headerlink" title="UIToggle_value"></a>UIToggle_value</h3><pre><code>gameObject.UIToggle_value = true/false
</code></pre><p>设置UIToggle的值</p>
<h3 id="UIWidget-color"><a href="#UIWidget-color" class="headerlink" title="UIWidget_color"></a>UIWidget_color</h3><pre><code>gameObject.UIWidget_color = Color.FormHex(&quot;6f4f3fff&quot;)
</code></pre><p>设置UIWidget或者继承他的子类（UILabel,UISprite)的颜色</p>
<h3 id="UIWidget-width"><a href="#UIWidget-width" class="headerlink" title="UIWidget_width"></a>UIWidget_width</h3><pre><code>gameObject.UIWidget_width = 100
</code></pre><p>设置UIWidget或者继承他的子类（UILabel,UISprite)的宽度</p>
<h3 id="UIWidget-height"><a href="#UIWidget-height" class="headerlink" title="UIWidget_height"></a>UIWidget_height</h3><pre><code>gameObject.UIWidget_height = 100
</code></pre><p>设置UIWidget或者继承他的子类的高度</p>
<h3 id="UIGrid-Reposition"><a href="#UIGrid-Reposition" class="headerlink" title="UIGrid_Reposition"></a>UIGrid_Reposition</h3><pre><code>gameObject:UIGrid_Reposition()
</code></pre><p>使Grid重新排序，一般给Grid添加了子节点后使用</p>
<h3 id="Tween-Play"><a href="#Tween-Play" class="headerlink" title="Tween_Play"></a>Tween_Play</h3><pre><code>gameObject:Tween_Play()
</code></pre><p>播放Tween动画</p>
<h2 id="MB"><a href="#MB" class="headerlink" title="MB"></a>MB</h2><h3 id="MB-Log"><a href="#MB-Log" class="headerlink" title="MB.Log"></a>MB.Log</h3><pre><code>MB.Log(&quot;Hello,World!&quot;)
</code></pre><p>打印日志</p>
<h3 id="MB-PCall"><a href="#MB-PCall" class="headerlink" title="MB.PCall"></a>MB.PCall</h3><pre><code>MB.PCall(function()
end)
</code></pre><p>安全的调用函数，当函数内部发生错误的时候，不会中断当前执行环境</p>
<h3 id="MB-LoadModule"><a href="#MB-LoadModule" class="headerlink" title="MB.LoadModule"></a>MB.LoadModule</h3><pre><code>MB.LoadModule(&quot;ui_task&quot;)
</code></pre><p>加载一个lua模块</p>
<h3 id="MB-ShowTheTip"><a href="#MB-ShowTheTip" class="headerlink" title="MB.ShowTheTip"></a>MB.ShowTheTip</h3><pre><code>MB.ShowTheTip(&quot;Hello,World!&quot;, 2)
</code></pre><p>弹出Tips，第二个参数表示时长单位是秒</p>
<h3 id="String-CSFormat"><a href="#String-CSFormat" class="headerlink" title="String.CSFormat"></a>String.CSFormat</h3><pre><code>String.CSFormat(&quot;id={0},name={1}&quot;,10,&quot;test&quot;)
</code></pre><p>调用C#的格式化函数</p>
<h3 id="MB-GetStringX"><a href="#MB-GetStringX" class="headerlink" title="MB.GetStringX"></a>MB.GetStringX</h3><pre><code>MB.GetStringX(bytes[], 10, &quot;test&quot;)
</code></pre><p>调用C#的格式化函数，第一个参数是byte数组，一般来说表格中的字段用它</p>
<h3 id="MB-GetExcelList"><a href="#MB-GetExcelList" class="headerlink" title="MB.GetExcelList"></a>MB.GetExcelList</h3><pre><code>MB.GetExcelList(&quot;NewTaskResConf&quot;)
</code></pre><p>读取表格</p>
<h3 id="MB-GO-GetResource"><a href="#MB-GO-GetResource" class="headerlink" title="MB.GO_GetResource"></a>MB.GO_GetResource</h3><pre><code>self.u_testSprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;)
</code></pre><p>获取资源 参数表示相对于Resources的路径，返回的是GameObject</p>
<h2 id="UITexture"><a href="#UITexture" class="headerlink" title="UITexture"></a>UITexture</h2><h3 id="SetTexturePath"><a href="#SetTexturePath" class="headerlink" title="SetTexturePath"></a>SetTexturePath</h3><pre><code>texture:SetTexturePath(&quot;Texture/UI/Chapter1&quot;)
</code></pre><p>设置texture的资源路径，路径相对于Resources，texture是通过gameObject获取的组件</p>
<h3 id="SetMat"><a href="#SetMat" class="headerlink" title="SetMat"></a>SetMat</h3><pre><code>texture:SetMat(path)
</code></pre><p>设置texture的材质，path表示相对Resources路径</p>
<h2 id="UILable"><a href="#UILable" class="headerlink" title="UILable"></a>UILable</h2><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><pre><code>label.text = &quot;Hello, World！&quot;
</code></pre><p>设置或者读取Label的文本</p>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><pre><code>label.color = Color.FromHex(&quot;6F4F3FFF&quot;)
</code></pre><p>设置或者读取Label的颜色</p>
<h3 id="effectColor"><a href="#effectColor" class="headerlink" title="effectColor"></a>effectColor</h3><pre><code>label.effectColor = Color.FromHex(&quot;6F4F3FFF&quot;)
</code></pre><p>设置或者读取Label的效果颜色</p>
<h3 id="fontSize"><a href="#fontSize" class="headerlink" title="fontSize"></a>fontSize</h3><pre><code>label.fontSize = 20
</code></pre><p>设置或者读取字体的大小</p>
<h2 id="UISprite"><a href="#UISprite" class="headerlink" title="UISprite"></a>UISprite</h2><h3 id="spriteName"><a href="#spriteName" class="headerlink" title="spriteName"></a>spriteName</h3><pre><code>sprite.spriteName = &quot;btn_red&quot;
</code></pre><p>设置或者读取Sprite的名字（图集中的）</p>
<h3 id="width"><a href="#width" class="headerlink" title="width"></a>width</h3><pre><code>sprite.width = 100
</code></pre><p>设置或者读取Sprite的宽度</p>
<h3 id="height"><a href="#height" class="headerlink" title="height"></a>height</h3><pre><code>sprite.height = 100
</code></pre><p>设置或者读取Sprite的高度</p>
<h3 id="atlas"><a href="#atlas" class="headerlink" title="atlas"></a>atlas</h3><pre><code>sprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;)
</code></pre><p>设置或者读取图集</p>
<h2 id="LuaEvent"><a href="#LuaEvent" class="headerlink" title="LuaEvent"></a>LuaEvent</h2><p>C#中</p>
<pre><code>LuaEvent.CallEvent((int)eLuaEvnet.eLuaEvent_PlayerTaskUpdate, param1, param2, param3);
</code></pre><p>lua中</p>
<pre><code>lua_event.InvokeEvent(lua_def.eLuaEvent_PlayerTaskUpdate, param1, param2, param3)

lua_event.InsertEvent(lua_def.eLuaEvent_PlayerTaskUpdate, callback, name, 0)
function callback(param1, param2, param3)

end
</code></pre><p>CallEvent表示C#事件通知Lua<br>InvokeEvent表示Lua事件通知Lua<br>LuaEvent.CallEvent中的第一个参数表示类型在obj_def.cs中定义，后面是需要传递给lua的参数</p>
<h2 id="lua-net"><a href="#lua-net" class="headerlink" title="lua_net"></a>lua_net</h2><h3 id="SendBin"><a href="#SendBin" class="headerlink" title="SendBin"></a>SendBin</h3><pre><code>lua_net.SendBin(lua_def.CS_CMD_GET_TASK_LIST_REQ, {Page = 1, Type = 4}, callback)
function callback(msg)
end
</code></pre><p>发送二进制包，第一个参数是消息ID，第二个参数是相对于数据结构类型，callback是回调函数，可选类型<br>回调函数中的msg表示一个json的xml中结构。</p>
<h3 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h3><pre><code>lua_net.Send(lua_def.eCTS_UI_Task, {op = &quot;get&quot;})
</code></pre><p>发送JSON包，第一个参数是cts_def.cs中定义的消息，第二个参数是lua table</p>
<h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><pre><code>lua_net.Register(lua_def.eSTC_UI_Task, OnUITaskHandle, signal, -1)
function OnUITaskHandler(msg)
end
lua_net.Register(lua_def.CS_CMD_GET_TASK_LIST_RES, OnGetTaskListRes, signal, -1)
function OnGetTaskListRes(msg) -- msg是xml生成的数据结构，传到lua里面是一个json table
end
</code></pre><p>注册一个消息回调，signal表示一个回调的唯一句柄，-1表示调用该回调函数的顺序，默认是0</p>
<h2 id="lua-timer"><a href="#lua-timer" class="headerlink" title="lua_timer"></a>lua_timer</h2><pre><code>lua_timer.Timer(self.gameObject, span, onTick, count, name)
</code></pre><p>— 创建Timer对象<br>— go : 指定挂到某个gameObject上<br>— span : 时间间隔，毫秒<br>— onTick : 回调函数(timer, dt)，回调的dt参数是超时的时间，一般也用不上<br>— count : 重复次数，缺省是1，如果是-1则无限循环。<br>— <em>return</em> : 返回一个lua table作为Timer</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/09/10/luajit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/10/luajit/" class="post-title-link" itemprop="url">luajit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-10 11:20:52" itemprop="dateCreated datePublished" datetime="2018-09-10T11:20:52+08:00">2018-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JIT = Just In Time<br>IOS中禁止使用（不让自主申请内存）</p>
<h2 id="解释执行："><a href="#解释执行：" class="headerlink" title="解释执行："></a>解释执行：</h2><ul>
<li>效率低</li>
<li>代码暴露</li>
</ul>
<h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><ul>
<li>不够灵活，无法热更新</li>
<li>平台兼容性差</li>
</ul>
<h2 id="JIT："><a href="#JIT：" class="headerlink" title="JIT："></a>JIT：</h2><ul>
<li>效率：高于解释执行，低于静态编译。</li>
<li>安全性：一般都先转换成字节码</li>
<li>热更新：无论源码还是字节码本质都是自愿文件。</li>
<li>兼容性：虚拟机会处理平台差异，对用户透明。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
