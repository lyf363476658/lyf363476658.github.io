<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/11/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/22/frame-sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/22/frame-sync/" class="post-title-link" itemprop="url">帧锁定同步(frame lock sync)按帧同步（frame sync）状态同步(state sync)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-22 19:48:47" itemprop="dateCreated datePublished" datetime="2019-04-22T19:48:47+08:00">2019-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="帧锁定同步-frame-lock-sync-lockstep"><a href="#帧锁定同步-frame-lock-sync-lockstep" class="headerlink" title="帧锁定同步(frame lock sync)lockstep"></a>帧锁定同步(frame lock sync)lockstep</h1><p>这个概念大家的理解基本都是一致的。准确的说，应该叫frame lockstep sync。但因为lockstep sync基本都是针对帧的（至少我现在想不出其他用法），把lockstep sync和frame lock sync直接画等号也没啥问题。<br>lockstep sync这个东西，最大的特点则是：</p>
<p>每一帧的运算都要依赖上一帧的数据，也就是所谓的上下文强相关。</p>
<p>每帧的数据，都是通过上一帧的数据通过相同的输入参数再次计算出来的，只要上一帧有一点点的不同，后面的结果就会完全不同。所以导致了lockstep在获得它的唯一优点（同步数据少）的同时，有了一些闹心的缺点：</p>
<ol>
<li>对误差极度敏感，任何差错都会因为产生蝴蝶效应被放大</li>
<li>所有逻辑都必须计算（包括视野外的），导致客户端运算量增加</li>
<li>因为整个游戏状态都必须存在于客户端，数据对“外挂”透明。</li>
<li>当本地状态遗失后（断网或应用崩溃），必须获得一个非常大的数据包来恢复状态，因为必须包含视野外，以及一些客户端本不需要关心的内容。</li>
</ol>
<p>当然，上述缺点在特定情况并不算是缺点，比如对于Moba类游戏而言，场景小，物体数量少，那么整个场景的总数据量也不是很大，增加的运算量也可以接受。对于2v2的格斗游戏就更不用说了，这些都是原本lockstep的标准应用样例。</p>
<p>但这时候肯定就有人说了，“帧同步的优点”并不是只有“数据量少”这一个啊，他还有帕拉啪啦啪啦……</p>
<p>没错“按帧同步”(frame sync)的优点确实没有帧锁定同步(frame lock sync)这么少。</p>
<p>当然，事实上其实并没有frame sync这样一个词在流传。但是从“帧同步”这个词的字面意思，正常人都会往这边理解成frame sync好吧？</p>
<p>把帧锁定同步(frame lock sync)缩写成帧同步(frame sync)，便是一切恶的根源。<br>而按帧同步（frame sync），按字面就是以一帧数据为单位进行同步，按照分词结构，帧锁定同步(frame lock sync)必定是按帧同步（frame sync），也就是这样的关系。</p>
<p>lockstep是用来交换流畅性的特性是公平性，这个特性其实和一致性有所类似。我们和其他玩家一起游戏的时候，有时候不希望对方因为电脑速度比较快，网络比较好，而能比我们更早的看到游戏的运行结果，从而提早作出操作。这一点在格斗对打游戏（如《街霸》）里面非常关键，在一些RTS（《星际争霸》）里面，提早看到游戏运行结果也是很有竞争优势的。因此我们为了让网络、硬件不一样的玩家能公平游戏，往往会使用一种叫“锁步”的策略：就好像一串绑着脚镣的囚犯，他们只能一起抬起左脚，然后再一起抬起右脚的走路，谁也不能走的更快。技术上的实现，就是每个客户端都定时（每N个渲染帧）发送一个网络帧到服务器上，就算玩家没操作，也类似心跳的这样发送空数据帧，所有客户端都要完整的收到所有的其他客户端的“心跳帧”才能开始运算一次游戏逻辑。这就是让所有的客户端，都互相等待，如果任何一个客户端卡了，其他的客户端都立刻就能知道，然后弹出界面让玩家停止输入来等待。因此在很多场合，帧同步的技术也被成为“<strong>锁步</strong>”技术，事实上，在没有统一的Relay Server服务器的时代（IPX局域网连机对战的时代），帧同步的网络帧其实就是上面所说的某个客户端的“心跳帧”，是由某个客户端产生并广播的（比如以前的局域网游戏，都会由一个客户端充当Host主机）。在《星际争霸》连机游戏中，如果有一个玩家掉线了，所有其他玩家就会发现有一个界面弹出来挡住画面，表示在等某某某。这种做法实际上是牺牲了流畅度的，因为你会发现一旦有网络、硬件卡的玩家加入游戏，所有其他玩家都受他的影响。为了减少这种对流畅度的影响，我们可以在需要“锁步”的时候，尽量少锁一点，比如不是发现缺了一帧就停下来，而是缺了若干帧，还是可以以“不公平”的方式继续玩一会儿（比如几秒），如果这段时间内还是没有补齐所缺的帧，才宣布锁住游戏等待。当然这个“容忍”的帧数我们可以调节到“最大”——就是没有。那么一个完全不锁步的游戏，肯定不是一个公平的游戏，但是也会在流畅性产生最大的好处，就是完全不受其他玩家影响。在那些不是PVP（玩家对战）的帧同步游戏中，不公平这个往往问题不大。我们完全可以在游戏的不同玩法里，打开、调整、甚至关闭这个“锁步”的机制，从而让游戏最大程度的平衡公平性和流畅性。<br><img src="/2019/04/22/frame-sync/9.jpg"></p>
<img src="/2019/04/22/frame-sync/1.jpg">
<p>也就是一个包含关系。帧锁定同步(frame lock sync)一定包含lock sync的所有优点和缺点，但帧同步未必包含lockset的优缺点——假如，帧同步仅仅是按帧同步frame sync，而不是帧锁定同步的“简称”的话。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p>它的开发效率比较高。如果你开发思路的整体框架是验证可行的，如果你把它的缺点解决了，那么你的开发思路完全就跟写单机一样，你只需要遵从这样的思路，尽量保证性能，程序该怎么写就怎么写。<br>比如我们以前要在状态同步下面做一个复杂的技能，有很多段位的技能，可能要开发好几天，才能有一个稍微过得去的结果，而在帧同步下面，英雄做多段位技能很可能半天就搞定了。</p>
</li>
<li><p>它能实现更强的打击感，打击感强除了我们说的各种反馈、特效、音效外，还有它的准确性。利用帧同步，游戏里面看到这些挥舞的动作，就能做到在比较准确的时刻产生反馈，以及动作本身的密度也可以做到很高的频率，这在状态同步下是比较难做的。</p>
</li>
<li>它的流量消耗是稳定的。大家应该看过《星级争霸》的录像，它只有几百K的大小，这里面只有驱动游戏的输入序列。帧同步只会随着玩家数量的增多，流量才会增长，如果玩家数量固定的话，不管你的游戏有多复杂，你的角色有多少，流量消耗基本上都是稳定的。这点延伸开来还有一个好处，就是可以更方便地实现观战，录像的存储、回放，以及基于录像文件的后续处理。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p>最致命的缺点是网络要求比较高，帧同步是锁帧的，如果有网络的抖动，一段时间调用次数不稳定，网络命令的延迟就会挤压，引起卡顿。</p>
</li>
<li><p>它的反外挂能力很弱，帧同步的逻辑都在客户端里面，你可以比较容易的修改它。但为什么《王者荣耀》敢用帧同步，一方面是因为当时立项的时候开发周期很短，半年时间要做上线，要有几十个英雄，存在时间的压力，另一方面，MOBA类游戏不像数值成长类的游戏，它的玩法是基于单局的，单局的作弊修改，顶多影响这一局的胜负，不会存档，不会出现刷多少钱刷多少好的装备的问题，而且作弊之后我们也很容易监测到，并给予应有的惩罚，所以我们认为这不是致命的缺点。</p>
</li>
<li>它的断线重回时间很长，相信台下也有很多王者玩家，也曾碰到过闪退以后重回加载非常长的情况，甚至加载完以后游戏也快结束了，这是帧同步比较致命的问题。</li>
<li>它的逻辑性能优化有很大的压力。大家应该没有见到哪一款大型游戏是用帧同步来做的，因为这些游戏的每一个逻辑对象都是需要在客户端进行运算的。如果你做一个主城，主城里面有上千人，上千人虽然玩家看不到它，但游戏仍然需要对他们进行有效的逻辑运算，所以帧同步无法做非常多的对象都需要更新的游戏场景。</li>
</ol>
<h2 id="三座大山"><a href="#三座大山" class="headerlink" title="三座大山"></a>三座大山</h2><h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p>帧同步的技术原理相当简单，从一个相同初始的状态开始，获得一个相同的输入，往下一帧一帧执行，执行时所有代码的流程走得都是一样的，这个结果调用完了以后，又有一个新状态，完成循环。相同的状态，相同的流程，不停的这样循环下去。<br>这个原理虽然简单，但是你要去实现它的时候，还是会有很多坑。<br><img src="/2019/04/22/frame-sync/11.jpg"><br>右边写的是实现要点，这是我们在解决第一座大山经验的总结，也是我们实际开发过程当中做的事情。</p>
<p>首先，我们所有的运算都是基于整数，没有浮点数。浮点数是用分子分母表达的。</p>
<p>其次，我们还会用到第三方的组件，帧组件也要需要进行一个比较严格的甄别。我们本身用的公司里面关于时间轴的编辑器里面，最初也是是浮点数，我们都是进行重写改造的。</p>
<p>再次，很多人初次接触帧同步里面的问题，就是在写逻辑的时候和本地进行了关联、和“我”相关，这样就导致不同客户端走到了不同的分支。实际上，真正客户端跟逻辑的话，要跟我这样一个概念无关。</p>
<p>接下来还有随机数，这个要严格一致。这是实现的要点，严格按照这上面的规则写代码还是有可能不同步，本身就很难杜绝这样的问题。<br>最后，真正重要的是开发者要提升自己发现不同步问题的能力，什么时候不同步了，不同步你还要知道不同步在什么点，这是最关键的。你需要通过你的经验和总结提升这样的能力。这个能力还是通过输出来看不同客户端不同输出，找到发生在什么点。</p>
<p>比如在《王者荣耀》里，我们看到不同步的现象应该是这样，有人对着墙跑，你看到的和别人玩的游戏是不一样的，就像进入平行世界。</p>
<p>最开始测试《王者荣耀》的，我们希望不同步率达到1%，就是100局里面有1局出现不同步，我们就算游戏合格，但实际上对于这么大体量游戏来说，这个比率是有问题的，经过我们不停的努力，现在已经控制在万分之几，一万局游戏里面，可能有几局是不同步的。<br>这个问题不一定是代码原因或者没有遵循这些要点才出现的，有可能是你去修改内存，你去加载资源的时候，本地资源有损害或者缺失，或者是异常。说白了，你没有办法往下执行，大家走了不同分支，这都可能引起最终是不同步的。</p>
<p>如果你不同步概率比较低，到了这种万分之几概率的时候，很难通过测试来去还原，去找到这样不同步的点。</p>
<p>最开始我们游戏出现不同步的时候，就是在周末玩家开黑多的时候，随着你的概率越来越低，基本上你就自己就还原不出这些问题了，只能依靠玩家帮你还原这样的场景，来分析这样的不同步问题。<br>同步性遵循这样的要点，按照这样的思路来写，加上你不同步定位的能力，有了监控手段能够去发现，这个问题其实就解决了。解决之后，你就可以好好享受帧同步的开发优势。<br><img src="/2019/04/22/frame-sync/12.jpg"></p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>《王者荣耀》技术测试版本出台的时候，延迟非常大，而且还是卡顿，现在看一下帧同步里面比较特别的地方。帧同步有点像在看电影，它传统的帧同步需要有buffer，每个玩家输入会转发给所有客户端，互相会有编号，按顺序输入帧。</p>
<p>比如我现在已经收到第N帧，只有当我收到第N+1帧的时候，第N这一帧我才可以执行。服务器会按照一定的频率，不同的给大家同步帧编号，包括这一帧的输入带给客户端，如果带一帧给你的数据你拿到之后就执行，下一帧数据没来就不能执行，它的结果就是卡顿。</p>
<p>网络绝对理想的情况下还好，但现实的网络环境不是这样的。帧同步要解决问题就是调试buffer，以前有动态的buffer，它有1到n这样的缓冲区，根据网络抖动的情况，收入然后放到队列里面。</p>
<p>这个buffer的大小，会影响到延迟和卡顿。如果你的buffer越小，你的延迟就越低，你拿到以后你不需要缓冲等待，马上就可以执行。但是如果下一帧没来，buffer很小，你就不能执行，最终导致的结果你的延迟还好，但是卡顿很明显。</p>
<p>如果调到帧同步的buffer，假如我们认为网络延迟是1秒，你抖动调到1秒，那得到的结果虽然你画面不抖动了，但是你的延迟极其高。如果连最坏的网络情况都考虑进去，buffer足够大，那么记过就跟看视频是一样的，平行的东西，看你调大条小。一些局部的措施我们都做过，都是一样的问题。</p>
<p>具体我们怎么优化卡顿的问题呢？</p>
<p>刚才提到该帧同步与buffer，这个buffer可以是1也可以到n，我们要解决我们的延迟问题，我们就让buffer足够小。事实上《王者荣耀》最后做到的buffer是零，它不需要buffer，服务器给了我n，马上知道是n，我收到n，我知道下一次肯定是n+1，所以我收到n之后马上就把n这一帧的输入执行了。</p>
<p>那么为什么不卡顿了，画面不抖动了？</p>
<p>最后一个关键点，是本地插值平滑加逻辑与表现分离。客户端只负责一些模型、动画、它的位置，它会根据绑定的逻辑对象状态、速度、方向来进行一个插值，这样可以做到我们的逻辑帧率和渲染帧率不一样，但是做了插值平滑和逻辑表现分离，画面不抖了，延迟感也是很好的。</p>
<p>做了这些后，我们还把TCP换成UDP，在手机环境下，弱网的情况下，TCP很难恢复重连，所以最后用了UDP来做。整体来说，在网络好的情况下，它延迟也是很好的，在网络比较差的情况下做插值，也是传统CS的表现。</p>
<p>我们经常见到角色A和B，有些客户端A在左B在右，有些是A在右B在左，帧同步逻辑上面AB之间的距离和坐标都是完全一样，但是画面上看到他们可能会不重合，那就是你把它们分离之后的表现。网络极其好的情况下，它应该是重合的，但是在网络差的情况下，可能会有些偏差。这里面是最重要的一块优化。<br><img src="/2019/04/22/frame-sync/13.jpg"></p>
<h3 id="性能的优化"><a href="#性能的优化" class="headerlink" title="性能的优化"></a>性能的优化</h3><p>本身帧同步逻辑上面在优化上面存在一些缺点，所有的角色都需要进行运算。这方面我们也是借助Unity的特性，如果你想追求性能上的极致，有些东西你需要寻求好的方式。</p>
<p>第一点是热点的处理。</p>
<p>我们是不用反射的，它都有GC性能开销，我们的做法里面，会把对象的显示隐藏放在不同的渲染层里面，尽量让整个游戏帧率是平滑的过程。还有我们本身有自己的系统，比如AI，在《王者荣耀》这样的多角色游戏中，你如果想要做出比较好的体验，那么AI就要做得比较复杂。</p>
<p>而要去优化热点，我觉得就只有这三个步骤可以走。</p>
<p>首先，从程序的结构上面能找到更优的，它的优化效果就是最明显的；其次，如果你的结构都是用的最好，就去挖掘局部的算法，调整你代码的一些写法。最后，如果局部的算法都已经调到最优还是没有什么办法，那只有一条路，就是牺牲整个质量，就是分帧降频。</p>
<p>第二点是GC，这块刚才说不用反射，还有装箱和拆箱的行为也是尽量少用。Unity指导过我们的优化，从GC上面的考虑，他们建议每一帧应该在200个字节以内是比较好的状态，其实很难做到，王者也是每一帧在1k左右，很难做到200。</p>
<p>第三点是Drawcall，这些传统的优化手段大家都用的很熟了。</p>
<p>第四点是裁剪，帧同步里面是不能裁剪的，表现里面我看不到的可以降低频率或者不更新它，这在表现里面可以做的。</p>
<p>第五点是3DUI的优化，比如《王者荣耀》的血条、小地图上面叠的元素等等，这些UI都比较丰富，这块我们用了31UI的方式来优化，没有用UGUI里面进行血条方面的处理。</p>
<p>我们也牺牲了一些东西，我们把所有东西都加载了，在游戏过程当中，我们希望不要有任何IO行为，包括输出我们都是要布局的。你处理的决策和复杂度，如果在一帧里面放出100颗子弹，在放100颗子弹的时候一定要掉帧的，一定要在力所能及的时候把这些东西做到极致。<br><img src="/2019/04/22/frame-sync/14.jpg"><br>上面提的是我们的第一代，也是在去年5月份以前做的优化方案。5月份以后，我们还做了另外一件事情：GameCore。</p>
<p>首先，为什么我们觉得iOS比安卓的优化效率高一些，一方面是iOS的CPU架构包括系统确实都优化的比较好，另一方面我们用的Unity4.6，在IOS下面它本身效率高一些，在安卓端的机器各种各样，性能也是千差万别，我们只能用性能比较差的方式。</p>
<p>因为我们已经做到逻辑和表现的分离，那么我们能不能把逻辑独立出来，做成一个C++的东西，实际上我们在去年开始已经在这样做了。做之前也测试过C++和Mono性能的差别，大概是2.5左右，本身我们的逻辑占比游戏消耗20%多，逻辑不是一个大头，我们做了这件事情之后，还是有效的，帧率提升了2到3帧，花的时间很长。</p>
<p>其次，做GameCore以后最明显的变化是我们以前逻辑上的GC没有了，我们有自己内存的管理、对象的管理，包括里面所有的容器类这些东西都是我们自己实现的，包括反射整个一套。它有了自己的内存管理，本身的效率就会比较高，这就已经是一个比较明显的优势了。</p>
<p>再次，有了GameCore之后，又多了很多应用场景，这个东西就是玩法的服务器版本，应用场景运行服务器要做很多的分析，还有第三方使用都是可以的。</p>
<p>最后，GameCore还有可以扩展多线程的潜力。<br><img src="/2019/04/22/frame-sync/15.jpg"></p>
<h1 id="status-sync"><a href="#status-sync" class="headerlink" title="status sync"></a>status sync</h1><p>这时候咱们再来谈谈状态同步（status sync）。怎么说呢，其实状态同步并非字面上的意思，而是以前一个标准化的网络同步方案。毕竟按字面意思的话，帧同步/帧锁定同步，人家同步的操作数据难道就不是状态了？<br>游戏中了包含各种状态，状态同步会在“合适”的时间，”合适”的间隔，”合适”的数据切分下，将一个客户机的状态同步到其他客户机上。所谓“合适”，即是没谱，也就是不定时不定期，有数据就算没数据就算了，所以，无法保证每个客户机上看到的画面是一致的，只能保证他们看到的内容不会差别特别大。<br>另外，为了减少同步的数据量，它通常只会将变化的数据进行同步，所以需要对数据进行切分以判断哪些有变化，哪些需要同步。因此，ECS自带的数据切分就对“状态同步天生亲和”，只要给Component写一个Dirty机制，然后同步所有Dirty的Component就好了，不需要重新设计同步规则。<br>但是，即使是这个狭义的状态同步（status sync），它其实和按帧同步（frame sync）也是不矛盾的。只要服务端先集齐一帧所有客户端发送的状态，再统一归结成一个数据包广播到所有客户端，它就可以拥有和frame sync完全一致的特性。<br>也就是说，status sync和frame sync其实是不冲突的，你完全可以搞出<strong>frame status sync（以帧为单位的状态同步）</strong>来。<br><img src="/2019/04/22/frame-sync/8.jpg"><br>所以，我个人建议大家舍弃掉“帧同步”“状态同步”这种词，而改成更少歧义的“帧锁定同步”和“非帧锁定同步”（或者lockstep同步和非lockstep同步）。<br>如果提到了我上面定义的这种不是lockstep的frame sync（其实LOL就是这样的），就干脆直接说“不是lockstep的按帧同步”。</p>
<h2 id="状态同步的优点"><a href="#状态同步的优点" class="headerlink" title="状态同步的优点"></a>状态同步的优点</h2><ol>
<li>它的安全性非常高，外挂基本上没有什么能力从中收益。</li>
<li>状态同步对于网络的带宽和抖动包有更强的适应能力，即便出现了200、300的输入延迟再恢复正常，玩家其实也感受不到不太舒服的地方。</li>
<li>在开发游戏过程中，它的断线重连比较快，如果我的游戏崩溃了，客户端重启之后只需要服务器把所有重要对象的状态再同步一次过来，重新再创建出来就可以了。</li>
<li>它的客户端性能优化优势也比较明显，比如优化时可以做裁剪，玩家看不到的角色可以不用创建，不用对它进行运算，节省消耗。</li>
</ol>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>第一，它的开发效率相对帧同步而言要差一些，很多时候你需要保证服务器与客户端的每一个角色对象的状态之间保持一致，但事实上你很难做到一致。</p>
<p>比如客户端和服务器端更新的频率，对优化的一些裁剪，网络的抖动等等，你要让每一个状态在客户端同步是比较难的，而你要想调试这些东西，来优化它带来的漏洞、不一致的现象，花费的周期也会比较长，想要达到优化好的水平也比较难。</p>
<p>第二，它比较难做出动作类游戏打击感和精确性。比如说你要做一个射击类角色，他的子弹每秒钟要产生几十颗，基于状态同步来做是比较难的，因为系统在很短时间内，会产生很多数据，要通过创建、销毁、位置运算来同步。</p>
<p>第三，它的流量会随着游戏的复杂度，而逐渐增长，比如角色的多少。我们做《王者荣耀》时，希望在3G、4G的网络条件下也能够玩PvP，所以我们希望它对付费流量的消耗能控制在比较合理的水平，不希望打一局游戏就消耗几十兆的数据流量。</p>
<ul>
<li>lockstep无法降低游戏延迟，反而还会增加延迟。lockstep或者说按帧同步frame sync，保证的是画面的一致性。延迟只能靠优化网络速度和本地预测降低。</li>
<li>同步精度和同步方式无关，只和服务器帧的频率和同步频率有关。频率越高精度自然就越高，就越不容易出现暂时性的画面错误。<br>是否能通过录像文件重放，只需要“伪随机数”和“固定间隔运行”即可，和“同步”无关。以前的FC模拟器就有完整的录像功能，难不成那也是lockstep了？</li>
<li>“lockstep（步调一致）”缩写成”lock（锁）”这个缩写本身就是错的这件事，就不用提了。毕竟这个缩写错误只会导致迷惑，并不会导致歧义。</li>
<li>lockstep不是MOBA游戏的唯一解，本来也不是。但是按帧同步确实是必须的。</li>
</ul>
<h1 id="帧同步的几个难点"><a href="#帧同步的几个难点" class="headerlink" title="帧同步的几个难点"></a>帧同步的几个难点</h1><h2 id="保证客户端独自计算的正确，即一致性"><a href="#保证客户端独自计算的正确，即一致性" class="headerlink" title="保证客户端独自计算的正确，即一致性"></a>保证客户端独自计算的正确，即一致性</h2><p>帧同步的基础，是不同的客户端，基于相同的操作指令顺序，各自执行逻辑，能得到相同的效果。就如大家所知道的，在unity下，不同的调用顺序，时序，浮点数计算的偏差，容器的排序不确定性，coroutine内写逻辑带来的不确定性，物理浮点数，随机数值带来的不确定性等等。<br>有些比较好解决，比如随机数值，只需要做随机种子即可。<br>有些注意代码规范，比如在帧同步的战斗中，逻辑部分不使用Coroutine，不依赖类似Dictionary等不确定顺序的容器的循环等。<br>还有最基础的，要通过一个统一的逻辑tick入口，来更新整个战斗逻辑，而不是每个逻辑自己去Update。保证每次tick都从上到下，每次执行的顺序一致。<br>浮点数计算无法保证一致性，我们需要转换为定点数。关于定点数的实现，比较简单的方式是，在原来浮点数的基础上乘1000或10000，对应地方除以1000或10000，这种做法最为简单，再辅以三角函数查表，能解决一些问题，减少计算不一致的概率，但是，这种做法是治标不治本的方式，存在一些隐患（举个例子，例如一个int和一个float做乘法，如果原数值就要*1000，那最后算出来的数值，可能会非常大，有越界的风险。）。<br>是使用实现更加精确和严谨，并经过验证的定点数数学库。<br>对于计算的不确定性，我们也有一些小的隐患，就是，我们用到了Physics.Raycast来检测地面和围墙，让人物可以上下坡，走楼梯等高低不平的路，也可以有形状不规则的墙。这里会获得一个浮点数的位置，可能会导致不确定性，这里，我们用了数值截断等方式，尽量规避，经过反复测试，没有出现过不一致。</p>
<p>帧同步游戏中，由于需要“每一帧”都要广播数据，所以广播的频率非常高，这就要求每次广播的数据要足够的小。最好每一个网络帧，能在一个MTU以下，这样才能有效降低底层网络的延迟。同样的理由，我们为了提高实时性，一般也倾向于使用UDP而不是TCP协议，这样底层的处理会更高效。但是，这样也会带来了丢包、乱序的可能性。因此我们常常会以冗余的方式——比如每个帧数据包，实际上是包含了过去2帧的数据，也就是每次发3帧的数据，来对抗丢包。也就是说三个包里面只要有一个包没丢，就不影响游戏。另外我们还会在RelayServer上保存大量的客户端上传的数据，如果客户端发现丢了包（如果乱序了也认为是丢包），那么就发起一次“下载”请求，从服务器上重新下载丢失了的帧数据包（这个可能会使用TCP）。这一切，都依赖于每个帧数据要足够的小。所以我们一般要求，每次客户端发送的数据，应该小于128字节。你可以大概计算一下，如果我们的游戏有4个玩家，我们的冗余是3帧，那么一个下行的网络帧数据包大小会到128x4x3=1536字节，而每秒我们发15个网络帧，那么占用的带宽会到1536x15=23,040字节/秒，加上一些底层协议包头也就是24kB/s，这个速度看起来已经要求手机是3G网络才能支持了（实测中GPRS一般很难稳定到这个速度）。<br>另外一个降低广播数据量的做法就是自己编写序列化函数：一般现代编程语言，特别是面向对象的语言，都带有把对象序列化和反序列化的功能。我们要广播游戏操作的时候，这些操作往往也是一个个的“对象”，因此最简单的方法就是使用编程语言自带的序列化库来把对象转换成字节数组去广播。但是这些编程语言的默认序列化功能，为了实现诸如反射等高级功能，会把很多游戏逻辑所“不必要”的数据也序列化了，比如对象的类名、属性名什么的。如果我们自己去针对特定的数据对象来编写序列化函数，就没有这个问题了，我们可以仅仅提取我们想要的数据，甚至能合并和裁剪一些数据项，达到最小化数据长度的目的。</p>
<p>在网络游戏中，各个客户端的运行条件和环境往往千差万别，有的硬件好一些，有的差一些，各方的网络情况也不一致；时不时玩家的网络还会在游戏过程中，发生临时的拥堵，我们称之为<strong>“网络抖动”</strong>。网络游戏有时候还会需要有中途加入游戏的需求（乱入），有游戏录像和观看、快进录像的功能。这些功能，都可能导致客户端收到“过去时间”里的一堆网络帧，因此，客户端必须要有处理这些堆积起来的网络数据的能力。最简单的做法就是加速播放（快进）——如果收到网络数据处理完游戏逻辑后，然后在同一个渲染帧（同一次Update()函数里）内，马上继续收下一个网络数据，然后又立刻处理。这样往往能在一个渲染帧的时间内，加速赶上服务器广播的最新游戏进度。但是这样做也会有副作用，如果客户端积累的包太多（比如游戏已经开始玩了10分钟，新的用户中途加入），会导致这个用户长时间卡住，因为程序正在疯狂的下载积累的帧同步包和运算快进。为了解决这个问题，有些程序员会限制每一个渲染帧中所快进的操作次数，这样用户还是能看到画面有活动。如果实在要快进的进度太多，就要采用“快照”技术，通过定时保存的游戏状态数据，来减少快进的进度了。这个快照功能这里就不展开了。</p>
<img src="/2019/04/22/frame-sync/2.jpg">
<img src="/2019/04/22/frame-sync/3.jpg">
<p>一般来说，我们的客户端的渲染帧率都会大大高于网络帧的接收频率。如果我们每个渲染帧都去发送一次玩家操作（比如触摸屏上的手指位置），那么可能会导致发送的游戏操作远远大于收到的操作，这样做要么会让游戏操作堆积在服务器上，导致操作的严重延迟，要么导致下行的网络包非常大（服务器每次都把收到的所有操作一次下发），这样会让网络带宽占满，同样是会感觉延迟。不管怎么处理，都是不太好的结果。正确的做法应该是控制发包频率，最好是至少收到一个网络下行帧，才发送一个上行的游戏操作，避免堆积。另外，刚刚讲到的“快进”，如果我们在快速播放游戏逻辑的时候，每次播放同时也采集玩家输入去发送，那么同样会导致短时间内发送一大堆上行数据给服务器，而这些数据很可能客户端接收时产生大量的延迟。所以最好是在快进的时候不采集玩家的输入，因为玩家在看到快进过程中，实际上也很难有效的做出合理的反应，一个常见的做法，就是快进的时候，给游戏覆盖一个“等待”或“Loading”的蒙皮层，让玩家不可以输入操作。</p>
<img src="/2019/04/22/frame-sync/4.jpg">
<img src="/2019/04/22/frame-sync/5.jpg">
<h2 id="关于流畅度的优化"><a href="#关于流畅度的优化" class="headerlink" title="关于流畅度的优化"></a>关于流畅度的优化</h2><p>实时同步游戏最重要的是流畅，然而影响游戏流畅的因素很多，网络带宽的限制，CPU运算和渲染效率的限制，都是很大的问题。所幸游戏本身还是有很多可以取舍的因素，这让我们可以牺牲一些游戏不太重要的特性，去提高流畅度。</p>
<p>第一个可以用来交换流畅度的是“一致性”特性。我们做帧同步的目标是各个客户端都能看到一致的显示。但是游戏内容有很多，有一部分内容是可以容忍“不一致”的，比如我们做飞行射击弹幕游戏，满屏幕有很多子弹，而每一颗子弹本身的存在的时间很短，如果我们不是做对打的游戏（而是一起打电脑），那么这些子弹是可以不一致的。又比如我们做一个横版过关的配合游戏，几个玩家一起打电脑控制的怪物，大家关心的是怪物是怎么被打死的，而玩法本身又比较容忍不一致（横版动作游戏的攻击范围往往比较大），所以就算有些不一致问题也不大。在以上的条件下，我们就可以尝试，把更多的游戏逻辑，从网络帧的UpdateByNet()函数里面拿出去，放回到单机游戏中的Update()函数里去。这样就算网络有点卡，起码整个画面里还是有很多东西是不会被“卡住”的。但是必须注意的是，一般玩家控制的角色的动作，包括当前客户端控制的角色，还是应该从网络帧里面获得行为数据，因为如果玩家爱控制角色不一致的太多，整个游戏场面就会差更多。很多游戏中的怪物AI都是根据玩家角色来设定的，所以一旦玩家角色的行为是同步的，那么大多数的怪物的表现还是一致的。<br><img src="/2019/04/22/frame-sync/6.jpg"></p>
<p>第二个可以用来交换流畅度的特性是实时性。一般来说，我们都希望游戏中的角色控制是灵敏的，实时的。我们的游戏角色往往在会玩家输入操作后的几十分之一秒内，就开始显示变化。在帧同步游戏中，我们可以让玩家一输入完操作，就立刻发包，然后尽快在下一个收到的网络帧中收到这个操作，从而尽快的完成显示。然而，网络并不是那么稳定，我们常常会发现一会快一会慢，这样玩家的操作体验就非常奇怪，无法预测输入动作后，角色会在什么时候起反应。这对于一些讲求操作实时性的游戏是很麻烦的。比如球类游戏，控制的角色跑的一会儿快一会儿慢，很难玩好“微操”。要解决这个问题，我们一般可以学习传输语音业务的做法，就是接收网络数据时，不立刻处理，而是给所有的操作增加一个固定的延迟，后在延迟的时间内，搜集多几个网络包，然后按固定的时间去播放（运算）。这样相当于做了一个网络帧的缓冲区，用来平滑那些一会儿快一会儿慢的数据包，改成匀速的运算。这种做法会让玩家感觉到一个固定延迟：输入操作后，最少要隔一段时间，才会起反应。但是起码这个延迟是固定的，可预计的，这对于游戏操作就便捷很多了，只要掌握了提前量，这个操作的感觉就好像角色有一定的“惯性”一样：按下跑并不立刻跑，松开跑不会立刻停，但这个惯性的时间是固定的。</p>
<img src="/2019/04/22/frame-sync/7.jpg">
<p>首先，是网络协议的选择。TCP和UDP的选择，我就不多说了，帧同步肯定要基于UDP才能保证更低的延迟。在UDP的选择上，我看网上有些文章，容易导入一个误区，即，我们是要用可靠传输的UDP，还是冗余信息的UDP。</p>
<p>基于可靠传输的UDP，是指在UDP上加一层封装，自己去实现丢包处理，消息序列，重传等类似TCP的消息处理方式，保证上层逻辑在处理数据包的时候，不需要考虑包的顺序，丢包等。类似的实现有Enet，KCP等。</p>
<p>冗余信息的UDP，是指需要上层逻辑自己处理丢包，乱序，重传等问题，底层直接用原始的UDP，或者用类似Enet的Unsequenced模式。常见的处理方式，就是两端的消息里面，带有确认帧信息，比如客户端（C）通知服务器（S）第100帧的数据，S收到后通知C，已收到C的第100帧，如果C一直没收到S的通知（丢包，乱序等原因），就会继续发送第100帧的数据给S，直到收到S的确认信息。<br>有些文章介绍的时候，没有明确这两者的区别，但是这两种方式，区别是巨大的。可靠传输的UDP，在帧同步中，个人认为是不合适的，因为他为了保证包的顺序和处理丢包重传等，在网络不佳的情况下，delay很大，将导致收发包处理都会变成类似tcp的效果，只是比TCP会好一些。必须要用冗余信息的UDP的方式，才能获得好的效果。并且实现并不复杂，只要和服务器商议好确认帧和如何重传即可，自己实现，有很大的优化空间。例如，我们的协议定义类似如下：<br><img src="/2019/04/22/frame-sync/10.jpg" title="双方都要通知对方，已经接受哪一帧的通知了，并通过cmd list重发没有收到的指令"></p>
<p>这里简单说一下，对于这种收发频繁的消息，如果使用protobuf，会造成每个逻辑帧的GC，这是非常不好的，解决方案，要么对<a href="http://localhost:4000/2019/04/24/protobuf-net-no-gc/" target="_blank" rel="noopener">protobuf做无GC改造</a>&gt;，要么就自己实现一个简单的byte[]读写。无GC改造工程太大，感觉无必要，我们只是在战斗的几个频繁发送的消息，需要自己处理一下byte[]读写即可。</p>
<p>此处补充一下，kcp+fec的模式，可以比冗余方式，有更好的效果，我之前并没有仔细研究过这个模式，不过可以推荐大家看一下，如果有用过朋友分享下结论就更好了。</p>
<p>因为我们项目早期，服务器定下了使用enet，我评估了一下，反正使用冗余包的方式，所以没有纠结enet或kcp，后续其实想改成kcp，服务器不想再动，也就放下了。</p>
<p>enet麻烦的地方是，enet的ipv6版本，是一个不成熟的pull request，enet作者没有merge（并且存在好几个ipv6的pull request），我不确定稳定性，还好看了下commit，加上测试下来，没有太大问题。KCP我没有评估过ipv6的问题，不过github上有C#版本，改一下ipv6支持应该很简单。</p>
<h2 id="逻辑和显示的分离"><a href="#逻辑和显示的分离" class="headerlink" title="逻辑和显示的分离"></a>逻辑和显示的分离</h2><p>这块很多讲帧同步的文章都提过了。我在前面讲<a href="https://zhuanlan.zhihu.com/p/38001896" target="_blank" rel="noopener">技能编辑器</a>的时候，也提过，配置的数据和显示要分离，在战斗中，战斗的逻辑，也要和显示做到分离。</p>
<p>例如，最基本，我们动作切换的逻辑，是基于自己抽象的逻辑帧，而不是基于animator中一个clip的播放。比如一个攻击动作，当第10帧的时候，开始出现攻击框，并开始检测和敌人受击框的碰撞，这个时候的第10帧，必须是独立的逻辑，不能依赖于animator播放的时间，或者AnimatorStateInfo的normalizedTime等。甚至，当我们不加载角色的模型，一样可以跑战斗的逻辑。如果抽离得好，还可以放到服务器跑，做为战斗的验证程序，王者荣耀就是这样做的。</p>
<h2 id="联机如何做到流畅战斗"><a href="#联机如何做到流畅战斗" class="headerlink" title="联机如何做到流畅战斗"></a>联机如何做到流畅战斗</h2><p>前面所有的准备，最终的目的，都是为了战斗的流畅。特别是我们这种Act游戏，或者格斗类游戏，对按键以后操作反馈的即时性，要求非常高，一点点延迟，都会影响玩家的手感，导致玩家的连招操作打断，非常影响体验。我们对延迟的敏感性，甚至比MOBA类游戏还要高，我们要做到好的操作手感，还要联机战斗（PVP，组队PVE），都需要把帧同步做到极致，不能因为延迟卡住或者操作反馈出现变化。</p>
<p>我们也不能用缓存服务器确认操作的方式，也就是一些游戏做的指令buffer。具体描述，王者荣耀的分析文章，讲得很具体了。这也是他们说的模式，这个模式能解决一些小的网络波动，对一些操作反馈不需要太高的游戏，例如有些游戏攻击前会有一个比较长的前摇动作，这类游戏，用这种方式，应该就能解决大部分问题。但是这种方式还是存在隐患，即使通过策略能很好地动态调整buffer，也还是难以解决高延迟下的卡顿和不流畅。王者荣耀优化得很好，他们说能让buffer长度为0，文章只提到通过平滑插值和逻辑表现分离来优化，更细节的没有提到，我不确定他们是否只是基于这个方式来优化的。目前也没有看到更具体的分析。</p>
<p>指令buffer的方式，也不能满足我们的需求，或者说，我没有找到基于此方式，能优化到王者荣耀的效果的办法。我也测试过其他moba和act，arpg类游戏的联机，在高延迟，网络波动情况下，没有比王者表现更好的了。</p>
<p>最后，在仔细研究了我们的需求后，找到一篇指导性的文章，非常适合我们。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/21/draw-texture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/21/draw-texture/" class="post-title-link" itemprop="url">3dmax利用视口画布在窗口中绘制贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-21 20:07:03" itemprop="dateCreated datePublished" datetime="2019-04-21T20:07:03+08:00">2019-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/3DMax/" itemprop="url" rel="index"><span itemprop="name">3DMax</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>打开场景文件<br><img src="/2019/04/21/draw-texture/1.png"><br>场景中创建了5个球体。单机打开材质编辑器，单机一个材质球，将材质名称我们命名为黄色，然后将它的材质类型设置为VR材质<br><img src="/2019/04/21/draw-texture/2.png"><br>单机漫反射后面的通道，添加一张黄色的贴图（选择位图可以自定义），选择贴图，单机打开<br><img src="/2019/04/21/draw-texture/3.png"><br>添加完成，需要设置下面的参数<br><img src="/2019/04/21/draw-texture/4.png"><br>单击转到父对象，设置一下它的反射颜色为白色，并且要勾选菲涅尔反射，设置细分的数值为20。可以打开它的背景显示。<br><img src="/2019/04/21/draw-texture/5.png"><br>假如渲染的更加清晰一点，可以设置一下模糊为0.01。<br><img src="/2019/04/21/draw-texture/6.png"><br>这样黄色材质就制作完成了，然后可以制作下一个材质，蓝色材质。为了操作方便，我们可以直接将它拖动复制，并将它命名为蓝色。<br><img src="/2019/04/21/draw-texture/7.png"><br>我们需要在菜单中进行工具，需要将视口画布的工具找到。选择视口画布，并单击。<br><img src="/2019/04/21/draw-texture/8.png"><br>此时会单击这样一个对话框。 然后看到有这样一些画笔可以进行设置。<br><img src="/2019/04/21/draw-texture/9.png"><br>选择一个黄色的球体，接着单击绘制按钮。此时弹出这样一个对话框。<br><img src="/2019/04/21/draw-texture/10.png"><br>选择第一项漫反射-贴图，选择完成，此时弹出层的对话框，在这个对话框可以单击添加新层的按钮。<br><img src="/2019/04/21/draw-texture/11.png"><br>也就是说我们后面绘制的贴图都会呈现在新层上面<br><img src="/2019/04/21/draw-texture/12.png"><br>这个时候设置一下画笔基本的参数。首先设置它的颜色为黑色，半径数值设置为10，设置硬度设置为25左右，设置完成。最后可以取消使用选项。<br><img src="/2019/04/21/draw-texture/13.png"><br>并且设置它的遮罩。在这里可以单击选择它的遮罩，我们选择第三个。<br><img src="/2019/04/21/draw-texture/14.png"><br>设置完成，然后在该球体上单击鼠标左键就可以进行绘制了<br><img src="/2019/04/21/draw-texture/15.png"><br>当然我们现在是用鼠标进行绘制，我们也可以使用手写板进行绘制。设置我们在绘制进行中也可以调整。这样就制作完成。<br><img src="/2019/04/21/draw-texture/16.png"><br>当然也可以更换它的遮罩等选项，这个绘制完成以后。这时候可以单击选择并移动工具。这样会弹出保存纹理层的对话框。<br><img src="/2019/04/21/draw-texture/17.png"><br>这时候可以单击另存为PSD文件，并且将它进行保存。在这里我们可以将它保存为黄色.psd就可以了。<br>同样的方法我们可以将另外的四个球体绘制出来。方法是一样的。都绘制完成以后，我们可以查看此时的绘制效果。我们看到已经出现5个卡通的球体。<br><img src="/2019/04/21/draw-texture/18.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/17/flash-effect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/17/flash-effect/" class="post-title-link" itemprop="url">flash-effect</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-17 12:38:01" itemprop="dateCreated datePublished" datetime="2019-04-17T12:38:01+08:00">2019-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/17/attribute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/17/attribute/" class="post-title-link" itemprop="url">特性（Attribute）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-17 09:56:09" itemprop="dateCreated datePublished" datetime="2019-04-17T09:56:09+08:00">2019-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p>
<p>特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：预定义特性和自定义特性。</p>
<h1 id="规定特性（Attribute）"><a href="#规定特性（Attribute）" class="headerlink" title="规定特性（Attribute）"></a>规定特性（Attribute）</h1><p>规定特性（Attribute）的语法如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">attribute(positional_parameters, name_parameter = value, ...)</span>]</span><br><span class="line">element</span><br></pre></td></tr></table></figure></p>
<p>特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。positional_parameters 规定必需的信息，name_parameter 规定可选的信息。</p>
<h1 id="预定义特性（Attribute）"><a href="#预定义特性（Attribute）" class="headerlink" title="预定义特性（Attribute）"></a>预定义特性（Attribute）</h1><p>.Net 框架提供了三种预定义特性：</p>
<ul>
<li>AttributeUsage</li>
<li>Conditional</li>
<li>Obsolete</li>
</ul>
<h2 id="AttributeUsage"><a href="#AttributeUsage" class="headerlink" title="AttributeUsage"></a>AttributeUsage</h2><p>预定义特性 AttributeUsage 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。</p>
<p>规定该特性的语法如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(</span></span><br><span class="line"><span class="meta">   validon,</span></span><br><span class="line"><span class="meta">   AllowMultiple=allowmultiple,</span></span><br><span class="line"><span class="meta">   Inherited=inherited</span></span><br><span class="line"><span class="meta">)</span>]</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>参数 validon 规定特性可被放置的语言元素。它是枚举器 AttributeTargets 的值的组合。默认值是 AttributeTargets.All。</li>
<li>参数 allowmultiple（可选的）为该特性的 AllowMultiple 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。</li>
<li>参数 inherited（可选的）为该特性的 Inherited 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。</li>
</ul>
<p>例如：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">AttributeTargets.Constructor |</span></span><br><span class="line"><span class="meta">AttributeTargets.Field |</span></span><br><span class="line"><span class="meta">AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">AttributeTargets.Property, </span></span><br><span class="line"><span class="meta">AllowMultiple = true)</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h2><p>这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符。</p>
<p>它会引起方法调用的条件编译，取决于指定的值，比如 Debug 或 Trace。例如，当调试代码时显示变量的值。</p>
<p>规定该特性的语法如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Conditional(</span></span><br><span class="line"><span class="meta">   conditionalSymbol</span></span><br><span class="line"><span class="meta">)</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Obsolete"><a href="#Obsolete" class="headerlink" title="Obsolete"></a>Obsolete</h2><p>这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。</p>
<p>规定该特性的语法如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Obsolete(</span></span><br><span class="line"><span class="meta">   message</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line">[<span class="meta">Obsolete(   message, iserror)</span>]</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>参数 message，是一个字符串，描述项目为什么过时的原因以及该替代使用什么。</li>
<li>参数 iserror，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。</li>
</ul>
<h1 id="创建自定义特性（Attribute）"><a href="#创建自定义特性（Attribute）" class="headerlink" title="创建自定义特性（Attribute）"></a>创建自定义特性（Attribute）</h1><p>.Net 框架允许创建自定义特性，用于存储声明性的信息，且可在运行时被检索。该信息根据设计标准和应用程序需要，可与任何目标元素相关。<br>创建并使用自定义特性包含四个步骤：</p>
<ul>
<li>声明自定义特性</li>
<li>构建自定义特性</li>
<li>在目标程序元素上应用自定义特性</li>
<li>通过反射访问特性</li>
</ul>
<p>最后一个步骤包含编写一个简单的程序来读取元数据以便查找各种符号。元数据是用于描述其他数据的数据和信息。该程序应使用反射来在运行时访问特性。</p>
<h2 id="声明自定义特性"><a href="#声明自定义特性" class="headerlink" title="声明自定义特性"></a>声明自定义特性</h2><p>一个新的自定义特性应派生自 System.Attribute 类。例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个自定义特性 BugFix 被赋给类及其成员</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">AttributeTargets.Constructor |</span></span><br><span class="line"><span class="meta">AttributeTargets.Field |</span></span><br><span class="line"><span class="meta">AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">AttributeTargets.Property,</span></span><br><span class="line"><span class="meta">AllowMultiple = true)</span>]</span><br><span class="line"></span><br><span class="line">public class DeBugInfo : System.Attribute</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们已经声明了一个名为 DeBugInfo 的自定义特性。</p>
<h2 id="构建自定义特性"><a href="#构建自定义特性" class="headerlink" title="构建自定义特性"></a>构建自定义特性</h2><p>让我们构建一个名为 DeBugInfo 的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息：</p>
<ul>
<li>bug 的代码编号</li>
<li>辨认该 bug 的开发人员名字</li>
<li>最后一次审查该代码的日期</li>
<li>一个存储了开发人员标记的字符串消息</li>
</ul>
<p>我们的 DeBugInfo 类将带有三个用于存储前三个信息的私有属性（property）和一个用于存储消息的公有属性（property）。所以 bug 编号、开发人员名字和审查日期将是 DeBugInfo 类的必需的定位（ positional）参数，消息将是一个可选的命名（named）参数。</p>
<p>每个特性必须至少有一个构造函数。必需的定位（ positional）参数应通过构造函数传递。下面的代码演示了 DeBugInfo 类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="comment">// 一个自定义特性 BugFix 被赋给类及其成员</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">AttributeTargets.Constructor |</span></span><br><span class="line"><span class="meta">AttributeTargets.Field |</span></span><br><span class="line"><span class="meta">AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">AttributeTargets.Property,</span></span><br><span class="line"><span class="meta">AllowMultiple = true)</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeBugInfo</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bugNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> developer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> lastReview;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeBugInfo</span>(<span class="params"><span class="keyword">int</span> bg, <span class="keyword">string</span> dev, <span class="keyword">string</span> d</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        bugNo = bg;</span><br><span class="line">        developer = dev;</span><br><span class="line">        lastReview = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> BugNo</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bugNo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Developer</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> developer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastReview</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lastReview;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Message</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            message = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用自定义特性"><a href="#应用自定义特性" class="headerlink" title="应用自定义特性"></a>应用自定义特性</h2><p>通过把特性放置在紧接着它的目标之前，来应用该特性：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DeBugInfo(45, <span class="meta-string">"Zara Ali"</span>, <span class="meta-string">"12/8/2012"</span>, Message = <span class="meta-string">"Return type mismatch"</span>)</span>]</span><br><span class="line">[<span class="meta">DeBugInfo(49, <span class="meta-string">"Nuha Ali"</span>, <span class="meta-string">"10/10/2012"</span>, Message = <span class="meta-string">"Unused variable"</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 成员变量</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">double</span> length;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">double</span> width;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="keyword">double</span> l, <span class="keyword">double</span> w</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      length = l;</span><br><span class="line">      width = w;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="meta">DeBugInfo(55, <span class="meta-string">"Zara Ali"</span>, <span class="meta-string">"19/10/2012"</span>,</span></span><br><span class="line"><span class="meta">  Message = <span class="meta-string">"Return type mismatch"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetArea</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">return</span> length * width;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="meta">DeBugInfo(56, <span class="meta-string">"Zara Ali"</span>, <span class="meta-string">"19/10/2012"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">"Length: &#123;0&#125;"</span>, length);</span><br><span class="line">      Console.WriteLine(<span class="string">"Width: &#123;0&#125;"</span>, width);</span><br><span class="line">      Console.WriteLine(<span class="string">"Area: &#123;0&#125;"</span>, GetArea());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="通过反射访问特性"><a href="#通过反射访问特性" class="headerlink" title="通过反射访问特性"></a>通过反射访问特性</h2><p>注意：只有在调用GetCustomAttributes才开始创建特性实例。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Rectangle r = <span class="keyword">new</span> Rectangle(<span class="number">4.5</span>, <span class="number">7.5</span>);</span><br><span class="line">        r.Display();</span><br><span class="line">        Type type = <span class="keyword">typeof</span>(Rectangle);</span><br><span class="line">        <span class="keyword">foreach</span> (Object attributes <span class="keyword">in</span> type.GetCustomAttributes(<span class="literal">false</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            DeBugInfo dbi = (DeBugInfo)attributes;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != dbi)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Bug no: &#123;0&#125;"</span>, dbi.BugNo);</span><br><span class="line">                Console.WriteLine(<span class="string">"Developer: &#123;0&#125;"</span>, dbi.Developer);</span><br><span class="line">                Console.WriteLine(<span class="string">"Last Reviewed: &#123;0&#125;"</span>, dbi.LastReview);</span><br><span class="line">                Console.WriteLine(<span class="string">"Remarks: &#123;0&#125;"</span>, dbi.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (MethodInfo m <span class="keyword">in</span> type.GetMethods())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (Attribute a <span class="keyword">in</span> m.GetCustomAttributes(<span class="literal">true</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a <span class="keyword">is</span> DeBugInfo)</span><br><span class="line">                &#123;</span><br><span class="line">                    DeBugInfo dbi = (DeBugInfo)a;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != dbi)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"Bug no: &#123;0&#125;, for Method: &#123;1&#125;"</span>, dbi.BugNo, m.Name);</span><br><span class="line">                        Console.WriteLine(<span class="string">"Developer: &#123;0&#125;"</span>, dbi.Developer);</span><br><span class="line">                        Console.WriteLine(<span class="string">"Last Reviewed: &#123;0&#125;"</span>, dbi.LastReview);</span><br><span class="line">                        Console.WriteLine(<span class="string">"Remarks: &#123;0&#125;"</span>, dbi.Message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/14/houdini/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/houdini/" class="post-title-link" itemprop="url">houdini</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 23:51:22" itemprop="dateCreated datePublished" datetime="2019-04-14T23:51:22+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Houdini/" itemprop="url" rel="index"><span itemprop="name">Houdini</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>entagma免费的教程都是教基础的</li>
<li><a href="https://www.anastasiaopara.com/procedural-realistic-tree-rd" target="_blank" rel="noopener">程序化生成树</a></li>
<li><a href="https://www.bilibili.com/video/av41681374/?p=1" target="_blank" rel="noopener">master class全集</a></li>
<li><a href="https://cgpersia.com" target="_blank" rel="noopener">https://cgpersia.com</a></li>
<li><a href="https://www.anastasiaopara.com/houdini-hive-siggraph-17" target="_blank" rel="noopener">https://www.anastasiaopara.com/houdini-hive-siggraph-17</a></li>
<li><a href="http://www.tokeru.com/cgwiki/index.php?title=Main_Page#" target="_blank" rel="noopener">http://www.tokeru.com/cgwiki/index.php?title=Main_Page#</a></li>
<li><a href="https://www.bilibili.com/video/av29099924" target="_blank" rel="noopener">https://www.bilibili.com/video/av29099924</a> 很渣</li>
</ol>
<img src="/2019/04/14/houdini/1.jpg">
<p>空格键+数字键1：透视图<br>空格键+数字键2：顶视图<br>空格键+数字键3：前视图<br>空格键+数字键4：左视图<br>空格键+鼠标左键：旋转视图<br>空格键+鼠标中键：移动视图<br>空格键+鼠标右键：缩放视图<br>空格键+F键：选中当前对象<br>空格键+G键：选中当前对象并还原视口<br>D键打开Display Option<br>感觉最右边的那个按钮表示激活。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/13/shader-xray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/13/shader-xray/" class="post-title-link" itemprop="url">遮挡显示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-13 12:49:05" itemprop="dateCreated datePublished" datetime="2019-04-13T12:49:05+08:00">2019-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>3D游戏中主角会经常被墙壁之内的东西挡住，此时为了达到突出主角的效果，会做一些特殊处理让主角显示出来。<br>光栅化阶段的后期，会有一个深度测试和颜色混合的过程，此效果就是针对这个过程进行的一种特殊处理。</p>
<ol>
<li>深度就是该像素点在3D世界中距离摄像机的距离，离摄像机越近，深度值越小。</li>
<li>深度测试：在屏幕上每一个点，都存放在一个缓存列表。如果启用深度缓存Zwrite On，那么在绘制每个像素钱，底层会将当前点的深度值和已经存储在这个位置的点的深度值进行比较。如果新的点的深度值小于原来点的深度值，则新的点会代替原来的点。反之新的点会被遮挡，其颜色值和深度值会被丢弃。</li>
</ol>
<p>实现步骤：</p>
<ol>
<li>定义了2个pass，一个输出纯色，一个输出模型色</li>
<li>当对象没有被遮挡是，先执行的纯色pass输出了纯色，然后模型的pass输出了模型色，最终纯色被替换显示正常模型。</li>
<li>当对象被墙壁挡住是，如果我们什么也不做，纯色pass输出的颜色和模型pass输出的颜色都会被墙壁代替，因为它们的深度值逗逼墙壁深度值大</li>
<li>当对象被墙壁遮挡住时，我们想要的效果是显示纯色，那么我们可以关闭纯色的ZWrite，就是不将它的深度值写入深度缓存，此时它的深度测试参数ZTest默认是LEqual，而它的深度值是大于墙壁的，所以也不会显示。</li>
<li>被挡住时，模型色已经被剔除了，最终的颜色混合为<br>Blend SrcAlpha OneMinusSrcAlpha<br>最终色 = 纯色rgb<em>纯色a + 墙壁rgb</em>(1-纯色a)</li>
</ol>
<img src="/2019/04/13/shader-xray/1.jpg">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custome/XRay"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="string">"Color"</span>, Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">        _AfterColor(<span class="string">"After Color"</span>, Color)=(<span class="number">0.435</span>,<span class="number">0.851</span>,<span class="number">1</span>,<span class="number">0.419</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags&#123;<span class="string">"Queue"</span>=<span class="string">"Geometry+1"</span> <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span>&#125;</span><br><span class="line">        LOD  <span class="number">300</span></span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest GEqual <span class="comment">// 深度测试，大于等于当前最小中的值就会显示</span></span><br><span class="line">            ZWrite  Off </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include <span class="string">"UnityCG.cginc"</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 _AfterColor;</span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _AfterColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest LEqual</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UnityCG.cginc"</span></span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex: SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata i)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(i.vertex);</span><br><span class="line">                o.uv = i.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 frag(v2f i):SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 c = tex2D(_MainTex, i.uv) + _Color;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/13/static-analyze-unity-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/13/static-analyze-unity-code/" class="post-title-link" itemprop="url">使用静态分析优化Unity代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-13 09:40:57" itemprop="dateCreated datePublished" datetime="2019-04-13T09:40:57+08:00">2019-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UnityEngineAnalyzer"><a href="#UnityEngineAnalyzer" class="headerlink" title="UnityEngineAnalyzer"></a>UnityEngineAnalyzer</h1><p>UnityEngineAnalyzer is a set of Roslyn analyzers that aim to detect common problems in Unity3D C# code. Unity3D makes it easy for us to make cross platform games, but there are hidden rules about performance and AOT, which might only come with experience, testing or reading the forums. It is hoped that such problems can be caught before compilation.</p>
<h2 id="Building-CLI-executable"><a href="#Building-CLI-executable" class="headerlink" title="Building CLI executable"></a>Building CLI executable</h2><p>CLI requires .NET Core 2.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -c Release -r win10-x64</span><br></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -c Release -r ubuntu.16.10-x64</span><br></pre></td></tr></table></figure></p>
<h2 id="Comand-Line-Interface"><a href="#Comand-Line-Interface" class="headerlink" title="Comand Line Interface"></a>Comand Line Interface</h2><p>In order to use the Command Line Interface (CLI), download the latest release of UnityEngineAnalyzer then unzip the archive (<a href="https://github.com/vad710/UnityEngineAnalyzer/releases" target="_blank" rel="noopener">https://github.com/vad710/UnityEngineAnalyzer/releases</a>).</p>
<ol>
<li>Open a Command Prompt or Powershell Window</li>
<li>Run <code>Linty.CLI.exe &lt;project path&gt;</code></li>
<li>Observe the analysis results</li>
<li>(Optional) In the same location as the project file are <code>report.json</code> and <code>UnityReport.html</code> files containig the results of the analysis<ul>
<li>Use command <code>-e customexporter exporter2 ...</code> to load custom exporters</li>
</ul>
</li>
<li>(Optional) configuration file path.<ul>
<li>Use command <code>-c configureFilePath.json</code> to load custom configurations</li>
<li>Configuration json, allows to enable / disable analyzers</li>
</ul>
</li>
<li>(Optional) minimal severity for reports<ul>
<li>Use command <code>-s Info/Warning/Error</code> to defined used minimal severity for reporting</li>
<li>Default is Warning</li>
</ul>
</li>
<li>(Optional) Unity version for check<ul>
<li>Use command <code>-v UNITY_2017_1/UNITY_5_5/UNITY_4_0/...</code> to Unity version</li>
<li>For default analyzer will try to find ProjectVersion.txt file and parse version automatically.</li>
</ul>
</li>
</ol>
<p>Example:</p>
<p><code>&gt; Linty.CLI.exe C:\Code\MyGame.CSharp.csproj</code> </p>
<h2 id="Visual-Studio-Integration"><a href="#Visual-Studio-Integration" class="headerlink" title="Visual Studio Integration"></a>Visual Studio Integration</h2><p>In Visual Studio 2017, go to <code>Tools &gt; Nuget Package Manager &gt; Manage Nuget Packages for Solution...</code>. Search for and install <code>UnityEngineAnalyzer</code></p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>Right-click <code>Analyzers</code> to modify the severity or to disable the rule completely.</p>
<p><img src="https://raw.githubusercontent.com/meng-hui/UnityEngineAnalyzer/master/Documents/configuration.png" alt></p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><ul>
<li>HTML Report requires FireFox or XOR (Corss Origin Request) enabled in other browsers</li>
<li>It doesn’t have rules for all of <a href="https://developer.xamarin.com/guides/ios/advanced_topics/limitations/" target="_blank" rel="noopener">Mono’s AOT Limitations</a></li>
<li>IL2CPP might change the limitations of AOT compilation</li>
</ul>
<p>Below is a sample of all the rules available in this analyzer</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AOT0001: System.Runtime.Remoting is not suppported</span></span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting;</span><br><span class="line"><span class="comment">// AOT0002: System.Reflection.Emit is not supported</span></span><br><span class="line"><span class="keyword">using</span> System.Reflection.Emit;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">FooBehaviour</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// AOT0003: Reflection only works for looking up existing types</span></span><br><span class="line">        Type.GetType(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// UEA0002: Using string methods can lead to code that is hard to maintain</span></span><br><span class="line">        SendMessage(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// UEA0006: Use of coroutines cause some allocations</span></span><br><span class="line">        StartCoroutine(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UEA0001: Using OnGUI causes allocations and GC spikes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UEA0003: Empty MonoBehaviour methods are executed and incur a small overhead</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// UEA0004: Using CompareTag for tag comparison does not cause allocations</span></span><br><span class="line">        <span class="keyword">if</span> (other.tag == <span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// UEA0005: Warning to cache the result of find in Start or Awake</span></span><br><span class="line">        GameObject.Find(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>See <a href="https://raw.githubusercontent.com/meng-hui/UnityEngineAnalyzer/master/LICENSE" target="_blank" rel="noopener">LICENSE</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/12/RTR-4th-Chapter2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/12/RTR-4th-Chapter2/" class="post-title-link" itemprop="url">RTR 4th Chapter2 图形渲染管线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-12 23:14:20" itemprop="dateCreated datePublished" datetime="2019-04-12T23:14:20+08:00">2019-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RTR-4th/" itemprop="url" rel="index"><span itemprop="name">RTR-4th</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>整个渲染流水线的目标是实时地通过一个虚拟的camera，把光源，3D物体（包括上面的纹理）等渲染到2D图像上，流水线是并行化执行的，但是会出现stall，直到流水线中最慢的一个阶段完成它的任务<br>整条流水线的架构，主要依次分为四个阶段：<br>Application,Geometry Processing,Rasterization和Pixel Processing</p>
<p><div align="center"><img src="/2019/04/12/RTR-4th-Chapter2/1.jpg"></div><br>每个阶段内部也有自己的pipeline的。<br>我们要区别“阶段（functional stage）”和具体的实现结构，也就是说具体的某个实现结合可能合并了几个stage的内容到一个单元（unit），使得其过程时间消耗更短。</p>
<h1 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>Application阶段主要是在CPU上完成的，可以利用现代CPU的多和特性进行多线程优化，这一部分通常包括碰撞检测，全局加速算法，动画，物理模拟等待，这些取决于application的类型。<br>Geometry Processing阶段主要处理转换（transforms），投影（projections）等等其他所有类型的几何操作，这个阶段计算了什么将会被渲染，怎样被渲染，在哪里被渲染，主要在GPU上完成。<br>Rasterization阶段一般接受三个顶点，构建出一个三角形，找到所有被这个三角形包含着的像素点，然后把这些像素点传递给Pixel Processing阶段，这部分完全在GPU上完成。<br>Pixel Processing阶段执行逐像素的程序，计算每个像素的color，也许会进行Z-Test等进行可见性判断，也许会进行blend操作等，这部分也完全在GPU上完成。</p>
<h1 id="具体介绍每个阶段"><a href="#具体介绍每个阶段" class="headerlink" title="具体介绍每个阶段"></a>具体介绍每个阶段</h1><h2 id="Application-Stage"><a href="#Application-Stage" class="headerlink" title="Application Stage"></a>Application Stage</h2><p>这部分是开发者完全控制的阶段，因为这部分通常是基于CPU执行的，对于这部分的改变会影响后续阶段的performance（比如这里可以通过算法减低要被渲染的三角形的数量）但是现在在这部分平台上也可以使用计算着色器来借GPU的力量加速。这个阶段的最后，渲染图元（点、线、三角形）传入到Geometry Procssing阶段。<br>这个部分是不能被分割成子部分的，因为这个是基于软件的实现方式，我们最多只能借助CPU的多核编写多线程程序来提升性能<br>这个阶段也是用来处理外接设备的输入，两个物体的碰撞检测，加速算法（比如部分剔除算法）</p>
<h2 id="Geometry-Processing"><a href="#Geometry-Processing" class="headerlink" title="Geometry Processing"></a>Geometry Processing</h2><p>用来负责逐三角形和逐顶点的操作。这部分可以被分为4个阶段：Vertex Shading，Projection，Clipping和Screen Mapping，下面逐一介绍：<br>Vertex Shading：这个子阶段主要处理两个任务：1.计算顶点位置 2.计算每个顶点包含的其他性质，如发现，纹理坐标等<br>以前会在这里实现逐顶点的光照，所以叫顶点着色器，现在顶点着色器变成了一个更加通用的用来设定与操作每个顶点相关的数据的计算单元（比如可以实现顶点动画等）<br>这个阶段同时是转换坐标的阶段，把坐标从模型空间转换到世界空间，为了便于后续的投影和裁剪，在使用view transform转换到相机空间，同时保存每个顶点对应的material，normal等信息，接下来把它转换到一个单位(-1,-1,-1)(1,1,1)中进行投影（z也可能是[0,1]），首先是进行投影，投影可分为正交投影和透视投影，在进行顶点着色器的操作<br>这个子阶段的输出（包含颜色，纹理坐标等）被送到Rasterization和Pixel Processing阶段被插值，用来计算表面的shading，这一步结束后，z-轴坐标不再存储在image中，而是z-buffer内，也就是说，这一步把3D-&gt;2D。</p>
<p>Optional Vertex Processing：这个阶段是可选的，而且不同的GPU对这部分的硬件支持程度也是不同的。简单来说依次是曲面细分，几何着色和流输出。</p>
<p>Clipping：只有那些全部部分在view volume中的渲染图元才能够pass这个阶段进入后续的阶段，使用投影矩阵意味着把transform后的图元裁剪单位立方体中。</p>
<img src="/2019/04/12/RTR-4th-Chapter2/2.jpg">
<p>Screen Mapping：把还是3D的坐标转换成屏幕坐标（屏幕坐标原点取决于API）</p>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>目标：找到所有被渲染图元包含或覆盖的像素点<br>这部分分为两个部分：三角形建立和三角形遍历。把2D的顶点在屏幕空间转换到屏幕上的像素，在这里，三角形通过传入的3个点得以简历，最后把所有图元的像素点传递到Pixel Processing中。这个阶段通常是由硬件实现的。</p>
<h2 id="Pixel-Processing"><a href="#Pixel-Processing" class="headerlink" title="Pixel Processing"></a>Pixel Processing</h2><p>这个阶段通常分为2个子阶段，分别是Pixel Shading和Mergeing<br>Pixel Shading：所有逐像素的计算都在这里完成，这里的输入是通过shading data的插值得到的。这里是基本上完全可编程的，通过自定义片元着色器（或者叫像素着色器）在GPU上完成光照，纹理等计算<br>Mergeing：每个像素存储来一个叫颜色缓冲的地方，我们需要一个Merge阶段处理片元着色器出来的颜色和buffer中本来存着的颜色之间的关系，这部分也用来负责可见性问题（使用z-buffer算法）<br>模版缓冲是一个离屏缓冲用来记录渲染图元的位置，每个像素通常为8bit，可以用来控制后续图元的渲染情况（通过模版测试的方式）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/unity-render-optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/unity-render-optimize/" class="post-title-link" itemprop="url">Unity中的渲染优化技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 20:01:17" itemprop="dateCreated datePublished" datetime="2019-04-11T20:01:17+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="移动平台的特点"><a href="#移动平台的特点" class="headerlink" title="移动平台的特点"></a>移动平台的特点</h1><p>和PC平台相比，移动平台上的GPU架构有很大的不同。由于处理资源等条件的限制，移动设备上的GPU架构专注于尽可能使用更小的带宽和公共能，也由此带来许多和PC平台完全不同的现象。<br>例如，为了尽可能移除那些隐藏的表面，减少overdraw（即一个像素被绘制多次），PowerVR芯片（通常用于iOS设备和某些Android设备）使用了基于瓦片的延迟渲染（Tiled-based Deffered Rendering，TBDR）架构，把所有的渲染图像装入一个个瓦片（tile）中，再由硬件找到可见的片元，而只有这些可见片元才会执行片元着色器。另一些基于瓦片的GPU架构，如Adreno（高通的芯片）和Mali（ARM的芯片）则会使用Early-Z或相似的技术进行一个低精度的深度检测，来剔除那些不需要渲染的片元。还有一些GPU，如Tegra（英伟达的芯片），则使用了传统的架构设计，因为在这些设备上，overdraw更可能造成性能的瓶颈。<br>由于这些芯片架构造成的不同，一些游戏往往需要针对不通的芯片发布不同的版本，以便对每个芯片进行更有针对性的优化。尤其是在Android平台上，不通设备使用的硬件，如图形芯片、屏幕分辨率等，大相径庭，这对图形优化提出了更高的挑战。相比于Android平台，iOS平台的硬件条件则相对统一。</p>
<h1 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h1><p>首先，在学习如何优化之前，我们得先了解影响游戏性能的因素有哪些。对于一个游戏来说，它主要需要使用两种计算资源：CPU和GPU。它们会互相合作，来让我们的游戏可以在预期的帧率和分辨率下工作。其中，CPU主要负责保证帧率，GPU主要负责分辨率相关的一些处理。<br>据此，可以把造成游戏性能瓶颈的主要原因分成以下几个方面。</p>
<ol>
<li>CPU<ul>
<li>过多的draw call</li>
<li>复杂的脚本或者物理模拟</li>
</ul>
</li>
<li>GPU<ul>
<li>顶点处理<ul>
<li>过多的顶点</li>
<li>过多的逐顶点计算</li>
</ul>
</li>
<li>片元处理<ul>
<li>过多的片元（既可能是由于分辨率造成的，也可能是由于overdraw造成的）。</li>
<li>过多的逐片元计算。</li>
</ul>
</li>
</ul>
</li>
<li>带宽<ul>
<li>使用了尺寸很大且未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ul>
</li>
</ol>
<p>对于CPU来说，限制它的主要是每一帧draw call的数目。简单来说，就是CPU在每次通知GPU进行渲染之前，都需要提前准备好顶点数据（如位置、法线、颜色、纹理坐标等），然后调用一系列API把它们放到GPU可以访问到的指定位置，最后，调用一个绘制命令，来告诉GPU。而调用一次绘制命令的时候，就会产生一个draw call。过多的draw call会造成CPU的性能瓶颈，这是因为每次调用draw call时，CPU往往都需要改变很多渲染状态的设置，而这些操作是非常耗时的。如果一帧中需要的draw call数目过多的话，就会导致CPU把大部分时间都花费在提交draw call的工作上面了。当然，其他原因也可能造成CPU瓶颈，例如物理、布料模拟、蒙皮、粒子模拟等，这些都是计算量很大的操作。<br>而对于GPU来说，它负责整个渲染流水线。它从处理CPU传递过来的模拟数据开始，进行顶点着色器、片元着色器等一系列工作，最后输出屏幕上的每个像素。因此，GPU的性能瓶颈和需要处理的顶点数目、屏幕分辨率、显存等因素有关。而相关的优化策略可以减少处理的数据（包括顶点数目和片元数目）、减少运算复杂度等方面入手。</p>
<ol>
<li>CPU优化<ul>
<li>使用批处理技术减少draw call数目</li>
</ul>
</li>
<li>GPU优化<ul>
<li>减少需要处理的顶点数目。<ul>
<li>优化几何体</li>
<li>使用模型的LOD（Level of Detail）技术</li>
<li>使用遮挡剔除（Ovvlusion Culling）技术</li>
</ul>
</li>
<li>减少需要处理的片元数目<ul>
<li>控制绘制顺序</li>
<li>警惕透明物体</li>
<li>减少实时光照</li>
</ul>
</li>
<li>减少计算复杂度<ul>
<li>使用Shader的LOD（Level Of Deail）技术</li>
<li>代码方面的优化</li>
</ul>
</li>
<li>节省内存带宽<ul>
<li>减少纹理大小</li>
<li>利用分辨率缩放</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在开始优化之前，我们首先需要知道是哪个步骤造成了性能瓶颈。而这可以利用Unity提供的一些渲染分析工具来实现。</p>
<h1 id="Unity中的渲染分析工具"><a href="#Unity中的渲染分析工具" class="headerlink" title="Unity中的渲染分析工具"></a>Unity中的渲染分析工具</h1><p>Unity内置了一些工具，来帮助我们方便地查看和渲染相关的各个统计数据。这些数据可以帮助我们分析游戏渲染性能，从而更有针对性的进行优化。这些工具包括了渲染统计窗口（Rendering Statistics Window）、性能分析器（Profiler），以及帧调试器（Frame Debugger）。需要注意的是，在不同的目标平台上，这些工具中显示的数据也会发生变化。</p>
<h2 id="渲染统计窗口"><a href="#渲染统计窗口" class="headerlink" title="渲染统计窗口"></a>渲染统计窗口</h2><p>渲染统计窗口主要包含了音频（Audio）、图像（Graphics）。这里我们只关心图像相关的渲染统计结果。<br>渲染统计窗口中显示了很多重要的渲染数据，例如FPS、批处理数目、顶点和三角网格的数目等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信息名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>每帧的时间和FPS</td>
<td>在Graphic的右侧显示，给出了处理和渲染一帧所需的时间，以及FPS数目</td>
</tr>
<tr>
<td>Batches</td>
<td>一帧中需要进行的批处理数目</td>
</tr>
<tr>
<td>Saved by batching</td>
<td>合并的批处理数目，这个数字表明了批处理为我们节省了多少的draw call</td>
</tr>
<tr>
<td>Tris和Verts</td>
<td>需要绘制的三角面片和顶点数目</td>
</tr>
<tr>
<td>Screen</td>
<td>屏幕的大小，以及它占用的内存大小</td>
</tr>
<tr>
<td>SetPass calls</td>
<td>渲染使用的Pass的数目，每个Pass都需要Unity的runtime来绑定一个新的Shader，这可能造成CPU瓶颈</td>
</tr>
<tr>
<td>Shadow casters</td>
<td>场景中有多少可以投射阴影的物体，一般这些物体都作为场景中光源</td>
</tr>
<tr>
<td>visible skinned meshed</td>
<td>渲染皮肤网格的数量</td>
</tr>
<tr>
<td>animations</td>
<td>正在播放动画的数量</td>
</tr>
</tbody>
</table>
</div>
<h2 id="性能分析器的渲染区域"><a href="#性能分析器的渲染区域" class="headerlink" title="性能分析器的渲染区域"></a>性能分析器的渲染区域</h2><img src="/2019/04/11/unity-render-optimize/1.jpg">
<p>性能分析器显示了绝大部分在渲染统计窗口中提供的信息，例如，绿线显示了批处理数目、蓝线显示了Pass数目等，同时还给出了许多其他非常有用的信息，例如，draw call数目、动态批处理/静态批处理的数目、渲染纹理的数目和内存占用等。<br>结合渲染统计窗口和性能分析器，我们可以查看与渲染相关的绝大多数重要的数据。一个值得注意的想象是，性能分析器给出的draw call数目和批处理数目、Pass数目并不相等，并且看起来好像要大于我们估算的数目，这是因为Unity在背后需要进行很多工作，例如，初始化各个缓存、为阴影更新深度纹理和阴影映射纹理等，因此需要花费比“预期”更多的draw call。</p>
<h2 id="帧调试器"><a href="#帧调试器" class="headerlink" title="帧调试器"></a>帧调试器</h2><p><div align="center"><img src="/2019/04/11/unity-render-optimize/2.jpg"></div><br>帧调试器的调试面板上显示了渲染这一帧锁需要的所有的渲染时间，在本例中，事件数目为41，而其中包含了36个draw call事件（其他渲染时间多为清空缓存等）。通过单击面板上的每个事件，我们可以在Game视图查看该时间的绘制结果，同时渲染统计面上的数据也会显示成截至当前事件为止的各个渲染统计数据。</p>
<h2 id="其他性能分析工具"><a href="#其他性能分析工具" class="headerlink" title="其他性能分析工具"></a>其他性能分析工具</h2><p>对于Android平台来说，高通的Adreno分析工具可以对不同的测试机进行详细的性能分析。英伟达提供的NVPerfHUD工具来帮助我们得到几乎所有需要的性能分析数据，例如，每个draw call的GPU时间，每个shader话费的cycle数目等。<br>对于iOS平台来说，Unity内置的分析器可以得到整个场景的花费的GPU时间。PowerVRaw的PVRUniSCo shader分析器也可以给出一个大致的性能评估。Xcode中的OpenGL ES Driver Instruments可以给出一些宏观上的性能信息，例如，设备利用率、渲染器利用率等。但相对于Android平台，对iOS的性能分析更加困难（工具较少）。而且PowerVR芯片采用了基于瓦片的延迟渲染器，因此，想要得到每个draw call话费的GPU时间是几乎不可能的。这是，一些宏观上统计数据可能更有参考价值。</p>
<h1 id="减少draw-call数目"><a href="#减少draw-call数目" class="headerlink" title="减少draw call数目"></a>减少draw call数目</h1><p>批处理的实现原理就是为了减少每一帧需要的draw call数目。为了把一个对象渲染到屏幕上，</p>
<h4 id="动态批处理"><a href="#动态批处理" class="headerlink" title="动态批处理"></a>动态批处理</h4><p>基本原理：每一帧把可以进行批处理的模型网格进行合并，再把合并后的模型数据传递给GPU，然后使用同一个材质对其渲染。动态批处理的一个好处是实现方便，另一个好处是，经过批处理的物体仍然可以移动，这是由于在处理每帧时Unity都会重新合并一次网格。</p>
<p>条件限制：</p>
<ul>
<li>能够进行动态批处理的网格的顶点属性规模要小于900。例如，如果shader中需要使用顶点位置、发现和纹理坐标这3个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。</li>
<li>多Pass的shader会中断批处理。在前向渲染中，我们有时需要使用额外的Pass来为模型添加更多的光照效果，但这样一来模型就不会被动态批处理了。</li>
</ul>
<h4 id="静态批处理"><a href="#静态批处理" class="headerlink" title="静态批处理"></a>静态批处理</h4><p>Unity提供了另一种批处理方式，即静态批处理。相比于动态批处理来说，静态批处理适用于任何大小的几何模式。它的实现原理是，只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网络结构中，这意味着这些模型不可以在运行时刻被移动。但由于它只需要进行一次合并操作，因此，比动态批处理更加高效。静态批处理的另一个缺点在与，它往往需要占用更多的内存来存储合并后的几何结构。这是因为，如果在静态批处理钱一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品，即一个网格会变成多个网格在发送给GPU。如果这类使用同一网格的对象很多，那么这就会成为一个性能瓶颈了。例如，如果在一个使用了1000个相同模型的森林中使用静态批处理，那么，就会多使用1000倍的内存，这会造成严重的内存影响。</p>
<h4 id="共享材质"><a href="#共享材质" class="headerlink" title="共享材质"></a>共享材质</h4><p>无论是静态批处理还是动态批处理，都要求模型之间需要共享同一个材质。但不同的模型之间总会需要有不同的渲染属性，例如，使用不同的纹理、颜色等。这是，我们需要一些策略来尽可能地合并材质。<br>如果两个材质之间只有使用的纹理不同，我们可以把这些纹理合并到一张更大的纹理中，这张更大的纹理被称为是一张图集（atlas）。一旦使用了同一张纹理，我们就可以使用同一个材质，再使用不同的采样坐标对纹理采样即可。<br>但有时，除了纹理不同外，不同的物体在材质上还有一些微小的参数变化，例如，颜色不同、某些浮点属性不同。但是，不管是动态批处理还是静态批处理，它们的前提都是要使用同一个材质。是同一个，而不是使用了同一种Shader的材质，也就是说它们指向的材质必须是同一个实体。这意味着，只要我们调整了参数，就会影响所有使用这个材质的对象，那么想要微小的调整怎么办？一种常用的方法就是使用网格的顶点（最常见的就是顶点颜色数据）来存储这些参数。经过批处理后的物体会被处理成更大的VBO发送给GPU，VBO中的数据可以作为输入传递给顶点着色器，因此，我们可以巧妙地对VBO中的数据进行控制，从而达到不通效果的目的。一个例子是，森林场景中所有的树使用了同一种材质，我们希望它们可以通过批处理来减少draw call，但不同树的颜色可能不同。这么，我们可以利用网格的顶点的颜色数据来调整。</p>
<h4 id="批处理的注意事项"><a href="#批处理的注意事项" class="headerlink" title="批处理的注意事项"></a>批处理的注意事项</h4><h3 id="减少需要处理的顶点数目"><a href="#减少需要处理的顶点数目" class="headerlink" title="减少需要处理的顶点数目"></a>减少需要处理的顶点数目</h3><h4 id="优化几何体"><a href="#优化几何体" class="headerlink" title="优化几何体"></a>优化几何体</h4><p>移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离。</p>
<h4 id="模型的LOD技术"><a href="#模型的LOD技术" class="headerlink" title="模型的LOD技术"></a>模型的LOD技术</h4><h4 id="遮挡剔除技术"><a href="#遮挡剔除技术" class="headerlink" title="遮挡剔除技术"></a>遮挡剔除技术</h4><h3 id="减少需要处理的片元数目"><a href="#减少需要处理的片元数目" class="headerlink" title="减少需要处理的片元数目"></a>减少需要处理的片元数目</h3><h4 id="控制绘制顺序"><a href="#控制绘制顺序" class="headerlink" title="控制绘制顺序"></a>控制绘制顺序</h4><h4 id="时刻警惕透明物体"><a href="#时刻警惕透明物体" class="headerlink" title="时刻警惕透明物体"></a>时刻警惕透明物体</h4><h4 id="减少实时光照和阴影"><a href="#减少实时光照和阴影" class="headerlink" title="减少实时光照和阴影"></a>减少实时光照和阴影</h4><h3 id="节省带宽"><a href="#节省带宽" class="headerlink" title="节省带宽"></a>节省带宽</h3><h4 id="减少纹理大小"><a href="#减少纹理大小" class="headerlink" title="减少纹理大小"></a>减少纹理大小</h4><ul>
<li>纹理的长宽比最好是正方形，长宽值最好是2的整数幂</li>
<li>多级渐远纹理技术（mipmapping）和纹理压缩。</li>
</ul>
<h4 id="利用分辨率缩放"><a href="#利用分辨率缩放" class="headerlink" title="利用分辨率缩放"></a>利用分辨率缩放</h4><h3 id="减少计算复杂度"><a href="#减少计算复杂度" class="headerlink" title="减少计算复杂度"></a>减少计算复杂度</h3><h4 id="Shader的LOD技术"><a href="#Shader的LOD技术" class="headerlink" title="Shader的LOD技术"></a>Shader的LOD技术</h4><h4 id="代码方面的优化"><a href="#代码方面的优化" class="headerlink" title="代码方面的优化"></a>代码方面的优化</h4><h4 id="根据硬件进行缩放"><a href="#根据硬件进行缩放" class="headerlink" title="根据硬件进行缩放"></a>根据硬件进行缩放</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/11/physics-base-render/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/11/physics-base-render/" class="post-title-link" itemprop="url">基于物理的渲染</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 16:58:13" itemprop="dateCreated datePublished" datetime="2019-04-11T16:58:13+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="双向反射分布函数（BRDF）"><a href="#双向反射分布函数（BRDF）" class="headerlink" title="双向反射分布函数（BRDF）"></a>双向反射分布函数（BRDF）</h2><p><strong>辐射率（radiance）</strong>是单位面积、单位方向上光源的辐射通量，通常用L表示，被认为是对单一光线的亮度和颜色评估。<font color="red">在渲染中，我们通常会基于表面的入射光线的入射辐射率 $ L<em>i  $ 来计算出射辐射率 $L</em>{0}$ ，这个过程往往也称为<strong>着色（shading）</strong>过程。</font><br>而要得到出射辐射率$L_{o}$，我们需要知道物体表面一点是如何和光进行交互的。而这个过程就可以使用<strong>BRDF（Bidirectional Reflectance Distribution Function，双向反射分布函数）</strong>来定量分析。在大多数情况下，BRDF可以用$f(I,v)$来表示，其中I为入射方向和v为观察方向（双向的含义）。这种情况下，绕着表面法线旋转入射方向或观察方向并不会影响BRDF的结果，这种BRDF被称为是<strong>各项同性（isotropic）</strong>的BRDF。与之对应的则是<strong>各项异性（anisotropic）</strong>的BRDF。</p>
<p>公式如下：</p>
<p>$L<em>{o}(p,w</em>{o}) = \int<em>\Omega(k</em>{d}{c \over \pi} + k<em>{s}{DGF \over 4(w</em>{o} \cdot n)(w<em>{i} \cdot n)})L</em>{i}(p,w<em>{i})(w</em>{i} \cdot n)dw_{i}$</p>
<p>这是PBR的核心，也是主要的劝退点。<br>翻译成自然语言，大概是这样的：</p>
<p>$输出颜色 = \int<em>\Omega(漫反射比例{纹理颜色 \over \pi} + 镜面反射比例{镜面高光 x 几何遮蔽 x 菲涅尔效应 \over 4(view</em>{Dir} \cdot normal)(lightDir \cdot normal)})光源颜色(lightDir,normal)dw_{i}$</p>
<p>先解释下这个公式遗留的部分。半球积分($\int<em>\Omega………dw</em>{i}$)</p>
<h3 id="放置反射探针"><a href="#放置反射探针" class="headerlink" title="放置反射探针"></a>放置反射探针</h3><p>在实时渲染中，我们经常会使用Cubemap来模拟物体的反射效果。例如，在赛车游戏中，我们需要对车身或车窗使用反射映射的技术来模拟它们的反光材质。然而，如果我们永远使用同一个Cubemap，那么，当赛车周围的场景发生较大变化时，就很容易出现“穿帮镜头”，因为车身或车窗的环境反射并没有随环境变化而变换。一种解决办法是可以在脚本中控制何时生成从当前位置观察到的Cubemap，Unity中提供了反射探针<strong>（Reflection Probes）</strong>。反射探针的工作原理和光照探针（Light Probes）类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity会把这些邻近探针存储的反射结果传递给物体使用的反射纹理。如果物体周围存在多个反射探针，Unity还会在这些反射之间进行插值，来得到平滑渐变的反射效果。实际上，Unity会在场景中放置一个默认的反射探针，这个反射探针粗怒触了对场景使用的Skybox的反射结果，来作为场景的环境光照。如果我们需要让场景中的物体包含额外的反射效果，就需要放置更多的反射探针。<br>反射探针同样有3种类型：Baked，这种类型的反射探针是通过提前烘培来得到该位置使用的Cubemap的，在游戏运行时反射探针中存储的Cubemap并不会发生变化。需要注意的是，这种类型的反射探针在烘培时同样只会处理那些静态物体（即那些被标志为Reflection Probe Static的物体）；Realtime，这种类型则会实时更新当前的Cubemap，并且不受静态物体还是动态物体的影响。当然，这种类型的反射探针需要花费更多的处理时间，因此，在使用时应当非常小心它们的性能。幸运的是，Unity允许我们从脚本中通过触发来精确控制反射探针的更新；最后一种类型是Custom，这种类型的探针即可以让我们从编辑器中烘培它，也可以让我们使用一个自定义的Cubemap来作为反射映射，但自定义的Cubemap不会被实时更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
