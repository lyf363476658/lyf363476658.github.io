<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/14/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/10/diffuse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/10/diffuse/" class="post-title-link" itemprop="url">标准光照模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-10 13:29:47" itemprop="dateCreated datePublished" datetime="2019-04-10T13:29:47+08:00">2019-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/10/diffuse/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/10/diffuse/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基本光照模型中漫反射部分的计算公式：<br>$c<em>{diffuse}=(c</em>{light} \cdot m<em>{diffuse})max(0, \vec{n} \cdot I)$<br>从公式可以看出，要计算漫反射需要知道4个参数：入射光线的颜色和强度$c</em>{light}$，表面发现$\vec{n}$以及光源方向$I$。<br>为了防止点击结果为赋值，我们需要使用max操作，而CG提供了这样的函数。在本例中，使用CG的另一个函数可以达到同样的目的，即saturate函数。<br><strong>函数：</strong>saturate(x)<br><strong>参数：</strong>x：用于操作的标量或矢量，可以是float、float2、float3等类型。<br><strong>描述：</strong>把x截取在[0,1]范围内，如果x是一个矢量，那么会对它的每一个分量进行这样的操作。</p>
<h1 id="逐顶点光照"><a href="#逐顶点光照" class="headerlink" title="逐顶点光照"></a>逐顶点光照</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Unity/Diffuse Vertex"</span>&#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (<span class="string">"Diffuse"</span>, Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 材质的漫反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 高光系数</span></span><br><span class="line">    &#125;   </span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tasg&#123;<span class="string">"LightMode"</span>=<span class="string">"ForwardBase"</span>&#125; <span class="comment">// 前向渲染，所有光源都在一个着色器中进行</span></span><br><span class="line">        &#125;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">        #pragma vertex vert</span><br><span class="line">        #pragma fragment frag</span><br><span class="line">        #include <span class="string">"Lighting.cginc"</span></span><br><span class="line">        fixed4 _Diffuse;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span>&#123;</span></span><br><span class="line">            float4 vertex : POSITION;</span><br><span class="line">            float3 normal : NORMAL;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            fixed3 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">v2f <span class="title">vert</span><span class="params">(a2v v)</span></span>&#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            float3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; <span class="comment">// 环境光</span></span><br><span class="line">            float3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); <span class="comment">// 世界法线</span></span><br><span class="line">            float3 lightNormal = normalize(_WorldSpaceLightPos0.xyz); <span class="comment">// 光的方向</span></span><br><span class="line">            float3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, lightNormal));</span><br><span class="line">            o.color = diffuse + ambient;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        fixed4 frag(v2f o) : COLOR</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(o.color,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶点着色器最基本的任务就是把顶点位置从模型空间转换到裁剪空间中，因此我们需要使用Unity内置的模型*世界*投影矩阵UNITY_MATRIX_MVP来完成这样的坐标转换。通过Unity的内置变量UNITY_LIGHTMODEL_AMBIENT得到了环境光部分。<br>然后，就是真正计算漫反射光照的部分。为了计算慢反射光照我们需要知道4个参数。在前面的步骤中，我们已经知道了材质的漫反射颜色_Diffuse以及顶点发现v.normal。我们还需知道光源的颜色和强度信息以及光源方向。Unity提供给我们一个内置变量_LightColor0来访问该Pass处理的光源的颜色和强度信息（注意，想要得到正确的值需要定义合适的LightMode标签），而光源方向可以由_WorldSpaceLightPos0来得到。需要注意的是，这里对光源方向的计算并不具有通用性。这里，我们假设场景中只有一个光源且该光源的类型是平行光。但如果场景中有多个光源并且类型可能是点光源等其他类型，直接使用_WorldSpaceLightPos0就不能得到正确的结果。</p>
<h1 id="半兰伯特光照模型"><a href="#半兰伯特光照模型" class="headerlink" title="半兰伯特光照模型"></a>半兰伯特光照模型</h1><p>$c<em>{diffuse}=(c</em>{light}\cdot m_{diffuse})(\alpha (\vec {n}\cdot I)+\beta)$<br>可以看出，与原兰伯特模型相比，半兰伯特光照模型没有使用max操作来防止$\vec {n}$</p>
<h1 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h1><p>Blinn模型计算高光反射的公式如下：</p>
<font size="4">
$c_{specular}=(c_{light} \cdot m_{specular})max(0,\vec{n} \cdot \vec{h})^{m_{glass}}$    
</font>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/10/new-delete-malloc-free/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/10/new-delete-malloc-free/" class="post-title-link" itemprop="url">new delete malloc free</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-10 11:34:54" itemprop="dateCreated datePublished" datetime="2019-04-10T11:34:54+08:00">2019-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/10/new-delete-malloc-free/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/10/new-delete-malloc-free/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>每个程序在执行时都会占用一块可用的内存空间，用于存放动态分配的对象，此内存空间成为自由存储区或堆。</p>
<h1 id="new和delete用法"><a href="#new和delete用法" class="headerlink" title="new和delete用法"></a>new和delete用法</h1><p>如下几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>第一行这个new表达式在自由存储区中分配创建了一个整型对象，并返回一个指向该对象的地址来初始化指针pi。第二行将指针pi指向的地址的值进行了初始化为0。第三行初始化为1024.<br>当动态创建的对象用完后必须释放内存，避免造成内存泄漏，可以用delete来完成，new和delete是成对使用的，如下命令释放pi指向的int型对象所占用的内存空间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure></p>
<p>此时pi尽管没有定义，但仍然存放了呃它所指向对象的地址，然而pi所指向的内存已经被释放，因此pi不再有效。建议一旦删除指针所指向的对象，立即将指针置为0，这样就清楚的表明指针不再指向任何对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是当执行下列表达式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pi = &amp;i;</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure></p>
<p>编译器一般不会报错，因为编译器通常不能断定一个指针指向什么类型的对象，所以尽管这个语句是错误的，但在大多数编译器上仍然能通过。<br>C++中允许动态创建const对象：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p>
<p>动态创建的const对象必须进行初始化，并且进行初始化后的值不能在改变。<br>当创建一个动态数组对象和进行内存释放时，执行以下语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[];    <span class="comment">// pi所指向的数组未初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[n];   <span class="comment">// pi指向长度为n的数组，未初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[]();  <span class="comment">// 指针pi所指向的地址初始化为0</span></span><br><span class="line"><span class="keyword">delete</span> [] pi;           <span class="comment">// 回收pi所指向的数组</span></span><br></pre></td></tr></table></figure></p>
<h1 id="malloc和free的用法"><a href="#malloc和free的用法" class="headerlink" title="malloc和free的用法"></a>malloc和free的用法</h1><p>两个函数的原型如下，他们都在头文件stdlib.h中声明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *pointer)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>示例代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);            <span class="comment">// 指向整型的指针p指向一个大小为100字节的内存的地址</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">25</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 指向整型的指针p指向一个25个int整型空间的地址</span></span><br></pre></td></tr></table></figure></p>
<p>因为malloc()函数的返回值类型为void *，所以需要在函数前面进行相应的强制类型转换。当int占4个字节内存时，上述的两个语句代码获得的内存空间大小是相同的。分配内存后需要验证内存是否分配成功，完成后free()释放内存，完整语句如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">if</span> (pi == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Out of memory!\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure></p>
<p>另外两个分配内存的函数：calloc和realloc，他们的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num_elements, <span class="keyword">size_t</span> element_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *tr, <span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0。另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数。<br>relloc函数用于修改一个原先已经分配的内存块大小。可以使一块内存扩大或缩小，如果扩大内存，则原来的内存块保持不变，在内存尾部增加新的内存块，切不进行初始化。如果缩小内存，则原来内存块从尾部进行删减。如果原先的内存块无法扩充，则新开辟一块内存，并复制原先的内存的内容，原先内存块失效无法再进行访问。</p>
<h1 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>使用new操作符申请内存分配时无须指定内存的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
<h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符号类型安全的操作符。而malloc内存分配成功则返回void <em>，需要通过强制类型转换将void </em>指针转换成我们需要的类型。</p>
<h2 id="分配失败"><a href="#分配失败" class="headerlink" title="分配失败"></a>分配失败</h2><p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时会返回NULL。</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。<br>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++允许重载new/delete操作符，malloc不允许重载。</p>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统锁维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p>
<hr>
<p>在C++/C#中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；<br>在C中，内存区分为堆、栈、全局/静态存储区、常量存储区；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/protocol-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/protocol-buffer/" class="post-title-link" itemprop="url">Google Protocol Buffer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 22:21:39" itemprop="dateCreated datePublished" datetime="2019-04-09T22:21:39+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Server/" itemprop="url" rel="index"><span itemprop="name">Server</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/protocol-buffer/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/protocol-buffer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义一个消息类型"><a href="#定义一个消息类型" class="headerlink" title="定义一个消息类型"></a>定义一个消息类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest</span><br><span class="line">&#123;</span><br><span class="line">    required <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">    optional int32 page_number = <span class="number">2</span>;</span><br><span class="line">    optional int32 result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该消息定义了三个字段，两个int32类型和一个string类型的字段，每个字段由字段限制，字段类型，字段名和Tag四部分组成，对于C++，每一个.proto文件经过编译之后都会对应的生成一个.h和一个.cc文件</p>
<h1 id="字段限制"><a href="#字段限制" class="headerlink" title="字段限制"></a>字段限制</h1><p>字段限制共有3类<br><strong>required</strong>:必须赋值的字段<br><strong>optional</strong>:可有可无的字段<br><strong>repeated</strong>:可重复字段（变长字段），类似于数组<br>由于一些历史原因，repeated字段并没有想象中那么高效，新版本中允许使用特殊的选项来获得更高效的编码：</p>
<pre><code>repeated int32 samples = 4 [packet=true];
</code></pre><h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><p>消息中的每一个字段都由一个独一无二的数值类型的Tag.1到15使用一个字节编码，16到2047使用2个字节编码，所以应该将Tags 1到15留个频繁使用的字段。<br>可以指定的最小的Tag为1，最大位$2^29$-1或536,870,911，但不能使用19000到19999之间的值，这些值是预留给protocol buffer的。</p>
<h1 id="Google-Protocol-Buffer的Encoding"><a href="#Google-Protocol-Buffer的Encoding" class="headerlink" title="Google Protocol Buffer的Encoding"></a>Google Protocol Buffer的Encoding</h1><p>Protobuf序列化所生成的二进制消息非常紧凑，这得益于Protobuf采用的非常巧妙的Encoding方法。<br>考擦消息结构之前，让我首先要介绍一个叫Varint的术语。<br>Varint是一种紧凑的表示数字的方法。它用一个或这个字节来表示一个数字，值越小的数字使用越小的字节数。这能减少用来表示数字的字节数。<br>比如对于int32类型的数字，一般需要4个byte来表示。但是采用Varint，对于很小的int32类型的数字，则可以用1个byte来表示。大的数字则需要5个byte表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用Varint后，可以用更少的字节数来吧iaoshi数字信息。下面就详细介绍一下Varint。<br>Varint中的每个byte的最高位bit有特殊的含义，如果该位为1，表示后续的byte也是该数字的一部分，如果该位为0，则结束。其他的7个bit都用来表示数字。因此小于128的数字都可以用一个byte表示。大于128的数字，比如300，会用两个字节来表示：1010 1100 0000 0010<br>下图演示了Google Protocol Buffer如何解析两个bytes。注意到最终计算前将两个byte的位置相互交换过一次，这是因为Google Protocol Buffer字节序采用little-endian的方式。</p>
<img src="/2019/04/09/protocol-buffer/1.jpg">
<p>消息经过序列化会成为一个二进制数据流，该流中的数据为一系列的Key-Value对。如下图所示：<br><img src="/2019/04/09/protocol-buffer/7.jpg"><br>采用这种Key-Pair结构无需使用分隔符来分割不通的Field。对于可选的Field，如果消息中不存在该Field，那么在最终的Message Buffer中就没有该field，这些特性都有助于节约消息本身的大小。<br>假如我们生成如下的一个消息Test1：</p>
<pre><code>Test1.id = 10;
Test1.str = &quot;hello&quot;;
</code></pre><p>则最终的Message Buffer中有两个Key-Value对，一个对应消息中的id；另一个对应str。<br>Key用来标识具体的field，在解包的时候，Protocol Buffer根据Key就可以知道相应的Value应该对应于消息中那一个Field。<br>Key的定义如下：</p>
<pre><code>(field_number&lt;&lt;3)|wire_type
</code></pre><p>可以看到Key由两部分组成。第一部分是field_number，比如消息Im.helloworld中的field id的field_number为1.第二部分为wire_type。表示Value的传输类型。</p>
<p>Wire Type可能的类型如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>Meaning</th>
<th>Used For</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Varint</td>
<td>int32,int64,uint32,uint64,sint32,sint64,bool,enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td>fixed64,sfixed64,double</td>
</tr>
</tbody>
</table>
</div>
<p>在我们的例子中，field id所采用的数据类型为int32，因此对应的wire type为0。可以看到Type 0所能表示的数据类型中有int32和sint32这两个非常类似的数据类型。Google Protocol Buffer区别它们的主要意图也是为了减少encoding后的字节数。<br>在计算内，一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用Varint表示一个负数，那么一定需要5个byte。为此Google Protocol Buffer定义了sint32这种类型，采用zigzag编码。<br>Zigzag编码用无符号数来表示有符号数字，正数和负数交错，这就是zigzag这个词的含义了。<br>如图所示：<br><img src="/2019/04/09/protocol-buffer/8.jpg"></p>
<p>使用zigzag编码，绝对值小的数字，无论正负都可以采用较少的byte来表示，充分利用了Varint这种技术。<br>其他的数据类型，比如字符串则采用类似数据库中的varchar的表示方法，即用一个varint表示长度，然后将其余部分紧跟在这个长度部分之后即可。<br>通过以上对protobuf Encoding方法的介绍，想必已经发现protobuf消息的内容效，适合网络传输。<br>对于消息Test1，用Protobuf序列化后的字节序为：<br>08 65 12 06 48 65 6C 6C 6F 77<br>而如果用XML，则类似这样<br>31 30 31 3C 2F 69 64 3E 3C 6E 61 6D 65 3E 68 65<br>6C 6C 6F 3C 2F 6E 61 6D 65 3E 3C 2F 68 65 6C 6C<br>6F 77 6F 72 6C 64 3E<br>一共55个字节，这些奇怪的数字需要稍微解释一下，其含义用ASCII表示如下：</p>
<p><helloworld><br>    <id>101</id><br>    <name>hello</name>
</helloworld></p>
<h1 id="封解包的速度"><a href="#封解包的速度" class="headerlink" title="封解包的速度"></a>封解包的速度</h1><p>首先我们来了解一下XML的封解包过程。XML需要从文件中读取出字符串，在转换为XML文档对象结构模型。之后，在从XML文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将XML文件转换为文档对象结构模型的过程通常需要完成词法文法分等大量消耗CPU的复杂计算。<br>反观Protobuf，它只需要简单地将一个二进制序列，按照指定的格式读取到C++对应的结构类型中就可以了。<br><img src="/2019/04/09/protocol-buffer/9.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/lua-hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/lua-hash/" class="post-title-link" itemprop="url">Lua hash</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 21:59:58" itemprop="dateCreated datePublished" datetime="2019-04-09T21:59:58+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/lua-hash/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/lua-hash/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一般哈希表处理冲突有两种方式，拉链法和开放地址法。拉链法就是哈希表的每个元素都是一个链表，如果有冲突的键就放在链表里面。而开放地址法是如果遇到了冲突，就在计算一个哈希值，直到没有冲突位置。<br>拉链法的优点就是实现简单，缺点也是有的：链表会导致低的缓存命中率，并且分配链表节点本身也会对内存分配器产生压力（主要是大量小块内存分配会导致碎片），而且有个更严重的问题：不太好估计哈希表的装载因子，因此不太容易判断啥时候需要扩充哈希表。<br>而开放地址法避免了这些问题，首先因为所有节点都存在哈希表里面，因此很容易就能估计装载因子，其次也不会有内存分配的问题，避免了零散碎片或者实现内存池的必要。不过问题是要找到一个新的地址就需要重新计算哈希，是一个负担，而且如果在对应哈希查不到元素也可能并不是没有元素，而只是之前的冲突导致元素不再它的”主位置”，这样就需要更多复杂的判断。<br>解决主位置的问题其实很简单：可以设置一个”墓碑”，删除的时候并不是直接删除，而是设置一个”墓碑”当发现是墓碑的时候，证明该位置曾经是有元素的，这时按照冲突的方式继续查找。总的来说，如果不考虑装载因子，因为要重复搜索哈希表，开放地址法的查找是会比较慢的。<br>Lua是将拉链法和开放地址法结合在了一起。具体的做法是这样的：Lua的哈希表主体是开放地址法，即所有元素都被存放在表中，而不是在链表里。但是，每个元素也的确有一个链表节点。在开始的时候，Lua维护一个”空闲槽指针”这个指针之后的位置一定都是有元素的。当发现冲突的时候，会将空闲槽指针迁移，以找到一个空闲的槽位，然后元素会被放在这个槽位里，并在主位置通过链表的方式链接进来！即对插入而言，Lua的哈希表采用实际上是不计算哈希的开放地址法（随意找一个槽位），而对于查找而言，因为有链表节点的存在，是按照拉链法的方式进行查找的。这种方法利用了两者的优点，又规避了缺陷。<br>这里面其实还是有一些其它可以优化的地方。比如墓碑还是需要的，这用于在主位置找不到以后，得得到后续节点的一个索引。但是通过在插入/删除节点时，挪动后续的节点的方法，就可以省略掉墓碑和对应的遍历操作。另外这种哈希表判断装载因子的方式也很简单—只要空闲槽指针指向表的第一个元素，就意味着表已经满了，这时就需要rehash了。<br>Lua的哈希函数使用的是通常的DJB法，也叫times33，计算简单，不过可能效果不太好，对随机的字符这种方式产生的哈希是比较平均的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/dictionary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/dictionary/" class="post-title-link" itemprop="url">Dictionary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 20:57:21" itemprop="dateCreated datePublished" datetime="2019-04-09T20:57:21+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp/" itemprop="url" rel="index"><span itemprop="name">CSharp</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/dictionary/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/dictionary/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Entry结构体"><a href="#Entry结构体" class="headerlink" title="Entry结构体"></a>Entry结构体</h1><p>这是Dictionary存放数据的最小单位，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> Entry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> hashCode; <span class="comment">// 除符号位以外的31位hashCode值，如果该Entry没有被使用，那么为-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> next;     <span class="comment">// 下一个元素的下标索引，如果没有下一个就为-1</span></span><br><span class="line">    <span class="keyword">public</span> TKey key;     <span class="comment">// 存放元素的键</span></span><br><span class="line">    <span class="keyword">public</span> TValue <span class="keyword">value</span>; <span class="comment">// 存放元素的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="其它关键私有变量"><a href="#其它关键私有变量" class="headerlink" title="其它关键私有变量"></a>其它关键私有变量</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] buckets;          <span class="comment">// Hash桶</span></span><br><span class="line"><span class="keyword">private</span> Entry[] entries;        <span class="comment">// Entry数组，存放元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;              <span class="comment">// 当前entries的index位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> version;            <span class="comment">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> freeList;           <span class="comment">// 被删除Entry在entries中下标index，这个位置是空闲的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> freeCount;          <span class="comment">// 有多少个被删除的Entry，有多少个空闲的位置</span></span><br><span class="line"><span class="keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer; <span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> KeyCollection keys;     <span class="comment">// 存放key的集合</span></span><br><span class="line"><span class="keyword">private</span> ValueCollection values; <span class="comment">// 存放Value的集合</span></span><br></pre></td></tr></table></figure>
<h1 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h1><p>首先我们用图的形式来描述一个Dictionary的数据结构，其中只画出了关键的地方。桶大小为4以及Entry大小也为4的一个数据结构。<br><img src="/2019/04/09/dictionary/1.png"><br>假设需要执行一个Add操作，dictionary.Add(“a”,”b”)，其中key=”a”，value=”b”。</p>
<ol>
<li>根据key的值，计算出它的hashCode。我们假设”a”的hash值为6(GetHashCode(“a”)=6)。</li>
<li>通过对hashCode取余运算，计算出该hashCode落在哪一个buckets桶中。现在桶的长度(buckets.Length)为4，那么就是6%4最后落在index为2的桶中，也就是buckets[2]。</li>
<li>接下来将hashCode、key、value等信息存入entries[count]中，因为count位置是空闲的；继续count++指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在entries[0]的位置。</li>
<li>将Entry的下标entryIndex赋值给buckets中对应下标的bucket。步骤3中存放在entries[0]的位置，所以buckets[2]=0。</li>
<li>最后version++，集合发生了变化，所以版本需要+1。只有增加、替换和删除元素才会更新版本。</li>
</ol>
<hr>
<p>完成上面Add操作后，数据结构更新成了下图这样的形式。<br><img src="/2019/04/09/dictionary/2.png"><br>这样是理想情况下的操作，一个bucket中只有一个hashCode没有碰撞的产生，但是实际上是会经常产生碰撞；那么Dictionary类中又是如何解决碰撞的呢。<br>我们继续执行一个Add操作，dictionary.Add(“c”,”d”)，假设GetHashCode(“c”)=6，最后6%4=2。最后桶的index也是2，按照之前的步骤1~3是没有问题的，执行完后数据结构如下图所示。<br><img src="/2019/04/09/dictionary/3.png"><br>如果继续执行步骤4那么bucket[2] = 1，然后原来的buckets[2]=&gt;entries[0]的关系就会丢失，这是我们不愿意看到的。现在Entry中的next就发挥大作用了。</p>
<hr>
<p>如果对应的buckets[index]有其它元素已经存在，那么会执行以下两条语句，让新的entry.next指向之前的元素，让buckets[index]指向现在的新元素，就构成了一个单链表。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entries[index].next = buckets[targetBucket];</span><br><span class="line">...</span><br><span class="line">buckets[targetBucket] = index;</span><br></pre></td></tr></table></figure></p>
<p>实际上步骤4也就是做一个这样的操作，并不会去判断是不是有其它元素，因为buckets中桶初始值就是-1，不会造成问题。</p>
<hr>
<p>经过上面的步骤以后，数据结构就更新成了下图这个样子</p>
<img src="/2019/04/09/dictionary/4.png">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/hash/" class="post-title-link" itemprop="url">哈希表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 16:21:17" itemprop="dateCreated datePublished" datetime="2019-04-09T16:21:17+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/hash/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/hash/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>散列表（Hash table，也叫哈希表），是根据关键码值（key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希（Hash）表，函数f（key）为哈希（Hash）函数。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。</li>
<li>对不同的关键字可能得到同一散列地址，即$k1 \neq k2$，而f(k1)=f(k2)，这种现象称为冲突（Collision）。具有相同函数值的关键字对该散列函数来说称作同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便成为散列表，这一映射过程称为散列造表或散列，所得的存储位置成散列地址。</li>
<li>若对于关键字集合中的任一个关键字，经散列函数映射到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li>
</ul>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。<br>实际工作需视不通的情况采用不同的哈希函数，通常考虑的因素有：</p>
<ul>
<li>计算哈希函数所需时间</li>
<li>关键字的长度</li>
<li>哈希表的大小</li>
<li>关键字的分布情况</li>
<li>记录的查找频率</li>
</ul>
<ol>
<li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key)=a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key)中已经有值了，就往下一个找，直到H(key)中没有值了，就放进去。</li>
<li>数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构建散列地址，则冲突的几率就会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</li>
<li>平方取中法：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。<br>例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01，B的内部编码为02。由此组成关键字“KEYA”的内部代码为1105201，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7位到第9位作为该关键字哈希地址，如下图所示</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>内部编码</th>
<th>内部编码的平方值</th>
<th>H(k)关键字的哈希地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>KEYA</td>
<td>11052501</td>
<td>122157778355001</td>
<td>778</td>
</tr>
<tr>
<td>KEYB</td>
<td>11250102</td>
<td>126564795010404</td>
<td>795</td>
</tr>
<tr>
<td>AKEY</td>
<td>01110525</td>
<td>001233265775625</td>
<td>265</td>
</tr>
<tr>
<td>BKEY</td>
<td>02110525</td>
<td>004454315775625</td>
<td>315</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端分割界来回折叠，然后对齐相加。</li>
<li>随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</li>
<li>除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即H(key)=key MOD p,p &lt;= m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。</li>
</ol>
<h1 id="Hash桶算法"><a href="#Hash桶算法" class="headerlink" title="Hash桶算法"></a>Hash桶算法</h1><p>说到Hash算法就会想到hash表，一个key通过hash函数运算后可快速得到hashCode，通过hashCode的映射可直接获取Value，但是hashCode一般取值都是非常大的，经常是$2^32$以上，不可能对每个hashCode都指定一个映射。<br>因为这样一个问题，所以将hashCode以分段的形式来映射，把每一段称之为一个Bucket(桶)，一般常见的Hash桶就是直接将结果取余。</p>
<h1 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h1><ol>
<li>开放寻址法：Hi=(H(key)+di)MOD m,i=1,2,…,k(k&lt;=m-1)，其中H(key)为散列函数，m为散列表长，di为增量序列，可有下列3种取法：<br>1.1. di=1,2,3,…,m-1，称线性探测在散列；<br>1.2. $di=1^2,-1^2,2^2,-2^2,…,k^2,-k^2(k&lt;=m/2)$称为二次探测在散列；<br>1.3. di=伪随机数序列，称伪随机探测在散列。</li>
<li>再散列法：Hi=RHi(key),i\1,2,…,k RHi均是不通的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</li>
<li>链地址法（拉链法）：这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储到hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式查找元素。<img src="/2019/04/09/hash/1.png"></li>
<li>建立一个公共溢出区</li>
</ol>
<h1 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h1><p>散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。<br>查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下3个因素：</p>
<ol>
<li>散列函数是否均匀；</li>
<li>处理冲突的方法；</li>
<li>散列表的装填因子；<br>散列表的装填因子定义为：$\alpha$=填入表中的元素个数/散列表的长度<br>$\alpha$是散列表装满程度的标志因子。由于表长是定值，$\alpha$与“填入表中的元素个数”成正比，所以，$\alpha$越大，填入表中的元素较多，产生冲突的可能性就越大；$\alpha$越小，填入表中的元素较少，产生冲突的可能性就越小。<br>实际上，散列表的平均查找长度是装填因子$\alpha$的函数，只是不同处理冲突的方法有不同的函数。</li>
</ol>
<h1 id="常见的hash函数"><a href="#常见的hash函数" class="headerlink" title="常见的hash函数"></a>常见的hash函数</h1><h2 id="MD4"><a href="#MD4" class="headerlink" title="MD4"></a>MD4</h2><p>MD4(RFC 1320)是MIT的Ronald L.Rivest在1990年设计的，MD是Message Digest的缩写。它适用在32位字长的处理器上用高速软件实现，它是基于32位操作数的位操作来实现的。</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>MD5(RFC 1321)是Rivest于1991年对MD4的改进版本。它对输入仍以512位分组，其输出是4个32位字的级联，与MD4相同。MD5比MD4来的复杂，并且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好</p>
<h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>SHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举（bruteforce）性更好。SHA-1设计时基于和MD4相同原理，并且模仿了该算法。</p>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><h2 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h2><p>我们比较熟悉的校验算法有奇偶校验和CRC校验，这两种校验并没有抗数据篡改的能力，它们一定程度上能检测出数据传输中信道误码，但却不能防止对数据的恶意破坏。<br>MD5 Hash算法的“数字指纹”特性，使它成为目前应用最广发的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>Hash算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。对hash值，又称“数字摘要”进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。</p>
<h2 id="鉴权协议"><a href="#鉴权协议" class="headerlink" title="鉴权协议"></a>鉴权协议</h2><p>如下的鉴权协议又被称作挑战—认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</p>
<h3 id="MD5、SHA1的破解"><a href="#MD5、SHA1的破解" class="headerlink" title="MD5、SHA1的破解"></a>MD5、SHA1的破解</h3><p>2004年8月17日，在美国国际密码大会上MD5、HAVAL-128、MD4和RIPEMD等四个著名密码算法的破译结果。2005年宣布破解SHA-1密码。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>（ELFhash算法）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ELFhash</span><span class="params">(<span class="keyword">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*key)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (h&lt;&lt;<span class="number">4</span>)+*key++;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> g = h &amp; <span class="number">0xF0000000</span>L;</span><br><span class="line">        <span class="keyword">if</span> (g)</span><br><span class="line">            h ^= g &gt;&gt; <span class="number">24</span>;</span><br><span class="line">        h &amp;= ~g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/alpha-depth-write/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/alpha-depth-write/" class="post-title-link" itemprop="url">透明物体的深度写入问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 15:01:40" itemprop="dateCreated datePublished" datetime="2019-04-09T15:01:40+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/alpha-depth-write/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/alpha-depth-write/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通常来说，透明物体是不需要写深度的，例如：</p>
<ul>
<li>透明物体与非透明物体间的渲染不会有问题，因为所有透明物体会在所有非透明物体之后渲染。</li>
<li>大多数情况下，透明物体之间的渲染也不会有问题，因为，所有透明物体按由远及近的顺序渲染，所以不会出现前面的透明物体挡住后面的透明物体，导致后面的透明物体不显示。</li>
</ul>
<p>但有些情况下，透明物体必须要写深度，例如：</p>
<ul>
<li>两个透明无间有交叉，如果不写深度，深度则无法正确比较，就会出现遮挡关系错误的现象。</li>
</ul>
<p>图1为俯视角度看两面片</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/assetbundle-fundamentals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/assetbundle-fundamentals/" class="post-title-link" itemprop="url">AssetBundle基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 01:43:10" itemprop="dateCreated datePublished" datetime="2019-04-09T01:43:10+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/assetbundle-fundamentals/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/assetbundle-fundamentals/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AssetBundle系统提供了将一个或多个文件存储到Unity能够进行索引和序列化的档案格式的方法，它是Unity用来在应用程序安装之后进行分发和更新非代码内容的首选工具。通过AssetBundle，开发者可以提交更小的程序安装包、最小化运行时内存压力以及根据终端用户设备选择性地加载优化内容。</p>
<h1 id="AssetBundle布局"><a href="#AssetBundle布局" class="headerlink" title="AssetBundle布局"></a>AssetBundle布局</h1><p>简单来说，一个AssetBundle中包含两部分：数据头和数据段。<br>数据头中含有AssetBundle的相关信息，例如标志符（Identifier）、压缩类型（Compression Type）和配置文件（Manifest）。配置文件是一个以Object名称为键的查找表，表中的每个条目头提供了一个用于标识Object在数据段中的位置的byte索引。在大多数平台上，这个查找表是用平衡查找树实现的，在Windows和OSX衍生平台（包括IOS）上的查找表是使用红黑树实现的。<br>因此，构建配置文件所需的时间随着AssetBundle中的Asset数量而增长的速度大于线性增长。</p>
<p>数据段中含有由序列化AsseBundle中的Asset而生成的原始数据。如果指定了压缩方案为LZMA，所有序列化的Asset会被压缩成一个字节数组中；如果指定了压缩方案为LZ4，不同的Asset的字节数据会被单独压缩；如果没有使用任何压缩，数据段会保留原始的字节流数据。</p>
<p>在Unity5.3之前的版本中，AssetBundle中的Object不能被单独压缩。因此，在5.3之前的版本的Unity中，如果要从已压缩的AssetBundle中读取Object，引擎必须压缩整个AssetBundle。通常情况下，Unity会缓存一份解压后的AssetBundle副本，以此来提高加载性能。</p>
<h1 id="加载AssetBundle"><a href="#加载AssetBundle" class="headerlink" title="加载AssetBundle"></a>加载AssetBundle</h1><p>AssetBundle可以通过不同的API来加载，这些API会受下面的两种因素的影响而产生不同的行为；</p>
<ol>
<li>AssetBundle使用了LZMA压缩方式或者LZ4压缩方式或者没有进行压缩</li>
<li>进行加载AssetBundle的平台</li>
</ol>
<p>这些API是：</p>
<ul>
<li>AssetBundle.LoadFromMemory（可选择异步模式）Unity不推荐使用这个API</li>
<li>AssetBundle.LoadFromFile（可选择异步模式）</li>
<li>AssetBundle.LoadFromStream（可选择异步模式）</li>
<li>UnityWebRequest的DownloadHandlerAssetBundle</li>
</ul>
<p>通过这些API获取的AssetBundle引用可以随意混用，也就是说，通过UnityWebRequest加载的AssetBundle可以兼容通过AssetBundle.LoadFromFile或者AssetBundle.LoadFromMemoryAsync加载的AssetBundle。</p>
<p>AssetBundle.LoadFromMemoryAsync从托管代码的字节数组（C#中的byte[]）中加载AssetBundle。该方法总是将托管代码中的源数据赋值到新分配的连续的内存块中。如果AssetBundle使用了LZM压缩，在赋值过程中AssetBundle会被解压；如果使用了LZ4压缩或者没有压缩，AssetBundle会被逐字复制（be copied verbatim）。</p>
<p>这个API占用内存的峰值至少是他处理的AssetBundle大小的两倍：一份由此API创建在本机内存中的副本和一份传递给此API的位于托管字节数组的副本。通过此API从AssetBundle加载的Asset会在内存中复制3次；在托管代码中的字节数组、本机内存中的副本以及在GPU或系统内存中的Asset本体。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/fundamentals-unity-ui/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/fundamentals-unity-ui/" class="post-title-link" itemprop="url">Unity UI优化（一）-Unity UI的基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 01:32:27" itemprop="dateCreated datePublished" datetime="2019-04-09T01:32:27+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/fundamentals-unity-ui/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/fundamentals-unity-ui/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>画布（Canvas）是以原生代码编写的Unity组件，它给Unity的渲染系统按层划分的几何系统，可以在其内部或其上层绘制其他几何形状。<br>画布负责将其内部的几何形状合并到批处理、生成合适的渲染指令并发送到Unity图形系统。这些操作都是由原生C++代码完成，这杯成为重新批处理（rebatch）或批处理构建（batch build）。当一个画布被标记为含有需要重新批处理的几何形状时，称这个画布为脏（dirty）画布。<br>由CanvasRenderer组件向画布提供几何形状。<br>子画布（Sub-canvas）是嵌套在其他画布组件内部的画布组件。子画布能够将其孩子节点与其画布隔离开，一个被标记为脏的子节点不会迫使其父画布重新构建几何内容，反之亦然。有几种特殊情况会使上述情形失效，比如，改变父画布导致子画布改变尺寸。<br>Graphic类是由Unity UI系统的C#库提供的基类，所有的画布系统提供可绘制几何内容的UI系统C#类都继承它。大多数内置的UI系统绘制类都是通过MaskableGraphic子类实现的，这个子类实现了IMaskable接口，可以被遮罩。Drawable类的主要子类是Image和Text，它们能提供与其名称相对应的内容。</p>
<p>Layout组件控制RectTransform的尺寸和位置，它通常用于创建具有复杂布局并且内部组件需要相对尺寸或者相对位置的UI。Layout组件只依赖RectTransform并且只影响与其关联的RectTransform的属性。他们不依赖Graphic类，并且可以独立于UI系统的Graphic类使用。<br>Graphic和Layout组件都依赖</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/04/09/optimizing-graphics-rendering-unity-games/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/optimizing-graphics-rendering-unity-games/" class="post-title-link" itemprop="url">Unity性能优化-图形渲染优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 01:31:05" itemprop="dateCreated datePublished" datetime="2019-04-09T01:31:05+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/渲染优化/" itemprop="url" rel="index"><span itemprop="name">渲染优化</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/09/optimizing-graphics-rendering-unity-games/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/optimizing-graphics-rendering-unity-games/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DTWMWSlnxcXcuUgR1H2qlVt9-gzGzoHsz',
      appKey     : 'Ms2yHVyCinQmWnsKtVv7NOHR',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
