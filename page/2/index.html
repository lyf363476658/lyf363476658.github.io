<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/2/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/06/StandardShaderMaterialParamterOcclusionMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/06/StandardShaderMaterialParamterOcclusionMap/" class="post-title-link" itemprop="url">Occlusion Map（环境光散射贴图）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-06 10:12:53" itemprop="dateCreated datePublished" datetime="2019-09-06T10:12:53+08:00">2019-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2019/09/06/StandardShaderMaterialParamterOcclusionMap/StandardShaderParameterOcclusion.png">
<p>The occlusion map is used to provide information about which areas of the model should receive high or low indirect lighting.Indirect lighting comes from ambient lighting and reflections,and so steep concave parts of your model such as a crack or fold would not realistically receive much indirect light.</p>
<p>Occlusion texture maps are normally calculated by 3D applications directly from the 3D model using the modeller or third party software.</p>
<p>An occlusion map is a greyscale image（灰度图像）,with white indicating areas（白色显示区域） that should receive full indirect lighting（间接光照）,and black indicating（指示） no indirect lighting.Sometimes this is as simple as a greyscale hightmap,for simple surface(such as the knobbly stone wall（有节的石墙）texture shown in the heightmap example above).</p>
<p>At other times,generating the correct occlusion texture is slightly more complex（稍微复杂的）.For example,if a character in you scene is wearing a hood（戴着头巾）,the inside edegs of the hood should be set to very low indirect lighting（头巾外围应该设置很低的间接光）,or none at all（或者一点也没有）.In these situations（状况）,occlusion maps will be often be produced by artists,using 3D applications to automaticalyy generate an occlusion map based on the model.</p>
<img src="/2019/09/06/StandardShaderMaterialParamterOcclusionMap/StandardShaderOcclusionMapTexture.jpg">
<p>This occlusion map identifies ares on a character’s sleeve（头套）that are exposed（暴露）or hidden from ambient lighting.It is used on the model pictured below.（它用在下面的模型）</p>
<img src="/2019/09/06/StandardShaderMaterialParamterOcclusionMap/StandardShaderOcclusionMap.jpg">
<p>Before and after applying an occlusion map.The areas that partially obscured,（部分模糊的区域）particularly in the folds of fabric around the neck.（特别是在脖子周围的织物褶皱上）are lit too brightly on the left.After the ambient occlusion map is assigned,these ares are no longer lit by the green ambient light from the surrounding wooded envirnoment.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/05/Bilinear-Trilinear-Anistropic-Filtering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/Bilinear-Trilinear-Anistropic-Filtering/" class="post-title-link" itemprop="url">纹理过滤模式中的Bilinear、Trilinear以及Anistropic Filtering</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 21:02:39" itemprop="dateCreated datePublished" datetime="2019-09-05T21:02:39+08:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么在纹理采样时需要texture-filter（纹理过滤）"><a href="#为什么在纹理采样时需要texture-filter（纹理过滤）" class="headerlink" title="为什么在纹理采样时需要texture filter（纹理过滤）"></a>为什么在纹理采样时需要texture filter（纹理过滤）</h1><p>我们的纹理是要贴到三维图形表面的，而三维图形上的pixel中心和纹理上的texel中心点并不一致（pixel不一定对应texture的采样中心texel），大小也不一定一致。当纹理大于三维图形表面时，导致一个像素被映射到许多纹理像素上；当纹理小于三维图形表面时，许多个像素都映射到同一个纹理。<br>当这些情况发生时，贴图就会变得模糊或发生错位，马赛克。要解决此类问题，必须通过技术平滑texel和pixel之间的对应。这种技术就叫纹理滤波。<br>不同的过滤模式，计算复杂度不一样，会得到不同的效果。过滤模式由简单到复杂包括：Nearest Point Sampling（最近采样点），Bilinear（双线性过滤），Trilinear（三线性过滤）、Anisotropic Filtering（各项异性过滤）。</p>
<h1 id="什么是各向同性和各向异性？"><a href="#什么是各向同性和各向异性？" class="headerlink" title="什么是各向同性和各向异性？"></a>什么是各向同性和各向异性？</h1><p>当需要贴图的三维表面平行于屏幕（viewport），则是各向同性的。当要贴图的三维表面与屏幕有一定角度的倾斜，则是各向异性的。</p>
<h1 id="Nearest-Point-Sampling（最近点采样）"><a href="#Nearest-Point-Sampling（最近点采样）" class="headerlink" title="Nearest Point Sampling（最近点采样）"></a>Nearest Point Sampling（最近点采样）</h1><p>这个最简单，每个像素的纹理坐标，并不是刚好对应Texture上的一个采样点texel，怎么办呢？最近点采样取最接近的texel进行采样。<br>当纹理的大小与贴图的三维图形的大小差不多时，这种方法非常有效和快捷。如果大小不同，纹理就需要进行放大或缩小，这样，结果就会变得矮胖、变形或模糊。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/05/GPU-Gems-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/GPU-Gems-2/" class="post-title-link" itemprop="url">GPU Gems 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 16:13:08" itemprop="dateCreated datePublished" datetime="2019-09-05T16:13:08+08:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GPU-Gems/" itemprop="url" rel="index"><span itemprop="name">GPU Gems</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《GPU Gems 2》这本书除了丰富的内容之外，还有两个特点。</p>
<ul>
<li>虚幻引擎之父Tim Sweeney为《GPU Gems 2》作序。作为Epic Games的创始人，Unreal Engine早期主要开发者，Tim也在序中展示了《GPU Gems 2》出版伊始（2005年3月）时开发完成的Unreal Engine 3。UE3可谓是开创了一个时代。随后包括《新鬼泣》在内的100+款大作（2005年~2015年），都是基于UE3开发。</li>
<li>《GPU Gems 2》的中文版是龚大2005年，但可以不夸张地说，书中介绍的很多方法技巧trick，哪怕是放到现在，依然非常值得学习和借鉴。</li>
</ul>
<p>ok，篇幅原因，开场话就不多说了，放一张本文的核心内容，真是感植物渲染的图，我们就直接开始正题。<br><img src="/2019/09/05/GPU-Gems-2/1.png"></p>
<h1 id="实现照片级真实感的虚拟植物（Toward-Photorealism-in-Virtual-Botany）"><a href="#实现照片级真实感的虚拟植物（Toward-Photorealism-in-Virtual-Botany）" class="headerlink" title="实现照片级真实感的虚拟植物（Toward Photorealism in Virtual Botany）"></a>实现照片级真实感的虚拟植物（Toward Photorealism in Virtual Botany）</h1><h2 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h2><p>众所周知，植物的渲染需要很多的视觉深度和细节才能令人信服。</p>
<p>本章即关于渲染逼真自然场景的技术，描述了对实时游戏引擎友好的、用于渲染更真实的自然场景的策略。讲述了在不需要大量CPU或GPU占用的前提下渲染出包含大量植物和树组成的绿色植物场景。</p>
<p>内容安排方面，这章从管理大型户外场景数据这一基础开始描述。然后，提供一些细节，例如关于如何最大化GPU吞吐量，以便可以看到密集的草丛。接下来扩展这些技术，增加地面杂物和大型植物，如树，将阴影和环境影响组合进去。</p>
<p>一些真实感植物渲染的效果图：</p>
<img src="/2019/09/05/GPU-Gems-2/2.png">
<img src="/2019/09/05/GPU-Gems-2/3.png">
<img src="/2019/09/05/GPU-Gems-2/4.png">
<h2 id="场景管理（Scene-Management）"><a href="#场景管理（Scene-Management）" class="headerlink" title="场景管理（Scene Management）"></a>场景管理（Scene Management）</h2><p>任何3D游戏引擎都应该有环境相关渲染技术的管理和组织。</p>
<p>游戏引擎必须管理其渲染技术，以适合于它们希望看到的环境范围。以自然场景为主的游戏由上千棵树，灌木和可能上百万片草叶组成。直接分开渲染会出现数据管理问题，只有解决了这一问题才能以交互的帧率实时渲染。</p>
<p>我们的目标是在一个逼真的室外场景中大范围地移动游戏相机，而不需要在任务管理上花费过多的存储器资源。</p>
<h2 id="种植栅格（The-Planting-Grid）"><a href="#种植栅格（The-Planting-Grid）" class="headerlink" title="种植栅格（The Planting Grid）"></a>种植栅格（The Planting Grid）</h2><p>场景管理方面，首先是使用了虚拟栅格的思想。</p>
<p>我们在相机周围建立一个世界空间固定的栅格，来管理每一层的植物和其他自然物体的种植数据。每个栅格单元包含渲染它所在物理空间层的所有数据。特别是，单元数据结构存储了对应的顶点、索引缓冲区和材质信息来再现需要绘制的内容。</p>
<p>对植物的每个层，建立相机到层的距离，层需要用它来产生视觉效果，这决定了虚拟栅格的大小。相机移动，虚拟栅格也随之移动。当一个栅格单元不再在虚拟栅格中时，丢弃它，并在需要维护完成栅格结构的地方添加新的单元。在添加每个单元格时，用一种种植算法把渲染所需的数据填充到层。如下图。<br><img src="/2019/09/05/GPU-Gems-2/5.png" title="一个虚拟栅格"><br>图注：内层有一个世界空间对齐的固定大小的栅格。深绿的单元表现为活动单元。当相机向前移动时，丢弃标记为X的单元，添加新的单元（显示为亮绿色）以维持虚拟栅格的大小，实现过程中有用的改进是使用栅格单元池且循环使用，因为当一个旧单元被丢弃时，总会增加一个新单元。</p>
<h3 id="种植策略（Planting-Strategy）"><a href="#种植策略（Planting-Strategy）" class="headerlink" title="种植策略（Planting Strategy）"></a>种植策略（Planting Strategy）</h3><p>对于充满自然物体的每个单元，需要在地面上选择需要放置物体的适当位置。采用试探的方法根据被防止对象对象类型来选择这些点。通常，需要的密度随机选点，然后看地面上的对应点是否适合要种植的东西。而地面多边形的材质决定了一个层是否适用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/05/GPU-Architectures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/GPU-Architectures/" class="post-title-link" itemprop="url">GPU Architectures</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 15:05:02" itemprop="dateCreated datePublished" datetime="2019-09-05T15:05:02+08:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Graphics-pipeline"><a href="#Graphics-pipeline" class="headerlink" title="Graphics pipeline"></a>Graphics pipeline</h1><img src="/2019/09/05/GPU-Architectures/1.jpg">
<ul>
<li>“Logical” pipeline described in OGL/DX specification<ul>
<li>It’s an abstraction</li>
</ul>
</li>
<li>At physical level things are very different<ul>
<li>As long as specs are met there’s no problem</li>
</ul>
</li>
<li>Today we will look at things from a slightly closer POV.</li>
</ul>
<h1 id="Anatomy-of-a-GPU"><a href="#Anatomy-of-a-GPU" class="headerlink" title="Anatomy of a GPU"></a>Anatomy of a GPU</h1><ul>
<li>Extremely Parallel machine <ul>
<li>Thousands of “threads” in flight</li>
<li>But</li>
<li>Limited flow control</li>
<li>Some threads shares program counter</li>
<li>No Inter process communication</li>
</ul>
</li>
<li>Memory bandwidth is very high（内存带宽很高）<ul>
<li>Hundreds of GB/s</li>
<li>But</li>
<li>Very high latency（延迟很高）<ul>
<li>Thousand of cycles</li>
</ul>
</li>
<li>Latency hidind mechanism necessary</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/04/OpenGLES-Fragment-Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/04/OpenGLES-Fragment-Shader/" class="post-title-link" itemprop="url">OpenGL ES 3.0 Fragment Shader</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 14:22:23" itemprop="dateCreated datePublished" datetime="2019-09-04T14:22:23+08:00">2019-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL-ES-3-0/" itemprop="url" rel="index"><span itemprop="name">OpenGL ES 3.0</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>第9章介绍了在片段着色器中创建和应用纹理的基础知识。在本章中，我们提供了片段着色器的更多细节，并描述它的一些用户。特别是，我们聚焦于如何用片段着色器实现固定功能技术。本章介绍的主题包括：</p>
<ul>
<li>固定功能片段着色器</li>
<li>可编程片段着色器概述</li>
<li>多重纹理</li>
<li>雾化</li>
<li>Alpha测试</li>
<li>用户裁剪平面</li>
</ul>
<img src="/2019/09/04/OpenGLES-Fragment-Shader/7.jpg">
<p>在图10-1中，已经包含了可编程管线的顶点着色器、图元装配和光栅化阶段。我们已经讨论了在片段着色器中使用纹理。现在，我们将重点放在管线的片段着色器部分，介绍片段着色器编写方面的其余细节。</p>
<h1 id="固定功能片段着色器"><a href="#固定功能片段着色器" class="headerlink" title="固定功能片段着色器"></a>固定功能片段着色器</h1><p>对可编程片段管线还不熟悉但是已经使用过OpenGL ES 1.x的读者可能熟悉固定功能片段管线。在研究片段着色器的细节之前，我们认为值得简单地回顾一下老式的固定功能片段管线，这将帮助你理解老式的固定功能管线映射到片段着色器的方式。在转到更先进的片段编程技术之前，这是很好的起点。</p>
<p>在OpenGL ES 1.1中，可以使用一组有限的方程式，确定如何组合片段着色的不同输入。在固定功能管线中，实际上可以使用3种输入：插值顶点颜色、纹理颜色和常量颜色。顶点颜色通常保存一个预先计算的颜色或者顶点照明计算的结果。纹理颜色来自于使用图元纹理坐标绑定中读取的值，而常量颜色可以对每个纹理单元设置。</p>
<h2 id="内建特殊变量"><a href="#内建特殊变量" class="headerlink" title="内建特殊变量"></a>内建特殊变量</h2><p>OpenGL ES 3.0有内建特殊变量，这些变量由片段着色器输出或者作为片段着色器的输入。片段着色器中可用的内建特殊变量如下所示：</p>
<ul>
<li>gl_FragCoord——片段着色器中的一个只读变量。这个变量保存片段的窗口相对坐标(x,y,z,1/w)。在一些算法中，知道当前片段的窗口坐标是很有用的。例如，可以使用窗口坐标作为某个随机噪声贴图纹理读取的偏移量，噪声贴图的值用于旋转阴影贴图的过滤核心。这种技术用于减少阴影贴图的锯齿失真。</li>
<li>gl_FrontFacing——片段着色器中的一个只读变量。这个布尔变量在片段是正面图元的一部分时为true，否则为false。</li>
<li>gl_PointCoord——一个只读变量，可以在渲染点精灵时使用。它保存点精灵的纹理坐标，这个坐标在点光栅化期间自动生成，处于[0,1]区间内。第14章中有一个使用该变量渲染点精灵的示例。</li>
<li>gl_FragDepth——一个只写输出变量，在片段着色器中写入时，覆盖片段的固定功能深度值。这一个功能应该谨慎使用（只在必要时），因为它可能禁用许多GPU的深度优化。例如，许多GPU有所谓的“Early-Z”功能，在执行片段着色器之前进行深度测试。使用Early-Z的好处是不能通过深度测试的片段永远不回被着色（从而保护了性能）。但是，使用gl_FragDepth时，必须禁用该功能，因为GPU在执行片段着色器之前不知道深度值。</li>
</ul>
<h2 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h2><p>下面是与片段着色器有关的内建变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mediump <span class="keyword">int</span> gl_MaxFragmentInputVectors = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> mediump <span class="keyword">int</span> gl_MaxTextureImageUnits = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">const</span> mediump <span class="keyword">int</span> gl_MaxFragmentUniformVectors = <span class="number">224</span>;</span><br><span class="line"><span class="keyword">const</span> mediump <span class="keyword">int</span> gl_MaxDrawBuffers = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> mediump <span class="keyword">int</span> gl_MinProgramTexelOffset = <span class="number">-8</span>;</span><br><span class="line"><span class="keyword">const</span> mediump <span class="keyword">int</span> gl_MaxProgramTexelOffset = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></p>
<p>内建常量描述如下最大项：</p>
<ul>
<li>gl_MaxFragmentInputVectors——片段着色器输入（或者可变值）的最大数量。所有ES 3.0实现支持的最小值为15。</li>
<li>gl_MaxTextureImageUnits——可用纹理图像单元的最大数量。所有ES 3.0 实现支持的最小值为16。</li>
<li>gl_MaxFragmentUniformVectors——片段着色器内可以使用vec4统一变量项目的最大数量。所有ES 3.0实现支持的最小值为224。开发者实际可以使用的vec4统一变量项目的数量在不同实现以及不同片段着色器可能不一样。这个问题在第8张中说明过，同样适用于片段着色器。</li>
<li>gl_MaxDrawBuffers——多重渲染目标（MRT）的最大支持数量。所有ES 3.0实现支持的最小值为4。</li>
<li>gl_MinProgramTexelOffset/gl_MaxProgramTexelOffset——通过内建ESSL函数texture*Offset()偏移参数支持的最大和最小偏移量。</li>
</ul>
<h2 id="多重纹理"><a href="#多重纹理" class="headerlink" title="多重纹理"></a>多重纹理</h2><p>我们从多重纹理入手，这是片段着色器中非常常见的操作，用于组合多个纹理贴图。例如，QuakeIII等多种游戏里曾经使用一种技术，将来自光照计算的照明效果存储在一个纹理贴图中。然后，这个贴图在片段着色器中与基本纹理贴图合并，以表现静态照明。多重纹理还有许多其他的示例，我们将在第14张介绍。例如，纹理贴图常常用于存储反射指数和遮罩，以衰减和遮盖反射光的分布。许多游戏还是用法线贴图，这种纹理以比逐顶点法线更高级别的细节存储法线信息，以便在片段着色器中计算照明。</p>
<h2 id="雾化"><a href="#雾化" class="headerlink" title="雾化"></a>雾化</h2><p>应用雾化是渲染3D场景的一种常见技术。在OpenGL ES 1.1中，雾化作为一种固定功能操作。雾化如此普遍应用的原因之一是，它可以用于减少绘图距离，并且消除靠近观看者的几何体的“突现”现象。</p>
<p>雾化的计算有几种可能的方式，使用可编程片段着色器，你就不必局限于任何特定的方程式。下面我们将介绍如何用片段着色器计算线性雾化。要计算任何类型的雾化，需要两个输入：像素到眼睛的距离以及雾化的颜色。要计算线性雾化，还需要雾化所覆盖的最小和最大距离。</p>
<h2 id="片段测试和操作"><a href="#片段测试和操作" class="headerlink" title="片段测试和操作"></a>片段测试和操作</h2><p>下面几个小节描述可以应用到OpenGL ES片段的各种测试。默认情况下，所有片段测试和操作都被禁用，片段在写入帧缓冲区时按照接受它们的顺序变成像素。通过启用不通的片段，可以应用操作性测试，以选择哪些片段成为像素并影响最终的图像。</p>
<p>每个片段测试都可以通过调用glEnable单独启用，该函数所带的标志参数如表11-1所示。</p>
<p>表11-1 片段测试启用标志</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>glEnable标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_DEPTH_TEST</td>
<td>控制片段的深度测试</td>
</tr>
<tr>
<td>GL_STENCIL_TEST</td>
<td>控制片段的模版测试</td>
</tr>
<tr>
<td>GL_BLEND</td>
<td>控制片段与颜色缓冲区中存储的颜色的混合</td>
</tr>
<tr>
<td>GL_DITHER</td>
<td>在写入颜色颜色缓冲区前控制片段颜色的抖动</td>
</tr>
<tr>
<td>GL_SAMPLE_COVERAGE</td>
<td>控制样本范围值的计算</td>
</tr>
<tr>
<td>GL_SAMPLE_ALPHA_TO_COVERAGE</td>
<td>控制样本范围值计算中样本Alpha的使用</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用裁剪测试"><a href="#使用裁剪测试" class="headerlink" title="使用裁剪测试"></a>使用裁剪测试</h2><p>裁剪测试通过制定一个矩形区域（进一步限制帧缓冲区中可以写入的像素）提供了额外的裁剪层次。使用裁剪矩形是两步的过程。首先，需用glScissor函数指定矩形区域：<br><code>void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);</code><br>x,y    以视口坐标指定裁剪矩形左下角<br>width  指定裁剪矩形宽度（以像素表示）<br>height 指定裁剪矩形高度（以像素显示）</p>
<p>指定裁剪矩形之后，需通过条用glEnable(GL_SCISSOR_TEST)启用它，以实施更多的裁剪。所有渲染（包括视口清除）都限于裁剪矩形之内。</p>
<p>一般来说，裁剪矩形是视口中的一个子区域，但是这两个区域不一定真正交叉。当两个区域不交叉时，裁剪操作将在视口区域外渲染的像素上进行。注意，视口的变换发生在片段着色器之前，而裁剪测试发生在片段着色器阶段之后。</p>
<h2 id="模版缓冲区测试"><a href="#模版缓冲区测试" class="headerlink" title="模版缓冲区测试"></a>模版缓冲区测试</h2><p>应用到片段的下一个操作是模版测试。模版缓冲区是一个逐像素掩码，保存可用于确定某个像素是否应该被更新的值。模版测试由应用程序启用或者禁用。<br>模版缓冲区的使用可以看做两步的操作。第一步是用逐像素掩码初始化模版缓冲区，这可以通过渲染几何形状并制定模版缓冲区的更新方式来完成。第二部通常是使用这些值控制后续在颜色缓冲区中的渲染。在两种情况下，都制定参数在模版测试中的使用方式。</p>
<p>模版测试实际上是一个位测试，就像在C程序中使用掩码确定某一位是否置位一样。控制模版测试的运算符和值的模版函数由glStencilFunc或glStencilFuncSeparate函数控制。<br><code>void glStencilFunc(GLenum func,GLint ref, GLuint mask)</code><br><code>void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/04/GPU-Optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/04/GPU-Optimize/" class="post-title-link" itemprop="url">当我们谈优化时，我们谈些什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 11:24:31" itemprop="dateCreated datePublished" datetime="2019-09-04T11:24:31+08:00">2019-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>过去几年里，我经历过大约几十场面试，几乎在每次面试的时候，面试官都会提问一个问题：“你在渲染性能优化方面有什么经验？”这个时候我就会开始揣测面试官的意图，试着去回忆他之前提的问题，看看面试官到底想听什么样的回答，往往这种尝试都是失败的，结果就是不知道从何说起，因为没有具体的情景，最后只能说“整个渲染流程中很多地方都可能出现瓶颈，只能case by case的去查看，找到项目的具体瓶颈，然后针对性的去解决，”几乎所有听到这个问题回答的面试官都会对我意味深长地一小，不置可否，一旦看到这种消融，我就知道糟了，之后的面试反馈中，很多人对我评价就是“对渲染算法比较熟悉，但是在优化方面经验欠缺”。</p>
<p>总得来说我觉得这不是一个好问题，因为太过宽泛而没有针对性。我并不想泛泛地说：“减少模型数量，减少/合并draw call，缩减贴图尺寸，压缩贴图，使用LOD”，因为这就是所谓“正确但无用的话”，所有游戏不都是这么优化的吗？此外，对于一个项目来讲，模型的面数，贴图尺寸，LOD的级别这些信息往往是在DEMO阶段就已经由TA主导确定的。对于引擎程序员来讲，需要你提出优化方案的，通常是在项目的开发过程中产生的新瓶颈（当然你首先需要定位它）。但反过来，我的回答其实也是废话，所有性能优化流程不都是这样吗？<br><img src="/2019/09/04/GPU-Optimize/1.jpg" title="一个典型的性能优化的流程，从profile开始，然后针对瓶颈优化，测试优化的效果，再进入下一轮的profile（一个性能的优化有可能导致新的性能瓶颈产生），如此无限循环"><br>所以，当我们谈论性能优化的时候，我们究竟在谈些什么呢？</p>
<p>我试着理解了这个问题的意图，如果我们换一种问法，比如“渲染常见的性能瓶颈有哪些？具体可能出现在什么样的情境下？为什么这些情景会造成对应的性能瓶颈？”会不会是一个更好的问题？所以这篇文章，是在试着回答这个新问题。不同于以往的文章，优化本身确实是一个比较宽泛的主题，所以本文的组织也比较松散，很多内容可能是我想到哪里就写到哪里。其中有些概念基于我对硬件的理解，如有错误之处，欢迎指正。</p>
<h1 id="说说GPU架构"><a href="#说说GPU架构" class="headerlink" title="说说GPU架构"></a>说说GPU架构</h1><p>核弹厂有一篇关于自己GPU架构和逻辑管线的非常好的文章<sup><a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline" target="_blank" title="life is triangle">[1]</a></sup>，如果你想要对GPU的结构有一个完整系统的认识，请一定不要错过。比较可惜的是，这边文章只更新到Maxwell这代架构，没有较新的Pascal架构（GTX10x0系列）和Turing架构（RTX20x0）的技术细节，不过总体来说，现代GPU的设计架构已经趋于稳定，一般只是针对某些单元做优化，或者增加feature，所以文章中的大部分内容仍然是有效的，这是文中的一张图：<br><img src="/2019/09/04/GPU-Optimize/2.jpg"><br>这张图是基于数据的流向，对GPU的硬件单元进行了大致的划分，实际上GPU中，最核心的部分可以被分为三大块，我画了图中示意他们大致的协作模式：<br><img src="/2019/09/04/GPU-Optimize/3.jpg"><br>通常来说，GPU会有三个比较重要的部分，分别是控制模块，计算模块（图中GPC）和输出模块（图中的FBP）。通常来说，GPU架构的设计需要有课伸缩性，这样通过增加/阉割计算和输出模块，就能产生性能不同的同架构产品（比如GTX1070和GTX1080的主要区别就是GPC和FBP的数量），以满足不同消费水平和应用场景的需求。</p>
<h1 id="控制模块"><a href="#控制模块" class="headerlink" title="控制模块"></a>控制模块</h1><p>控制模块负责接收和验证（主要是Host和Front End）来自CPU的经过打包的PushBuffer（经过Driver翻译的Command Buffer），然后读取顶点索引（注意是Vertex Indices不是Vertex Attributes，主要是由Primitive Distributor负责）分发到下游管线或者读取Compute Grid的信息（主要由CWD负责，这部分是Compute Pipeline，不做展开）并向下游分发给CTA。</p>
<p>Tips：计算管线和图形管线共享大部分的芯片单元，只在分发控制的单元上各自独享（PD和CWD）。许多较新的Desktop GPU允许图形和计算管线并行执行，可以在一些SM压力轻的图形计算环节（比如Shadow Map绘制），利用Compute Shader去做一些SM压力重的工作（比如后处理），让各个硬件单元的负载更加平衡。</p>
<h1 id="什么情景会造成性能瓶颈？"><a href="#什么情景会造成性能瓶颈？" class="headerlink" title="什么情景会造成性能瓶颈？"></a>什么情景会造成性能瓶颈？</h1><h1 id="Shader的优化"><a href="#Shader的优化" class="headerlink" title="Shader的优化"></a>Shader的优化</h1><h2 id="减少分支"><a href="#减少分支" class="headerlink" title="减少分支"></a>减少分支</h2><p>我们已经解释过GPU是如何实现分支的，</p>
<h1 id="用贴图缓存中间计算结果？"><a href="#用贴图缓存中间计算结果？" class="headerlink" title="用贴图缓存中间计算结果？"></a>用贴图缓存中间计算结果？</h1><p>很多时候，我们会把一些数学上的中间计算缓存到一张贴图里，这些贴图的数值本身不代表视觉信息，而是纯粹的数学。比如Marschner Hair Mode用LUT去存BRDF；UE4用LUT去存储PBR的环境光BRDF。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/04/Mobile-GPU-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/04/Mobile-GPU-Architecture/" class="post-title-link" itemprop="url">移动GPU架构浅析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 08:53:59" itemprop="dateCreated datePublished" datetime="2019-09-04T08:53:59+08:00">2019-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>移动GPU相对桌面GPU只能算小弟弟，移动GPU的劣势主要表现在理论性能和带框。移动GPU受限于芯片面积，能耗以及成本所以必须牺牲部分性能和带宽来求得性价比和电池续航的平衡。与桌面GPU动辄256bit甚至512bit的带宽、1.2-1.5GHz的高频显存相比，移动GPU不仅要和CPU共享内存带宽，而且普遍使用的是双32bit位宽、LPDDR2-800或1066左右的内存系统，总带宽普遍在10GB/s以内。</p>
<img src="/2019/09/04/Mobile-GPU-Architecture/1.png">
<p>在上图中移动处理器中内存带宽最高的是iPad 3/4，因为他们使用Retina屏幕，2048x1536的高分辨率对GPU带宽要求更高，不过就算是这两款产品，17GB/s的带宽与PC显卡动辄200GB/s以上的带宽相比还是小儿科，没有带宽就没有大容量纹理数据，也就不会有高画质。尽管带宽不是制约移动GPU发展的唯一因素，但是在目前的限制下，移动GPU厂商关心的头等大事就是如何尽可能小的带宽需求下提升GPU性能及画质，纹理压缩是一个方法，还有一种就是使用不通的渲染架构。目前在GPU领域主要有IMR、TBR及TBDR等三种主流架构。</p>
<h1 id="移动GPU的模型"><a href="#移动GPU的模型" class="headerlink" title="移动GPU的模型"></a>移动GPU的模型</h1><h2 id="IMR模式"><a href="#IMR模式" class="headerlink" title="IMR模式"></a>IMR模式</h2><img src="/2019/09/04/Mobile-GPU-Architecture/2.png">
<p>IMR（Immediate Mode Rendering）就如字面意思一样，提交的每个渲染命令都会立即执行，并且该渲染命令会在整条流水线中执行完毕后才开始执行下一个渲染命令。</p>
<p>这种模式的优点：</p>
<ul>
<li>GPU架构比TBR模式简单直接。</li>
<li>在一帧里面执行FBO操作时，不会因为需要清空缓冲的渲染指令而影响性能。</li>
<li>不用像TBR架构一样需要片上高速缓存来保存中间结果。</li>
<li>不用像TBR架构一样缓存Triangle List，因此在有大量顶点运算的场景时比TBR有优势。例如PC上面的复杂模型可能有几百万个triangle。</li>
</ul>
<p>这种模式的缺点就是：</p>
<ul>
<li>IMR的渲染会存在浪费带宽的情况。例如，当两次渲染有前后遮蔽关系时，IMR模式因为两次draw命令都要执行，因此会存在经过Pixel Shader后的Pixel被Depth test抛弃，这样就浪费了Shader Unit运算能力。不过幸运的是，目前几乎所有的IMR架构的GPU都会提供Early Z的判断方式，一般是在Rasterizer里面对图形的遮蔽关系进行判断，如果需要渲染的图形被遮挡住，那么就直接抛弃该图形而不需要执行Pixel Shader。</li>
<li>IMR的另外一个缺点就是其渲染命令在执行需要随时读写frame buffer，depth buffer和stencil buffer，这带来大量的内存带宽消耗，在移动平台上面访问片外内存是最消耗电量和最耗时的操作。</li>
</ul>
<p>因此在桌面GPU灵越，TBR节省带宽和低性能不符合PC机的要求，IMR一统江湖。但是在移动GPU领域，TBR的低带宽消耗，低功耗正好满足移动设备需求，与其在PC端的待遇相反，移动设备领域TBR几乎一统江湖。<br>IMR模式的代表是NVIDIA的Tegra和Vivante的GC系列芯片。在此列出Vivante GC芯片的内部架构图，我们可以看到Vivante的GPU架构相当简单。<br><img src="/2019/09/04/Mobile-GPU-Architecture/3.png"></p>
<h2 id="TBR模式"><a href="#TBR模式" class="headerlink" title="TBR模式"></a>TBR模式</h2><img src="/2019/09/04/Mobile-GPU-Architecture/4.png">
<p>与IMR简单粗暴的做法不通，TBR（Tile Based Rendering）它将需要渲染的画面分成一个个的矩形区块（tile）,tile一般是4x4或者8x8的矩形块。模型的顶点金经过过Vertex Shader运算以后会组装成一个个的triangle，这些triangle会被缓冲在一个triangle cache里面。如果某个triangle需要在某个tile里面绘制，那么就会在该tile的triangle list中存在一个索引。等一帧里面所有的渲染命令都经过执行完Vertex Shader生成triangle以后，每个tile就会有一个triangle list，这list就包含了需要在该tile内部绘制的所有triangle。然后GPU在基于triangle list执行每个tile的raster和Per-fragment operation。</p>
<p>TBR的优点是执行raster和Per-fragment operation时不需要反复的访问frame buffer，depth buffer，stencil buffer。这是因为GPU可能把整个tile的frame buffer/depth buffer/stencil buffer保存在一个片上的高速缓冲中，这样GPU就直接访问tile，而不需要访问外部内存。这大大减少了内存的带宽消耗，也意味着能耗的降低。</p>
<p>TBR的缺点是需要保存Vertex Shader执行后的结构以及每个tile的triangle list。这意味着如果场景里面有很多的顶点，那么片上缓存就不可能存下这么多顶点信息和triangle list，就不能不依靠外部内存来存储，就会有额外的带宽消耗。不过庆幸的是当前的移动3D绘制都会不会有太多的triangle的场景。一个复杂的模型也就是1万多个triangle，因此一个通常的场景大概就是几十万triangle。随着移动游戏越来越复杂精美，模型的复杂程度也会快速上升，这也是TBR架构在未来将会面临的一大挑战。</p>
<p>如果在一帧里面有两遍及其以上的渲染，那么就需要使用Frame buffer object 来缓存中间结果，这对TBR又是一大性能损耗。根据我们前面的讲解，TBR需要缓冲一帧所有的图元，所有图元执行完毕后才开始raster和Per-fragment operation。在这种情况下，一旦后面的draw命令需要使用前面渲染生成的结果，那么就不得不在该命令前执行，要求GPU把缓存的所有draw命令都执行完毕，然后放弃当前缓存内容。在极端情况下，例如每次draw都需要读取前一次draw渲染的结果，那么TBR就会直接退化成IMR模式。</p>
<p>基于以上的缺点，我们可以看出在桌面GPU领域TBR没有任何优势，因此其完全退出桌面GPU市场。但是在移动GPU市场它更适应性能/带宽/能耗三者的平衡。</p>
<p>TBR的代表有ARM的Mali和高通的Adreno。下图是Mali的架构图：<br><img src="/2019/09/04/Mobile-GPU-Architecture/5.png"></p>
<h2 id="TBDR模式"><a href="#TBDR模式" class="headerlink" title="TBDR模式"></a>TBDR模式</h2><img src="/2019/09/04/Mobile-GPU-Architecture/6.png">
<p>TBDR（Tile Based Deferred Rendering，贴图延迟渲染）算是TBR的近亲，它跟TBR原理相似，但是通过HSR（Hidden Surface Removal，隐藏面消除）操作，在执行Pixel Shader之前进一步减少了不需要渲染的fragment，降低了带宽需求。在执行Pixel Shader之前，对Raster生成的每个像素都做depth test比较，剔除被遮挡的像素，这就是HSR的原理。理论上经过HSR剔除以后，使得TBDR每帧需要渲染的像素上限就是屏幕像素的数量（没有考虑alpha blend的情况下）。而传统的TBR在执行复杂一点的游戏时可能需要渲染6倍于屏幕的像素。</p>
<p>TBDR是PowerVR的王牌，因为TBR的HSR带来的带宽和运算开销的降低，使得苹果手机的续航能力让人惊叹。下图是PowerVR的SGX系列的GPU架构图，可以看到其复杂程度大大超过Vivante这类IMR的架构。<br><img src="/2019/09/04/Mobile-GPU-Architecture/7.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/03/Life-of-a-triangle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/03/Life-of-a-triangle/" class="post-title-link" itemprop="url">Life of a triangle - NVIDIA's logical pipeline</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-03 22:48:15" itemprop="dateCreated datePublished" datetime="2019-09-03T22:48:15+08:00">2019-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Since the release of the ground breaking Fermi architecture almost 5 years have gone by. it might be time to refresh the principle graphics architecture beneath it.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/03/CPU-Buffer-hit-ratio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/03/CPU-Buffer-hit-ratio/" class="post-title-link" itemprop="url">浅谈CPU三级缓存和缓冲命中率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-03 22:11:50" itemprop="dateCreated datePublished" datetime="2019-09-03T22:11:50+08:00">2019-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CPU缓冲（Cache Memory）是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存快得多。缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间数据到来或数据写入内存。在缓存中的数据是内存的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。由此可见，在CPU中加入缓冲是一种高效的解决方案，这样整个内存存储器（缓存+内存）就变成了既有缓存的高速度，又有内存的大容量的存储系统了。缓存对CPU的性能影响很大，主要是因为CPU的数据交换顺序和CPU与缓存间的带宽引起的。</p>
<p>缓存的工作原理是当CPU要读取一个数据时，首先从缓存中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就用相对慢的速度内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。<br>正是这样的读取机制使CPU读取缓冲缓存的命中率非常高（大多数CPU可达90%左右），也就是说CPU下一次要读取的数据90%都在缓存中，大约10%需要从内存读取。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/03/Video-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/03/Video-Memory/" class="post-title-link" itemprop="url">显存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-03 20:14:48" itemprop="dateCreated datePublished" datetime="2019-09-03T20:14:48+08:00">2019-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>显存全称显示存储器，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
