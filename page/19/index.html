<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/19/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/03/08/Unity-Avatar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/08/Unity-Avatar/" class="post-title-link" itemprop="url">Unity Avatar</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-08 16:29:32" itemprop="dateCreated datePublished" datetime="2019-03-08T16:29:32+08:00">2019-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity3D/" itemprop="url" rel="index"><span itemprop="name">Unity3D</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/03/06/Unity-Reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/06/Unity-Reflection/" class="post-title-link" itemprop="url">Unity Reflection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-06 12:11:36" itemprop="dateCreated datePublished" datetime="2019-03-06T12:11:36+08:00">2019-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>反射是.NET中的重要机制，通过反射，可以在运行时获得程序或者程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息。另外还可以直接创建对象，即使这个对象的类型在编译时还不知道。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>使用Assembly定义和加载程序集，加载在程序集清单中列出模块，从此程序集中查找类型并创建并创建该类型的实例。</li>
<li>使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。</li>
<li>使用ConstructorInfo了解构造函数的名称，参数，访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。</li>
<li>使用MethodInfo了解方法的名称，返回类型，参数，访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。</li>
<li>使用FieldInfo了解字段的名称、访问修饰符（如public或private）和实现相信信息（如static）等，并获取或设置字段值。</li>
<li>使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。</li>
<li>使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。</li>
<li>使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。</li>
</ul>
<h2 id="需要的namespace"><a href="#需要的namespace" class="headerlink" title="需要的namespace"></a>需要的namespace</h2><pre><code>System.Reflection;
System.Type;
System.Reflection.Assembly;
</code></pre><h2 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h2><pre><code>System.Type // 通过这个类可以访问任何给定数据类型的信息
System.Reflection.Assembly; // 访问或者加载程序集的信息
</code></pre><h3 id="System-Type"><a href="#System-Type" class="headerlink" title="System.Type"></a>System.Type</h3><p>System.Type类对于反射起着核心的作用。它是一个抽象的基类，Type有与每种数据类型对应的派生类。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">string</span>  Name &#123;<span class="keyword">get</span>;&#125;           <span class="comment">// 数据类型名</span></span><br><span class="line"><span class="keyword">string</span>  FullName &#123;<span class="keyword">get</span>;&#125;       <span class="comment">// 数据类型的完全限定名（包括命名空间）</span></span><br><span class="line"><span class="keyword">string</span>  Namespace;      <span class="comment">// 命名空间名</span></span><br><span class="line"><span class="keyword">bool</span>    IsAbstract;     <span class="comment">// 是否抽象</span></span><br><span class="line"><span class="keyword">bool</span>    IsArray;        <span class="comment">// 是否数组</span></span><br><span class="line"><span class="keyword">bool</span>    IsClass;        <span class="comment">// 是否类</span></span><br><span class="line"><span class="keyword">bool</span>    IsEnum;         <span class="comment">// 是否枚举</span></span><br><span class="line"><span class="keyword">bool</span>    IsInterface;    <span class="comment">// 是否接口</span></span><br><span class="line"><span class="keyword">bool</span>    IsPublic;       <span class="comment">// 是否是公有的类型</span></span><br><span class="line"><span class="keyword">bool</span>    IsSealed;       <span class="comment">// 是否是密封类</span></span><br><span class="line"><span class="keyword">bool</span>    IsValueType;    <span class="comment">// 是否是指类型</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">// 用于取得该类的构造函数的信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConstructorInfo <span class="title">GetConstructor</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConstructorInfo[] <span class="title">GetConstructors</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 取得该类的事件信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventInfo <span class="title">GetEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> EventInfo[] <span class="title">GetEvents</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FieldInfo <span class="title">GetField</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FieldInfo[] <span class="title">GetFields</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InterfaceInfo <span class="title">GetInterFace</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InterfaceInfo[] <span class="title">GetInterFaces</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> MemberInfo <span class="title">GetMember</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> MemberInfos <span class="title">GetMembers</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyInfo <span class="title">GetProperty</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyInfo[] <span class="title">GetProperties</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 调用上述成员，方式是调用Type的InvokeMember()方法，或者调用MethodInfo，PropertyInfo的Invoke方法</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看类的构造方法</span></span><br><span class="line">NewClass nc = <span class="keyword">new</span> NewClass();</span><br><span class="line">Type t = nc.GetType();</span><br><span class="line">ConstructorInfo[] ci = t.GetConstructors(); <span class="comment">// 获取类的所有构造函数</span></span><br><span class="line"><span class="keyword">foreach</span> (ConstructorInfo c <span class="keyword">in</span> ci)</span><br><span class="line">&#123;</span><br><span class="line">    ParamterInfo[] ps = c.GetParameters();</span><br><span class="line">    <span class="keyword">foreach</span> (ParamterInfo pi <span class="keyword">in</span> ps)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"&#123;0&#125;\t&#123;1&#125;"</span>, pi.ParamterType.ToString(), pi.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用构造函数动态生成对象</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(NewClass);</span><br><span class="line">Type[] pt = <span class="keyword">new</span> Type[<span class="number">2</span>];</span><br><span class="line">pt[<span class="number">0</span>] = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br><span class="line">pt[<span class="number">1</span>] = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br><span class="line"><span class="comment">// 根据参数类型获取构造函数</span></span><br><span class="line">ConstructorInfo ci = t.GetConstructor(pt);</span><br><span class="line"><span class="comment">// 构造Object数组，作为构造函数的输入参数</span></span><br><span class="line"><span class="keyword">object</span>[] obj = <span class="keyword">new</span> <span class="keyword">object</span>[<span class="number">2</span>]&#123;<span class="string">"Liyanfeng"</span>, <span class="string">"Hello World"</span>&#125;;</span><br><span class="line"><span class="comment">// 调用构造函数生成对象</span></span><br><span class="line"><span class="keyword">object</span> o = ci.Invoke(obj);</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Activator生成对象</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(NewClass);</span><br><span class="line"><span class="comment">// 用Activator的CreateInstance静态方法，生成新对象</span></span><br><span class="line"><span class="keyword">object</span> o = Activator.CreateInstance(t, <span class="string">"Liyanfeng"</span>, <span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="获取给定类型的Type引用有3中常用方式"><a href="#获取给定类型的Type引用有3中常用方式" class="headerlink" title="获取给定类型的Type引用有3中常用方式"></a>获取给定类型的Type引用有3中常用方式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typeof运算啊</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br><span class="line"><span class="comment">// 使用对象GetType()方法</span></span><br><span class="line"><span class="keyword">string</span> s = <span class="string">"Liyanfeng"</span>;</span><br><span class="line">Type t = s.GetType();</span><br><span class="line"><span class="comment">// 调用Type类的静态方法GetType()</span></span><br><span class="line">Type t = Type.GetType(<span class="string">"System.String"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(MemberInfo mi <span class="keyword">in</span> t.GetMembers())</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">"&#123;0&#125;/t&#123;1&#125;"</span>, mi.MemberType, mi.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/03/05/Batch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/05/Batch/" class="post-title-link" itemprop="url">图形渲染及优化-Batch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-05 11:43:54" itemprop="dateCreated datePublished" datetime="2019-03-05T11:43:54+08:00">2019-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>批处理（Batch）就是对某对象进行批量的处理，本文介绍一下Batch的基本概念、</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/03/05/CsharpJobSystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/05/CsharpJobSystem/" class="post-title-link" itemprop="url">C# Jobs System</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-05 08:16:08" itemprop="dateCreated datePublished" datetime="2019-03-05T08:16:08+08:00">2019-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Unity C＃ Job System允许用户编写与Unity其余部分良好交互的多线程代码，并使编写正确的代码变得更加容易。<br>编写多线程代码可以提供高性能的好处。其中包括显着提高帧速率和延长移动设备的电池寿命。<br>C＃ Job System的一个重要方面是它与Unity内部使用的集成（Unity的native jobsystem）。用户编写的代码和Unity共享工作线程。这种合作避免了导致争用CPU资源的问题，并且可以创建比CPU核心更多的线程。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>在单线程计算机系统中，一次只能进入一条指令，并且只能得出一个结果。加载和完成程序的时间取决于CPU需要完成的工作量。<br>多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力，它不是一个接一个地执行任务或指令，而是同时运行的。<br>默认情况下，一个线程在程序的开头运行。这是“主线程”。主线程创建新线程来处理任务。这些新线程彼此并行运行，并且通常在完成后将其结果与主线程同步。<br>如果有一些运行很长时间的任务，这种多线程方法很有效。但是，游戏开发代码通常包含许多一次执行的小指令。如果为每个小指令创建一个线程，最终可能会有许多线程，每个线程的生命周期都很短。这可以推动CPU和操作系统处理能力的极限。<br>通过拥有一个线程池可以缓解线程生存期的问题。但是，即使使用线程池，也可能同时激活大量线程。线程数多于CPU核心导致线程相互争用CPU资源，导致频繁的上下文切换。上下文切换是通过执行保存线程状态的过程，然后处理另一个线程，然后重新构建第一个线程，以便继续处理它。上下文切换是资源密集型的，因此您应尽可能避免使用它。<br>大多数使用多线程代码的人都知道编写线程安全代码很难，线程争抢资源可能会发生，但机会非常少，如果程序员没有想到这个问题，可能会导致潜在的严重错误。除此之外，上下文切换的成本很高，因为学习如何平衡工作负载已尽可能高效地运行是很困难的。</p>
<h1 id="Job-System"><a href="#Job-System" class="headerlink" title="Job System"></a>Job System</h1><p>Job System通过创建Job而不是线程来管理多线程代码。<br>Job System跨多个核心管理一组工作线程。它通常每个逻辑CPU核心有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。<br>Job System将Job放入作业队列中用来执行。Job System中的工作线程从作业队列中获取Job并执行它们。作业系统管理依赖关系并确保作业以适当的顺序执行。</p>
<div align="center"><img src="/2019/03/05/CsharpJobSystem/1.jpg"></div>

<p>我们来看一下简单的子弹运动系统，大多数程序员都会为GameObject编写一个管理器，如Bullet Manager，通常，这些管理器会管理一个GameObjects列表，并每帧更新场景中所有子弹活动的位置。这非常符合使用C# Jobs System的条件，由于子弹运动可以单独处理，因此非常适合并行化，借助C# Jobs System，可以轻松地将此功能拉出来，并行运行不通的数据块，作为开发人员，只需要专注游戏逻辑代码即可。</p>
<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>Job是完成一项特定任务的一小部分工作。Job接收参数并对数据进行操作，类似于方法调用的行为方式。Job可以是独立的，也可以是依赖的（需要等其他作业完成后，然后才能运行。）</p>
<h2 id="Job-依赖"><a href="#Job-依赖" class="headerlink" title="Job 依赖"></a>Job 依赖</h2><p>在复杂的系统中，如游戏开发所需的系统，每个工作都不可能是独立的。一项工作通常是为下一份工作准备数据。作业了解并支持依赖关系以使其发挥作用。如果jobA对jobB依赖，则Job System确保在完成jobA之前不会开始执行jobB。</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>编写多线程代码时，总是存在竞争条件的风险。当一个操作的输出取决于其控制之外的另一个过程的时间的时候，就会发生竞争条件。<br>竞争条件并不总是一个bug，但是它不确定行为的来源，当竞争条件导致bug的时候，总是比较难以找到问题的根源。因为它取决于时间，因此你可能极少数情况下会复现问题。调试的时候可能会导致问题消失。因此调试和日志可能会改变bug的发生条件。竞争条件是编写多线程的时候面临的比较大的挑战。</p>
<p>为了更容易编写多线程代码，Job System可以检测所有潜在的竞争条件，并保护你免受可能导致的bug的影响。<br>例如：如果Job System将主线程中代码中的数据引用发送到Job中，则无法验证作业在写入数据的时候同时读取数据，这种情况就会创建竞争条件。</p>
<p>Job System通过向每个作业发送它需要的操作的数据的副本来解决这个问题，而不是对主线程中的数据的引用，这种拷贝隔离了数据，从而消除了竞争条件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/03/03/Unity-Hub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/03/Unity-Hub/" class="post-title-link" itemprop="url">UnityHub破解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 04:49:42" itemprop="dateCreated datePublished" datetime="2019-03-03T04:49:42+08:00">2019-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>退出UnityHub</p>
<pre><code>npm install -g asar
cd C:\Program Files\Unity Hub\resources
asar extract .\app.aser app
rm -rf app.asar
cd app/src/services/licenseService
vim licenseClient.js
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getLicenseInfo(callback)&#123;</span><br><span class="line">    // load license</span><br><span class="line">    // get latest data from licenseCore</span><br><span class="line">    //licenseInfo.activated = licenseCore.getLicenseToken().length &gt; 0; // 注释这行</span><br><span class="line">    licenseInfo.activated = true; // 新增这行</span><br><span class="line">    licenseInfo.flow = licenseCore.getLicenseKind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>vim licenseCore.js
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">verifyLicenseData(xml)&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;</span><br><span class="line">        resolve(true); //新增这行</span><br><span class="line">        if (xml === &apos;&apos;)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/03/02/NetSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/02/NetSocket/" class="post-title-link" itemprop="url">IO多路复用之select、poll、epoll详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-02 13:19:19" itemprop="dateCreated datePublished" datetime="2019-03-02T13:19:19+08:00">2019-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前支持I/O多路复用的系统调用有select,pselect,poll,epoll,I/O多路复用就是通过一种机制，一个进程可以监听多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就能够通知程序进行相应的读写操作。但select,pselect,poll,epoll本质上都是同步I/O，因为他们都需要在读写时间就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这一步有性能开销）<br>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减少了系统的开销。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>IO多路复用是指内核一旦发生进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：<br>1）当客户处理多个描述符时（一般是交互式输入和网络套接口），必须适用I/O复用。<br>2）当一个客户同时处理多个套接口，这种情况是可能的，但很少出现。（貌似没见过）<br>3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用I/O复用。（这是最常见的方式，貌似没有其他取代方式？）<br>4）如果一个服务器既要处理TCP，又要处理UDP，一般要使用I/O复用。<br>5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>
<h1 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h1><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核都支持，其中epoll是Linux所特有，而select则应该是POSIX规定。<br>基本流程，如图所示：<br><img src="/2019/03/02/NetSocket/netsocket1.png" title="这是一个新的博客的图片的说明"><br>select目前几乎在所有的平台上支持，其良好的跨平台支持也是它的一个优点。select的一个缺点在与单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。<br>select本质上是通过设置或者检查存放fb标志位的数据结构来进行下一步处理。这样所带来的的缺点是：<br>1.select最大的缺陷就是单个进程打开的DF是有一定限制的，它由FD_SETSIZE设置，默认值是1024。<br>一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max查看。32位默认1024个，64位默认2048个。我查了一下自己的虚拟机Centos6.0 是95979，从数量上分析来看，对于游戏来说，select模型个人感觉这点可以忽视了。<br>2.对socket进行扫描是线性扫描，即采用轮询的方法，效率较低。<br>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。（这可太扯了）这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。<br>3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销很大。</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll是select的一种改良，最突出的改良有两点：<br>1.文件描述符数量没有上限<br>2.将输入输出参数进行分离，不用每次设定<br>缺点：<br>1.和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符<br>2.每次调用poll都需要大把大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>1.文件描述符没有上限，通过epoll_ctl()来注册一个文件描述符，内核中使用红黑树的数据结构来管理所有需要监控的文件描述符。<br>2.基于时间就绪通知方式，一旦被监听的某个文件描述符就绪，内核会采用类似于callback的回调机制，迅速激活这个文件描述符，这样随着文件描述符数量的增加，也不会影响判定就绪的性能。<br>3.维护就绪队列，当文件描述符就绪，就会被放到内核中的一个就绪队列中，这样调用epoll_wait获取就绪文件描述符的时候，只要取队列中的元素即可，操作的时间复杂度恒为O(1)。<br>4.epoll内存映射机制，即内核将就绪队列通过mmap的方式映射到用户态，避免了拷贝内存这样的额外性能开销。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/02/25/QuickSort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/QuickSort/" class="post-title-link" itemprop="url">排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-25 20:45:21" itemprop="dateCreated datePublished" datetime="2019-02-25T20:45:21+08:00">2019-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序(Quick Sort)使用分治法策略。它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>一趟快速排序的算法是：</p>
<ol>
<li>设置两个变量i、j，排序开始的时候，i=0，j=N-1；</li>
<li>以第一个数组元素作为关键数据，赋值给key，即key=A[0]</li>
<li>从j开始向前搜索，即由后开始向前搜索（j—），找到第一个小于key的值A[j]，将A[j]=A[i]的值交换；</li>
<li>从i开始向后搜索，即由钱开始向后搜索（i++），找到第一个大于key的值A[i]，将A[i]和A[j]的值交换；</li>
<li>重复第3、4步，直到i=j；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high;</span><br><span class="line">    <span class="keyword">int</span> key = arr[i];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; arr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">    arr[j] = arr[low];</span><br><span class="line">    arr[low] = temp;</span><br><span class="line">    Sort(arr, low, i);</span><br><span class="line">    Sort(arr, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分支（divide-and-conquer）策略（分治法将问题分(divide)成一些小问题然后在递归求解，而治(conquer)的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）。</p>
<img src="/2019/02/25/QuickSort/1.png">
<p>可以看到这种结构很像一颗完全二叉树，本文的归并排序我们采用递归去实现，递归深度为$log_{2^n}$</p>
<h2 id="合并相邻有序子序列"><a href="#合并相邻有序子序列" class="headerlink" title="合并相邻有序子序列"></a>合并相邻有序子序列</h2><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p>
<img src="/2019/02/25/QuickSort/2.png">
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>归并排序比较占用内存，但却是一种高效且稳定的算法。<br>时间复杂度：$O(n \cdot log^n)$<br>空间复杂度：T(n)</p>
<h1 id="二叉堆（binary-heap）"><a href="#二叉堆（binary-heap）" class="headerlink" title="二叉堆（binary heap）"></a>二叉堆（binary heap）</h1><p>二叉堆是一种特殊的堆，二叉堆是完全二叉树（二叉树）或者近似完全二元树（二叉树）。二叉堆有两种：最小堆和最大堆。最大堆：父节点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/02/25/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/C++/" class="post-title-link" itemprop="url">C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-25 18:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T18:00:00+08:00">2019-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul>
<li>对于一个class，产生一堆指向virtual functions的指针，虚函数表指针通常放在对象实例的最前面的位置。编译报错的时候没有vtable，表示该纯虚函数没有实现。</li>
<li>每一个对象添加一个指针，指向相关的virtual table。这个指针被称作虚函数表指针。</li>
</ul>
<h1 id="C-C-中static关键字作用总结"><a href="#C-C-中static关键字作用总结" class="headerlink" title="C/C++中static关键字作用总结"></a>C/C++中static关键字作用总结</h1><h2 id="先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"><a href="#先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）" class="headerlink" title="先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"></a>先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</h2><p>当同事编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br><span class="line">    (<span class="keyword">void</span>)msg();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序运行结果是：<br>A Hello<br>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上了static，main.c就看不到它们了。利用这一特性可以再不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。</p>
<h2 id="static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）"><a href="#static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）" class="headerlink" title="static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）"></a>static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）</h2><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的，虽然这种用法不常见<br>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p>
<p>程序举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a就不会再次被初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量；</span></span><br><span class="line">    <span class="keyword">return</span> count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;=<span class="number">10</span>;++count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>,count,fun());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static这个说明符在不同的地方所起的作用是不同的。</p>
<h2 id="static的第三个作用是默认初始化为0（static变量）"><a href="#static的第三个作用是默认初始化为0（static变量）" class="headerlink" title="static的第三个作用是默认初始化为0（static变量）"></a>static的第三个作用是默认初始化为0（static变量）</h2><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏举证，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’；太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’;</p>
<p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。</p>
<h2 id="static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）"><a href="#static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）" class="headerlink" title="static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）"></a>static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）</h2><p>在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：<br>（1）类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。<br>（2）不能将静态成员函数定义为虚函数。<br>（3）由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个”nonmember函数指针”。<br>（4）由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based XWindow系统结合，同时也成功的应用于线程函数身上。（这条没遇见过）<br>（5）static并没有增加程序的时空开销，相反它还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。<br>（6）静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>（7）静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是Link时会报错误）<br>（8）静态成员初始化与一般数据成员初始化不同：<br>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private,public等；<br>初始化时使用作用域来标明它所属类；<br>所以我们得出静态数据成员初始化的格式：<br>&lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;<br>（9）为了防止父类的影响，可以在子类定一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling用以生成唯一的标志。</p>
<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象</p>
<h1 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h1><p>通过一张虚函数表（Virtual Table）来实现<br>sizeof不统计虚函数表</p>
<h1 id="C-C-内存对齐"><a href="#C-C-内存对齐" class="headerlink" title="C/C++内存对齐"></a>C/C++内存对齐</h1><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>32位系统下，int占4byte，char占1byte，那么将它们放到一个结构体中实际上占8byte，这就是内存对齐导致的。</p>
<h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><h2 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h2><p>内联函数是指那些定义在类体内部的成员函数，即该函数的函数体放在类体内。<br>一般来说，inline适用的函数有两种，一种是类内定义的成员函数，另一种是类内声明，类外定义的成员函数，对于这两种情况inline的使用有一些不同；</p>
<h2 id="内联函数的优缺点："><a href="#内联函数的优缺点：" class="headerlink" title="内联函数的优缺点："></a>内联函数的优缺点：</h2><p>优点：<br>1.inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。<br>2.inline也是真正的函数，编辑器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个正在的函数一样。这样就消除了它的隐患和局限性。（宏替换不会检查参数类型，安全隐患较大）<br>缺点：<br>1.内联函数具有一定的局限性，inline函数的函数体一般来说不能太大，如果太大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。（换句话说，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请），这样，内联和普通函数执行效率一样了。<br>2.inline对编译器来说只是一种简易，编译器可以选择忽略这个建议。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.内联函数不能宝库欧复杂的控制语句，如循环语句和switch语句；</p>
<h1 id="接口（抽象类）"><a href="#接口（抽象类）" class="headerlink" title="接口（抽象类）"></a>接口（抽象类）</h1><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><ol>
<li>C语言</li>
<li>面向对象</li>
<li>C++模版</li>
<li>STL容器</li>
</ol>
<h1 id="尽量用const，enum，inline替换-define"><a href="#尽量用const，enum，inline替换-define" class="headerlink" title="尽量用const，enum，inline替换#define"></a>尽量用const，enum，inline替换#define</h1><ol>
<li>const的好处：define直接常量替换，出现编译错误不易定位（不知道常量是哪个变量，这个其实还好，工程规范点的都不存在这个问题）；define没有作用域，const有作用域提供了封装性（这个同上，不过这两点都是人为的避开了）</li>
<li>enum的好处：提供了封装性，编译器肯定不会分配额外的内存空间（其实const也不会，难道define会？至于封装性，undef，所以这么多年了，虽然说避免，但是工程上用的还是比较多的）</li>
<li>inline的好处：define宏函数容易造成误用</li>
</ol>
<p>宏实现工厂设计模式</p>
<ol>
<li>需要一个全局map用于存储类的信息以及创建实例的函数</li>
<li>需要调用全局对象的构造函数用于注册</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef void *(*register_fun)();</span><br><span class="line"></span><br><span class="line">class CCFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void *NewInstance(string class_name)</span><br><span class="line">    &#123;</span><br><span class="line">        auto it = map_.find(class_name);</span><br><span class="line">        if (it == map_.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return it-&gt;second();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Register(string class_name, register_fun func)</span><br><span class="line">    &#123;</span><br><span class="line">        map_[class_name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static map&lt;string, register_fun&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, register_fun&gt; CCFactory::map_; // 体外初始化</span><br><span class="line"></span><br><span class="line">#define REGISTER_CLASS(class_name); \</span><br><span class="line">    CCFactory::Register(#class_name, []()-&gt;void *&#123;return (new class_name);&#125;);</span><br><span class="line"></span><br><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Say() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Register : public Product // 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Say()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Say What?\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">    REGISTER_CLASS(Register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Release()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    Register* a = (Register*)CCFactory::NewInstance(&quot;Register&quot;);</span><br><span class="line">    a-&gt;Say();</span><br><span class="line">    Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没写完，但是感觉做个池还是挺好玩的。</p>
<h1 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h1><ol>
<li>const定义接口，防止误用</li>
<li>const成员函数，代表这个成员函数承诺不会改变对象值（const成员只能调用const成员函数(加-fpermissive编译选项就可以了)，非const成员可以调用所有成员函数）</li>
</ol>
<h1 id="确定对象使用前被初始化"><a href="#确定对象使用前被初始化" class="headerlink" title="确定对象使用前被初始化"></a>确定对象使用前被初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef void *(*register_fun)();</span><br><span class="line"></span><br><span class="line">class CCFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void *NewInstance(string class_name)</span><br><span class="line">    &#123;</span><br><span class="line">        auto it = map_.find(class_name);</span><br><span class="line">        if (it == map_.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return it-&gt;second();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Register(string class_name, register_fun func)</span><br><span class="line">    &#123;</span><br><span class="line">        map_[class_name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static map&lt;string, register_fun&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, register_fun&gt; CCFactory::map_; // 体外初始化</span><br><span class="line"></span><br><span class="line">#define REGISTER_CLASS(class_name); \</span><br><span class="line">    CCFactory::Register(#class_name, []()-&gt;void *&#123;return (new class_name(#class_name));&#125;);</span><br><span class="line"></span><br><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Say() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Register : public Product // 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Say()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; name.c_str() &lt;&lt; &quot;: Say What?\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void Run() const // 表明这个函数不会对类对象的数据成员（准确地说是非静态数据成员）作任何改变</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int b;</span><br><span class="line">    const string name; // 必须在初始化的时候赋值</span><br><span class="line">    Register(string _y) : name(_y)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">    REGISTER_CLASS(Register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Release()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    Register* a = (Register*)CCFactory::NewInstance(&quot;Register&quot;);</span><br><span class="line">    a-&gt;Say();</span><br><span class="line">    Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造、析构、赋值运算"><a href="#构造、析构、赋值运算" class="headerlink" title="构造、析构、赋值运算"></a>构造、析构、赋值运算</h1><p>如果类中没有定义，程序却调用了，编译器会产生一些函数</p>
<ol>
<li>一个default的构造函数</li>
<li>一个copy构造函数</li>
<li>一个copy assignment 操作符</li>
<li>一个析构函数(non virtual)</li>
</ol>
<ul>
<li>如果自己构造了带参数的构造函数，编译器不会产生default构造函数</li>
<li>base class如果把拷贝构造函数或者复制操作符设置为private，不会产生这两个函数</li>
<li>含有引用成员变量或者const成员变量不产生复制操作符</li>
</ul>
<h1 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h1><p>将默认生成的函数声明为private，或者C++ 11新特性”=delete”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UncopyTable</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    UncopyTable(const UncopyTable&amp;);</span><br><span class="line">    UncopyTable&amp; operator=(const UncopyTable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h1><p>上下文无关，在编译时就可以确定其类型。</p>
<h1 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h1><p>基类指针指向的对象在编译的时候无法确定</p>
<h1 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h1><p>静态绑定：编译时绑定，通过对象调用<br>动态绑定：运行时绑定，通过地址实现</p>
<p>要触发动态绑定，需满足两个条件</p>
<ol>
<li>只有虚函数才能惊醒动态绑定，非虚函数不能进行动态绑定</li>
<li>必须通过基类类型的引用或指针进行函数调用</li>
</ol>
<h1 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h1><ol>
<li>给多态基类应该主动声明virtual析构函数</li>
<li>非多态基类，没有virtual函数，不要声明virtual析构函数</li>
</ol>
<h1 id="复制对象时勿忘其每个成分"><a href="#复制对象时勿忘其每个成分" class="headerlink" title="复制对象时勿忘其每个成分"></a>复制对象时勿忘其每个成分</h1><ol>
<li>实现拷贝构造函数和赋值操作符的时候，调用base的相关函数</li>
<li>可以让拷贝构造函数和赋值操作符调用一个共同的函数，比如Init</li>
</ol>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><ol>
<li>为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源</li>
<li>shared_ptr，unique_lock都是RAII对象</li>
</ol>
<h2 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h2><ul>
<li>常见的RAII对象copy行为<ul>
<li>禁止copy</li>
<li>引用计数</li>
<li>深度赋值</li>
<li>转移资源拥有权</li>
</ul>
</li>
</ul>
<h1 id="头文件搜索目录"><a href="#头文件搜索目录" class="headerlink" title="头文件搜索目录"></a>头文件搜索目录</h1><pre><code>#include &quot;headfile.h&quot;
</code></pre><p>搜索顺序为：</p>
<ol>
<li>当前目录</li>
<li>-I指定目录</li>
<li>gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH）</li>
<li>gcc内定目录<br>/usr/include<br>/usr/local/include<br>/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/12/09/fiction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/09/fiction/" class="post-title-link" itemprop="url">序章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-09 16:37:36" itemprop="dateCreated datePublished" datetime="2018-12-09T16:37:36+08:00">2018-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>芩也不是一开始就知道这个世界是黑白的，是他的父亲告诉他的。父亲说，芩，你长大了，父亲要走了。芩问，父亲你去哪里？父亲说，我也不知道，我总觉得有人在召唤我，我该上路了。我们每个人都会上路的，包括你，芩。芩说，父亲，我可以陪你一起上路吗？父亲回答，我们每个人的路都是不一样的，你以后会有你自己的路走的，或许是明天，或许是明年，或许是更久。芩没说话，六岁的他不知道该说什么，也不太明白父亲对他说的话。他只知道，父亲要走了。要去很远的地方，一个他找不到的地方。而他，再也见不到父亲了。<br>从那天起，我的天空里再也没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/11/23/PowerVR-Performance-Recommendations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/23/PowerVR-Performance-Recommendations/" class="post-title-link" itemprop="url">PowerVR Performance Recommendations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-23 14:43:57" itemprop="dateCreated datePublished" datetime="2018-11-23T14:43:57+08:00">2018-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>PowerVR SGX and PowerVR Rogue are Graphics Core architectures from Imagination Technologies designed specifically for shader-based APIs such as OpenGL ES 2.0,3.x,and Vulkan.Due to their scalable architectures,the PowerVR family spans a huge performance range.</p>
<h2 id="Document-Overview"><a href="#Document-Overview" class="headerlink" title="Document Overview"></a>Document Overview</h2><p>This purpose of this document is to serve as recommendation and advice for developers who wish to get the best graphics performance from a PowerVR SGX or PowerVR Rogue enabled device. Throughout the document, the specific recommendations for PowerVR SGX and PowerVR Rogue are marked as appropriate.</p>
<h2 id="The-Golden-Rules"><a href="#The-Golden-Rules" class="headerlink" title="The Golden Rules"></a>The Golden Rules</h2><p>The Golden Rules are a set of more generic performance recommendations that developers should seek to implement,as well as observe as many of the techniques and principles mentioned.This should help produce well-behaved,high performance graphics applications.These rules are detailed in the document entitled “PowerVR Performance Recommendations: The Golden Rules”,which is supplied with the PowerVR SDK.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
