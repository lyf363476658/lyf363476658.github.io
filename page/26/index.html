<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Console:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/26/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/23/Unity-Skinned-Mesh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/Unity-Skinned-Mesh/" class="post-title-link" itemprop="url">Skinned Mesh原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 11:41:53" itemprop="dateCreated datePublished" datetime="2018-03-23T11:41:53+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/23/Unity-Skinned-Mesh/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/23/Unity-Skinned-Mesh/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、3D模型动画基本原理和分类"><a href="#一、3D模型动画基本原理和分类" class="headerlink" title="一、3D模型动画基本原理和分类"></a>一、3D模型动画基本原理和分类</h1><p>3D模型动画的基本原理是让模型中各定点的位置随时间变化。主要种类由Morph动画，关节动画和骨骼蒙皮动画(Skinned Mesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。</p>
<p>Morph(渐变，变形)动画是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。</p>
<p>关节动画的模型不是一个整体的Mesh，而是分成很多部分(Mesh),通过一个父子层级结构将这些分散的Mesh组织在一起，父Mesh带动其子Mesh运动，各mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。动画帧中设置各子Mesh相对于Mesh的变化（主要是旋转，当然也可以包括移动和缩放），通过子到父，一级级的变化累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。关节动画的问题是，各部分Mesh中的顶点时固定在其Mesh坐标系中的，这样在两个mesh结合处就可能产生裂缝。</p>
<p>第三类就是骨骼蒙皮动画即Skinned Mesh了，骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。</p>
<h1 id="二、Skinned-Mesh-原理和结构分析"><a href="#二、Skinned-Mesh-原理和结构分析" class="headerlink" title="二、Skinned Mesh 原理和结构分析"></a>二、Skinned Mesh 原理和结构分析</h1><p>Skinned Mesh中文一般乘坐骨骼蒙皮动画，这种动画包含骨骼(Bone)和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同：关节动画中时使用多个分散的Mesh,而Skinned Mesh中的Mesh是一个整体，也就是说只有一个mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了，Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图，而是mesh本身，蒙皮是将mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样的关节处的顶点由于同时收到了父子骨骼的拉扯而改变位置就消除了裂缝。</p>
<h2 id="1-理解骨骼和骨骼层次结构-Bone-Hierarchy"><a href="#1-理解骨骼和骨骼层次结构-Bone-Hierarchy" class="headerlink" title="1.理解骨骼和骨骼层次结构(Bone Hierarchy)"></a>1.理解骨骼和骨骼层次结构(Bone Hierarchy)</h2><p>首先要明确一个观念：骨骼决定了模型整体在世界坐标系中的位置和朝向。<br>先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。在渲染静态模型时，由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换就可以进行渲染。而对于骨骼动画，设置模型的位置和朝向，实际实在设置根骨骼的位置和朝向，然后根据骨骼层级结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼堆Mesh中顶点的绑定计算出顶点在世界坐标系中的坐标，从而堆顶点进行渲染，要记住，在骨骼动画中，骨骼才是模型主题，Mesh不过是一层皮，一件衣服。<br>如何理解骨骼？请看第二个管娘：骨骼可理解为一个坐标空间。<br>在一些文章中往往会提到关节和骨骼，那么关节是什么？骨骼有事什么？下图是一个手臂的骨骼层次的实例。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Skinned-Mesh-1.png"><br>骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的远点。关节的位置由它在父骨骼坐标空间中描述，上图中由三块骨骼，分别是手臂，前臂和两个手指。Clavicle(骨锁)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的远点。关节既决定了骨骼空间的位置，旋转和缩放分量决定了骨骼空间的旋转和缩放。我们来看前臂这个骨骼，其原点位置位于上臂上某处的，对于上臂来说，它知道自己的坐标空间某处(即肘关节所在的位置)有一个子空间，那就是前臂，至于前臂里面是啥就不考虑了。当前臂绕肘关节旋转时，实际是前臂坐标空间在旋转，从而其中包含的子空间也在绕肘关节旋转，这个例子中是finger骨骼。和实际生物骨骼不同的是，我们这里的骨骼并没有实质的骨头，所以前臂旋转时，他自己没啥可转的，改变的只是坐标空间的朝向。你可以说上图蓝线在转，但实际蓝线并不存在，蓝线只是画上去表示骨骼之间关系的，真正转的是骨骼空间，我们能看到在转的是wrist joint,也就是两个finger骨骼的坐标空间，因为他们是子空间，会跟随父空间运动，就好比跟着地球转一样。</p>
<p>骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点再其父空间中的位置，绕关节旋转是指骨骼坐标空间(包括所有子空间)自身的旋转。但还有两个可能的疑问，一是骨骼的长度，由于骨骼是坐标空间没有所谓的长度和宽度限制，我们看到的长度一方面是蒙皮后的结果，而另一方面子骨骼的原点(也就是关节)的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。第二个问题，实际上我们的例子中手指没有子骨骼，所以那个端点并不存在，那是为了方便演示画上去的。实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点了。对了，那么手指的长度如何确定？我们看到的长度应该是手指部分的顶点和蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。</p>
<p>经过一段长篇大论，我们终于弄清楚骨骼和骨骼层次结构了，但是为什么要将骨骼组织成层次结构呢？答案是为了做动画方便，设想如果只有一块骨骼，那么让他动起来太简单了，动画每一帧直接指定他的位置即可，如果是n块呢？通过组成一个层次结构，就可以通过父骨骼控制子骨骼的运动，牵一发而动全身，改变某骨骼时并不需要设置其子骨骼的位置，子骨骼的位置会通过计算自动得到，上问已经说过，父子骨骼之间的关系可以理解为，子骨骼位于父骨骼的坐标系中，我们知道物体在坐标系中可以平移变换，以及自身的旋转和缩放。子骨骼在父骨骼的坐标系中也可以做这些变换来改变自己在其父骨骼坐标系中的位置和朝向等，那么如何表示呢？由于4x4矩阵可以同时表示上述三种变换，所以一般描述骨骼在其父骨骼坐标系时使用一个举证，也就是DirectX SkinnedMesh中的FramrTrnsformMatrix。实际上这不是唯一的方法，但应该是公认的方法因为矩阵不光可以同时表示多种变换还可以方便的通过连乘进行变换的组合，这在层次结构中非常方便。在本文的例子-最简单的skinned mesh示例中，我只演示了评议变换，所以只用一个3d坐标就可以表示子骨骼在父骨骼的位置。下面是Bone Class最初的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//这个坐标是定义在父骨骼坐标系中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时增加了一组坐标，存放计算好的世界坐标系。<br>将各个骨骼相关于相对于父骨骼摆放好，就形成了一个骨骼层次结构的初始坐标，所谓初始是指定义骨骼层次时，后来动画改变了骨骼的相对位置，准确的说一般是改变了骨骼自身的旋转而位置保持不变。</p>
<p>假设我们通过某种方法建立了骨骼层次结构，那么每一块骨骼的位置都依赖于其父骨骼的位置，而跟骨骼没有父，他的位置就是整个骨骼体系在世界坐标系中的位置。可以认为root的父就是世界坐标系。但是初始位置时，跟骨骼一般不是世界原点的，比如使用3d max character studio创建的biped骨架时，一般两脚之间时世界原点，而根骨骼-骨盆位于原点上方(+z轴上)。这有什么关系呢，其实也没什么大不了的，只是我们在指定骨骼动画模型整体坐标时，比如设定坐标(0,0,0),则根骨骼-骨盆被置于世界原点，假如xy平面时地面，那么人下个身子到地面下了。我们想让两脚之间算作人的原点，这样设定(0,0,0)的坐标时人就站在地面上了，所以可以在两脚之间设定一个额外的根骨骼放到世界原点上，或者这个骨骼并不需要真实存在，只是在你的骨骼模型结构中保存骨盆骨骼到世界原点的变换矩阵。在微软X文件中，一般有一个Scene_Root节点，这算一个额外的骨骼吧，他的变换矩阵为单位阵，表示他初始位于世界原点，而真正骨骼的跟Bip01,作为Scene_root的子骨骼，其变换矩阵表示相对于root的位置。说这么多其实我只是像解释下，为什么要存在Scenen_Root这种额外的骨骼，以及加深理解骨骼定位骨骼动画模型整体的世界坐标的作用。</p>
<p>有了骨骼类，现在让我们看一下建立骨骼层次的代码，在bone class中增加一个构造函数和两个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bone(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z): m_pSibling(<span class="literal">NULL</span>),m_pFirstChild(<span class="literal">NULL</span>),m_pFather(<span class="literal">NULL</span>),</span><br><span class="line">    m_x(x),m_y(y),m_z(z)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFirstChild</span><span class="params">(Bone *pChild)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_pFirstChild = pChild;</span><br><span class="line">        m_pFirstChild-&gt;m_pFather = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSibling</span><span class="params">(Bone *pSibling)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_pSibling = pSibling;</span><br><span class="line">        m_pSibling-&gt;m_pFather = m_pFather;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我增加了一个成员变量，Bone* m_pFather,这是指向父骨骼的指针，在这个例子中计算骨骼动画时本不需要这个指针，但我为了画一条从父骨骼关节到子骨骼关节的连线，增加了它，因为每个骨骼只有第一子骨骼的指针，绘制父骨骼时从父到子画线就只能画一条，所以记录每个骨骼的父，在胡子hi子骨骼时画这根线。</p>
<p>有了这个函数，就可以创建骨骼层次了，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bone * g_boneRoot;</span><br><span class="line">Bone * g_bone1, *g_bone32, *g_bone22;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildBones</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_boneRoot = <span class="keyword">new</span> Bone(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone1 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone21 = <span class="keyword">new</span> Bone(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone22 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>, <span class="number">0.0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    g_boneRoot-&gt;SetFirstChild(g_bone1);</span><br><span class="line">    gbone1-&gt;SetFirstChild(g_bone21);</span><br><span class="line">    g_bone21-&gt;SetSibling(g_bone22);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是骨骼层次中最核心的部分，更新骨骼！由于动画的作用，某个骨骼的变化(TransformMatrix)变了，这时就要根据新的变化来计算，所以这个过程一般乘坐UpdateBoneMatrix。因为骨骼的变化都是相对父的，要变换顶点必须使用世界变换矩阵，所以这个过程根据更新了某些骨骼的骨骼变换矩阵(TransformMatrix)计算出所有骨骼的世界变换矩阵(CombinedMatrix)。在本文的例子中，骨骼只能平移，甚至我们没有用矩阵，所以当有骨骼变动时要做的只是直接计算骨骼的世界坐标，因此函数命名为ComputeWorldPos,相当于UpdateBoneMatrix后再用顶点相乘CombinedMatrix。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//give father's world pos, compute the bone's world pos</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPos</span><span class="params">(<span class="keyword">float</span> fatherWX, <span class="keyword">float</span> fatherWY, <span class="keyword">float</span> WZ)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_wx = fatherWX + m_x;</span><br><span class="line">        m_wy = fatherWY + m_y;</span><br><span class="line">        m_wz = fatherWZ + m_z;</span><br><span class="line">        <span class="keyword">if</span> (m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">            m_pSibling-&gt;ComputeWorldPos(fatherWX, fatherWY, fatherWZ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pFirstChild != <span class="literal">NULL</span>)</span><br><span class="line">            m_pFirstChild-&gt;ComputreWorldPos(m_wx, m_wy, m_wz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的递归调用使用了微软例子的思想。</p>
<p>有了上述函数，当某骨骼运动时就可以让其子骨骼跟随运动了，但是怎么让骨骼运动呢？这就是动画问题了，我不打算在这个简单的例子中使用关键帧动画，而只是通过程序每帧改变某些骨骼的位置，DEMO中的animateBones就是做这个的，你可以在里面改变不同的骨骼看看效果。在本文下面会对骨骼的关键帧动画做简单的讨论。</p>
<h2 id="2-蒙皮信息和蒙皮过程"><a href="#2-蒙皮信息和蒙皮过程" class="headerlink" title="2.蒙皮信息和蒙皮过程"></a>2.蒙皮信息和蒙皮过程</h2><h3 id="2-1-Skin-info的定义"><a href="#2-1-Skin-info的定义" class="headerlink" title="2-1 Skin info的定义"></a>2-1 Skin info的定义</h3><p>上文曾讨论过，Skinned Mesh中Mesh时作为皮肤使用，蒙在骨骼之上的。为了让普通的Mesh具有蒙皮的功能，必须添加蒙皮信息，即Skin info。我们知道mesh是由顶点构成的，建模时顶点是定义在模型自身坐标系的，即相对于Mesh原点的，而骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标，这就要将顶点和骨骼联系起来，Skin info正是起了这个作用。下面是DEMO中顶点类的定义的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BONE_PER_VERTEX 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//local pos in mesh space</span></span><br><span class="line">    <span class="keyword">float</span> m_wX, m_wY, m_wZ; <span class="comment">// blended vertex pos, in world space</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// skin info</span></span><br><span class="line">    <span class="keyword">int</span> m_boneNum;</span><br><span class="line">    Bone * m_bones[MAX_BONE_PER_VERTEX];</span><br><span class="line">    <span class="keyword">float</span> m_boneWeights[MAX_BONE_PER_VERTEX];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶点的Skin info包含影响该顶点的骨骼数目，只想这些骨骼的指针，这些骨骼作用于该顶点的权重(Skin weight)。由于只是一个简单的例子，这儿没有考虑优化，所以用静态数组存放骨骼指针和权重，且实际引擎中Skin info的定义方式不一定是这样的，但基本原理一致。</p>
<p>MAX_BONE_PER_VERTEX在这儿用来设置可同时影响顶点的最大骨骼数，实际上由于这个DEMO是手工进行Vertex Blending并且没有硬件加速，以及为了确保速度，一般会定义最大骨骼数。另外在本Demo中，Skin info是手工设定的，而实际项目中，一般是在建模软件中生成这些信息并导出。</p>
<p>Skin info 的作用是使用各个骨骼的变换矩阵对顶点进行变换并乘以权重，这样某块骨骼只能对该顶点产生部分影响。各骨骼权重之和应该为1.</p>
<p>Skin info是针对顶点的，然后在使用Skin info前我们必须要使用Bone Offset Matrix对顶点进行变换，下面具体讨论Bone offset Matrix。（写下这句话的时候我感觉不妥，因为实际是先将所有的矩阵相乘最后在用作顶点，这儿是按照理论上的顺序进行讲述吧，请不要与实际情况混肴，其实他们也并不矛盾。而且在我们的DEMO中由于没有使用矩阵，所以变换的顺序和理论顺序是一致的）</p>
<h3 id="2-2-Bone-Offset-Matrix的含义和计算方法"><a href="#2-2-Bone-Offset-Matrix的含义和计算方法" class="headerlink" title="2-2 Bone Offset Matrix的含义和计算方法"></a>2-2 Bone Offset Matrix的含义和计算方法</h3><p>上文已经说过：“骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标”，现在让我们看下顶点受一块骨骼的作用的坐标变换过程：<br>    mesh vertex(defined in mesh space)——&gt;Bone space——&gt;world<br>从这个过程中可以看出，需要首先将模型顶点从模型空间变换到某块骨骼自身的骨骼空间，然后才能利用骨骼的世界变换计算顶点的世界坐标。Bone Offset Matrix的作用正是将模型从顶点空间变换到骨骼空间。那么Bone Offset Matrix如何得到呢？下面具体分析：</p>
<p>Mesh space是建模时使用的空间，mesh中顶点的位置相对于这个空间的原点定义。比如在3dmax中建模时(视xy平面为地面，+z朝上)，可将模型两脚之间的中点作为Mesh空间的原点，并将其放置在世界原点，这样左脚上某一顶点坐标是(10,10,2),右脚上堆成的一点坐标是(-10,10,2)，头顶的坐标是(0,0,170)。由于此时Mesh空间和世界空间重合，上述坐标即在Mesh空间也是世界空间，换句话说，此时实际是以世界空间作为Mesh空间了。在骨骼动画中，在世界中放置的是骨骼而不是Mesh，所以这个区别并不重要。在3d max中添加骨骼的时候，也是将骨骼放入世界空间中，并调整骨骼的相对位置是得和mesh相吻合（即设置骨骼的TransformMatrix),得到股价的初始姿势以及相应的Transform Matrix(按惯例模型做成两臂侧平举直立，骨骼也要适合这个姿态)。由于骨骼的Transform Matrix(作用是将顶点从骨骼空间变换到上层空间)是基于其父骨骼空间的，只有根骨骼的Transform是基于世界空间的，所以要通过自下而上一层层Tranform变换(如果使用行向量右乘矩阵，这个Transform的累计过程就是C=MboneMfatherMgrandpar..Mroot),得到该骨骼在世界空间上的变换矩阵-Combined Transform Matrix,即通过这个矩阵可将该顶点从骨骼空间变换到世界空间。那么这个矩阵的逆矩阵就可以将世界空间中的顶点变换到某块骨骼的骨骼空间。由于Mesh实际上就是定义在世界空间了，所以这个逆矩阵就是Offset Matrix。即OffsetMatrix就是骨骼在初始位置（没有经过任何动画改变）时将bone变换到世界空间的矩阵(CombinedTransformMatrix)的逆矩阵，有一些资料称之为InverseMatrix。在几何流水线中，是通过变换矩阵将顶点变换到上层空间，最终得到世界坐标，逆矩阵则作相反的事，所以Inverse这种提法也符合惯例。那么Offset这种提法从字面上怎么理解呢？Offset即骨骼相对世界原点的偏移，世界原点加上这个偏移就变成骨骼空间的原点，同样定义在世界空间中的点经过这个偏移矩阵的作用也被变换成骨骼空间了。从另一角度理解，在动画中模型中顶点的位置是根据骨骼位置动态计算的，也就是说顶点跟着骨骼动，但首先必须确定顶点和骨骼之间的相对位置（即顶点在该骨骼坐标系中的位置），一个骨骼可能对应很多顶点，如果要保存这个相对位置每个顶点对于每块受控制的骨骼都要保存，这样就要保存太多的矩阵了。。所以只保存mesh空间到骨骼空间的变换（即OffsetMatrix),然后通过这个变换计算每个顶点在该骨骼空间中的坐标，所以OffsetMatrix也反应了mesh和每块骨骼的相对位置，只是这个位置是间接的通过和世界坐标空间的关系表达的，在初始位置将骨骼按照模型的形状摆好的关键之处。</p>
<p>以上的分析是通过mesh space和world space重合得到Offset Matrix的计算方法。那么如果他们不重合呢？那就要先计算顶点从mesh space变换到world space的变换矩阵，并乘上（还是右乘为例）Combined Matrix的Inverse Matrix从而得到Offset Matrix。但是这不是找麻烦吗，因为Mesh的原点在哪里并不重要，为啥不让他们重合呢？</p>
<p>还有一个问题是，既然Offset Matrix可以计算出来，为啥还要在骨骼动画文件中同时提供TransformMatrix和OffsetMatrix呢？实际上文件中确实可以不提供OffsetMatrix,而只在载入时计算，但TransformMatrix不可缺少，动画关键帧数据一般只存储骨骼的旋转和跟骨骼的位置，骨骼见的相对位置还是要靠TransformMatrix提供。在微软的X文件结构中提供了OffsetMatrix,原因是什么呢？我不知道。我猜想一个可能的原因是为了兼容性和灵活性，比如mesh并没有定义在世界坐标系，而是作为一个object放置在3d max中，在导出骨骼动画时不能简单的认为mesh的顶点坐标时相对于世界远点的，还要把这个object的位置考虑进去，于是导出插件要计算OffsetMatrix并保存在x文件中以避免兼容性问题。</p>
<p>关于OffsetMatrix和TransformMatrix含有评议，旋转和缩放的讨论：</p>
<p>首先，OffsetMatrix取决于骨骼的初始位置(即TransformMatrix),由于骨骼动画中我们使用的动画中的位置，初始位置时什么样并不重要，所以可以在初始位置中包含平移，而旋转和缩放在动画中设置(一般也仅仅使用旋转，这也是为啥动画通常中可以用一个四元数表示骨骼的关键帧)。在这种情况下，OffsetMatrix只包含平移即可。因此一些引擎的Bone中不存放Transform矩阵，而只存放骨骼在父骨骼空间的坐标，然后旋转只在动画帧中设置，最基本的骨骼动画即可实现。但也可在Transform和Offset Matrix中包括旋转和缩放，这样可以提供创建动画时的容错性。</p>
<p>在本文的DEMO中，我们也没有使用矩阵保存Bone Offset，而只用了一个坐标保存偏移位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoneOffset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m_offx, m_offy, m_offz;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Bone class中，有一个方法用来计算Bone Offset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BoneOffset m_boneOffset;</span><br><span class="line">    <span class="comment">//called after ComputeWorldPos() when bone loaded but not animated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeBoneOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_boneOffset.m_offx = -m_wx;</span><br><span class="line">        m_boneOffset.m_offy = -m_wy;</span><br><span class="line">        m_boneOffset.m_offz = -m_wz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">            m_pSibing-&gt;ComputeBoneOffset();</span><br><span class="line">        <span class="keyword">if</span> (m_pFirstChild != <span class="literal">NULL</span>)</span><br><span class="line">            m_pFirstChild-&gt;ComputeBoneOffset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在ComputeBoneOffset()中，使用计算好的骨骼的世界坐标来计算bone offset,这儿的计算只是取一个负数，在实际引擎中，如果bone offset是一个矩阵，这儿就应该是求逆矩阵，其实由于旋转矩阵是正交的，只要求出旋转矩阵的转置矩阵。注意由于我们计算Bone offset时是使用计算好的世界坐标，所以在这之前必须在初始位置时对根骨骼调用ComputeWorldPos()以计算出各个骨骼在初始位置时的世界坐标。</p>
<h3 id="2-3-最终：顶点混合-vertex-blending"><a href="#2-3-最终：顶点混合-vertex-blending" class="headerlink" title="2-3 最终：顶点混合(vertex blending)"></a>2-3 最终：顶点混合(vertex blending)</h3><p>现在我们有了Skin info,有了Bone Offset。现在开始做顶点混合，这是骨骼动画的精髓所在，正是这个技术消除了关节处的裂缝。顶点混合后得到了顶点新的世界坐标，对所有的顶点执行vertex blending后，从Mesh的角度看，Mesh deform(变形)了，变成动画需要的形状了。</p>
<p>首先，让我们看看使用单块骨骼对顶点进行作用的过程以下是DEMO中的相关代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputerWorldPosByBone</span><span class="params">(Bone *pBone, <span class="keyword">float</span> &amp;outx, <span class="keyword">float</span> &amp;outY, <span class="keyword">float</span> &amp;outZ)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">//step1: transform vertex from mesh space to bone space</span></span><br><span class="line">        outX = m_x + pBone-&gt;m_boneOffset.m_offx;</span><br><span class="line">        outY = m_y + pBone-&gt;m_boneOffset.m_offy;</span><br><span class="line">        outZ = m_z + pBone-&gt;m_boneOffset.m_offz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step2: transform vertex bone space to world space</span></span><br><span class="line">        outX += pBone-&gt;m_wx;</span><br><span class="line">        outY += pBone-&gt;m_wy;</span><br><span class="line">        outZ += pBone-&gt;m_wz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个函数使用一块骨骼对顶点进行变换，将顶点Mesh坐标系变换到世界坐标系，这儿使用了骨骼的Bone Offset Matrix和Combined Transform Matrix</p>
<p>对于多块骨骼，对每块骨骼执行这个过程并将结果根据权重混合(即vertex blending)就得到顶点最终的世界坐标。进行vertex blending的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlendVertex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">//do the vertex blending,get the vertex's pos in world space</span></span><br><span class="line">        m_wX = <span class="number">0</span>;</span><br><span class="line">        m_wY = <span class="number">0</span>;</span><br><span class="line">        m_wZ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_boneNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> tx, ty, tz;</span><br><span class="line">            ComputeWorldPosByBone(m_bones[i], tx, ty, tz);</span><br><span class="line">            tx *= m_boneWeights[i];</span><br><span class="line">            ty *= m_boneWeights[i];</span><br><span class="line">            tz *= m_boneWeights[i];</span><br><span class="line"></span><br><span class="line">            m_wX += tx;</span><br><span class="line">            m_wY += ty;</span><br><span class="line">            m_wZ += tz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些函数我都放在Vertex类中了，因为只是一个简单DEMO所以没有特别考虑类结构问题，在BlendVertex()中，遍历影响该顶点的所有骨骼，用每块骨骼计算出顶点的世界坐标，然后使用Skin Weight对这些坐标进行加权平均。tx,ty,tz是某块骨骼作用后顶点的世界坐标乘以权重后的值，这些值相加后就是最终的世界坐标了。</p>
<p>现在让我们用一个工时回顾以下Vertex blending的整个过程(使用矩阵变换)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vworld = Vmesh * BoneOffsetMatrix1 * CombindMatrix1 * Weight1</span><br><span class="line">+ Vmesh* BoneOffsetMatrix2 * CombineMatrix2*Wright2</span><br><span class="line">+ ...</span><br><span class="line">+ Vmesh * BoneOffsetMatrixn * CombindMatrixN * WeightN</span><br></pre></td></tr></table></figure>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>从结构上看，SkinnedMesh包括：动画数据，骨骼数据，包括Skin info的Mesh数据，以及Bone Offset Matrix。</p>
<p>从过程上看，载入阶段：载入并建立骨骼层次结构，计算或载入Bone Offset Matrix,载入Mesh数据和Skin info(具体的实现不同的引擎可能都不一样)。运行阶段：根据时间从动画数据中获取骨骼当前时刻的Transfrom Matrix，调用UpdateBoneMatrix计算出各骨骼的CombineMatrix,对于每个顶点根据Skin info进行Vertex Blending计算出顶点的世界坐标，最终进行模型的渲染。</p>
<h1 id="三、关于本文的例子"><a href="#三、关于本文的例子" class="headerlink" title="三、关于本文的例子"></a>三、关于本文的例子</h1><p>这个例子做了尽可能的简化，只包含一个cpp文件，使用OpenGL和GLUT作为渲染器和框架，仅有400多行代码。例子中手工创建了一个骨骼层次和Mesh，手工设置Skin info并自动计算BoneOffset,使用程序控制骨骼平移演示了骨骼层次的运动和骨骼影响下Mesh顶点的运动，例子中甚至没有使用矩阵。本例子仅作理解骨骼动画只用。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Skinned-Mesh-2.png"><br>截图中绿色网格是模型原始形状，蓝色是骨骼，红色是动画时模型形状，DEMO中左数第二个骨骼做上下运动，最下方的骨骼做x方向平移。DEMO没有使用旋转，而实际的骨骼动画中往往没有平移只有旋转的，因为胳膊只能转不能边长，但原理一致。<br>(这个公式使用的是行向量左乘矩阵)<br>由于BoneOffsetMatrix和Combined Matrix都是矩阵，可以先相乘这样就减少了很多计算了，在实际游戏中可以VS进行硬件加速计算。<br>代码的执行过程为，初始化时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">buildBones();<span class="comment">//创建骨骼层次</span></span><br><span class="line">buildMesh();<span class="comment">//创建mesh,设置skin info，计算bone offset </span></span><br><span class="line">```	</span><br><span class="line">每帧运行时：</span><br><span class="line">```C++</span><br><span class="line"><span class="comment">//draw original mesh</span></span><br><span class="line">g_mesh-&gt;DrawStaticMesh(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//move bones</span></span><br><span class="line">animateBones();</span><br><span class="line"></span><br><span class="line"><span class="comment">//update all bone's pos in bone tree</span></span><br><span class="line">g_boneRoot-&gt;ComputeWorldPos(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//update vertex pos by bones,using vertex blending</span></span><br><span class="line">g_mesh-&gt;UpdateVertices();</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw deformed mesh</span></span><br><span class="line">g_mesh-&gt;Draw();</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw bone</span></span><br><span class="line">g_boneRoot-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<p>为保证文本的完整性，下面贴出所有代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simplest Skinned Mesh demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoneOffset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//BoneOffset transform a vertex from mesh space to bone space.</span></span><br><span class="line">    <span class="comment">//In other words, it is the offset from mesh space to a bone's space.</span></span><br><span class="line">    <span class="comment">//For each bone, there is a BoneOffest.</span></span><br><span class="line">    <span class="comment">//If we add the offset to the vertex's pos (in mesh space), we get the vertex's pos in bone space</span></span><br><span class="line">    <span class="comment">//For example: if a vertex's pos in mesh space is (100,0,0), the bone offset is (-20,0,0), so the vertex's pos in bone space is (80,0,0)</span></span><br><span class="line">    <span class="comment">//Actually, BoneOffset is the invert transform of that we place a bone in mesh space, that is (-20,0,0) means the bone is at (20,0,0) in mesh space</span></span><br><span class="line">    <span class="keyword">float</span> m_offx , m_offy , m_offz ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Bone () &#123;&#125;</span><br><span class="line">    Bone ( <span class="keyword">float</span> x , <span class="keyword">float</span> y , <span class="keyword">float</span> z ):m_pSibling (<span class="literal">NULL</span> ),m_pFirstChild (<span class="literal">NULL</span> ),m_pFather (<span class="literal">NULL</span> ),m_x (x ),m_y (y ),m_z (z )&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~Bone () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Bone * m_pSibling ;</span><br><span class="line">    Bone * m_pFirstChild ;</span><br><span class="line">    Bone * m_pFather ; <span class="comment">//only for draw bone</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFirstChild</span> <span class="params">(Bone * pChild )</span> </span>&#123; m_pFirstChild = pChild ; m_pFirstChild -&gt;m_pFather = <span class="keyword">this</span> ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSibling</span> <span class="params">(Bone * pSibling )</span> </span>&#123; m_pSibling = pSibling ; m_pSibling -&gt;m_pFather = m_pFather ; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> m_x , m_y , m_z ; <span class="comment">//pos in its parent's space</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> m_wx , m_wy , m_wz ; <span class="comment">//pos in world space</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//give father's world pos, compute the bone's world pos</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPos</span> <span class="params">( <span class="keyword">float</span> fatherWX , <span class="keyword">float</span> fatherWY , <span class="keyword">float</span> fatherWZ )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       m_wx = fatherWX +m_x ;</span><br><span class="line">       m_wy = fatherWY +m_y ;</span><br><span class="line">       m_wz = fatherWZ +m_z ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;ComputeWorldPos (fatherWX , fatherWY , fatherWZ );</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;ComputeWorldPos (m_wx , m_wy , m_wz );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BoneOffset m_boneOffset ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//called after compute world pos when bone loaded but not animated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeBoneOffset</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       m_boneOffset .m_offx = -m_wx ;</span><br><span class="line">       m_boneOffset .m_offy = -m_wy ;</span><br><span class="line">       m_boneOffset .m_offz = -m_wz ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;ComputeBoneOffset ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;ComputeBoneOffset ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">0</span>,<span class="number">0</span>,<span class="number">1.0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       glVertex3f (m_wx ,m_wy ,m_wz );</span><br><span class="line">       glEnd ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFather !=<span class="literal">NULL</span> )</span><br><span class="line">       &#123;</span><br><span class="line">           glBegin (GL_LINES );</span><br><span class="line">              glVertex3f (m_pFather -&gt;m_wx ,m_pFather -&gt;m_wy ,m_pFather -&gt;m_wz );</span><br><span class="line">              glVertex3f (m_wx ,m_wy ,m_wz );</span><br><span class="line">           glEnd ();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;Draw ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BONE_PER_VERTEX 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Vertex ():m_boneNum (<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPosByBone</span> <span class="params">(Bone * pBone , <span class="keyword">float</span> &amp; outX , <span class="keyword">float</span> &amp; outY , <span class="keyword">float</span> &amp; outZ )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//step1: transform vertex from mesh space to bone space</span></span><br><span class="line">       outX = m_x +pBone -&gt;m_boneOffset .m_offx ;</span><br><span class="line">       outY = m_y +pBone -&gt;m_boneOffset .m_offy ;</span><br><span class="line">       outZ = m_z +pBone -&gt;m_boneOffset .m_offz ;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//step2: transform vertex from bone space to world sapce</span></span><br><span class="line">       outX += pBone -&gt;m_wx ;</span><br><span class="line">       outY += pBone -&gt;m_wy ;</span><br><span class="line">       outZ += pBone -&gt;m_wz ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlendVertex</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//do the vertex blending,get the vertex's pos in world space</span></span><br><span class="line"></span><br><span class="line">       m_wX = <span class="number">0</span>;</span><br><span class="line">       m_wY = <span class="number">0</span>;</span><br><span class="line">       m_wZ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_boneNum ; ++i )        </span><br><span class="line">       &#123;            </span><br><span class="line">       		<span class="keyword">float</span> tx , ty , tz ;            </span><br><span class="line">       		ComputeWorldPosByBone (m_bones [i ], tx , ty , tz );            </span><br><span class="line">       		tx *= m_boneWeights [i ];            </span><br><span class="line">       		ty *= m_boneWeights [i ];            </span><br><span class="line">       		tz *= m_boneWeights [i ];            </span><br><span class="line">       		m_wX += tx ;            </span><br><span class="line">       		m_wY += ty ;            </span><br><span class="line">       		m_wZ += tz ;        </span><br><span class="line">       	&#125;     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">float</span> m_x , m_y , m_z ; </span><br><span class="line">    <span class="comment">//local pos in mesh space     </span></span><br><span class="line">    <span class="keyword">float</span> m_wX , m_wY , m_wZ ; </span><br><span class="line">    <span class="comment">//blended vertex pos, in world space     </span></span><br><span class="line">    <span class="comment">//skin info     </span></span><br><span class="line">    <span class="keyword">int</span> m_boneNum ;     </span><br><span class="line">    Bone * m_bones [MAX_BONE_PER_VERTEX ];     </span><br><span class="line">    <span class="keyword">float</span> m_boneWeights [MAX_BONE_PER_VERTEX ];     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBoneAndWeight</span> <span class="params">( <span class="keyword">int</span> index , Bone * pBone , <span class="keyword">float</span> weight )</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">    	m_bones [index ] = pBone ;        </span><br><span class="line">    	m_boneWeights [index ] = weight ;     </span><br><span class="line">   	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//----------------------------------------------------------- </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkinMesh</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span> :     </span><br><span class="line">    SkinMesh ():m_vertexNum (<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    SkinMesh ( <span class="keyword">int</span> vertexNum ):m_vertexNum (vertexNum )     </span><br><span class="line">    &#123;        </span><br><span class="line">        m_vertexs = <span class="keyword">new</span> Vertex [vertexNum ];     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    ~SkinMesh ()     </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span> (m_vertexNum &gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">delete</span> [] m_vertexs ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateVertices</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">       &#123;</span><br><span class="line">           m_vertexs [i ].BlendVertex ();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawStaticMesh</span> <span class="params">( <span class="keyword">float</span> x , <span class="keyword">float</span> y , <span class="keyword">float</span> z )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">0</span>,<span class="number">1.0</span>,<span class="number">0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z );</span><br><span class="line">       glEnd ();</span><br><span class="line"></span><br><span class="line">       glBegin (GL_LINE_LOOP );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z );</span><br><span class="line">       glEnd ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">1.0</span>,<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ );</span><br><span class="line">       glEnd ();</span><br><span class="line"></span><br><span class="line">       glBegin (GL_LINE_LOOP );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )            glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ );        glEnd ();     &#125;     <span class="keyword">int</span> m_vertexNum ;     Vertex * m_vertexs ; <span class="comment">//array of vertices in mesh &#125;; //-------------------------------------------------------------- Bone * g_boneRoot ; Bone * g_bone1 , *g_bone2 , *g_bone31 , *g_bone32 ; void buildBones () &#123;     g_boneRoot = new Bone (0, 0, 0);     g_bone1 = new Bone (0.2, 0, 0);     g_bone2 = new Bone (0.2, 0, 0);     g_bone31 = new Bone (0.2, 0.1, 0);     g_bone32 = new Bone (0.2, -0.1, 0);     g_boneRoot -&gt;SetFirstChild (g_bone1 );</span></span><br><span class="line">    g_bone1 -&gt;SetFirstChild (g_bone2 );</span><br><span class="line">    g_bone2 -&gt;SetFirstChild (g_bone31 );</span><br><span class="line">    g_bone31 -&gt;SetSibling (g_bone32 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteBones</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> g_boneRoot ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone1 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone2 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone31 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone32 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateBones</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dir =<span class="number">-1</span>, dir2 =<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//animate bones manually</span></span><br><span class="line"></span><br><span class="line">    g_bone1 -&gt;m_y +=<span class="number">0.00001f</span>*dir ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_bone1 -&gt;m_y m_y &gt;<span class="number">0.2</span>)</span><br><span class="line">       dir *=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g_bone32 -&gt;m_x +=<span class="number">0.00001f</span>*dir2 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_bone32 -&gt;m_x m_x &gt;<span class="number">0.2</span>)</span><br><span class="line">       dir2 *=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SkinMesh * g_mesh ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMesh</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> _meshData []=</span><br><span class="line">    &#123; <span class="comment">//x,y,z</span></span><br><span class="line">       <span class="number">-0.1</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.3</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.45</span>,<span class="number">0.06</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.6</span>,<span class="number">0.15</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.65</span>,<span class="number">0.1</span>,<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">0.65</span>,<span class="number">-0.1</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.6</span>,<span class="number">-0.15</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.45</span>,<span class="number">-0.06</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.3</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.1</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">-0.1</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> _skinInfo []=</span><br><span class="line">    &#123; <span class="comment">//bone_num,bone id(0,1,2,31 or 32), bone weight 1~4,</span></span><br><span class="line">       <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">1</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">2</span>,  <span class="number">31</span>, <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">1</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexNum = <span class="keyword">sizeof</span> (_meshData )/( <span class="keyword">sizeof</span> ( <span class="keyword">float</span> )*<span class="number">3</span>);</span><br><span class="line">    g_mesh = <span class="keyword">new</span> SkinMesh (vertexNum );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i m_vertexs [i ].m_x = _meshData [i *<span class="number">3</span>];</span><br><span class="line">       g_mesh -&gt;m_vertexs [i ].m_y = _meshData [i *<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line">       g_mesh -&gt;m_vertexs [i ].m_z = _meshData [i *<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set skin info</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i m_vertexs [i ].m_boneNum = _skinInfo [i *<span class="number">9</span>];</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> j =<span class="number">0</span>; j &lt;g_mesh -&gt;m_vertexs [i ].m_boneNum ; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           Bone * pBone = g_boneRoot ;</span><br><span class="line">           <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">1</span>)</span><br><span class="line">              pBone = g_bone1 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">2</span>)</span><br><span class="line">              pBone = g_bone2 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">31</span>)</span><br><span class="line">              pBone = g_bone31 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">32</span>)</span><br><span class="line">              pBone = g_bone32 ;</span><br><span class="line"></span><br><span class="line">           g_mesh -&gt;m_vertexs [i ].SetBoneAndWeight (j , pBone , _skinInfo [i *<span class="number">9</span>+<span class="number">5</span>+j ]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compute bone offset</span></span><br><span class="line">    g_boneRoot -&gt;ComputeWorldPos (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    g_boneRoot -&gt;ComputeBoneOffset ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> deleteMesh ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> g_mesh ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myInit ()</span><br><span class="line">&#123;</span><br><span class="line">    buildBones ();</span><br><span class="line">    buildMesh ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myQuit ()</span><br><span class="line">&#123;</span><br><span class="line">    deleteBones ();</span><br><span class="line">    deleteMesh ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myReshape ( <span class="keyword">int</span> width , <span class="keyword">int</span> height )</span><br><span class="line">&#123;</span><br><span class="line">    GLfloat h = (GLfloat ) height / (GLfloat ) width ;</span><br><span class="line"></span><br><span class="line">    glViewport (<span class="number">0</span>, <span class="number">0</span>, (GLint ) width , (GLint ) height );</span><br><span class="line">    glMatrixMode (GL_PROJECTION );</span><br><span class="line">    glLoadIdentity ();</span><br><span class="line"><span class="comment">//  glFrustum(-1.0, 1.0, -h, h, 5.0, 60.0);</span></span><br><span class="line">    glFrustum (<span class="number">-1.0</span>, <span class="number">1.0</span>, -h , h , <span class="number">1.0</span>, <span class="number">100.0</span>);</span><br><span class="line">    glMatrixMode (GL_MODELVIEW );</span><br><span class="line">    glLoadIdentity ();</span><br><span class="line">    glTranslatef (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myDisplay ( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    glClear (GL_COLOR_BUFFER_BIT );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw original mesh</span></span><br><span class="line">    g_mesh -&gt;DrawStaticMesh (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//move bones</span></span><br><span class="line">    animateBones ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update all bone's pos in bone tree</span></span><br><span class="line">    g_boneRoot -&gt;ComputeWorldPos (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update vertex pos by bones, using vertex blending</span></span><br><span class="line">    g_mesh -&gt;UpdateVertices ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw deformed mesh</span></span><br><span class="line">    g_mesh -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw bone</span></span><br><span class="line">    g_boneRoot -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    glFlush ();</span><br><span class="line">    glutSwapBuffers ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myIdle ( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    myDisplay ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main ( <span class="keyword">int</span> argc , <span class="keyword">char</span> *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    glutInit (&amp;argc , argv );</span><br><span class="line">    glutInitDisplayMode (GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE );</span><br><span class="line">    glutInitWindowPosition (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    glutInitWindowSize (<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">    glutCreateWindow ( <span class="string">"A simplest skinned mesh DEMO, by happyfirecn@yahoo.com.cn"</span> );</span><br><span class="line"></span><br><span class="line">    glutDisplayFunc (myDisplay );</span><br><span class="line">    glutReshapeFunc (myReshape );</span><br><span class="line">    glutIdleFunc (myIdle );</span><br><span class="line"></span><br><span class="line">    myInit ();</span><br><span class="line">    glutMainLoop ();</span><br><span class="line">    myQuit ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/23/actor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/actor/" class="post-title-link" itemprop="url">Actor模型原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 10:36:48" itemprop="dateCreated datePublished" datetime="2018-03-23T10:36:48+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/23/actor/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/23/actor/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Actor模型"><a href="#1-Actor模型" class="headerlink" title="1.Actor模型"></a>1.Actor模型</h1><p>在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改（通过消息传递来进行状态修改），所以使用Actors模型进行并发编程可以很好避免这些问题，Actor由状态(state),行为(Behavior)和邮箱(mailBox)三部分组成<br>1.状态(state):Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题<br>2.行为(Behavior):行为指的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态<br>3.邮箱(mailBox):邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送发Actor消息，接收方Actor从邮箱队列中获取消息</p>
<p>Actor的基础就是消息传递</p>
<h1 id="2-使用Actor模型的好处"><a href="#2-使用Actor模型的好处" class="headerlink" title="2.使用Actor模型的好处"></a>2.使用Actor模型的好处</h1><p>1.事件驱动—Actor之间的通信是异步的，即使Actor在发送消息后也无需阻塞或者等待就能够处理其他事件<br>2.强隔离性—Actor中的方法不能由外部部署直接调用，所有的一切都通过消息传递进行的，从而避免了Actor之间的数据共享，想要观察到另一个Actor的状态变化只能通过消息传递进行询问<br>3.位置透明—无论Actor地址实在本地还是在远程机上对于代码来说都是一样的<br>4.轻量性—Actor是非常轻量的计算单机，单个Actor仅占400多字节，只需少量内存就能达到高并发</p>
<h1 id="3-Actor模型原理"><a href="#3-Actor模型原理" class="headerlink" title="3.Actor模型原理"></a>3.Actor模型原理</h1><p>以下通过学生于教师之间的邮件通信来理解akka中的Actor模型</p>
<h2 id="学生-教师的消息传递"><a href="#学生-教师的消息传递" class="headerlink" title="学生-教师的消息传递"></a>学生-教师的消息传递</h2><p>首先只考虑学生单向发送消息给教师（学生—》教师），如下图：<br><img src="http://oxcvfpext.bkt.clouddn.com/actor-1.png"><br>图解：<br>1.学生创建一个ActorSystem<br>2.通过ActorSystem创建ActorRef，将QuoteRequest消息发送到ActorRef(教师代理)<br>3.ActorRef(教师代理)消息传到Dispatcher中<br>4.Dispather依次的将消息发送到TeacherActor邮箱中<br>5.Dispather将邮箱推送到一条线程中<br>6.邮箱取出一条消息并委派给TeacherActor的Receiver方法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/22/thread-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/22/thread-process/" class="post-title-link" itemprop="url">简单介绍多进程和多线程服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-22 20:19:23" itemprop="dateCreated datePublished" datetime="2018-03-22T20:19:23+08:00">2018-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/22/thread-process/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/22/thread-process/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="首先贴下多进程单线程和单进程多线程的特点："><a href="#首先贴下多进程单线程和单进程多线程的特点：" class="headerlink" title="首先贴下多进程单线程和单进程多线程的特点："></a>首先贴下多进程单线程和单进程多线程的特点：</h1><p>多进程：有独立的地址空间，进程之间不共享内存和变量，但可以通过共享内存实现，每个进程只有一个线程，一般用于单机系统开发。<br>多线程：在同一个进程下所有线程可以共享内存和变量。<br>而共同点是，同开辟的进程数/线程数多余系统cpu核数时，无法继续提供应用的性能。<br>而多线程架构的服务器，只要适当将一些任务分出来用新的进程启动，就可以扩展成分布式架构，使用tcp通信即可。当然多进程也可以这么干，通信方式也是使用tcp。<br>而操作系统对于线程的切换是比进程的切换要快。</p>
<h1 id="下面先介绍下多进程单线程服务器架构，以单机系统为例："><a href="#下面先介绍下多进程单线程服务器架构，以单机系统为例：" class="headerlink" title="下面先介绍下多进程单线程服务器架构，以单机系统为例："></a>下面先介绍下多进程单线程服务器架构，以单机系统为例：</h1><p>下贴架构图：<br><img src="http://oxcvfpext.bkt.clouddn.com/thread-process-1.png"><br>一个游戏服大概就有这几个进程。<br>router:作用如其名，路由。每个功能进程启动时，会先连接router,router会给连上来的进程分配一个唯一标识，所有功能进程都是靠这个router进程通信。<br>login:登录服务器，client登录验证在这个进程进行。<br>login:玩家单人逻辑操作处理进程，login会将登录的玩家平台到这些logic上。<br>global_login:全局操作进程，多人玩法的功能，例如战斗匹配，工会等操作会放在这里进行。<br>log:游戏日志输出进程，所有功能进程的日志输出都发到这个进程，log进程会输出到磁盘文件。<br>db:redis作为内存数据库，Mysql作为数据持久化，其它功能进程取数据都会发送请求到db。<br>back:后台进程，集成了一个http服务器。处理http请求，这里可以集成一些第三方服务功能，如gm指令。</p>
<p>以上每个进程都是单线程，所以无需考虑锁的问题。<br>对于每个进程收发数据：<br>    发数据：直接把{target_id:data}发送到router<br>    收数据：帧驱动，如100ms主动向router询问是否有数据，有则取过来处理。<br>单机系统下，如果采用共享内存方式，通信效率将非常高。<br>所以多进程的服务器架构设计起来还是比较简单的。</p>
<h1 id="在介绍下多线程服务器架构，这里我想介绍actor模型。"><a href="#在介绍下多线程服务器架构，这里我想介绍actor模型。" class="headerlink" title="在介绍下多线程服务器架构，这里我想介绍actor模型。"></a>在介绍下多线程服务器架构，这里我想介绍actor模型。</h1><p><img src="http://oxcvfpext.bkt.clouddn.com/thread-process-2.png"><br>一个Actor指的是一个最基本的计算单元。它能接收一个消息并且基于其执行计算。<br>这个理念很像面向对象语言，一个对象接受一条消息（方法调用），然后根据接受的消息做事（调用了哪个方法）。<br>Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。<br>每个Actor都有一个邮箱，用于接受其他actor发送的消息。</p>
<p>这里重点讲一下Actor模型的调度是怎样做的。<br>Actor模型实际上可以有成千上万个，但目前一台通用服务器最多只有24核，当然不可能也开成千上万个线程。</p>
<p>我们可以把Actor简单想象成这样一个类实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetch_msg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> actor_id;</span><br><span class="line">        <span class="built_in">string</span> actor_name;</span><br><span class="line">        <span class="built_in">list</span>&lt;msg&gt; msg_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Actor定义了自己实现的功能(process_1,process_2)<br>当msg_queue邮箱有消息到来的时候，就调用fetch_msg取获取这些消息进程处理。<br>这一步就靠调度线程来做了。</p>
<p>Actor模型的调度实现起码要有：<br>    1.一个位于主线程的Actor队列，如global_queue<actor*> gq,当某个Actor收到消息时，就会被放进这个gp，等待工作线程进行调度。<br>    2.n个工作线程，这个就要根据机器的核数来决定开多少个了，例如只是一台双核的机器，那么开一个就好了，开多了会浪费时间在线程切换上，得不尝试。<br>每个工作线程做的事件很简单，向主线程询问任务，获取任务，处理任务，然后又继续询问，大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    task_list = fetch_task();</span><br><span class="line">    process_task(task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></actor*></p>
<p>所以一个Actor的创建和调度过程如下：<br>1.在主线程创建并放入管理列表<br>2.其他actor往本actor发送消息，消息进入msg_queue,本actor进入global_queue等待调度。<br>3.有工作线程处理完一堆任务了，向主线程询问任务，主线程把本actor分配给这个工作线程。<br>4.该工作线程取出msg，调用actor相应处理函数处理这个消息。</p>
<p>所以可见，actor数目于工作线程数目没有必然的关系，当然理想状态是，每个actor都有自己的处理线程，这里有消息来到时，就可以马上处理，不用等待。</p>
<p>理论上，actor开的越多，业务逻辑就分的越细，每次处理的时间就越短，只要actor的数目超过线程数，就可以最大限度利用多核的优势，cpu的调度就越充分。所以actor模型设计关键在于如何将业务逻辑平摊到更多的actor上，而不是集中，例如上面提到global_logic是多人玩法的业务逻辑，只要一细分，可以分成帮会actor,组队actor,战斗actor等等，这样三个消息同时就有机会被三个cpu处理，而不是固定只有一个。</p>
<p>Actor可以理解成用户级别的进程，于操作系统级别的进程分离，即使开很多Actor，只要工作线程数目设计合理（&lt;=系统cpu核数),就能保证线程能一直在同一个cpu上进行操作，减少线程切换的消耗，这对于cpu核数小的机器非常游泳，而对于像24核的机器，因为开辟的线程数是配置的，所以也很好规划一台机器能部署多少个服。<br>而多线程如果要对某些功能进程扩展，如增加login,增加Logic,就是要增加一个系统线程，一旦进程超过cpu核，就会有时间浪费在切换线程上了，这是一个缺点。<br>而Actor模型本身是优秀的，但是Actor的调度算法会有很多中实现，而且必然涉及到锁的涉及，这就需要设计者的设计功力了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/21/JVM-heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/21/JVM-heap/" class="post-title-link" itemprop="url">JVM的新生代、老年代、MinorGC、MajorGC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-21 17:30:17" itemprop="dateCreated datePublished" datetime="2018-03-21T17:30:17+08:00">2018-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/21/JVM-heap/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/21/JVM-heap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JVM中的堆，一般分为三大部分：新生代、老年代、永久代：<br>一、新生代<br>主要时用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁发MinorGC进行垃圾回收。<br>新生代又分为Eden区、ServivorFrom、ServivorTo三个区。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/21/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/21/JVM/" class="post-title-link" itemprop="url">JVM初探：内存分配、GC原理与垃圾收集器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-21 17:21:27" itemprop="dateCreated datePublished" datetime="2018-03-21T17:21:27+08:00">2018-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/21/JVM/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/21/JVM/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JVM内存的分配与回收大致可分为如下4个步骤：何时分配-》怎样分配-》何时回收-》怎样回收，除了在概念上可简单认为new时分配外，我们着重介绍后面三个步骤</p>
<h1 id="1-怎样分配-》JVM内存分配策略"><a href="#1-怎样分配-》JVM内存分配策略" class="headerlink" title="1.怎样分配-》JVM内存分配策略"></a>1.怎样分配-》JVM内存分配策略</h1><p>对象内存主要分配在Eden区，如果启用了本地线程分配缓存，则有限在TLAB上分配，少数情况能会直接分配在老年代，或被拆分成标量类型在栈上分配（JIT优化）。分配的规则并不是百分百固定，细节主要取决于垃圾收集器组合，以及VM内存相关的参数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/21/String-StringBuffer-StringBuilder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/21/String-StringBuffer-StringBuilder/" class="post-title-link" itemprop="url">String-StringBuffer-StringBuilder</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-21 17:02:30" itemprop="dateCreated datePublished" datetime="2018-03-21T17:02:30+08:00">2018-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/21/String-StringBuffer-StringBuilder/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/21/String-StringBuffer-StringBuilder/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>String 字符串常量<br>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）<br>String类型和StringBuffer类型的主要性能区别其实在于String是不可变的对象，因此每次对String类型进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>String和JAVA中的一样</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/19/Unity-Lua-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/19/Unity-Lua-2/" class="post-title-link" itemprop="url">Unity手游开发-使用Lua来开发大型游戏（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-19 21:09:20" itemprop="dateCreated datePublished" datetime="2018-03-19T21:09:20+08:00">2018-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/19/Unity-Lua-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/19/Unity-Lua-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>Hotfix的基本原理依然是基于动态语言的Reload功能，更加准确的说是Function Reload。下图简单描述了整个Hotfix的流程：<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Lua-2-1.png"><br>更加具体地可以描述为：<br>1.程序发现要修复的bug，编写特殊的Hotfix代码进行修复，测试通过后上传svn服务器；<br>2.通过发布指令，将svn上更新后的Hotfix代码同步到服务器上；<br>3.服务器发现Hotfix代码有更新，则将其压缩序列化后通过socket发送给所有在线的客户端，同时带上字符串的MD5值供客户端验证；<br>4.客户端收到Hotfix消息之后，首先反序列化数据得到代码内容，校验MD5值之后，如果和本地已经执行过的Hotfix的MD5值，则执行替换逻辑，并记录当前已经执行过的Hotfix的MD5值，如果相同则不再执行；<br>5.客户端连接服务器的时候会主动请求一次Hotfix。</p>
<h1 id="实现方式-项目通过打一个更新包来实现，如果是表格的话可以走Hotfix"><a href="#实现方式-项目通过打一个更新包来实现，如果是表格的话可以走Hotfix" class="headerlink" title="实现方式(项目通过打一个更新包来实现，如果是表格的话可以走Hotfix)"></a>实现方式(项目通过打一个更新包来实现，如果是表格的话可以走Hotfix)</h1><p>执行Hotfix执行的代码非常简单，基于loadstring函数即可：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = loadstring(GameContent.HotfixData)</span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">    ClientUtils.trycall(f)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>这里的实现就没有reload那么复杂，但是也是有一定的限制，比如local的函数或者在闭包的函数依然很难做正确的hotfix,需要编写特殊的Hotfix代码。</p>
<h2 id="向lua中注册c函数的过程是通过lua-pushcclosure-luaState-fn-n-函数实现的"><a href="#向lua中注册c函数的过程是通过lua-pushcclosure-luaState-fn-n-函数实现的" class="headerlink" title="向lua中注册c函数的过程是通过lua_pushcclosure(luaState, fn, n)函数实现的"></a>向lua中注册c函数的过程是通过lua_pushcclosure(luaState, fn, n)函数实现的</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/19/markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/19/markdown/" class="post-title-link" itemprop="url">Markdown</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-19 09:45:21" itemprop="dateCreated datePublished" datetime="2018-03-19T09:45:21+08:00">2018-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/19/markdown/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/19/markdown/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h1><ul>
<li>需要引用代码时，如果引用的语句只有一段，不分行，可以用`将语句包起来。</li>
<li>如果引用的语句为多行，可以将```置于这段代码的首行和末行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/19/Unity-Lua-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/19/Unity-Lua-1/" class="post-title-link" itemprop="url">Unity-Lua</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-19 08:57:26" itemprop="dateCreated datePublished" datetime="2018-03-19T08:57:26+08:00">2018-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/19/Unity-Lua-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/19/Unity-Lua-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>逻辑使用脚本来做的好处：</p>
<ul>
<li>使用脚本语言的动态特性，客户端可以做Hotfix,服务器可以做Refresh，无论在运营还是开发期这一特性都很有用；</li>
<li>脚本语言在虚拟机运行，有效控制崩溃率</li>
<li>上手难度低<br>缺点是运行效率低，但是之前看的LuaJit的效率只是略低于c（有待验证),动态语言容易出一些运行时错误（一般是语法错误），但是调试难度在真机下相对容易一些<br>lua的集成在目前维护的这个项目集成了uLua(感觉算是toLua的前身吧)和sLua(腾讯的SDK集成的).具体性能对比自己就不测试了，（懒）<br>在这里可以看到<a href="http://link.zhihu.com/?target=http%3A//qiankanglai.me/2016/07/31/unity-lua/" target="_blank" rel="noopener">http://link.zhihu.com/?target=http%3A//qiankanglai.me/2016/07/31/unity-lua/</a><h1 id="性能差异的可能原因之一"><a href="#性能差异的可能原因之一" class="headerlink" title="性能差异的可能原因之一"></a>性能差异的可能原因之一</h1>个人感觉ToLua在属性操作方面性能较好，而Vectore的向量操作，因为可能会有Lua层的优化，即在Lua层完全实现了对应的操作（vector.bytes),因此需要针对源码进行详细的对比。至于性能差异的原因，我没有从Lua虚拟机的实现部分分析，只是查看两种生成的Warp后的接口进行一个简单的猜想。<br>选取同一个接口进行对比，UnityEngine.Animator的GetFloat接口，ToLua的实现如下：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetFloat</span>(<span class="params">IntPtr L</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> count = LuaDLL.lua_gettop(L);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span> &amp;&amp; TypeChecker.CheckTypes(L, <span class="number">1</span>, <span class="keyword">typeof</span>(UnityEngine.Animator), <span class="keyword">typeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Animator obj = (UnityEngine.Animator)ToLua.ToObject(L, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> arg0 = (<span class="keyword">int</span>)LuaDLL.lua_tonumber(L, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> o = obj.GetFloat(arg0);</span><br><span class="line">            LuaDLL.lua_pushnumber(L, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处省略另一个重载接口</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> LuaDLL.luaL_throw(L, <span class="string">"invalid arguments to method: UnityEngine.Animator.GetFloat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> LuaDLL.toluaL_exception(L, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>SLua生成的代码如下：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetFloat</span>(<span class="params">IntPtr l</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> argc = LuaDLL.lua_gettop(l);</span><br><span class="line">        <span class="keyword">if</span>(matchType(l, argc, <span class="number">2</span>, <span class="keyword">typeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Animator self = (UnityEngine.Animator)checkSelf(l);</span><br><span class="line">            System.Int32 a1;</span><br><span class="line">            checkType(l, <span class="number">2</span>, <span class="keyword">out</span> a1);</span><br><span class="line">            <span class="keyword">var</span> ret = self.GetFloat(a1);</span><br><span class="line">            pushValue(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">            pushValue(<span class="number">1</span>, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="number">1</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们注意到，这一函数只需要一个返回值的，但是SLua往栈里pushValue了两个值，然后返回2。SLua使用一个单独的值来表示函数运行的结果，这对于错误可以进行更好的处理，但是多出的压栈和出栈操作有额外的性能消耗。</p>
<h1 id="导出方式对比"><a href="#导出方式对比" class="headerlink" title="导出方式对比"></a>导出方式对比</h1><p>ToLua导出的使用的是白名单的方式，在CustomeSetting.cs文件中定义的接口才会导出，也提供了导出引擎所有的接口功能；而SLua是以黑名单的方式进行，默认提供的功能是导出了除了黑名单中的所有模块接口，也是了一个导出最简接口的方式。<br>从使用角度来看，SLua黑名单的方式在开发期比较方便，默认会导出所有接口，因此不需要每次想要增加一个已经存在的类Lua接口都要自己定义然后重新导出，发布的时候也可以使用最简接口。维护起来ToLua因为所有的导出类都是我们自己定义的，因此更加清晰明确。<br>鉴于这部分内容有源码可以进行修改 ，因此不是一个核心需要考虑的内容，两种方式各有利弊。</p>
<h1 id="如何使用Lua语言"><a href="#如何使用Lua语言" class="headerlink" title="如何使用Lua语言"></a>如何使用Lua语言</h1><p>在进行了初步集成后，怎样让开发人员可以更好地使用Lua语言是接下来面临的问题。<br>ToLua对应有一套之前uLua作者开发的<a href="https://github.com/jarjin/LuaFramework_UGUI" target="_blank" rel="noopener">LuaFramework</a>，这一框架集成了脚本打包和二进制脚本读取，UI制作流程等多个功能，但是也如作者自己所有，这一框架最初源自一个示例形式的Demo，因此其中代码有很多部分是和示例写死的绑定的逻辑，比如启动逻辑，Lua二进制脚本的加载需要手动指定等等。<br>相对应的，SLua也有多套已经开源的框架，其中最为完善的<a href="https://github.com/mr-kelly/KSFramework" target="_blank" rel="noopener">KSFramwork</a>，这套框架集成了资源打包，导表，Lua热重载在内的多个功能，而且代码质量初步开起来还不错，因此最后我们决定把KSFramwork中的SLua部分替换成ToLua的部分来结合使用。<br>改造的过程还比较简单，由于该部分使用Lua耦合的只有两块内容，一是UIControler部分，二是LuaBehavior部分，所有的接口都由LuaModule模块提供。因此改造的过程也就比较明确了：<br>1.删除源代码中的SLua部分，接入ToLua的部分；<br>2.使用ToLua重写LuaModule的实现；<br>3.改造LuaUIController，使用新的LuaModule接口实现之前的功能；<br>4.改造LuaBehavior模块；<br>代码删除和LuaModule模块的重新实现都比较简单，着重介绍一下LuaUIController和LuaBehavior模块的改造。</p>
<h1 id="改造初衷"><a href="#改造初衷" class="headerlink" title="改造初衷"></a>改造初衷</h1><p>之前的KSFramwork还是一个核心逻辑在C#，Lua只承载UI等逻辑的模块，其实目前逻辑也是这样的，但是个人比较同意“轻引擎，重脚本”，引擎可以看作渲染，资源加载，音效等功能的提供者，脚本逻辑负责使用这些功能构建游戏内容。那这样大部分与逻辑相关的控制权就应该从引擎交给脚本来进行。Unity作为一个比较特殊的例子，虽然对于它来说，C#部分已经是脚本了，但是对于希望着重使用Lua脚本的我们来说，因为C#不可更新，因此被视作了引擎部分。<br>最为简单的设计就是当引擎初始化完毕之后，通过一个接口调用把后续的逻辑都交由脚本来控制，大部分与游戏玩法相关的模型加载、声音播放、特效播放、动画等由脚本控制。tick逻辑为了减少调用次数，没帧也由引擎调用注册的一个脚本接口进行统一调用，脚本层自己做分发。</p>
<h1 id="LuaUIController的改造"><a href="#LuaUIController的改造" class="headerlink" title="LuaUIController的改造"></a>LuaUIController的改造</h1><p>LuaUIController原始的方式是在C#层通过ui模块的名称加载对应的一个lua文件，获取一个lua table 进行缓存，在比如OnInit等需要接口调用的地方查找这个table中对应的函数进行调用。这种方式的界面是由C#层的逻辑来驱动加载和显示的，而且在加载过程要有文件的搜索和检查过程。<br>这样会存在一个问题，就是脚本层的逻辑无法或者很难或者很难去控制界面对象的生命周期。针对资源的生命周期，“谁创建谁管理”的策略不在可以很方便地来明确责任的划分，因此要进行改造。<br>改造的方向很简单，讲界面在家和显示的接口开放到Lua层，然后在创建的时候由lua层传递一个table对象进来，C#中进行缓存，当界面资源异步加载完毕，需要进行接口调用的地方的实现与之前保存一致。这样，界面资源的生命周期全部交由脚本层来管理，在脚本构建一个结构合理功能齐全的UIManager来进行一些功能的封装，就可以满足大部分的需求。</p>
<h1 id="LuaBehavior的改造"><a href="#LuaBehavior的改造" class="headerlink" title="LuaBehavior的改造"></a>LuaBehavior的改造</h1><p>MonoBehavior是Unity为了方便开发而提供的一个很好的功能，脚本以组件的方式挂接在GameObject身上，就可以在Awake,Start,Update等接口中处理想要的逻辑。为了能够继续使用Unity的这一特性，在Lua层也实现了一个简单的LuaBehavior封装。<br>KSFramwork中的思路非常简单，同样根据名称来把一个LuaBehavior和一个Lua脚本进行绑定，在对应的逻辑中调用与之对应的接口就可以了，比如Awake接口的实现如下：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(LuaPath))</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        CallLuaFunction(<span class="string">"Awake"</span>);</span><br><span class="line">    &#125;<span class="comment">//else Null Lua Path, pass Awake!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CallLuaFunction的实现也很明确，从缓存的lua table中获取名称为Awake的function进行调用。这种方式没有问题，但是当场景中挂在了LuaBehavior(项目中是LuaComponent)的GameObject很多的时候，每一帧都会有非常多次的update(这个函数就不要暴露了),这个调用从C#层传递到Lua层，有很多额外的性能消耗。<br>前文也提到了，比较好的方式是没帧只有一个C#到Lua层的Update方法调用，然后脚本层自己做分发。因此，针对这一需求，我们使用ToLua#自带的LuaLooper来实现的这一功能。<br>LuaLooper(项目是自己包装的一个luatimer)是全局只创建一个的MonoBehaviour,注意这里只创建一个只由逻辑来决定的，而不是一个单例模式。这里针对单例模式适合场合的讨论不再展开，此处由逻辑来保证只有一个Looper存在是一件比较合理的事情，预留了一些扩展的可能。<br>LuaLooper以时间的方式讲三种Update分发出去：Update,LateUpdate,FixedUpdate,它在自己对应的函数中调用luaState的对应函数来将事件告知脚本，脚本中需要的模块向分发模块注册回调来监听事件,就可以做到每帧只有一次Update调用了。<br>具体的代码实现可以去看ToLua#中的LuaLooper.cs的类实现。<br>-注意 这里有一个小心的点是当事件在脚本层分发的时候，要注意执行时序问题的影响，最好能够保证任意的执行顺序都可以不影响游戏逻辑的结果，否则可能会出现很难查的诡异bug。<br>对于Awake,Start等一次性调用的函数，由于不是频繁的逻辑，因此保留了原始的实现方式，这样可以让Lua层对应的代码实现更加简洁。而使用事件注册的方式，让不需要update逻辑的脚本没有任何额外的性能消耗。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/03/18/XCAAFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/18/XCAAFS/" class="post-title-link" itemprop="url">XCAAFS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-18 19:07:38" itemprop="dateCreated datePublished" datetime="2018-03-18T19:07:38+08:00">2018-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/03/18/XCAAFS/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/03/18/XCAAFS/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>负载均衡服务器，应用在登录模块上，开新服的时候入口流量会增大，一段时间以后流量会递减或者趋于平缓，市面上已经有了成熟的解决方案了。<br>一般最常用，最简单的也是基于DNS的负载均衡系统了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">334</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DTWMWSlnxcXcuUgR1H2qlVt9-gzGzoHsz',
      appKey     : 'Ms2yHVyCinQmWnsKtVv7NOHR',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
