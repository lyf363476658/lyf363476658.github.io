<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/24/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/16/Unity-Manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/16/Unity-Manual/" class="post-title-link" itemprop="url">Unity Manual</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-16 19:01:26" itemprop="dateCreated datePublished" datetime="2018-04-16T19:01:26+08:00">2018-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>public static float Mathf.Round(float f)</td>
<td>四舍五入</td>
</tr>
</tbody>
</table>
</div>
<p>DisallowMultipleComponent 禁止一个脚本被加载多次</p>
<h3 id="YieldInstruction-中断指令"><a href="#YieldInstruction-中断指令" class="headerlink" title="YieldInstruction 中断指令"></a>YieldInstruction 中断指令</h3><p>所有yield指令的基类<br>参考WaitForSeconds, WaitForFixedUpdate, Coroutine and MonoBehaviour,StartCoroutine</p>
<h3 id="WaitForSeconds-等待几秒"><a href="#WaitForSeconds-等待几秒" class="headerlink" title="WaitForSeconds 等待几秒"></a>WaitForSeconds 等待几秒</h3><p>Namespace: UnityEngine<br>Inherits from: YieldInstruction</p>
<p>在给定的秒数内，暂停协同程序的执行。<br>WaitForSeconds只能用在协同程序中的yield声明。</p>
<h3 id="RequireComponent"><a href="#RequireComponent" class="headerlink" title="RequireComponent"></a>RequireComponent</h3><p>当你添加了一个用了RequireComponent组件的脚本，需要的组件将会自动被添加到GameObject上。这个可以有效避免组装错误。在新建类的前面加</p>
<pre><code>[RequireComponent(typeof(LineRenderer))]
</code></pre><h3 id="AssetDatabase-ImportAsset"><a href="#AssetDatabase-ImportAsset" class="headerlink" title="AssetDatabase.ImportAsset"></a>AssetDatabase.ImportAsset</h3><pre><code>static function ImportAsset(path : string, options : ImportAssetOptions = ImportAssetOptions.Default):void
</code></pre><p>导入指定路径的资源<br>所有路径都是相对于工程目录文件，例如”Assets/MyTexture/hello.png”</p>
<h3 id="AssetImporter-GetAtPath"><a href="#AssetImporter-GetAtPath" class="headerlink" title="AssetImporter.GetAtPath"></a>AssetImporter.GetAtPath</h3><pre><code>static function GetAtPath(path: string):AssetImporter
</code></pre><p>通过指定路径来导入资源</p>
<h3 id="TextureWrapMode"><a href="#TextureWrapMode" class="headerlink" title="TextureWrapMode"></a>TextureWrapMode</h3><p>在进行纹理贴图时，图像会出现在物体表面(u,v)位置上，而这些值在[0.0,1.0]范围内。但是，如果超出这个范围，会发生什么情况呢，这由纹理的映射函数来决定.常见有下面几种：</p>
<ol>
<li>重复(REPEAT):图像在表面上重复出现。在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应于底部的纹理单元相匹配，在纹理左侧的纹理单元也应于右侧的纹理单元相匹配。</li>
<li>截取(CLAMP): 将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。</li>
<li>镜像重复(MIRRORED_REPEAT_ARB)</li>
<li>边界截取(CLAMP_TO_BORDER_ARB)</li>
<li>边缘截取(CLAMP_TO_EDGE)</li>
</ol>
<h3 id="CameraClearFlag"><a href="#CameraClearFlag" class="headerlink" title="CameraClearFlag"></a>CameraClearFlag</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CameraClearFlags</span><br><span class="line">&#123;</span><br><span class="line">    Skybox = <span class="number">1</span>,			<span class="comment">// 这是默认设置，在屏幕上空的部分显示当前相机的天空盒。如果当前相机没有设置天空盒，它会默认使用Edit-&gt;Render Settings里)中选择天空盒。然后它将退回使用背景颜色，另外天空盒组件可以添加到相机上。</span></span><br><span class="line">    SolidColor = <span class="number">2</span>, <span class="comment">// 屏幕上的任何空的部分显示当前相机的背景颜色</span></span><br><span class="line">    Color = <span class="number">2</span>,</span><br><span class="line">    Depth = <span class="number">3</span>,			<span class="comment">// 该深度的东西永远都不会被裁剪</span></span><br><span class="line">    Nothing = <span class="number">4</span>,		<span class="comment">// 什么事情都不做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Projector"><a href="#Projector" class="headerlink" title="Projector"></a>Projector</h3><pre><code>nearClipPlane       近裁剪面的距离
farClipPlane        远裁剪面的距离
fieldOfView         该投影的视野，以度为单位
aspectRatio         投影的宽高比
orthographic        投射是正交还是透视
orthographicSize    在正交模式下投射的一半尺寸
ignoreLayers        哪个物体层被这个投射器忽略
material            要投射到每个物体的材质
</code></pre><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><h3 id="Mesh-RecalculateBounds"><a href="#Mesh-RecalculateBounds" class="headerlink" title="Mesh.RecalculateBounds"></a>Mesh.RecalculateBounds</h3><p>在修改完顶点后你应该用这个函数以确保包围体是恰当的。赋值三角形将自动重新计算包围体。</p>
<h3 id="Mesh-RecalculateNormals"><a href="#Mesh-RecalculateNormals" class="headerlink" title="Mesh.RecalculateNormals"></a>Mesh.RecalculateNormals</h3><p>重新计算网格的法线<br>在修改完定点后，通常会更新发现来反映新的变化。发现是根据共享的顶点计算出来的。导入到网格有时不共享所有顶点。例如：一个顶点在一个纹理坐标的接缝处将会被分为两个顶点。因此这个RecalculateNormals函数将会在纹理坐标接缝处创建一个不光滑的法线。RecalculateNormals不会自动产生切线，因此bumpmap着色器在调用RecalculateNormals之后不会工作。然而你可以提取你自己的切线。</p>
<h2 id="惯性坐标系"><a href="#惯性坐标系" class="headerlink" title="惯性坐标系"></a>惯性坐标系</h2><p>因为在进行物体到世界坐标系的转换时候，即需要平移同时也需要进行旋转，为了简化这种变化，在其中假如惯性坐标系，其中惯性坐标系的原点与本地坐标系的原点重合其轴和世界坐标系平英。那么本地坐标系到惯性坐标系只需要旋转操作（之前也得缩放）再到世界坐标系只需要进行平移。</p>
<h1 id="构建AssetBundles"><a href="#构建AssetBundles" class="headerlink" title="构建AssetBundles"></a>构建AssetBundles</h1><p>在<a href="https://docs.unity3d.com/Manual/AssetBundles-Workflow.html" target="_blank" rel="noopener">AssetBundle工作流</a>的文档中，我们有一个代码示例，它将三个参数传递给BuildPipeline.BuildAssetBundles函数。让我们更深入实际的了解。<br>Assets/AssetBundles:这是AssetBundles输出的目录。您可以将其更改为您想要的任何输出目录，只需确保在尝试构建之前文件夹实际存在。</p>
<h2 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h2><p>BuildAssetBundleOptions您可以指定几种具有各种效果的不同。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/12/Unity-Optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/12/Unity-Optimize/" class="post-title-link" itemprop="url">Unity优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-12 14:51:15" itemprop="dateCreated datePublished" datetime="2018-04-12T14:51:15+08:00">2018-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>更新不透明贴图的压缩格式为ETC 4bit，因为android市场的手机中的GPU有多种，每家的GPU支持不同的压缩格式，但他们都兼容ETC格式。</li>
<li>对于透明贴图，我们只能选择RGBA 16bit 或者RGBA 32bit。</li>
<li>减少FPS，在ProjectSetting-&gt; Quality中的VSync Count 参数会影响你的FPS，EveryVBlank相当于FPS=60，EverySecondVBlank = 30；<br>这两种情况都不符合游戏的FPS的话，我们需要手动调整FPS，首先关闭垂直同步这个功能，然后在代码的Awake方法里手动设置FPS（Application.targetFrameRate = 45;）<br>降低FPS的好处：<br>1）省电，减少手机发热的情况；<br>2）能都稳定游戏FPS，减少出现卡顿的情况。</li>
<li>当我们设置了FPS后，再调整下Fixed timestep这个参数，这个参数在ProjectSetting-&gt;Time中，目的是减少物理计算的次数，来提高游戏性能。</li>
<li>尽量少使用Update LateUpdate FixedUpdate，这样也可以提升性能和节省电量。多使用事件（不是SendMessage，使用自己写的，或者C#中的事件委托）。</li>
<li>待机时，调整游戏的FPS为1，节省电量。</li>
<li>图集大小最好不要高于1024，否则游戏安装之后、低端机直接崩溃、原因是手机系统版本低于2.2、超过1000的图集无法读取、导致。2.2 以上没有遇见这个情况。注意手机的RAM 与 ROM、小于 512M的手机、直接放弃机型适配。</li>
</ol>
<h2 id="VSCount-垂直同步"><a href="#VSCount-垂直同步" class="headerlink" title="VSCount 垂直同步"></a>VSCount 垂直同步</h2><p>Unity3D中新建一个空场景的时候，帧速率（FPS总是很低），大概在60~70之间。在Unity3D中当运行场景打开Profiler的时候，我们会看到VSync 这一项占了很大的比重。<br>这个是什么呢，这个就是垂直同步。<br>我们可以关闭VSync来提高帧速率，选择edit-&gt;project settings-&gt;Quality。<br>在右侧面板中可以找到VSync Count,把它选成Don’t Sync。<br>这就关闭了VSync(垂直同步)，现在在运行场景看看，帧速率是不是提高很多。<br>现在来说说什么是垂直同步，要知道什么是垂直同步，必须要先明白显示器的工作原理，<br>显示器上的所有图像都是一线一线的扫描上去的，无论是隔行扫描还是逐行扫描，<br>显示器都有两种同步参数——水平同步和垂直同步。</p>
<p>什么叫水平同步？什么叫垂直同步？<br>垂直和水平是CRT中两个基本的同步信号，水平同步信号决定了CRT画出一条横越屏幕线的时间，<br>垂直同步信号决定了CRT从屏幕顶部画到底部，再返回原始位置的时间，<br>而恰恰是垂直同步代表着CRT显示器的刷新率水平。</p>
<p>为什么关闭垂直同步信号会影响游戏中的FPS数值？<br>如果我们选择等待垂直同步信号（也就是我们平时所说的垂直同步打开），<br>那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，<br>显卡无法绘制下一屏，只有等85单位的信号到达，才可以绘制。<br>这样FPS自然要受到操作系统刷新率运行值的制约。</p>
<p>而如果我们选择不等待垂直同步信号（也就是我们平时所说的关闭垂直同步），那么游戏中作完一屏画面，<br>显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制，自然可以完全发挥显卡的实力。<br>但是不要忘记，正是因为垂直同步的存在，才能使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。<br>取消了垂直同步信号，固然可以换来更快的速度，但是在图像的连续性上势必打折扣。<br>这也正是很多朋友抱怨关闭垂直后发现画面不连续的理论原因。</p>
<p>合并材质球Unity3D中每导入一次模型就多一个材质球，可我的这些模型都是共用一张贴图的就想共用一个材质球，所以每次都要删除再附上，很麻烦。怎么才能合并这些材质球？<br>采用TexturePacking吧</p>
<ol>
<li>遍历gameobject，取出material，并根据shader来将material分类；</li>
<li>调用Unity自带的PackTextures函数来合并每个shader分类中的material所对应的textures（PackTextures函数有缺陷，不过可以将就用）；</li>
<li>根据合并的大的texture来更新原有模型的texture、material已经uv坐标值。</li>
</ol>
<p>需要注意的是：需要合并的纹理应该是物体在场景中距离相近的，如果物体在场景中的距离较远，<br>则不建议合并纹理，因为这样做很有可能非但起不到优化的作用，反而降低了运行效率。 </p>
<p>mesh合并<br>分为2种方式合并</p>
<ol>
<li><p>自带的合并必须勾选静态。</p>
<p>所有被勾选了“Static”的GameObject，其中的Mesh Filter中的mesh都会被合并到 “Combined Mesha (root: scene)” 中</p>
</li>
<li><p>也可以用脚本来合并mesh 。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title">MyClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">        MeshFilter [] meshFilters = GetComponentsInChildren&lt;MeshFilter&gt; ();</span><br><span class="line">        CombineInstance[] combine = <span class="keyword">new</span> CombineInstance[meshFilters.Length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; meshFilters.Length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            combine[i].mesh = meshFilters[i].sharedMesh;</span><br><span class="line">            combine[i].transform = meshFilters[i].transform.localToWorldMatrix;</span><br><span class="line">            meshFilters[i].gameObject.active = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        transform.GetComponent&lt;MeshFilter&gt;().mesh = <span class="keyword">new</span> Mesh ();</span><br><span class="line">        transform.GetComponent&lt;MeshFilter&gt;().mesh.CombineMeshes (combine);</span><br><span class="line">        transform.gameObject.active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先在 Unity 中建立空物件 ( Empty ) </p>
</li>
<li>再创建2个 Cube 方块，并放入空物件底下 (可以改成你自己的模型)</li>
<li>把 MyClass 代码丟进空物件上 。</li>
<li>(可选) 建立一个 Material 材质，并且丢进空物件上</li>
<li><p>执行</p>
</li>
<li><p>角色Material数量2-3个，骨骼数量小于30个，面片数量300-1500，一般角色应该没有IK结点<br>这是因为角色的动作大多数都是事先设定好的，并不需要经过IK操作来进行实时计算（Rogdoll除外），所以在模型导入时，不要将IK结点一起导入。</p>
</li>
<li>静态实体不要附加Animation Component<br>在静态实体上附加Animation部件虽然对结果没有影响，但却会增加一定的CPU开销来调用这一组件，所以尽量去掉该组件。<br>网格顶点数小于500；UV值范围尽量不要超过（0, 1）区间；尽量保证UV值不越界，这对于将来的纹理拼合优化很有帮助。</li>
<li>地形<br>地形的分辨率大小<br>长宽均尽量小于257。这是因为地形太大，会造成大量顶点数据，给你的内存带宽造成一定的影响，在目前的ios设备中，内存带宽是非常有限的，需要尽量节省。同时，如果用Unity自带的地形，一定也要使用Occlusion Culling，因为Unity的刷地形工具虽然方便，但却是framekiller，刷过之后，你会发现drawcall增加的非常多。<br>混合纹理数量<br>不要超过4。地形的混合操作是很耗时的，应该尽量避免。能合并的纹理尽量合并。</li>
<li>纹理</li>
</ol>
<ul>
<li>纹理格式<br>建议png或tga。不用转成ios硬件支持的PVRTC格式，因为Unity在发布时会帮你自动转的。</li>
<li>纹理尺寸<br>长宽小于1024。同时应该尽可能地小，够用就好，以保证纹理对内存带宽的影响达到最小。</li>
<li>支持Mipmap（UI不需要转，不然会增大内存）<br>建议生成Mipmap。虽然这种做法会增加一些应用程序的大小，但在游戏运行时，系统会根据需求应用Mipmap来渲染，从而减少内存带宽。</li>
<li>检查Alpha值<br>如果纹理的alpha通道均为1，则用RGB的24位纹理来代替RGBA的32位纹理。（据说Unity内部会进行自动检测）</li>
</ul>
<ol>
<li>光源<br>光源“Important”个数建议1个，一般为方向光。“Important”个数应该越小越少。个数越多，drawcall越多。<br>Pixel Light数目1-2个。</li>
<li>粒子特效<br>屏幕上的最大粒子数建议小于200个粒子。<br>每个粒子发射器发射的最大粒子数建议不超过50个。<br>粒子大小如果可以的话，粒子的size应该尽可能地小。因为Unity的粒子系统的shader无论是alpha test还是alpha blending都是一笔不小的开销。同时，对于非常小的粒子，建议粒子纹理去掉alpha通道。<br>尽量不要开启粒子的碰撞功能。<br>非常耗时。</li>
<li>音频<br>游戏中播放时间较长的音乐（如背景音乐）使用.ogg或.mp3的压缩格式。<br>较短音乐（如枪声）使用.wav和.aif的未压缩音频格式。</li>
<li>相机<br>裁剪平面<br>将远平面设置成合适的距离。远平面过大会将一些不必要的物体加入渲染，降低效率。<br>根据不同的物体设置不同的远裁剪平面<br>Unity提供了可以根据不同的layer来设置不同的view distance，所以我们可以实现将物体进行分层，大物体层设置的可视距离大些，而小物体层可以设置地小些，另外，一些开销比较大的实体（如粒子系统）可以设置得更小些等等。</li>
<li>碰撞<br>尽量不用MeshCollider<br>如果可以的话，尽量不用MeshCollider，以节省不必要的开销。如果不能避免的话，尽量用减少Mesh的面片数，或用较少面片的代理体来代替。</li>
<li>其他<br>Drawcall<br>尽可能地减少Drawcall的数量。IOS设备上建议不超过100。减少的方法主要有如下几种：Frustum Culling，Occlusion Culling，Texture Packing。Frustum Culling是Unity内建的，我们需要做的就是寻求一个合适的远裁剪平面；Occlusion Culling，遮挡剔除，Unity内嵌了Umbra，一个非常好OC库。但Occlusion Culling也并不是放之四海而皆准的，有时候进行OC反而比不进行还要慢，建议在OC之前先确定自己的场景是否适合利用OC来优化；Texture Packing，或者叫Texture Atlasing，是将同种shader的纹理进行拼合，根据Unity的static batching的特性来减少draw call。建议使用，但也有弊端，那就是一定要将场景中距离相近的实体纹理进行拼合，否则，拼合后很可能会增加每帧渲染所需的纹理大小，加大内存带宽的负担。这也就是为什么会出现“DrawCall降了，渲染速度也变慢了”的原因。</li>
</ol>
<p>非运动物体尽量打上Static标签<br>Unity在运行时会对static物体进行自动优化处理，所以应该尽可能将非运行实体勾上static标签。</p>
<p>场景中尽可能地使用prefab<br>尽可能地使用prefab的实例化物体，以降低内存带宽的负担。检查实体的PrefabType，尽量将其变成PrefabInstance，而不是ModelPrefabInstance。</p>
<p>移动平台相对于PC机，具有体积小，计算弱，带宽少的特点。</p>
<p>因此做手机游戏的开发，优化的方向，与力度对比PC游戏都有所区别。</p>
<p>必须要做到优化流程，合理利用资源。<br>目前在手机上面，还不能够像PC游戏那样追求高质量渲染效果，为了让手机不那么容易发烫，还要控制cpu，gpu，不能让他们全速运算。</p>
<p>材质方面：<br>纹理方面，建议使用压缩纹理，</p>
<p>Android上面使用ETC1，苹果上面使用PVRTC。<br>UV坐标控制在0到1之间，人物模型面数控制在1500内，骨骼控制在30个以内。<br>场景中使用一个主光（不能再多了）。<br>尽量减少alphaTest和alphaBlend材质的使用。在手机上，这是很杀效率的。<br>骨骼动画方面：<br>在动画方面可以考虑不使用插值，固定的帧率的动画。</p>
<p>如果要做插值，考虑使用四元数（表示旋转）和向量（表示位移）来做插值。</p>
<p>四元数做插值速度比矩阵来的快，Slerp提供了平滑插值。</p>
<p>优化的常规技巧<br>剖析你的游戏。<br>不要花费时间来优化那些晦涩的代码或者缩减图形文件的大小，除非这是你游戏的瓶颈。<br>第一次剖析你的游戏将会使你发现你游戏的瓶颈。Apple’s Shark是一个很好的用来剖析基于OpenGL的程序的工具。<br>再次剖析你的游戏。<br>优化之后不要忘记再剖析一次你的游戏，这样可以检查你所做的优化是否达到了预期的效果。<br>当然，这样做也可能会使你发现更多的瓶颈。<br>流程第一、性能第二。花费时间来使你游戏的创建尽可能地流畅。<br>尽可能快地修正游戏中的错误将会使你后期更容易优化你的游戏。<br>在Scene View中测试场景。<br>这样做将会使你清楚了解这个场景中的物体或者附加在物体上的脚本是否降低了游戏性能。<br>如果Scene View反应迟钝，那么有可能是图形方面的原因，如果Scene View反应不迟钝，那么瓶颈可能出在脚本或者物理系统上。<br>禁用指定游戏物体。<br>在play模式下，尝试禁用并启用游戏物体来排查出游戏慢的原因。</p>
<p>网格<br>如果可能的话，把相邻的物体（网格）合并为一个只有一个材质的物体（网格）。比如，你的游戏中包含一个桌子，上面有一堆东西，你完全可以在3D程序中将它们合并在一起（这可能也需要你将这些物体的纹理合并为一个大的纹理集）。减少需要渲染的物体的数量可以极大地提高游戏性能。</p>
<p>不要有不必要的网格。<br>如果你的游戏场景中有一个人物，那么他应该是一个网格。如果你有一个船，那么它也应该只是一个网格。<br>每一个网格只用一种材质。<br>使用极少的面数的网格（比如500个多边形以下）。<br>最好把你人物的三角面数量控制在1500-2000个之间。<br>这个数量可以说是游戏质量和性能之间一个均衡值。如果你的模型有四边形，那么在导入模型的时候，引擎将会把每个四边形变为两个三角形。</p>
<p>光照<br>像素光。<br>像素光可以让你的游戏看起来效果很牛逼，但是不要使用过多的像素光。<br>在你的游戏中可以使用质量管理器来调节像素光的数量来取得一个性能和质量的均衡点.</p>
<p>性能占用顺序：聚光灯&gt;点光源&gt;平行光。<br>一个好的点亮场景的方法就是先得到你想要的效果，然后看看哪些光更重要；<br>在保持光效的前提下看看哪些光可以去掉。</p>
<p>点光源和聚光灯只影响它们范围内的网格。<br>如果一个网格处于点光源或者聚光灯的照射范围之外，并且光源的attenuate开关是打开的，那么这个网格将不会被光源所影响，这样就可以节省性能开销。<br>这样做理论上来讲可以使用很多小的点光源而且依然能有一个好的性能，因为这些光源只影响一小部分物体。<br>一个网格在有8个以上光源影响的时候，只响应前8个最亮的光源。</p>
<p>贴图<br>在外观不变的前提下，贴图大小越小越好。<br>如果你的显卡的显存不够大的话，你游戏中的贴图将会被转存到系统内存中，在显卡调用它们的时候再传到显卡中。<br>对于比较新的电脑来说，内存和显卡之间有足够的带宽来达到一个很好的性能；<br>如果你很无耻地用了巨多的大图片的话，在低显存的电脑上运行你的游戏的时候，你的游戏必然会挂掉。<br>倒是没有必要在图形编辑软件中调整贴图的大小。你可以在unity导入贴图的时候进行调整。</p>
<p>不要使用低质量的图片。<br>在小播放界面的游戏中使用低质量的jpeg图片或者低色彩的png图片亦或是gif图片没什么问题。<br>在发布游戏的时候，引擎会自动压缩这些图片，多重压缩和解压将会降低图片的质量，所以最好保持贴图文件的分辨率为原始分辨率。<br>这样就会减少多重压缩和解压所导致的图片失真现象。</p>
<p>Shaders<br>多重效果的shader就比看起来样式很单一的shader要更耗费资源。<br>同样在一个拥有贴图和光反射的物体上，使用VertexLit Diffuse shader无疑是最省资源的。</p>
<p>在美术制作场景的过程中，会使用到大量的粒子系统。<br>比如场景中的火把。在我们的一个地下城场景中，美术们放置了大量的火把。整个场景中的各个地方，有100来个火把。</p>
<p>unity中，在摄像机范围外的粒子系统虽然不会被绘制。<br>但是update是一直持续的。这也就意味着，这100多个火把，不论是否可见都在更新。</p>
<p>这个设计应该是很不合理的，在我看过的其他引擎中，都会有一个开关，来控制不可见的粒子系统是否需要update。<br>有的粒子系统在不可见的时候需要更新,比如爆炸。有的不需要更新，比如火堆火把。</p>
<p>为了避免不必要的update开销，尤其是最后游戏是要发布到页游平台（web player只能使用一个cpu的核）。<br>于是写了一个脚本，控制不可见的粒子系统就不更新。</p>
<p>该脚本主要是用到了2个MonoBehaviour的函数。<br>OnBecameInvisible() 当变为不可见   和   OnBecameVisible() 当变成可见。 </p>
<p>要这2个函数起作用的前提是，该GameObject绑定了MeshRender组件。<br>所以，我们要在粒子系统的GameObject放置在一个GameObject  下，且给该GameObject绑定一个MeshRender 与 MeshFilter。<br>MeshFilter中的mesh可以随便找个cube。</p>
<p>在Start（） 的时候，把最GameObject的scale设置为很小，以保证该cube不被看见。<br>其实遍历所有的child，把active设置为false。</p>
<p>在OnBecameVisible 中 遍历所有child，把active设置为true。<br>在OnBecameInvisible中 遍历所有child，把active设置为false。</p>
<p>Unity 性能优化 Draw Call </p>
<p>Unity（或者说基本所有图形引擎）生成一帧画面的处理过程大致可以这样简化描述：引擎首先经过简单的可见性测试，确定摄像机可以看到的物体，然后把这些物体的顶点（包括本地位置、法线、UV等），索引（顶点如何组成三角形），变换（就是物体的位置、旋转、缩放、以及摄像机位置等），相关光源，纹理，渲染方式（由材质/Shader决定）等数据准备好，然后通知图形API——或者就简单地看作是通知GPU——开始绘制，GPU基于这些数据，经过一系列运算，在屏幕上画出成千上万的三角形，最终构成一幅图像。</p>
<p>在Unity中，每次引擎准备数据并通知GPU的过程称为一次Draw Call。这一过程是逐个物体进行的，对于每个物体，不只GPU的渲染，引擎重新设置材质Shader也是一项非常耗时的操作。因此每帧的Draw Call次数是一项非常重要的性能指标，对于iOS来说应尽量控制在20次以内，这个值可以在编辑器的Statistic窗口看到。</p>
<p>Unity内置了Draw Call Batching技术，从名字就可以看出，它的主要目标就是在一次Draw Call中批量处理多个物体。只要物体的变换和材质相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。Draw Call Batching技术的核心就是在可见性测试之后，检查所有要绘制的物体的材质，把相同材质的分为一组（一个Batch），然后把它们组合成一个物体（统一变换），这样就可以在一个Draw Call中处理多个物体了（实际上是组合后的一个物体）。</p>
<p>但Draw Call Batching存在一个缺陷，就是它需要把一个Batch中的所有物体组合到一起，相当于创建了一个与这些物体加起来一样大的物体，与此同时就需要分配相应大小的内存。这不仅会消耗更多内存，还需要消耗CPU时间。特别是对于移动的物体，每一帧都得重新进行组合，这就需要进行一些权衡，否则得不偿失。但对于静止不动的物体来说，只需要进行一次组合，之后就可以一直使用，效率要高得多。</p>
<p>Unity提供了Dynamic Batching和Static Batching两种方式。Dynamic Batching是完全自动进行的，不需要也无法进行任何干预，对于顶点数在300以内的可移动物体，只要使用相同的材质，就会组成Batch。Static Batching则需要把静止的物体标记为Static，然后无论大小，都会组成Batch。如前文所说，Static Batching显然比Dynamic Batching要高效得多</p>
<p>要有效利用Draw Call Batching，首先是尽量减少场景中使用的材质数量，即尽量共享材质，对于仅纹理不同的材质可以把纹理组合到一张更大的纹理中（称为Texture Atlasing）。然后是把不会移动的物体标记为Static。此外还可以通过CombineChildren脚本（Standard Assets/Scripts/Unity Scripts/CombineChildren）手动把物体组合在一起，但这个脚本会影响可见性测试，因为组合在一起的物体始终会被看作一个物体，从而会增加GPU要处理的几何体数量，因此要小心使用。</p>
<p>对于复杂的静态场景，还可以考虑自行设计遮挡剔除算法，减少可见的物体数量同时也可以减少Draw Call。</p>
<p>总之，理解Draw Call和Draw Call Batching原理，根据场景特点设计相应的方案来尽量减少Draw Call次数才是王道，其它方面亦然。</p>
<p>Draw Call Batching （绘制调用批处理）</p>
<p>To draw an object on the screen, the engine has to issue a draw call to the graphics API (OpenGL ES in the case of iOS). Every single draw call requires a significant amount of work on the part of the graphics API, causing significant performance overhead on the CPU side.<br>在屏幕上渲染物体，引擎需要发出一个绘制调用来访问图形API（iOS系统中为OpenGL ES）。<br>每个绘制调用需要进行大量的工作来访问图形API，从而导致了CPU方面显著的性能开销。</p>
<p>Unity combines a number of objects at runtime and draws them together with a single draw call. This operation is called “batching”. The more objects Unity can batch together, the better rendering performance you will get.<br>Unity在运行时可以将一些物体进行合并，从而用一个绘制调用来渲染他们。这一操作，我们称之为“批处理”。<br>一般来说，Unity批处理的物体越多，你就会得到越好的渲染性能。</p>
<p>Built-in batching support in Unity has significant benefit over simply combining geometry in the modeling tool (or using theCombineChildren script from the Standard Assets package). Batching in Unity happensafter visibility determination step. The engine does culling on each object individually, and the amount of rendered geometry is going to be the same as without batching. Combining geometry in the modeling tool, on the other hand, prevents effecient culling and results in much higher amount of geometry being rendered.<br>Unity中内建的批处理机制所达到的效果要明显强于使用几何建模工具（或使用Standard Assets包中的CombineChildren脚本）的批处理效果。<br>这是因为，Unity引擎的批处理操作是在物体的可视裁剪操作之后进行的。<br>Unity先对每个物体进行裁剪，然后再进行批处理，这样可以使渲染的几何总量在批处理前后保持不变。<br>但是，使用几何建模工具来拼合物体，会妨碍引擎对其进行有效的裁剪操作，从而导致引擎需要渲染更多的几何面片。</p>
<p>Materials<br>材质<br>Only objects sharing the same material can be batched together. Therefore, if you want to achieve good batching, you need to share as many materials among different objects as possible.<br>只有拥有相同材质的物体才可以进行批处理。<br>因此，如果你想要得到良好的批处理效果，你需要在程序中尽可能地复用材质和物体。</p>
<p>If you have two identical materials which differ only in textures, you can combine those textures into a single big texture - a process often calledtexture atlasing. Once textures are in the same atlas, you can use single material instead.<br>如果你的两个材质仅仅是纹理不同，那么你可以通过纹理拼合操作来将这两张纹理拼合成一张大的纹理。<br>一旦纹理拼合在一起，你就可以使用这个单一材质来替代之前的两个材质了。</p>
<p>If you need to access shared material properties from the scripts, then it is important to note that modifyingRenderer.material will create a copy of the material. Instead, you should useRenderer.sharedMaterial to keep material shared.<br>如果你需要通过脚本来访问复用材质属性，那么值得注意的是改变Renderer.material将会造成一份材质的拷贝。<br>因此，你应该使用Renderer.sharedMaterial来保证材质的共享状态。</p>
<p>Dynamic Batching<br>动态批处理<br>Unity can automatically batch moving objects into the same draw call if they share the same material.<br>如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。</p>
<p>Dynamic batching is done automatically and does not require any additional effort on your side.<br>动态批处理操作是自动完成的，并不需要你进行额外的操作。</p>
<p>Tips:<br>提醒：<br>1、Batching dynamic objects has certain overheadper vertex, so batching is applied only to meshes containing less than900 vertex attributes in total.<br>批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。</p>
<p>2、If your shader is using Vertex Position, Normal and single UV, then you can batch up to 300 verts and if your shader is using Vertex Position, Normal, UV0, UV1 and Tangent, then only 180 verts.<br>Please note: attribute count limit might be changed in future<br>如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；<br>如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。<br>请注意：属性数量的限制可能会在将来进行改变。</p>
<p>4、Don’t use scale. Objects with scale (1,1,1) and (2,2,2) won’t batch.<br>不要使用缩放尺度（scale）。分别拥有缩放尺度(1,1,1)和(2,2,2)的两个物体将不会进行批处理。</p>
<p>5、Uniformly scaled objects won’t be batched with non-uniformly scaled ones.<br>统一缩放尺度的物体不会与非统一缩放尺度的物体进行批处理。<br>Objects with scale (1,1,1) and (1,2,1) won’t be batched. On the other hand (1,2,1) and (1,3,1) will be.<br>使用缩放尺度(1,1,1)和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1)和(1,3,1)的两个物体将可以进行批处理。</p>
<p>6、Using different material instances will cause batching to fail.<br>使用不同材质的实例化物体（instance）将会导致批处理失败。</p>
<p>7、Objects with lightmaps have additional (hidden) material parameter: offset/scale in lightmap, so lightmapped objects won’t be batched (unless they point to same portions of lightmap)<br>拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。</p>
<p>8、Multi-pass shaders will break batching. E.g. Almost all unity shaders supports several lights in forward rendering, effectively doing additional pass for them<br>多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。</p>
<p>9、Using instances of a prefab automatically are using the same mesh and material.<br>预设体的实例会自动地使用相同的网格模型和材质。</p>
<p>Static Batching<br>静态批处理</p>
<p>Static batching, on the other hand, allows the engine to reduce draw calls for geometry of any size (provided it does not move and shares the same material). Static batching is significantly more efficient than dynamic batching. You should choose static batching as it will require less CPU power.<br>相对而言，静态批处理操作允许引擎对任意大小的几何物体进行批处理操作来降低绘制调用（只要这些物体不移动，并且拥有相同的材质）。因此，静态批处理比动态批处理更加有效，你应该尽量低使用它，因为它需要更少的CPU开销。</p>
<p>In order to take advantage of static batching, you need explicitly specify that certain objects are static and willnot move, rotate or scale in the game. To do so, you can mark objects as static using the Static checkbox in the Inspector:<br>为了更好地使用静态批处理，你需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。想完成这一步，你只需要在检测器（Inspector）中将Static复选框打勾即可；<br>Using static batching will require additional memory for storing the combined geometry. If several objects shared the same geometry before static batching, then a copy of geometry will be created for each object, either in the Editor or at runtime. This might not always be a good idea - sometimes you will have to sacrifice rendering performance by avoiding static batching for some objects to keep a smaller memory footprint. For example, marking trees as static in a dense forest level can have serious memory impact.<br>使用静态批处理操作需要额外的内存开销来储存合并后的几何数据。在静态批处理之前，如果一些物体共用了同样的几何数据，那么引擎会在编辑以及运行状态对每个物体创建一个几何数据的备份。这并不总是一个好的想法，因为有时候，你将不得不牺牲一点渲染性能来防止一些物体的静态批处理，从而保持较少的内存开销。比如，将浓密森里中树设为Static，会导致严重的内存开销。</p>
<p>Static batching is only available in Unity iOS Advanced.<br>静态批处理目前只支持Unity iOS Advanced。</p>
<p>前两天，MadFinger，就是当今iOS与Android上画质最牛逼闪闪的游戏之一——ShadowGun的开发商，令人惊异地放出了一个ShadowGun的样例关卡以及若干可免费使用的Shader，国外同行们的分享精神真的是令人赞叹不已。原文在这里，以下是我的一些摘录和笔记。</p>
<p>首先是一些优化常识。针对图形方面的优化主要包括三角形数量，纹理所占内存，以及Shader，前两项基本没什么好讲的，针对设备机能的限制制定相应的指标即可，所以Shader就成为了图形性能优化的关键。</p>
<p>Alpha blending</p>
<p>在Unity官方文档中讲，由于硬件原因，在iOS设备上使用alpha-test会造成很大的性能开销，应尽量使用alpha-blend代替。这里提到，在同屏使用alpha-blend的面数，尤其是这些面所占屏幕面积的大小，对性能也会造成很大影响。原因是使用alpha-blend的面会造成overdraw的增加，这尤其对低性能设备的影响很大。不过没有购买Pro版，没有Occlusion Culling功能的话，就不必顾虑这一问题了，反正overdraw是必然的。</p>
<p>复杂的Per-pixel shader</p>
<p>Per-pixel shader即Fragment shader，顾名思义是要对每个渲染到屏幕上的像素做处理的shader，如果per-pixel shader比较复杂且需要处理的像素很多时，也就是使用该shader的面占屏幕面积很大时，对性能的影响甚至要超过alpha blending。因此复杂的per-pixel shader只适用于小物体。</p>
<p>下面是对几个Shader的逐一讲解：</p>
<p>Environment specular maps(Shader Virtual Gloss Per Vertex Additive)<br>Specular map通常都是利用贴图的alpha通道来定义物体表面的光滑程度（反光度），这个shader的特点是per-vertex计算反光度的，有着相当不错的效果的同时比per-pixel的shader性能要高得多。这个shader很适用于关卡环境等占很大区域的模型。</p>
<p>经过优化的动态角色光照和阴影(Light probes和BRDF Shader)<br>传统的Lightmaps无法支持动态物体，对此Unity提供了Light probes技术，预先把动态物体的光照信息保存在代理对象(即Light probes)中，运行时动态物体从距离最近的Probe中获取光照信息。</p>
<p>Unity本身还提供了一个效果非常棒的专为移动设备优化过的角色Shader，支持Diffuse、Specular和Normal maps，并通过一个特殊的脚本生成贴图用于模仿BRDF光照效果。最终产生的效果堪比次时代大作中的角色光影效果。</p>
<p>雾和体积光(Shader Blinking Godrays)<br>目前在移动设备上要开启真正的雾效基本不可行，ShadowGun的方案是通过简单的网格＋透明贴图(称为雾面)来模拟雾效。在玩家靠近时，雾面逐渐变淡，同时fog plane的顶点也会移开(即使完全透明的alpha面也会消耗很多渲染时间)。</p>
<p>使用这个Shader的网格需要经过处理：</p>
<p>顶点的alpha值用于决定顶点是否可以移动(在例子中0为不可动，1为可动)。<br>顶点法线决定移动的方向<br>然后Shader通过计算与观察者的距离来控制雾面的淡入/淡出。<br>这个Shader还可以用来做体积光和其它一些alpha效果。</p>
<p>飞机坠毁的浓烟效果(Shader Scroll 2 Layers Sine Alpha-blended)<br>通过粒子产生浓烟的代价太高，所以ShadowGun中使用了网格＋贴图动画来制作这个效果。通过混合两层贴图并让它们交错移动来产生动画效果。其中顶点alpha值用于让网格的边缘看起来比较柔和，同时使用顶点颜色来模拟从火焰到烟雾的过渡效果。</p>
<p>带动态效果的天空盒(Shader Scroll 2 Layers Multiplicative)<br>通过两张贴图的混合和移动产生云的动态效果。</p>
<p>旗帜和衣服的飘动效果(Shader Lightmap + Wind)<br>同样利用顶点alpha值决定哪些顶点可以移动，然后shader的参数用于调整摆动的方向和速度。</p>
<p>一、程序方面<br>　　1. 务必删除脚本中为空或不需要的默认方法；<br>　　2. 只在一个脚本中使用OnGUI方法；（最好不要加）<br>　 3. 避免在OnGUI中对变量、方法进行更新、赋值，输出变量建议在Update内；<br>　　4. 同一脚本中频繁使用的变量建议声明其为全局变量，脚本之间频繁调用的变量或方法建议声明为全局静态变量或方法；<br>　　5. 不要去频繁获取组件，将其声明为全局变量；<br>　　6. 数组、集合类元素优先使用Array，其次是List；<br>　　7. 脚本在不使用时脚本禁用之，需要时再启用；<br>　　8. 可以使用Ray来代替OnMouseXXX类方法；<br>　　9. 需要隐藏/显示或实例化来回切换的对象，尽量不要使用SetActiveRecursively或active，而使用将对象远远移出相机范围和移回原位的做法；<br>　　10. 尽量少用模运算和除法运算，比如a/5f，一定要写成a * 0.2f。<br>　　11. 对于不经常调用或更改的变量或方法建议使用Coroutines &amp; Yield；<br>　　12. 尽量直接声明脚本变量，而不使用GetComponent来获取脚本；<br>iPhone<br>　　13. 尽量使用整数数字，因为iPhone的浮点数计算能力很差；<br>　　14. 不要使用原生的GUI方法；<br>　　15. 不要实例化（Instantiate）对象，事先建好对象池，并使用Translate“生成”对象；<br>二、模型方面<br>　　1. 合并使用同贴图的材质球，合并使用相同材质球的Mesh；<br>　　2. 角色的贴图和材质球只要一个，若必须多个则将模型离分离为多个部分；<br>　　2. 骨骼系统不要使用太多；<br>　　3. 当使用多角色时，将动画单独分离出来；<br>　　4. 使用层距离来控制模型的显示距离；<br>　　5. 阴影其实包含两方面阴暗和影子，建议使用实时影子时把阴暗效果烘焙出来，不要使用灯光来调节光线阴暗。<br>　　6. 少用像素灯和使用像素灯的Shader；<br>　　7. 如果硬阴影可以解决问题就不要用软阴影，并且使用不影响效果的低分辨率阴影；<br>　　08、实时阴影很耗性能，尽量减小产生阴影的距离；<br>　　09、允许的话在大场景中使用线性雾，这样可以使远距离对象或阴影不易察觉，因此可以通过减小相机和阴影距离来提高性能；<br>　　10、使用圆滑组来尽量减少模型的面数；<br>　　11、项目中如果没有灯光或对象在移动那么就不要使用实时灯光；<br>　　12、水面、镜子等实时反射/折射的效果单独放在Water图层中，并且根据其实时反射/折射的范围来调整；<br>　　13、碰撞对效率的影响很小，但碰撞还是建议使用Box、Sphere碰撞体；<br>　　14、建材质球时尽量考虑使用Substance；<br>　　15、尽量将所有的实时反射/折射（如水面、镜子、地板等等）都集合成一个面；<br>　　16、假反射/折射没有必要使用过大分辨率，一般64<em>64就可以，不建议超过256</em>256；<br>　　17、需要更改的材质球，建议实例化一个，而不是使用公共的材质球；<br>　　18、将不须射线或碰撞事件的对象置于IgnoreRaycast图层；<br>　　19、将水面或类似效果置于Water图层<br>　　20、将透明通道的对象置于TransparentFX图层；<br>　　21、养成良好的标签（Tags）、层次（Hieratchy）和图层（Layer）的条理化习惯，将不同的对象置于不同的标签或图层，三者有效的结合将很方便的按名称、类别和属性来查找；<br>　　22、通过Stats和Profile查看对效率影响最大的方面或对象，或者使用禁用部分模型的方式查看问题到底在哪儿；<br>　　23、使用遮挡剔除（Occlusion Culling）处理大场景，一种较原生的类LOD技术，并且能够“分割”作为整体的一个模型。</p>
<p>三、其它<br>　　场景中如果没有使用灯光和像素灯，就不要使用法线贴图，因为法线效果只有在有光源（Direct Light/Point Light/Angle Light/Pixel Light）的情况下才有效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/12/C-Thread-Sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/12/C-Thread-Sync/" class="post-title-link" itemprop="url">C# 线程同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-12 14:26:42" itemprop="dateCreated datePublished" datetime="2018-04-12T14:26:42+08:00">2018-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h1><p>线程同步有：临界区、互斥区、事件、信号量四种方式</p>
<ol>
<li>临界区(Critical Section)：临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li>
<li>互斥量(Mutex)：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 </li>
<li>信号量(Semaphore)：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 </li>
<li>事件(Event)：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作</li>
</ol>
<h2 id="lock-关键字"><a href="#lock-关键字" class="headerlink" title="lock 关键字"></a>lock 关键字</h2><p>lock 关键字将语句块标记为临界区，方法是获取给定对象的互斥锁，执行语句，然后释放该锁。<br>lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p>
<h2 id="同步事件和等待句柄"><a href="#同步事件和等待句柄" class="headerlink" title="同步事件和等待句柄"></a>同步事件和等待句柄</h2><p>使用锁或监视器对于防止同时执行区分线程的代码块很有用，但是这些构造不允许一个线程向另一个线程传达事件。这需要“同步事件”，它是有两个状态（终止和非终止）的对象，可以用来激活和挂起线程。让线程等待非终止的同步事件可以将线程挂起，将事件状态更改为终止可以将线程激活。如果线程试图等待已经终止的事件，则线程将继续执行，而不会延迟。     </p>
<p>同步事件有两种：AutoResetEvent 和 ManualResetEvent。它们之间唯一的不同在于，无论何时，只要 AutoResetEvent 激活线程，它的状态将自动从终止变为非终止。相反，ManualResetEvent 允许它的终止状态激活任意多个线程，只有当它的 Reset 方法被调用时才还原到非终止状态。</p>
<p>等待句柄，可以通过调用一种等待方法，如WaitOne、WaitAny 或 WaitAll，让线程等待事件。System.Threading.WaitHandle.WaitOne使线程一直等待，直到单个事件变为终止状态；System.Threading.WaitHandle.WaitAny 阻止线程，直到一个或多个指示的事件变为终止状态；System.Threading.WaitHandle.WaitAll 阻止线程，直到所有指示的事件都变为终止状态。当调用事件的 Set 方法时，事件将变为终止状态。</p>
<p>AutoResetEvent 允许线程通过发信号互相通信。 通常，当线程需要独占访问资源时使用该类。线程通过调用 AutoResetEvent 上的 WaitOne 来等待信号。 如果 AutoResetEvent 为非终止状态，则线程会被阻止，并等待当前控制资源的线程通过调用 Set 来通知资源可用。调用 Set 向 AutoResetEvent 发信号以释放等待线程。 AutoResetEvent 将保持终止状态，直到一个正在等待的线程被释放，然后自动返回非终止状态。 如果没有任何线程在等待，则状态将无限期地保持为终止状态。如果当 AutoResetEvent 为终止状态时线程调用 WaitOne，则线程不会被阻止。 AutoResetEvent 将立即释放线程并返回到非终止状态。<br>可以通过将一个布尔值传递给构造函数来控制 AutoResetEvent 的初始状态：如果初始状态为终止状态，则为 true；否则为 false。<br>AutoResetEvent 也可以同 staticWaitAll 和 WaitAny 方法一起使用。</p>
<h2 id="WaitHandle-WaitOne"><a href="#WaitHandle-WaitOne" class="headerlink" title="WaitHandle.WaitOne()"></a>WaitHandle.WaitOne()</h2><p>阻止当前线程，直到当前的 WaitHandle 收到信号为止</p>
<h2 id="EventWaitHandle-Set"><a href="#EventWaitHandle-Set" class="headerlink" title="EventWaitHandle.Set()"></a>EventWaitHandle.Set()</h2><p>将事件状态设置为有信号，从而允许一个或多个等待线程继续执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/managed-code-unmanaged-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/managed-code-unmanaged-code/" class="post-title-link" itemprop="url">托管代码和非托管代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 19:39:27" itemprop="dateCreated datePublished" datetime="2018-04-11T19:39:27+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>托管代码是-Microsoft的中间语言(IL)，他主要作用是在.Net FRAMEWORK的公共语言运行库(CLR)执行代码前去编译源代码，也就是说托管代码充当着翻译的作用，源代码在运行时分为两个阶段：</p>
<ol>
<li>源代码编译为托管代码，(所以源代码可以有很多种，如VB,C#,J#)</li>
<li>托管代码编译为Microsoft的平台专用语言</li>
</ol>
<p>编译器把代码编译成中间语言(IL),而不是能在你的电脑上运行的机器码。中间语言被封装在一个叫程序集(Assembly)的文件中，程序集中包含了描述你所创建的类，方法和属性(例如安全需求)的所有元数据。你可以拷贝这个程序集到另一台服务器上部署它。</p>
<p>托管代码在公共语言运行库(CLR)中运行。这个运行库给你的运行代码提供各种各样的服务，通常来说，他会加载和验证程序集，以此来保证中间语言的正确性</p>
<ol>
<li>托管代码是一种中间语言，运行在CLR上；<br>非托管代码被编译为机器码，运行在机器上</li>
<li>托管代码独立于平台和语言，能更好的实现不同语言平台之间的兼容；<br>非托管代码依赖于平台和语言。</li>
<li>托管代码可享受CLR提供的服务（如安全检测，垃圾回收），不需要自己完成这些操作<br>非托管代码需要自己提供安全检测、垃圾回收等操作。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/AssetBundle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/AssetBundle/" class="post-title-link" itemprop="url">Unity加载和内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 17:16:57" itemprop="dateCreated datePublished" datetime="2018-04-11T17:16:57+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Unity有两种动态加载机制：Resources.Load和AssetBundle，二者本质并无区别。Resources.Load就是从一个缺省打进程程序包的AssetBundle(Resourece)里加载资源，而一般AssetBundle文件需要你自己创建，运行时加载。</p>
<h1 id="AssetBundle加载基础"><a href="#AssetBundle加载基础" class="headerlink" title="AssetBundle加载基础"></a>AssetBundle加载基础</h1><p>通过AssetBunlde加载资源，分为两步，第一步是获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细地描述。</p>
<h2 id="第一步，获取AssetBundle对象常用地API"><a href="#第一步，获取AssetBundle对象常用地API" class="headerlink" title="第一步，获取AssetBundle对象常用地API"></a>第一步，获取AssetBundle对象常用地API</h2><h3 id="方式一，先获取WWW对象，再通过WWW-assetBundle获取AssetBundle对象："><a href="#方式一，先获取WWW对象，再通过WWW-assetBundle获取AssetBundle对象：" class="headerlink" title="方式一，先获取WWW对象，再通过WWW.assetBundle获取AssetBundle对象："></a>方式一，先获取WWW对象，再通过WWW.assetBundle获取AssetBundle对象：</h3><pre><code>public WWW(string uri);
</code></pre><p>加载Bundle文件并获取WWW对象，完成后会在内存中创建较大地WebStream(解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大),因此后续的AssetBundle.Load可以直接在内存中进行。</p>
<pre><code>public static WWW LoadFromCacheOrDownload(string uri, int version, unit crc = 0);
</code></pre><p>加载Bundle文件并获取WWW对象，同时将解压形式的Bundle内容存入磁盘中作为缓存（如果该Bundle已在缓存中，则省去这一步），完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中的缓存获取。</p>
<pre><code>public AssetBundle assetBundle;
</code></pre><p>通过之前两个接口获取WWW对象后，即可通过WWW.assetBundle获取AssetBundle对象。</p>
<h3 id="方式二，直接获取AssetBundle"><a href="#方式二，直接获取AssetBundle" class="headerlink" title="方式二，直接获取AssetBundle:"></a>方式二，直接获取AssetBundle:</h3><pre><code>public static AssetBundle LoadFromFile(string path); 
public static AssetBundle LoadFromFileAsync(string path);
</code></pre><p>通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中获取。<br>如果AssetBundle是未压缩，或者是数据块形式（LZ4算法压缩）的，LoadFromFile将从磁盘中直接加载它。如果AssetBundle是高度压缩(LZMA算法压缩)的，再将它加载进入内存前，会首先将它解压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void LoadAssetBundles(string baseDir)</span><br><span class="line">&#123;</span><br><span class="line">    if (assetBundleInfos != null)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; assetBundleInfos.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var bInfo = assetBundleInfos[i];</span><br><span class="line">            if (bInfo.assetBundle != null)</span><br><span class="line">            &#123;</span><br><span class="line">                bInfo.assetBundle.Unload(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assetBundleInfos = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var abInfos = new List&lt;AssetBundleInfo&gt;(50);</span><br><span class="line"></span><br><span class="line">    var files = Directory.GetFiles(m_dir_update, &quot;*.bytes&quot;);</span><br><span class="line">    for (int i = 0; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string f = files[i];</span><br><span class="line">        string n = Path.GetFileName(f);</span><br><span class="line">        if (!CheckABName(abInfos, n)) contine;</span><br><span class="line"></span><br><span class="line">        abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (baseDir != null)</span><br><span class="line">    &#123;</span><br><span class="line">        files = Directory.GetFiles(baseDir, &quot;*.bytes&quot;);</span><br><span class="line">        for (int i = 0; i &lt; files.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string f = files[i];</span><br><span class="line">            string n = Path.GetFileName(f);</span><br><span class="line">            if (!CheckABName(abInfos, n)) continue;</span><br><span class="line"></span><br><span class="line">            abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files = LoadConfigLines(&quot;res_idx&quot;);</span><br><span class="line">    for (int i = 0; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string n = files[i].Trim();</span><br><span class="line">        if (!CheckABName(abInfos, n)) continue;</span><br><span class="line"></span><br><span class="line">        string f = streamAssetsPath + n;</span><br><span class="line">        abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (abInfos.Count == 0) return;</span><br><span class="line"></span><br><span class="line">    string prefix = &quot;assets/res/&quot;;</span><br><span class="line">    int cprefix = prefix.Length;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; abInfos.Count;)</span><br><span class="line">    &#123;</span><br><span class="line">        var abInfo = abInfos[i];</span><br><span class="line">        var ab = AssetBundle.LoadFromFile(abInfo.uri);</span><br><span class="line">        if (ab == null)</span><br><span class="line">        &#123;</span><br><span class="line">            abInfos.RemoveAt(i);</span><br><span class="line">            sbError.Append(&quot;\nfail ab : &quot;);</span><br><span class="line">            sbError.Append(abInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>public static AssetBundle LoadFromMemory(byte[] binary)
</code></pre><p>通过Bundle的二进制数据，异步创建AssetBundle对象，完成后会在内存中创建较大的WebStream。调用时，Bundle的解压是异步进行的，因此对于未压缩的Bundle文件，该接口于LoadFromMemoryAsync是等价的。</p>
<pre><code>public static AssetBundle LoadFromMemoryAsync
</code></pre><p>该接口是 CreateFromMemory 的同步版本，这个方法的参数是包含了AssetBundle数据的字节数组。如果需要的话，你还可以传入一个CRC(循环冗余校验码)参数。如果AssetBundle使用了LZMA算法压缩，那么AssetBundle在加载的时候会被解压。如果AssetBundle使用了LZ4算法压缩，它将直接以压缩形式被加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator LoadFromMemoryAsync(string path)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">    yield return createRequest;</span><br><span class="line">    AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">    var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);</span><br><span class="line">    Instantiate(prefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二步，从AssetBundle加载资源的常用API"><a href="#第二步，从AssetBundle加载资源的常用API" class="headerlink" title="第二步，从AssetBundle加载资源的常用API"></a>第二步，从AssetBundle加载资源的常用API</h2><pre><code>public Object Load(string name, Type type);
</code></pre><p>通过给定的名字和资源类型，加载资源。加载时会自动加载其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。</p>
<pre><code>public Object[] LoadAll(Type type);
public AssetBundleRequest LoadAllAssetsAsync();
</code></pre><p>一次性加载Bundle中给定资源类型的所有资源</p>
<pre><code>public AssetBundleRequest LoadAsync(string name, Type type)
</code></pre><h3 id="AssetBundle的压缩类型"><a href="#AssetBundle的压缩类型" class="headerlink" title="AssetBundle的压缩类型"></a>AssetBundle的压缩类型</h3><p>Unity3D引擎为我们提供了三种压缩策略来处理AssetBundle的压缩，即：</p>
<ul>
<li>LZMA格式</li>
<li>LZ4格式</li>
<li>不压缩</li>
</ul>
<blockquote>
<p>LZ4是块压缩(chunk-based)，LZMA是流压缩(stream-based)。流压缩(LZMA)在处理整个数据块时使用同一个字典，它提供了最大可能的压缩率但只支持顺序读取。块压缩(LZ4)指的是原始数据被分成大小相同的子块并单端压缩。如果你想要实时解压/随机读取开销小，则应该使用这种。</p>
<p>LZMA压缩方式的优点在于使用同一个字典压缩率较高，但只能顺序读取意味着加载任意一个资源时，都需要将整个AssetBundle解压，造成卡顿和额外内存占用。LZ4基于快压缩率较低（测试LZMA换LZ4：86.9M-&gt;108M），但只需解压需要块即可，不会有大的卡顿和额外内存占用。</p>
</blockquote>
<h4 id="LZMA-stream-based"><a href="#LZMA-stream-based" class="headerlink" title="LZMA(stream-based)"></a>LZMA(stream-based)</h4><p>在默认情况下，打包生成的AssetBundle都会被压缩。在U3D中，AssetBundle的标准压缩格式便是LZMA（LZMA是一种序列化流文件），因此在默认情况下，打出的AssetBundle包处于LZMA格式的压缩状态。</p>
<h4 id="LZ4-chunk-based"><a href="#LZ4-chunk-based" class="headerlink" title="LZ4(chunk-based)"></a>LZ4(chunk-based)</h4><p>Unity 5.3之后的版本增加了LZ4格式压缩，是一种块压缩方式，由于LZ4的压缩比一般，因此经过压缩之后的AssetBundle包体的体积较大（该算法基于chunk）。但是，使用LZ4格式的好处在于解压缩的时间相对要短。</p>
<p>使用LZ4格式压缩，需要打包设置</p>
<pre><code>BuildPipeline.BuildAssetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.ChunkBasedCompression);
</code></pre><h4 id="不压缩"><a href="#不压缩" class="headerlink" title="不压缩"></a>不压缩</h4><p>当然，我们也可以不对AssetBundle进行压缩。没有经过压缩的胞体系最大，但是访问速度最快。</p>
<p>若要使用不压缩的策略，只需要在打包的时候开启</p>
<pre><code>BuildPipeline.BuildAsetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.UncompressedAssetBundle);
</code></pre><h1 id="五-AssetBundle原理分析"><a href="#五-AssetBundle原理分析" class="headerlink" title="五 AssetBundle原理分析"></a>五 AssetBundle原理分析</h1><h2 id="5-2-AssetBundle及Assets的卸载"><a href="#5-2-AssetBundle及Assets的卸载" class="headerlink" title="5.2 AssetBundle及Assets的卸载"></a>5.2 AssetBundle及Assets的卸载</h2><p>在AssetBundle的下载和加载过程中，以及Assets加载和实例化过程中，AssetBundle以及加载的Assets都会占用内存。</p>
<ol>
<li>AssetBundle的卸载采用Assetbundle.Unload(bool)接口。</li>
<li>Assets的卸载有两种方式:<ul>
<li>AssetBundle.Unload(true); // 这会强制卸载掉所有从AssetBundle加载的Assets。</li>
<li>Resource.UnloadUnusedAssets()和Resources.UnloadAsset。这会卸载掉所有没有用到的Assets。需要注意的是，该接口作用于整个系统，而不仅仅是当前的AssetBundle，而且不会卸载从当前AssetBundle文件中加载并仍在使用的Assets。</li>
</ul>
</li>
<li>对于实例化出来的对象，可以使用GameObject.Destroy活GameObject.DestroyImmediate。注意的是：官方说法是这样的，如果使用GameObject.Destroy接口，Unity会将真正的删除操作延后到一个合适的时机统一进行处理，但会在渲染之前。</li>
</ol>
<p>对于WWW对象，可以使用www=null或www.dispose。<br>这两者是由区别的，www=null不会立即释放内存，而是系统自动回收机制启动时回收。www.dispose则会立即调用系统的回收机制来释放内存。当WWW对象被释放后，其对于Web Stream数据的引用计数也会相应减1。</p>
<p>对于Web Stream数据，它所占用的内存会在其引用计数为0时，被系统自动回收。例如：当上图中的AssetBundle对象和WWW对象被释放后，Web Stream数据所占内存也会被系统自动回收。</p>
<h1 id="AssetBundle依赖加载"><a href="#AssetBundle依赖加载" class="headerlink" title="AssetBundle依赖加载"></a>AssetBundle依赖加载</h1><p>如果一个或者多个UnityEngine.Objects引用了其他AssetBundle中的UnityEngine.Object，那么AssetBundle之间就产生了依赖关系了。如果UnityEngine.ObjectA所引用的UnityEngine.ObjectB不是其他的AssetBundle中的，那么依赖就不会产生。<br>如果产生依赖，被依赖对象(UnityEngine.ObjectB)将被拷贝进你创建的AssetBundle(指包含UnityEngine.ObjectA的AssetBundle)</p>
<p>更近一步，如果有多个对象(UnityEngine.ObjectA1、UnityEngine.ObjectA2、UnityEngine.ObjectA3…)引用了同一个被依赖对象(UnityEngine.ObjectB)，那么被依赖对象将被拷贝多份，打包进各个对象各自的AssetBundle。</p>
<p>如果一个AssetBundle存在依赖性，那么要注意的是，那些包含了被依赖对象的AssetBundles，需要在你想要实例化的对象的加载之前加载。Unity不会自动帮你加载这些依赖。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/Unity-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/Unity-Note/" class="post-title-link" itemprop="url">Unity3D中自带事件函数的执行顺序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 16:16:30" itemprop="dateCreated datePublished" datetime="2018-04-11T16:16:30+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Unity3D继承自MonoBehavior的脚本中，有几个Unity3D自带的事件函数按照预定的顺序作为脚本执行。其执行顺序如下：</p>
<h1 id="编辑器（Editor）"><a href="#编辑器（Editor）" class="headerlink" title="编辑器（Editor）"></a>编辑器（Editor）</h1><ul>
<li><strong>Reset</strong>：Reset函数被调用来初始化脚本属性当脚本第一次被附到对象上，并且在Reset命令被使用时也会调用。Reset是在用户点击Inspector面板上Reset按钮或者首次添加该组件时被调用。Reset最常用于在检视面板中给定一个默认值。</li>
</ul>
<h1 id="第一次场景加载（First-Scene-Load）"><a href="#第一次场景加载（First-Scene-Load）" class="headerlink" title="第一次场景加载（First Scene Load）"></a>第一次场景加载（First Scene Load）</h1><p>这些函数会在一个场景开始（场景中每个物体只调用一次）时被调用。</p>
<ul>
<li><strong>Awake</strong>：这个函数总是在任何<code>Start()</code>函数之前一个预设被实例化之后调用，如果一个GameObject是非激活的(inactive)，在启动期间Awake函数是不会被调用的直到它是活动的(active)。</li>
<li><strong>OnEnable</strong>：只有在对象激活(active)状态下才会被调用，这个函数只有在object被启动(enable)后才调用。这会发生在一个MonoBehavior实例被创建，例如当一个关卡被加载或者一个带有脚本组件的GameObject被实例化。</li>
</ul>
<p>注意：当一个场景被添加到场景中，所有脚本上的Awake()和OnEnable()函数将会被调用在Start()、Update()等它们中任何函数被调用之前。自然的，当一个物体在游戏过程中被实例化时这不能被强制执行。</p>
<h1 id="第一帧更新之前（Before-the-first-frame-update）"><a href="#第一帧更新之前（Before-the-first-frame-update）" class="headerlink" title="第一帧更新之前（Before the first frame update）"></a>第一帧更新之前（Before the first frame update）</h1><ul>
<li><strong>Start</strong>：只有在脚本被启用了Start()函数将会在Update()函数第一帧之前被调用。对于那些被添加到场景中的物体，所有脚本上的Start()函数将会在它们中任何的Update()函数之前被调用，当一个物体在游戏过程中被实例化时这不能被强制执行。</li>
</ul>
<h1 id="在帧之间（In-between-frames）"><a href="#在帧之间（In-between-frames）" class="headerlink" title="在帧之间（In between frames）"></a>在帧之间（In between frames）</h1><ul>
<li><strong>OnApplicationPause</strong>：这个函数将会被调用在暂停被检测有效的在正常的帧更新之间的一帧的结束时。在OnApplicationPause被调用后将会有额外的一帧用来允许游戏显示图像表示在暂停状态下。</li>
</ul>
<h1 id="更新顺序（Update-Order）"><a href="#更新顺序（Update-Order）" class="headerlink" title="更新顺序（Update Order）"></a>更新顺序（Update Order）</h1><p>当你在跟踪游戏逻辑和状态，动画，相机位置等的时候，有几个不同的事件函数你可以使用。常见的模式是在Update()函数中执行大多数人物，但是也有其它的函数你可以使用。</p>
<ul>
<li><strong>FixedUpdate</strong>：<strong>常被用作逻辑Tick函数</strong>，FixedUpdate函数经常会比Update函数更频繁的被调用。它一帧会被调用多次，如果帧率低它可能不会在帧之间被调用，就算帧率是高的。所有的图形计算和更新在FixedUpdate之后会立即执行。当在FixedUpdate里执行移动计算，你并不需要Time.deltaTime乘以你的值，这是因为FixedUpdate是按真实时间，独立于帧被调用的。</li>
<li><strong>Update</strong>：Update每一帧都会被调用，对于帧更新它是主要的负荷函数。</li>
<li><strong>LateUpdate</strong>：LateUpdate会在Update结束之后每一帧被调用，任何计算在Update里执行结束当LateUpdate开始时。LateUpdate常被为第三人称视角相机跟随。</li>
</ul>
<h1 id="渲染（Rendering）"><a href="#渲染（Rendering）" class="headerlink" title="渲染（Rendering）"></a>渲染（Rendering）</h1><ul>
<li><strong>OnPreCull</strong>：在相机剔除场景前被调用。剔除是取决于哪些物体对于摄像机是可见的，OnPreCull尽在剔除起作用之前被调用。</li>
<li><strong>OnBecameVisible/OnBecameInvisible</strong>：当一个物体对任意摄像机变得可见/不可见时被调用。</li>
<li><strong>OnPreRender</strong>：在摄像机开始渲染场景之前被调用。</li>
<li><strong>OnRenderObject</strong>：在指定场景渲染完成之后调用，你可以使用GL类或者Graphics.DrawMeshNow来绘制自定义几何体在这里。</li>
<li><strong>OnPostRender</strong>：在摄像机完成渲染之后调用。</li>
<li><strong>OnRenderImage(Pro Only)</strong>：在场景渲染完成之后允许屏幕图像后期处理调用。</li>
<li><strong>OnGUI</strong>：为了响应GUI事件，每帧会被调用多次（一般最低两次）。布局Layout和Repaint事件会首先处理，接下来是通过Layout和键盘/鼠标事件对应的每个输入事件。</li>
<li><strong>OnDrawGizmos</strong>：用于可视化的绘制一些小玩意在场景视图中。</li>
</ul>
<h1 id="协同程序（Corotines）"><a href="#协同程序（Corotines）" class="headerlink" title="协同程序（Corotines）"></a>协同程序（Corotines）</h1><p>正常的协同程序更新是在Update函数饭回之后运行。一个协同程序是可以暂停执行(yield)直到给出的依从指令（YieldInstruction）完成，携程的不同运用。</p>
<ul>
<li><strong>yield</strong>：在所有的Update函数都已经被调用的下一帧该协程将持续执行。</li>
<li><strong>yield WaitForSeconds</strong>：一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后。</li>
<li><strong>yield WaitForFixedUpdate</strong>：所有脚本上的FixedUpdate函数已经执行调用之后持续。</li>
<li><strong>yield WWW</strong>：在WWW下载完成之后持续。</li>
<li><strong>yield StartCoroutine</strong>：协同程序链，将会等到MuFunc函数协程执行完成首先。</li>
</ul>
<h1 id="销毁（When-the-Object-is-Destroyed）"><a href="#销毁（When-the-Object-is-Destroyed）" class="headerlink" title="销毁（When the Object is Destroyed）"></a>销毁（When the Object is Destroyed）</h1><ul>
<li><strong>OnDestroy</strong>：这个函数会在一个对象销毁前一帧调用，会在所有帧更新一个对象存在的最后一帧之后执行，对象也许会响应Object.Destroy或一个场景关闭时被销毁。</li>
</ul>
<h1 id="退出游戏（When-Quitting）"><a href="#退出游戏（When-Quitting）" class="headerlink" title="退出游戏（When Quitting）"></a>退出游戏（When Quitting）</h1><p>这些函数会在你场景中所有的激活的物体上调用：</p>
<ul>
<li><strong>OnApplicationQuit</strong>：这个函数在应用退出之前的所有游戏物体上调用，在编辑器（Editor）模式中会在用户停止PlayMode时调用，在网页播放器（web Player）中会在网页视图关闭时调用。</li>
<li><strong>OnDisable</strong>：当行为变为非启用(disable)或非激活（inactive）时调用。</li>
</ul>
<h1 id="脚本的生命周期流程图"><a href="#脚本的生命周期流程图" class="headerlink" title="脚本的生命周期流程图"></a>脚本的生命周期流程图</h1><img src="/2018/04/11/Unity-Note/1.png">
<p>在Update中使用Time.deltaTime，获取到的是这一帧的时间，如果游戏卡，帧率低，那这个值就大。如果游戏流畅，帧率高，这个值就小，Time.deltaTime=1.0f/帧率</p>
<ol>
<li><p>MonoBehaviour.Update 更新渲染帧<br>当MonoBehaviour启用时，其Update在每一帧被调用。</p>
</li>
<li><p>MonoBehaviour.FixedUpdate 固定更新逻辑帧<br>当MonoBehaviour启用时，其 FixedUpdate在每一帧被调用。<br>处理Rigidbody时，需要用FixedUpdate代替Update。例如：给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧(两者帧长不同)。</p>
</li>
<li><p>MonoBehaviour.LateUpdate 晚于更新渲染帧末尾<br>当Behaviour启用时，其LateUpdate在每一帧被调用。<br>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。</p>
</li>
</ol>
<h1 id="Update和FixedUpdate的区别"><a href="#Update和FixedUpdate的区别" class="headerlink" title="Update和FixedUpdate的区别"></a>Update和FixedUpdate的区别</h1><p>Update跟当前平台的帧数有关，而FixedUpdate是CPU tick 的时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update。<br>Update是在每次渲染新的一帧的时候才会调用，也就是说，这个函数的更新频率和设备的性能有关以及被渲染的物体（可以认为是三角形的数量）。在性能好的机器上可能fps 30，差的可能小些。这会导致同一个游戏在不同的机器上效果不一致，有的快有的慢。因为Update的执行间隔不一样了。<br>而FixedUpdate，是在固定的时间间隔执行，不受游戏帧率的影响。有点像Tick。所以处理Rigidbody的时候最好用FixedUpdate。</p>
<p>FixedUpdate的时间间隔可以在项目设置中更改，Edit-&gt;ProjectSetting-&gt;time  找到Fixedtimestep。就可以修改了。</p>
<h1 id="Update和LateUpdate的区别"><a href="#Update和LateUpdate的区别" class="headerlink" title="Update和LateUpdate的区别"></a>Update和LateUpdate的区别</h1><p>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如：当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。<br>LateUpdate是晚于所有Update执行的。例如：游戏中有2个脚步，脚步1含有Update和LateUpdate，脚步2含有Update，那么当游戏执行时，每一帧都是把2个脚步中的Update执行完后才执行LateUpdate 。虽然是在同一帧中执行的，但是Update（渲染帧）会先执行，LateUpdate（渲染帧末尾）会晚执行。<br>现在假设有2个不同的脚本同时在Update中控制一个物体，那么当其中一个脚本改变物体方位、旋转或者其他参数时，另一个脚步也在改变这些东西，那么这个物体的方位、旋转就会出现一定的反复。如果还有个物体在Update中跟随这个物体移动、旋转的话，那跟随的物体就会出现抖动。 如果是在LateUpdate中跟随的话就会只跟随所有Update执行完后的最后位置、旋转，这样就防止了抖动。</p>
<h1 id="影响渲染顺序因素地总结"><a href="#影响渲染顺序因素地总结" class="headerlink" title="影响渲染顺序因素地总结"></a>影响渲染顺序因素地总结</h1><ol>
<li>Camrea Depth 相机组件上设置的相机深度，深度越大越靠后渲染。</li>
<li>Sorting Layer 在Tags &amp; Layers设置中可见。</li>
<li>Order In Layer 相当于Sorting Layer的子排序，用这个值做比较时只有都在同一层时才有效。</li>
<li>RenderQueue Shader中对Tags设置的”Queue”</li>
</ol>
<p>Camera Depth永远最高。Camera Depth小的一定先进渲染管线。<br>当Sorting Layer和Order in Layer相同时<br>RenderQueue小的先进渲染管线。</p>
<p>当Sorting Layer和Order In Layer不相同时！<br>当两个材质使用了不同的RenderQueue,且这两个RenderQueue都在[0~2500]或[2501~5000]时，SortingLayer和OrderInLayer的排序生效。<br>当两个材质使用了不同的RenderQueue,且这两个RenderQueue分别再[0~2500]或[2501~5000]时，则一定会按照RenderQueue绘制，无视SortingLayer,OrderInLayer的排序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/constraint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/constraint/" class="post-title-link" itemprop="url">约束</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 13:51:35" itemprop="dateCreated datePublished" datetime="2018-04-11T13:51:35+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>T:struct</td>
<td>类型参数必须是值类型。可以指定除Nullable以外的任何值类型。</td>
</tr>
<tr>
<td>T:class</td>
<td>类型参数必须是引用类型，包括任何类、接口、委托或数组类型。</td>
</tr>
<tr>
<td>T:new()</td>
<td>类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new()约束必须最后指定。</td>
</tr>
<tr>
<td>T:&lt;接口名称&gt;</td>
<td>类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</td>
</tr>
<tr>
<td>T:U</td>
<td>为T提供的类型参数必须是为U提供的参数或派生自为U提供的参数。这称为螺类型约束。</td>
</tr>
</tbody>
</table>
</div>
<pre><code>public class MyGenericClass&lt;T&gt; where T:IComparable {}

class MyClassy&lt;T, U&gt;
where T : class
where U : struct 
{}

public class MyGenericClass&lt;T&gt; where T: IComparable, new()
{
    T item = new T();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface MyI &#123;&#125;</span><br><span class="line">class Dictionary&lt;TKey, TVal&gt;</span><br><span class="line">where TKey: IComparable, IEnumerable</span><br><span class="line">where TVal: MyI</span><br><span class="line">&#123;</span><br><span class="line">    public void Add(Tkey key, TVal val)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>public bool MyMethod&lt;T&gt; (T t) where T: IMyInterface {}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class List&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    void Add&lt;U&gt;(List&lt;U&gt; items) where U: T </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>default</p>
<p>之所以会用到default关键字，是因为需要在不知道类型参数为值类型还是引用类型的情况下，为对象实例赋初值。</p>
<p>```<br>class TestDefault<t><br>{<br>    public T foo()<br>    {<br>        return default(T);<br>    }<br>}</t></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/23-Design-Patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/23-Design-Patterns/" class="post-title-link" itemprop="url">23种设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 13:37:36" itemprop="dateCreated datePublished" datetime="2018-04-11T13:37:36+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>设计模式分为三大类：<br>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介模式、解释器模式。<br>其实还有两类：并发型模式和线程池模式。</p>
<p>设计模式六大原则：<br>总原则-开闭原则<br>对扩展开放，对修改封闭。在程序需要进行扩展的时候，不能去修改原有的代码，而是扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。<br>想要达到这样的效果，外面需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p>
<p>1、单一职责原则<br>不要存在多余一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p>
<p>2.里氏替换原则(Liskov Substitution Principle)<br>任何积累可以出现的地方，子类一定可以出现</p>
<p>6.合成复用原则(Composite Reuse Principle)<br>尽量首先使用合成/聚合的方式，而不是使用继承。</p>
<h1 id="单线程单例模式"><a href="#单线程单例模式" class="headerlink" title="单线程单例模式"></a>单线程单例模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton // 密封防止继承</span><br><span class="line">&#123;</span><br><span class="line">    private static Singleton uniqueInstance; // 唯一的实例</span><br><span class="line"></span><br><span class="line">    // 私有构造函数外部无法创建实例</span><br><span class="line">    private Singleton()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 全局唯一访问点</span><br><span class="line">    public static Singleton GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (uniqueInstance == null)</span><br><span class="line">        &#123;</span><br><span class="line">            uniqueInstance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单线程单例模式的几个要点：</p>
<ol>
<li>Singleton模式的实例构造器可以设置为protected以允许子类派生。</li>
<li>Singleton模式一般不要ICloneable接口，因为这可能会导致多个对象实例，与Singleton模式的初衷违背。</li>
<li>Singleton模式一般不要支持序列化，因为这也有可能导致多个对象实例，同样与Singleton模式的初衷违背。</li>
<li>Singleton模式只考虑到了对象创建的工作，没有考虑到对象效果的工作。全局静态的放到托管堆中还可以接受？</li>
<li>不能应对多线程环境，在多线程环境下，使用Singleton模式仍然有可能得到Singleton类的多个实例对象。</li>
</ol>
<h1 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h1><h2 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public enum FruitKind</span><br><span class="line">&#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Pear,</span><br><span class="line">&#125;</span><br><span class="line">public interface Fruit</span><br><span class="line">&#123;</span><br><span class="line">    void WhatIm();</span><br><span class="line">&#125;</span><br><span class="line">public class Apple : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pear : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am pear&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FruitFactory</span><br><span class="line">&#123;</span><br><span class="line">    public static Fruit CreateFruit(FruitKind type)</span><br><span class="line">    &#123;</span><br><span class="line">        switch(type)</span><br><span class="line">        &#123;</span><br><span class="line">            case FruitKind.Apple:</span><br><span class="line">                return new Apple();</span><br><span class="line">            case FruitKind.Pear:</span><br><span class="line">                return new Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Fruit a = FruitFactory.CreateFruit(FruitKind.Pear);</span><br><span class="line">        a.WhatIm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不太喜欢损失性能和不容易看到内部的逻辑，所以上述不太喜欢。上述存在一个问题，产品内部随便折腾没啥问题，但是做一个新的产品就蛋疼了。</p>
<h2 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h2><ol>
<li>抽象产品类</li>
<li>具体产品类</li>
<li>抽象工厂类</li>
<li>具体工厂类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public enum FruitKind</span><br><span class="line">&#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Pear,</span><br><span class="line">&#125;</span><br><span class="line">public interface Fruit</span><br><span class="line">&#123;</span><br><span class="line">    void WhatIm();</span><br><span class="line">&#125;</span><br><span class="line">public class Apple : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pear : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am pear&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface FruitFactory</span><br><span class="line">&#123;</span><br><span class="line">    Fruit CreateFruit();</span><br><span class="line">&#125;</span><br><span class="line">public class PearFactory : FruitFactory</span><br><span class="line">&#123;</span><br><span class="line">    public Fruit CreateFruit()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码解耦了，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/Interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/Interface/" class="post-title-link" itemprop="url">面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 13:30:35" itemprop="dateCreated datePublished" datetime="2018-04-11T13:30:35+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接口(Interface)是一种规划，为你定义了一系列的规则和任务，但不去实现它<br>类和结构体可以继承多个接口<br>抽象类表示该类中可能已经有一些的具体定义<br>生成的库在这里：</p>
<pre><code>Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so
</code></pre><p>符号表在这里，需要把扩展名弄成.so，才能被bugly的符号工具转换。</p>
<pre><code>Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so.debug
</code></pre><p>C++代码生成到这里，最好保存这个目录，以便对应看调用栈：</p>
<pre><code>Temp\StagingArea\Il2Cpp\il2cppOutput
</code></pre><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>会把所有插入其中的数据都当成了object类型来处理。<br>弊端：1、不是类型安全的；2、存在装箱拆箱操作<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Add() <span class="comment">//向数组中添加一个元素</span></span><br><span class="line">Remove() <span class="comment">//删除数组中的一个元素</span></span><br><span class="line">RemoveAt(<span class="keyword">int</span> i);<span class="comment">//</span></span><br><span class="line"><span class="comment">//不是骨骼动画,可以用animator,/</span></span><br><span class="line"><span class="comment">//骨骼动画 animator只能用一个,</span></span><br><span class="line">Reverse()<span class="comment">//反转数组的元素</span></span><br><span class="line">Sort()<span class="comment">//从小到大排序数组的元素</span></span><br><span class="line">Clone()<span class="comment">//复制一个数组</span></span><br><span class="line"><span class="comment">//List</span></span><br><span class="line"><span class="comment">//可通过索引访问</span></span><br></pre></td></tr></table></figure></p>
<p>在决定使用List还是使用ArrayList 类(两者具有类似的功能)时,记住List类在大多数情况下执行的更好并且是类型安全的,<br>如果对List类型T使用值类型,则需要考虑实现和装箱问题<br>如果对类型T实用值类型,则编译器将特别针对该值类型生成List类的实现,这意味着不必对<br>再提醒一下，模板容器里不要使用枚举。<br>比如Dictionary之类的，枚举会boxing，产生无用的GC<br>就用int替代吧</p>
<ol>
<li>请描述游戏动画有哪几种，以及其原理。<br>答:主要有关节动画,单一网络模型动画(关键帧动画),骨骼动画.<br>关节动画把角色分为若干独立部分,一个部分对应一个网络模型,部分的动画连接成一个整体的动画,角色比较灵活Quake2中实用了这种动画.<br>单一网络模型动画由一个完整的网络模型构成,在动画序列的关键帧里记录各个顶点的原位置及其改变量,然后插值运算实现动画效果,角色动画较真实.<br>骨骼动画,广泛应用的动画方式,集成了以上两个方式的优点,骨骼按角色特点组成一定的层次结构,由关节相连,可做相对运动,皮肤作为单一网络蒙在骨骼之外,决定角色的外观,皮肤网络每一个顶点都会收到骨骼的影响,从而实现完美的动画.</li>
</ol>
<h1 id="alpha-blend-工作原理"><a href="#alpha-blend-工作原理" class="headerlink" title="alpha blend 工作原理"></a>alpha blend 工作原理</h1><p>alpha blend用于做半透明效果.Color=(源颜色 <em> 源系数)OP(目标颜色 </em> 目标系数);其中OP(混合方式)有加,减,反减,取最小,取最大</p>
<h2 id="OpenGL-Alpha混合"><a href="#OpenGL-Alpha混合" class="headerlink" title="OpenGL Alpha混合"></a>OpenGL Alpha混合</h2><p>假设一种不透明的东西的颜色是A，另一种透明的东西颜色是B，那么透过B看A，看上去的颜色C就是B和A的混合颜色，可以用以下公式来模拟，设B物体的透明度为alpha（取值为0-1，0为完全透明，1为完全不透明）</p>
<pre><code>R(C)=alpha*R(B)+(1-alpha)R(A)
G(C)=alpha*G(B)+(1-alpha)G(A)
B(C)=alpha*B(B)+(1-alpha)G(A)
</code></pre><ol>
<li><p>写光照计算中的diffuse的计算公式<br>答:漫反射光(diffuse)计算公式为:ldiffuse = Dintensity<em>Dcolor</em>N.L;(Dintensity)表示漫反射强度,Dcolor表示漫反射光颜色,N为该点的法向量,L为光源向量<br>其他,3D渲染中,物体表面的光照计算公式为:<br>I = 环境关(lambient) + 漫反射光(ldiffuse) + 镜面高光(lspecular);<br>其中,环境光(ambient)计算公式为:</p>
<p> lambient = Aintensity*Acolor;(Aintensity)表示环境光强度,Acolor表示环境光颜色</p>
</li>
</ol>
<p>镜面高光(specular)计算公式为:<br>lspecular = Sintensity<em>Scolor</em>(R.V)n;(Sintensity)表示镜面光照强度,Scolor表示镜面光颜色,R为光的反射向量,V为观察者向量</p>
<ol>
<li>MipMap是什么？作用？<br>答:在三维计算机图形的贴图渲染中有一个常用的技术成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为mipmap</li>
<li>用u3d实现2d游戏，有几种方式？<br>答：一种用UI实现(GUI,NGUI…)，一种是采用3d实体对象（plane），绘制在3d对象上，调节摄像机，采用平行投影模式或则固定视角。</li>
<li>u3d中碰撞器和触发器的区别？<br>答：触发器只是碰撞器身上的一个属性，碰撞器是触发器的载体。</li>
<li>物体发生碰撞的必要条件<br>答：需要检测碰撞的物体身上存在刚体组件（或被检测物体），也要碰撞器collider</li>
<li>CharacterController和Rigidbody的区别</li>
<li>物体发生碰撞时，有几个阶段，分别对应的函数<br>答：排除触发，有3种，OnCollisionEnter(),OnCollisionStay(); OnCollisionExit()</li>
<li>u3d中，几种施加力的方式，描述出来。<br>答：a)爆炸力（AddExplosionForce(force : float, forcePos : Vector3，radius : float, upwards : float, mode : ForceMode)），应用一个力到刚体来模拟爆炸效果,就是在爆炸力中心坐标position,搜索在radius范围内的刚体，对其释放力作用，超出radius范围的刚体不受力作用，爆炸力将随着刚体的距离线性减弱。<br>b)力AddForce(force : Vector3, mode : ForceMode),主要施力给一个刚，使其移动。<br>c)位置力AddForceAtPosition(force : Vector3, position : Vector3, mode : ForceMode), 在position施加一个力，施力的主体将会受到一个力和力矩。<br>d)相对力AddRelativeForce(force : Vector3, mode : ForceMode),类似于AddForce；</li>
<li>什么叫做链条关节<br>答:Hinge Joint ,他可以模拟两个物体见</li>
<li>物体自旋转使用的函数叫什么<br>答：transform.Rotate(eulerAngles : Vector3, relativeTo : Space = Space.self);</li>
<li>物体绕某点旋转使用函数叫什么<br>答：transform.RotateAround(point : Vector3, axis : Vector3, angles : float)</li>
<li>u3d提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数<br>答：PlayerPrefs.GetInt(key : string, defaultValue : int = 0);</li>
<li>unity3d提供了几种光源，分别是什么<br>答：平行光,点光源，聚光灯，环境光</li>
<li>unity3d从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。<br>答：void Awake(),void Start(), void Update(), void FixedUpdate(),void LateUpdate(), void OnGUI() ，void Reset(), OnDisable(), void OnDestroy()</li>
<li>物理更新一般在哪个系统函数里？<br>答：void FixedUpdate()</li>
<li>移动相机动作在哪个函数里，为什么在这个函数里。<br>答：void LateUpdate(),因为这个函数是在Update执行完毕才执行的，不然的话就有可能出现摄像机里面什么都看到的情况。</li>
<li>当游戏中需要频繁创建一个物体对象时，我们需要怎么做来节省内存。<br>Unity里有两种动态加载机制:一个是Resources.Load,另外一个通过AssetBundle,其实两者区别不大,Resources.Load就是从一个缺省打进程序包里的AssetBundle里加载资源,而一般AssetBundle文件需要你自己创建,运行时动态加载<br>AssetBundle运行时加载<br>AssetBundle.Unload(flase)是释放AssetBundle文件</li>
<li>一个场景放置多个camera并同时处于活动状态，会发生什么<br>23.简述prefab的用处和环境<br>24.如何销毁一个UnityEngine.Object以及其子类<br>25.为什么u3d会出现组件上数据丢失的情况<br>26.u3d下如何安全的在不同工程迁移asset数据<br>DrawCall优化<br>一 Mesh Renderer<br>二 Skinned Mesh Renderer<br>三 合并要求对比<br>四 总结<br>五 场景制作建议<br>DrawCall优化合并,即DrawCall Batching.通过减少Draw call数和对显卡性能的消耗来提高性能<br>一 Mesh Renderer<br>分为Dynamic Batching 和 Static Batching<br>Dynamic Batching<br>不需要任何操作,只要共享材质(即使是不同的Mesh模型也可以)<br>Unity中的内存种类实际上Unity游戏使用的内存一共有三种:程序代码,托管堆(Managed Heap)以及本机堆(Native Heap)<br>程序代码包括了所有的Unity引擎,使用的库,以及你所写的所有的游戏代码,在编译后,得到的运行文件将会被加载到设备中执行,并占用一定内存.<br>这部分内存实际上是没有办法去”管理的”</li>
</ol>
<p>法线贴图<br>一: 法线贴图的原理<br>光照效果很大程度上是由垂直于物体表面的法线决定的,因为法线影响反射光的方向,均匀垂直的法线是镜面贴图但是有时候我们会给一个平面使用砖墙贴图,砖墙应该是凹凸不平的,而如果让砖墙使用该平面的法线的话,画面就很假,<br>而如果按真实砖墙去做模型的话,即做高精度模型,一方面制作麻烦,另一方面运行时对性能的损耗很大.<br>法线贴图就是来解决这个问题的.法线贴图就是把法线信息存储在一张图里.使用发现贴图时,通常顶点数和三角形面数只有高精度模型的十分之一不到.<br>二: 法线贴图的实现<br>将材质贴图对应的法线绘制在一张贴图上,将贴图对应点的单位法线向量信息float3(x,y,z)存储在途中对应的颜色里<br>压缩法线贴图的好处:<br>压缩后的法线贴图,大小只有原来的1/4左右,故可以使用更大或者更多的贴图来提升画面品质.<br>Unity3D的法线贴图<br>Unity3D使用的压缩法线贴图是DXT5nm格式的,有A和G两个通道,对于法线(x,y,z) A对应x,G对应y<br>对压缩法线贴图的采样依然是如下函数</p>
<pre><code>float4 packedNormal = tex2D(_NormalMap, IN.uv_MainTex);
</code></pre><p>packedNormal.w对应A通道,既法线的x<br>packedNormal.y对应G通道,既法线的y<br>Unity3D热更新全书-加载(一)从AssetBundle说起<br>我们试全面分析一下Unity3D提供的资源加载机制</p>
<ol>
<li>Resourecs//内嵌资源,使用方法Resources.Load,可以加载任意种类的资源,不能动态修改</li>
<li>StreamingAssets//随包资源,使用方法IO或WWW.Load,WWW.Load可以加载任意种类资源,IO仅限bytes和text</li>
<li>WWW从网络下载并加载</li>
<li>WWW从网络加载AssetBundle<br>一和二显然不具有热更新的效果,这里就不做讨论<br>3 4都是从网络加载的,他们有什么区别呢<br>首先说3,这是没有缓冲的,我们显然不想让用户重复的浪费流量,不可取<br>然后是4,assetbundle提供了一个版本号来做缓冲对比,可以比较好的起到更新的目标<br>assetbundle原来就是Unity3D为我们准备的方案,难怪每本书都会大篇介绍AssetBundle,后文简称AB<br>每本书都告诉你,AB很强大,AB帮你解决了跨平台问题,帮你解决了依赖关系.<br>首先AB的确很好很强大,他能收纳Unity自己的所有资源种类,贴图,材质,shader预设<br>然后可以每平台支持,这就是第一个陷进,注意是每平台都支持,不是多平台支持<br>每个平台都要单独导出,而每个平台到底差了些什么呢?nothing<br>而最大的质量差异,源自贴图<br>有些平台贴图不压缩,有些平台贴图要压缩,而且根据不通的平台特性,套用不通的压缩算法,先压过再存到包里<br>这就是AB帮你干的最主要的事情<br>听起来很贴心呢,等等,你是不是忘了一个特定的命题,这个命题叫做UI<br>压缩的图片会有质量损失,UI贴图我们通常是不压缩的<br>然后UI还会触及到AB的另一个问题<br>以NGUI为例,NGUI的资源关系比较复杂,有贴图-&gt;图集-&gt;布局<br>不同的布局经常交叉应用贴图<br>如果用AB想把每个界面分开打包,给用户最小的资源更新量,这个任务可以用来灾难来形容<br>最终热更新推送给用户的东西是以文件为单位的,而AB在小粒度文件并且之间有较为复杂的应用关系这种需求的下的使用是一场灾难<br>AB对每个平台的差异编译不是可选的,而是强制的,假如你有web,ios,android,三个平台,无论如何你都要导出三次<br>没了AssetBundle,我们怎么办<br>把碎片文件下载回来,并且组装<br>对于UI这个情景,是完全可行的,把布局和图集保存为文本形式,把文本和贴图下载回来,然后组装<br>对于其他场景片段,在有动画和贴图需要压缩的情况下,AB依然是唯一的选择<br>unity没有提供在运行时压缩压缩贴图的手段,动画也不容易存储,只能运行时压缩DXT,只有pc和wp8支持<br>对于各种各样的资源加载回特别凌乱么,不会<br>其实本质上可以统一成bytes的处理<br>texture可以从bytes加载<br>字符串可以从bytes加载<br>AB可以从bytes加载<br>自定义二进制存储,本身就是bytes<br>Unity3D热更新全书-加载(二)如何在不用AssetBundle的前提下动态加载预设<br>Unity3D的主要构成大家都知道,首先是场景图,场景图上的节点构成一棵树<br>每个节点对应一个GameObject对象<br>然后每个GameObject有若干个组件<br>有一些组件会与资源产生关系,比如MeshRenderer会关联材质,材质回关联shader和贴图<br>场景图的一部分回保存为一个预设,prefab<br>有时候我们会需要预设去复用,而预设的加载似乎只能通过AB去打包,其实不然,这里我们有一个开源的库就可以解决这个问题<br>为什么不使用AB,可以见上一篇,加载(一),不使用AB一份资源全平台同意,也没有痛苦的打包时间,资源依赖也很容易处置</li>
</ol>
<p>物理更新一般在FixedUpdate里,每固定帧绘制时执行一次,和update不同的是FixedUpdate是渲染帧执行,如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降,FixedUpdate比较适用于物理引擎的计算,因为是跟每帧渲染有关,Update就比较适合做控制.<br>移动相机动作在LateUpdate函数,当所有Update结束才调用,比较适合用于命令脚本的执行,<br>当游戏中需要频繁创建一个物体对象时,做一个pool,游戏开始时预先实例化足够的数量,用的时候取,不用的时候回收.</p>
<ol>
<li>什么是渲染管道?<br>渲染管道中有很多步骤,都要将几何体从一个坐标系中变换到另一个坐标系中.<br>本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化<br>优化内存:</li>
<li>自带压缩类库</li>
<li>将暂时不用的以后还需要实用的物体隐藏起来而不是直接Destroy掉</li>
<li>释放AssetBundle占用的资源</li>
<li>降低模型的片面数,降低模型的骨骼数量,降低贴图的大小</li>
<li>使用光照贴图,使用多层次细节(LOD),使用着色器(Shader),使用预设(Prefab)<br>资源加载:</li>
<li>Resources.Load();</li>
<li>AssetBundle<br>localPosition:自身位置,相对于父级的变换位置,Position:在世界坐标transform的位置<br>静态构造函数不允许访问修饰符,也不接受任何参数<br>碰撞器(Collider)有碰撞效果,IsTrigger=false,可以调用OnCollisionEnter/Stay/Exit函数<br>触发器(Trigger)没有碰撞效果,IsTrigger=true,可以调用OnTriggerEnter/Stay/Exit函数</li>
<li>物体发生碰撞的必要条件?<br>必须带有collider碰撞起和rigibody刚体属性或者人物控制器其实人物控制器就包含了前两者,另外一个也要带有Collider,Collider分类:网格碰撞器,盒子碰撞器,胶囊碰撞器,球型碰撞器,地形碰撞器</li>
<li>CharacterController和Rigidbody的区别?<br>Rigidbody具有完全真是物理的特性,而CharacterController可以说是受限的Rigidbody,具有一定的物理效果但不是完全真实的.<br>4.物体发生碰撞时,几种施加力的方式,描述出来?<br>rigidbody.AddForce/AddForceAtPosition,都是rigidbody的成员函数</li>
<li>物体发生碰撞时,有几个阶段,分别对应的函数<br>三个阶段,OnCollsionEnter/Stay/Exit函数</li>
<li>Unity3d提供了几种光源,分别是什么<br>共4中,DirectrionaLight,PointLight,SpotLight,AreaLight(用于烘培)</li>
<li>使用Unity3d实现2d游戏,有几种方式?<br>(1).使用本身GUI<br>(2).把相机的Projection(投影)值调位Orthographic(正交投影),不考虑z轴;<br>(3).使用2d插件,如:2DTollKit<br>9.下列代码在运行中回产生几个临时对象?<br>string a = new string(“abc”);<br>a = (a.ToUpper() + “123”).SubString(0, 2);<br>答:其实在C#第一行是会出错的(Java中倒是可行),应该这样初始化<br>string b = new string(new char[]{‘a’, ‘b’, ‘c’}}</li>
<li>请简述关键字Sealed用在类声明和函数声明时的作用<br>答:类声明时可防止其他类继承此类,在方法中声明则可防止派生类重写此方法</li>
<li>简述四元数的作用,四元数对欧拉角的优点?<br>答:四元数用于表示旋转<br>相对于欧拉角的优点:<br>(1).能进行增量旋转<br>(2).避免方向锁<br>(3)给定方位的表达方式有两种,互为负(欧拉角有无数种表达方式)<br>12.如何安全的在不用工程间安全的迁移asset数据,三种方法<br>答<br>(1).将Assets目录和Library目录一起迁移<br>(2)导出包<br>(3)用unity自带的assert server功能<br>13.当一个细小的高速物体碰撞另一个较大的物体时,会出现什么情况?如何避免?<br>穿透(碰撞检测失败)<br>14.MipMap是什么?作用?<br>在三维计算机图形的贴图渲染中有一个常用的技术被成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成为</li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>实现原理：在运行时根据程序集和其中的类型得到元数据<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line">Assembly.Load(<span class="string">"程序集"</span>);<span class="comment">//加载一个程序集，返回类型是一个Assembly</span></span><br><span class="line"><span class="keyword">foreach</span>(Type type <span class="keyword">in</span> assembly.GetType())</span><br><span class="line">&#123;</span><br><span class="line">    stromh t = type.name;</span><br><span class="line">&#125;</span><br><span class="line">Type type = assembly.GetType(<span class="string">"程序集.类名"</span>); <span class="comment">//获取当前类的类型</span></span><br><span class="line"><span class="keyword">var</span> activator = System.Activator.CreateInstance(type); <span class="comment">// 创建此类型实例</span></span><br><span class="line">MethodInfo mInfo = type.GetMethod(<span class="string">"方法名"</span>);<span class="comment">//获取当前方法</span></span><br><span class="line">mInfo.Invok(<span class="literal">null</span>, 方法参数);</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/10/unity-nature-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/10/unity-nature-review/" class="post-title-link" itemprop="url">unity-nature-review</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-10 15:36:26" itemprop="dateCreated datePublished" datetime="2018-04-10T15:36:26+08:00">2018-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>是否有多维子材质：多维子材质材质测试，三个子材质，50个物体，使用多维子材质12帧，330个dc，343面。拆开之后20帧，154dc，134面。多维子材质Unity无法动态合并。<br>叠加模式贴图，可以不用Alpha通道<br>特效粒子贴图是否合并<br>是否有些粒子能使用序列帧，不过和视角有关，去掉alpha贴图合并。<br>动画boneweight,没有特殊需要的情况下受两个骨骼影响就够了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
