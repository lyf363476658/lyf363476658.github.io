<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/24/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/managed-code-unmanaged-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/managed-code-unmanaged-code/" class="post-title-link" itemprop="url">托管代码和非托管代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 19:39:27" itemprop="dateCreated datePublished" datetime="2018-04-11T19:39:27+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>托管代码是-Microsoft的中间语言(IL)，他主要作用是在.Net FRAMEWORK的公共语言运行库(CLR)执行代码前去编译源代码，也就是说托管代码充当着翻译的作用，源代码在运行时分为两个阶段：</p>
<ol>
<li>源代码编译为托管代码，(所以源代码可以有很多种，如VB,C#,J#)</li>
<li>托管代码编译为Microsoft的平台专用语言</li>
</ol>
<p>编译器把代码编译成中间语言(IL),而不是能在你的电脑上运行的机器码。中间语言被封装在一个叫程序集(Assembly)的文件中，程序集中包含了描述你所创建的类，方法和属性(例如安全需求)的所有元数据。你可以拷贝这个程序集到另一台服务器上部署它。</p>
<p>托管代码在公共语言运行库(CLR)中运行。这个运行库给你的运行代码提供各种各样的服务，通常来说，他会加载和验证程序集，以此来保证中间语言的正确性</p>
<ol>
<li>托管代码是一种中间语言，运行在CLR上；<br>非托管代码被编译为机器码，运行在机器上</li>
<li>托管代码独立于平台和语言，能更好的实现不同语言平台之间的兼容；<br>非托管代码依赖于平台和语言。</li>
<li>托管代码可享受CLR提供的服务（如安全检测，垃圾回收），不需要自己完成这些操作<br>非托管代码需要自己提供安全检测、垃圾回收等操作。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/AssetBundle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/AssetBundle/" class="post-title-link" itemprop="url">Unity加载和内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 17:16:57" itemprop="dateCreated datePublished" datetime="2018-04-11T17:16:57+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Unity有两种动态加载机制：Resources.Load和AssetBundle，二者本质并无区别。Resources.Load就是从一个缺省打进程程序包的AssetBundle(Resourece)里加载资源，而一般AssetBundle文件需要你自己创建，运行时加载。</p>
<h1 id="AssetBundle加载基础"><a href="#AssetBundle加载基础" class="headerlink" title="AssetBundle加载基础"></a>AssetBundle加载基础</h1><p>通过AssetBunlde加载资源，分为两步，第一步是获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细地描述。</p>
<h2 id="第一步，获取AssetBundle对象常用地API"><a href="#第一步，获取AssetBundle对象常用地API" class="headerlink" title="第一步，获取AssetBundle对象常用地API"></a>第一步，获取AssetBundle对象常用地API</h2><h3 id="方式一，先获取WWW对象，再通过WWW-assetBundle获取AssetBundle对象："><a href="#方式一，先获取WWW对象，再通过WWW-assetBundle获取AssetBundle对象：" class="headerlink" title="方式一，先获取WWW对象，再通过WWW.assetBundle获取AssetBundle对象："></a>方式一，先获取WWW对象，再通过WWW.assetBundle获取AssetBundle对象：</h3><pre><code>public WWW(string uri);
</code></pre><p>加载Bundle文件并获取WWW对象，完成后会在内存中创建较大地WebStream(解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大),因此后续的AssetBundle.Load可以直接在内存中进行。</p>
<pre><code>public static WWW LoadFromCacheOrDownload(string uri, int version, unit crc = 0);
</code></pre><p>加载Bundle文件并获取WWW对象，同时将解压形式的Bundle内容存入磁盘中作为缓存（如果该Bundle已在缓存中，则省去这一步），完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中的缓存获取。</p>
<pre><code>public AssetBundle assetBundle;
</code></pre><p>通过之前两个接口获取WWW对象后，即可通过WWW.assetBundle获取AssetBundle对象。</p>
<h3 id="方式二，直接获取AssetBundle"><a href="#方式二，直接获取AssetBundle" class="headerlink" title="方式二，直接获取AssetBundle:"></a>方式二，直接获取AssetBundle:</h3><pre><code>public static AssetBundle LoadFromFile(string path); 
public static AssetBundle LoadFromFileAsync(string path);
</code></pre><p>通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中获取。<br>如果AssetBundle是未压缩，或者是数据块形式（LZ4算法压缩）的，LoadFromFile将从磁盘中直接加载它。如果AssetBundle是高度压缩(LZMA算法压缩)的，再将它加载进入内存前，会首先将它解压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void LoadAssetBundles(string baseDir)</span><br><span class="line">&#123;</span><br><span class="line">    if (assetBundleInfos != null)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; assetBundleInfos.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var bInfo = assetBundleInfos[i];</span><br><span class="line">            if (bInfo.assetBundle != null)</span><br><span class="line">            &#123;</span><br><span class="line">                bInfo.assetBundle.Unload(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assetBundleInfos = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var abInfos = new List&lt;AssetBundleInfo&gt;(50);</span><br><span class="line"></span><br><span class="line">    var files = Directory.GetFiles(m_dir_update, &quot;*.bytes&quot;);</span><br><span class="line">    for (int i = 0; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string f = files[i];</span><br><span class="line">        string n = Path.GetFileName(f);</span><br><span class="line">        if (!CheckABName(abInfos, n)) contine;</span><br><span class="line"></span><br><span class="line">        abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (baseDir != null)</span><br><span class="line">    &#123;</span><br><span class="line">        files = Directory.GetFiles(baseDir, &quot;*.bytes&quot;);</span><br><span class="line">        for (int i = 0; i &lt; files.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string f = files[i];</span><br><span class="line">            string n = Path.GetFileName(f);</span><br><span class="line">            if (!CheckABName(abInfos, n)) continue;</span><br><span class="line"></span><br><span class="line">            abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files = LoadConfigLines(&quot;res_idx&quot;);</span><br><span class="line">    for (int i = 0; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string n = files[i].Trim();</span><br><span class="line">        if (!CheckABName(abInfos, n)) continue;</span><br><span class="line"></span><br><span class="line">        string f = streamAssetsPath + n;</span><br><span class="line">        abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (abInfos.Count == 0) return;</span><br><span class="line"></span><br><span class="line">    string prefix = &quot;assets/res/&quot;;</span><br><span class="line">    int cprefix = prefix.Length;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; abInfos.Count;)</span><br><span class="line">    &#123;</span><br><span class="line">        var abInfo = abInfos[i];</span><br><span class="line">        var ab = AssetBundle.LoadFromFile(abInfo.uri);</span><br><span class="line">        if (ab == null)</span><br><span class="line">        &#123;</span><br><span class="line">            abInfos.RemoveAt(i);</span><br><span class="line">            sbError.Append(&quot;\nfail ab : &quot;);</span><br><span class="line">            sbError.Append(abInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>public static AssetBundle LoadFromMemory(byte[] binary)
</code></pre><p>通过Bundle的二进制数据，异步创建AssetBundle对象，完成后会在内存中创建较大的WebStream。调用时，Bundle的解压是异步进行的，因此对于未压缩的Bundle文件，该接口于LoadFromMemoryAsync是等价的。</p>
<pre><code>public static AssetBundle LoadFromMemoryAsync
</code></pre><p>该接口是 CreateFromMemory 的同步版本，这个方法的参数是包含了AssetBundle数据的字节数组。如果需要的话，你还可以传入一个CRC(循环冗余校验码)参数。如果AssetBundle使用了LZMA算法压缩，那么AssetBundle在加载的时候会被解压。如果AssetBundle使用了LZ4算法压缩，它将直接以压缩形式被加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator LoadFromMemoryAsync(string path)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">    yield return createRequest;</span><br><span class="line">    AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">    var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);</span><br><span class="line">    Instantiate(prefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二步，从AssetBundle加载资源的常用API"><a href="#第二步，从AssetBundle加载资源的常用API" class="headerlink" title="第二步，从AssetBundle加载资源的常用API"></a>第二步，从AssetBundle加载资源的常用API</h2><pre><code>public Object Load(string name, Type type);
</code></pre><p>通过给定的名字和资源类型，加载资源。加载时会自动加载其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。</p>
<pre><code>public Object[] LoadAll(Type type);
public AssetBundleRequest LoadAllAssetsAsync();
</code></pre><p>一次性加载Bundle中给定资源类型的所有资源</p>
<pre><code>public AssetBundleRequest LoadAsync(string name, Type type)
</code></pre><h3 id="AssetBundle的压缩类型"><a href="#AssetBundle的压缩类型" class="headerlink" title="AssetBundle的压缩类型"></a>AssetBundle的压缩类型</h3><p>Unity3D引擎为我们提供了三种压缩策略来处理AssetBundle的压缩，即：</p>
<ul>
<li>LZMA格式</li>
<li>LZ4格式</li>
<li>不压缩</li>
</ul>
<blockquote>
<p>LZ4是块压缩(chunk-based)，LZMA是流压缩(stream-based)。流压缩(LZMA)在处理整个数据块时使用同一个字典，它提供了最大可能的压缩率但只支持顺序读取。块压缩(LZ4)指的是原始数据被分成大小相同的子块并单端压缩。如果你想要实时解压/随机读取开销小，则应该使用这种。</p>
<p>LZMA压缩方式的优点在于使用同一个字典压缩率较高，但只能顺序读取意味着加载任意一个资源时，都需要将整个AssetBundle解压，造成卡顿和额外内存占用。LZ4基于快压缩率较低（测试LZMA换LZ4：86.9M-&gt;108M），但只需解压需要块即可，不会有大的卡顿和额外内存占用。</p>
</blockquote>
<h4 id="LZMA-stream-based"><a href="#LZMA-stream-based" class="headerlink" title="LZMA(stream-based)"></a>LZMA(stream-based)</h4><p>在默认情况下，打包生成的AssetBundle都会被压缩。在U3D中，AssetBundle的标准压缩格式便是LZMA（LZMA是一种序列化流文件），因此在默认情况下，打出的AssetBundle包处于LZMA格式的压缩状态。</p>
<h4 id="LZ4-chunk-based"><a href="#LZ4-chunk-based" class="headerlink" title="LZ4(chunk-based)"></a>LZ4(chunk-based)</h4><p>Unity 5.3之后的版本增加了LZ4格式压缩，是一种块压缩方式，由于LZ4的压缩比一般，因此经过压缩之后的AssetBundle包体的体积较大（该算法基于chunk）。但是，使用LZ4格式的好处在于解压缩的时间相对要短。</p>
<p>使用LZ4格式压缩，需要打包设置</p>
<pre><code>BuildPipeline.BuildAssetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.ChunkBasedCompression);
</code></pre><h4 id="不压缩"><a href="#不压缩" class="headerlink" title="不压缩"></a>不压缩</h4><p>当然，我们也可以不对AssetBundle进行压缩。没有经过压缩的胞体系最大，但是访问速度最快。</p>
<p>若要使用不压缩的策略，只需要在打包的时候开启</p>
<pre><code>BuildPipeline.BuildAsetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.UncompressedAssetBundle);
</code></pre><h1 id="五-AssetBundle原理分析"><a href="#五-AssetBundle原理分析" class="headerlink" title="五 AssetBundle原理分析"></a>五 AssetBundle原理分析</h1><h2 id="5-2-AssetBundle及Assets的卸载"><a href="#5-2-AssetBundle及Assets的卸载" class="headerlink" title="5.2 AssetBundle及Assets的卸载"></a>5.2 AssetBundle及Assets的卸载</h2><p>在AssetBundle的下载和加载过程中，以及Assets加载和实例化过程中，AssetBundle以及加载的Assets都会占用内存。</p>
<ol>
<li>AssetBundle的卸载采用Assetbundle.Unload(bool)接口。</li>
<li>Assets的卸载有两种方式:<ul>
<li>AssetBundle.Unload(true); // 这会强制卸载掉所有从AssetBundle加载的Assets。</li>
<li>Resource.UnloadUnusedAssets()和Resources.UnloadAsset。这会卸载掉所有没有用到的Assets。需要注意的是，该接口作用于整个系统，而不仅仅是当前的AssetBundle，而且不会卸载从当前AssetBundle文件中加载并仍在使用的Assets。</li>
</ul>
</li>
<li>对于实例化出来的对象，可以使用GameObject.Destroy活GameObject.DestroyImmediate。注意的是：官方说法是这样的，如果使用GameObject.Destroy接口，Unity会将真正的删除操作延后到一个合适的时机统一进行处理，但会在渲染之前。</li>
</ol>
<p>对于WWW对象，可以使用www=null或www.dispose。<br>这两者是由区别的，www=null不会立即释放内存，而是系统自动回收机制启动时回收。www.dispose则会立即调用系统的回收机制来释放内存。当WWW对象被释放后，其对于Web Stream数据的引用计数也会相应减1。</p>
<p>对于Web Stream数据，它所占用的内存会在其引用计数为0时，被系统自动回收。例如：当上图中的AssetBundle对象和WWW对象被释放后，Web Stream数据所占内存也会被系统自动回收。</p>
<h1 id="AssetBundle依赖加载"><a href="#AssetBundle依赖加载" class="headerlink" title="AssetBundle依赖加载"></a>AssetBundle依赖加载</h1><p>如果一个或者多个UnityEngine.Objects引用了其他AssetBundle中的UnityEngine.Object，那么AssetBundle之间就产生了依赖关系了。如果UnityEngine.ObjectA所引用的UnityEngine.ObjectB不是其他的AssetBundle中的，那么依赖就不会产生。<br>如果产生依赖，被依赖对象(UnityEngine.ObjectB)将被拷贝进你创建的AssetBundle(指包含UnityEngine.ObjectA的AssetBundle)</p>
<p>更近一步，如果有多个对象(UnityEngine.ObjectA1、UnityEngine.ObjectA2、UnityEngine.ObjectA3…)引用了同一个被依赖对象(UnityEngine.ObjectB)，那么被依赖对象将被拷贝多份，打包进各个对象各自的AssetBundle。</p>
<p>如果一个AssetBundle存在依赖性，那么要注意的是，那些包含了被依赖对象的AssetBundles，需要在你想要实例化的对象的加载之前加载。Unity不会自动帮你加载这些依赖。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/Unity-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/Unity-Note/" class="post-title-link" itemprop="url">Unity3D中自带事件函数的执行顺序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 16:16:30" itemprop="dateCreated datePublished" datetime="2018-04-11T16:16:30+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Unity3D继承自MonoBehavior的脚本中，有几个Unity3D自带的事件函数按照预定的顺序作为脚本执行。其执行顺序如下：</p>
<h1 id="编辑器（Editor）"><a href="#编辑器（Editor）" class="headerlink" title="编辑器（Editor）"></a>编辑器（Editor）</h1><ul>
<li><strong>Reset</strong>：Reset函数被调用来初始化脚本属性当脚本第一次被附到对象上，并且在Reset命令被使用时也会调用。Reset是在用户点击Inspector面板上Reset按钮或者首次添加该组件时被调用。Reset最常用于在检视面板中给定一个默认值。</li>
</ul>
<h1 id="第一次场景加载（First-Scene-Load）"><a href="#第一次场景加载（First-Scene-Load）" class="headerlink" title="第一次场景加载（First Scene Load）"></a>第一次场景加载（First Scene Load）</h1><p>这些函数会在一个场景开始（场景中每个物体只调用一次）时被调用。</p>
<ul>
<li><strong>Awake</strong>：这个函数总是在任何<code>Start()</code>函数之前一个预设被实例化之后调用，如果一个GameObject是非激活的(inactive)，在启动期间Awake函数是不会被调用的直到它是活动的(active)。</li>
<li><strong>OnEnable</strong>：只有在对象激活(active)状态下才会被调用，这个函数只有在object被启动(enable)后才调用。这会发生在一个MonoBehavior实例被创建，例如当一个关卡被加载或者一个带有脚本组件的GameObject被实例化。</li>
</ul>
<p>注意：当一个场景被添加到场景中，所有脚本上的Awake()和OnEnable()函数将会被调用在Start()、Update()等它们中任何函数被调用之前。自然的，当一个物体在游戏过程中被实例化时这不能被强制执行。</p>
<h1 id="第一帧更新之前（Before-the-first-frame-update）"><a href="#第一帧更新之前（Before-the-first-frame-update）" class="headerlink" title="第一帧更新之前（Before the first frame update）"></a>第一帧更新之前（Before the first frame update）</h1><ul>
<li><strong>Start</strong>：只有在脚本被启用了Start()函数将会在Update()函数第一帧之前被调用。对于那些被添加到场景中的物体，所有脚本上的Start()函数将会在它们中任何的Update()函数之前被调用，当一个物体在游戏过程中被实例化时这不能被强制执行。</li>
</ul>
<h1 id="在帧之间（In-between-frames）"><a href="#在帧之间（In-between-frames）" class="headerlink" title="在帧之间（In between frames）"></a>在帧之间（In between frames）</h1><ul>
<li><strong>OnApplicationPause</strong>：这个函数将会被调用在暂停被检测有效的在正常的帧更新之间的一帧的结束时。在OnApplicationPause被调用后将会有额外的一帧用来允许游戏显示图像表示在暂停状态下。</li>
</ul>
<h1 id="更新顺序（Update-Order）"><a href="#更新顺序（Update-Order）" class="headerlink" title="更新顺序（Update Order）"></a>更新顺序（Update Order）</h1><p>当你在跟踪游戏逻辑和状态，动画，相机位置等的时候，有几个不同的事件函数你可以使用。常见的模式是在Update()函数中执行大多数人物，但是也有其它的函数你可以使用。</p>
<ul>
<li><strong>FixedUpdate</strong>：<strong>常被用作逻辑Tick函数</strong>，FixedUpdate函数经常会比Update函数更频繁的被调用。它一帧会被调用多次，如果帧率低它可能不会在帧之间被调用，就算帧率是高的。所有的图形计算和更新在FixedUpdate之后会立即执行。当在FixedUpdate里执行移动计算，你并不需要Time.deltaTime乘以你的值，这是因为FixedUpdate是按真实时间，独立于帧被调用的。</li>
<li><strong>Update</strong>：Update每一帧都会被调用，对于帧更新它是主要的负荷函数。</li>
<li><strong>LateUpdate</strong>：LateUpdate会在Update结束之后每一帧被调用，任何计算在Update里执行结束当LateUpdate开始时。LateUpdate常被为第三人称视角相机跟随。</li>
</ul>
<h1 id="渲染（Rendering）"><a href="#渲染（Rendering）" class="headerlink" title="渲染（Rendering）"></a>渲染（Rendering）</h1><ul>
<li><strong>OnPreCull</strong>：在相机剔除场景前被调用。剔除是取决于哪些物体对于摄像机是可见的，OnPreCull尽在剔除起作用之前被调用。</li>
<li><strong>OnBecameVisible/OnBecameInvisible</strong>：当一个物体对任意摄像机变得可见/不可见时被调用。</li>
<li><strong>OnPreRender</strong>：在摄像机开始渲染场景之前被调用。</li>
<li><strong>OnRenderObject</strong>：在指定场景渲染完成之后调用，你可以使用GL类或者Graphics.DrawMeshNow来绘制自定义几何体在这里。</li>
<li><strong>OnPostRender</strong>：在摄像机完成渲染之后调用。</li>
<li><strong>OnRenderImage(Pro Only)</strong>：在场景渲染完成之后允许屏幕图像后期处理调用。</li>
<li><strong>OnGUI</strong>：为了响应GUI事件，每帧会被调用多次（一般最低两次）。布局Layout和Repaint事件会首先处理，接下来是通过Layout和键盘/鼠标事件对应的每个输入事件。</li>
<li><strong>OnDrawGizmos</strong>：用于可视化的绘制一些小玩意在场景视图中。</li>
</ul>
<h1 id="协同程序（Corotines）"><a href="#协同程序（Corotines）" class="headerlink" title="协同程序（Corotines）"></a>协同程序（Corotines）</h1><p>正常的协同程序更新是在Update函数饭回之后运行。一个协同程序是可以暂停执行(yield)直到给出的依从指令（YieldInstruction）完成，携程的不同运用。</p>
<ul>
<li><strong>yield</strong>：在所有的Update函数都已经被调用的下一帧该协程将持续执行。</li>
<li><strong>yield WaitForSeconds</strong>：一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后。</li>
<li><strong>yield WaitForFixedUpdate</strong>：所有脚本上的FixedUpdate函数已经执行调用之后持续。</li>
<li><strong>yield WWW</strong>：在WWW下载完成之后持续。</li>
<li><strong>yield StartCoroutine</strong>：协同程序链，将会等到MuFunc函数协程执行完成首先。</li>
</ul>
<h1 id="销毁（When-the-Object-is-Destroyed）"><a href="#销毁（When-the-Object-is-Destroyed）" class="headerlink" title="销毁（When the Object is Destroyed）"></a>销毁（When the Object is Destroyed）</h1><ul>
<li><strong>OnDestroy</strong>：这个函数会在一个对象销毁前一帧调用，会在所有帧更新一个对象存在的最后一帧之后执行，对象也许会响应Object.Destroy或一个场景关闭时被销毁。</li>
</ul>
<h1 id="退出游戏（When-Quitting）"><a href="#退出游戏（When-Quitting）" class="headerlink" title="退出游戏（When Quitting）"></a>退出游戏（When Quitting）</h1><p>这些函数会在你场景中所有的激活的物体上调用：</p>
<ul>
<li><strong>OnApplicationQuit</strong>：这个函数在应用退出之前的所有游戏物体上调用，在编辑器（Editor）模式中会在用户停止PlayMode时调用，在网页播放器（web Player）中会在网页视图关闭时调用。</li>
<li><strong>OnDisable</strong>：当行为变为非启用(disable)或非激活（inactive）时调用。</li>
</ul>
<h1 id="脚本的生命周期流程图"><a href="#脚本的生命周期流程图" class="headerlink" title="脚本的生命周期流程图"></a>脚本的生命周期流程图</h1><img src="/2018/04/11/Unity-Note/1.png">
<p>在Update中使用Time.deltaTime，获取到的是这一帧的时间，如果游戏卡，帧率低，那这个值就大。如果游戏流畅，帧率高，这个值就小，Time.deltaTime=1.0f/帧率</p>
<ol>
<li><p>MonoBehaviour.Update 更新渲染帧<br>当MonoBehaviour启用时，其Update在每一帧被调用。</p>
</li>
<li><p>MonoBehaviour.FixedUpdate 固定更新逻辑帧<br>当MonoBehaviour启用时，其 FixedUpdate在每一帧被调用。<br>处理Rigidbody时，需要用FixedUpdate代替Update。例如：给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧(两者帧长不同)。</p>
</li>
<li><p>MonoBehaviour.LateUpdate 晚于更新渲染帧末尾<br>当Behaviour启用时，其LateUpdate在每一帧被调用。<br>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。</p>
</li>
</ol>
<h1 id="Update和FixedUpdate的区别"><a href="#Update和FixedUpdate的区别" class="headerlink" title="Update和FixedUpdate的区别"></a>Update和FixedUpdate的区别</h1><p>Update跟当前平台的帧数有关，而FixedUpdate是CPU tick 的时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update。<br>Update是在每次渲染新的一帧的时候才会调用，也就是说，这个函数的更新频率和设备的性能有关以及被渲染的物体（可以认为是三角形的数量）。在性能好的机器上可能fps 30，差的可能小些。这会导致同一个游戏在不同的机器上效果不一致，有的快有的慢。因为Update的执行间隔不一样了。<br>而FixedUpdate，是在固定的时间间隔执行，不受游戏帧率的影响。有点像Tick。所以处理Rigidbody的时候最好用FixedUpdate。</p>
<p>FixedUpdate的时间间隔可以在项目设置中更改，Edit-&gt;ProjectSetting-&gt;time  找到Fixedtimestep。就可以修改了。</p>
<h1 id="Update和LateUpdate的区别"><a href="#Update和LateUpdate的区别" class="headerlink" title="Update和LateUpdate的区别"></a>Update和LateUpdate的区别</h1><p>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如：当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。<br>LateUpdate是晚于所有Update执行的。例如：游戏中有2个脚步，脚步1含有Update和LateUpdate，脚步2含有Update，那么当游戏执行时，每一帧都是把2个脚步中的Update执行完后才执行LateUpdate 。虽然是在同一帧中执行的，但是Update（渲染帧）会先执行，LateUpdate（渲染帧末尾）会晚执行。<br>现在假设有2个不同的脚本同时在Update中控制一个物体，那么当其中一个脚本改变物体方位、旋转或者其他参数时，另一个脚步也在改变这些东西，那么这个物体的方位、旋转就会出现一定的反复。如果还有个物体在Update中跟随这个物体移动、旋转的话，那跟随的物体就会出现抖动。 如果是在LateUpdate中跟随的话就会只跟随所有Update执行完后的最后位置、旋转，这样就防止了抖动。</p>
<h1 id="影响渲染顺序因素地总结"><a href="#影响渲染顺序因素地总结" class="headerlink" title="影响渲染顺序因素地总结"></a>影响渲染顺序因素地总结</h1><ol>
<li>Camrea Depth 相机组件上设置的相机深度，深度越大越靠后渲染。</li>
<li>Sorting Layer 在Tags &amp; Layers设置中可见。</li>
<li>Order In Layer 相当于Sorting Layer的子排序，用这个值做比较时只有都在同一层时才有效。</li>
<li>RenderQueue Shader中对Tags设置的”Queue”</li>
</ol>
<p>Camera Depth永远最高。Camera Depth小的一定先进渲染管线。<br>当Sorting Layer和Order in Layer相同时<br>RenderQueue小的先进渲染管线。</p>
<p>当Sorting Layer和Order In Layer不相同时！<br>当两个材质使用了不同的RenderQueue,且这两个RenderQueue都在[0~2500]或[2501~5000]时，SortingLayer和OrderInLayer的排序生效。<br>当两个材质使用了不同的RenderQueue,且这两个RenderQueue分别再[0~2500]或[2501~5000]时，则一定会按照RenderQueue绘制，无视SortingLayer,OrderInLayer的排序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/constraint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/constraint/" class="post-title-link" itemprop="url">约束</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 13:51:35" itemprop="dateCreated datePublished" datetime="2018-04-11T13:51:35+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>T:struct</td>
<td>类型参数必须是值类型。可以指定除Nullable以外的任何值类型。</td>
</tr>
<tr>
<td>T:class</td>
<td>类型参数必须是引用类型，包括任何类、接口、委托或数组类型。</td>
</tr>
<tr>
<td>T:new()</td>
<td>类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new()约束必须最后指定。</td>
</tr>
<tr>
<td>T:&lt;接口名称&gt;</td>
<td>类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</td>
</tr>
<tr>
<td>T:U</td>
<td>为T提供的类型参数必须是为U提供的参数或派生自为U提供的参数。这称为螺类型约束。</td>
</tr>
</tbody>
</table>
</div>
<pre><code>public class MyGenericClass&lt;T&gt; where T:IComparable {}

class MyClassy&lt;T, U&gt;
where T : class
where U : struct 
{}

public class MyGenericClass&lt;T&gt; where T: IComparable, new()
{
    T item = new T();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface MyI &#123;&#125;</span><br><span class="line">class Dictionary&lt;TKey, TVal&gt;</span><br><span class="line">where TKey: IComparable, IEnumerable</span><br><span class="line">where TVal: MyI</span><br><span class="line">&#123;</span><br><span class="line">    public void Add(Tkey key, TVal val)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>public bool MyMethod&lt;T&gt; (T t) where T: IMyInterface {}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class List&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    void Add&lt;U&gt;(List&lt;U&gt; items) where U: T </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>default</p>
<p>之所以会用到default关键字，是因为需要在不知道类型参数为值类型还是引用类型的情况下，为对象实例赋初值。</p>
<p>```<br>class TestDefault<t><br>{<br>    public T foo()<br>    {<br>        return default(T);<br>    }<br>}</t></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/23-Design-Patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/23-Design-Patterns/" class="post-title-link" itemprop="url">23种设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 13:37:36" itemprop="dateCreated datePublished" datetime="2018-04-11T13:37:36+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>设计模式分为三大类：<br>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介模式、解释器模式。<br>其实还有两类：并发型模式和线程池模式。</p>
<p>设计模式六大原则：<br>总原则-开闭原则<br>对扩展开放，对修改封闭。在程序需要进行扩展的时候，不能去修改原有的代码，而是扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。<br>想要达到这样的效果，外面需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p>
<p>1、单一职责原则<br>不要存在多余一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p>
<p>2.里氏替换原则(Liskov Substitution Principle)<br>任何积累可以出现的地方，子类一定可以出现</p>
<p>6.合成复用原则(Composite Reuse Principle)<br>尽量首先使用合成/聚合的方式，而不是使用继承。</p>
<h1 id="单线程单例模式"><a href="#单线程单例模式" class="headerlink" title="单线程单例模式"></a>单线程单例模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton // 密封防止继承</span><br><span class="line">&#123;</span><br><span class="line">    private static Singleton uniqueInstance; // 唯一的实例</span><br><span class="line"></span><br><span class="line">    // 私有构造函数外部无法创建实例</span><br><span class="line">    private Singleton()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 全局唯一访问点</span><br><span class="line">    public static Singleton GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (uniqueInstance == null)</span><br><span class="line">        &#123;</span><br><span class="line">            uniqueInstance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单线程单例模式的几个要点：</p>
<ol>
<li>Singleton模式的实例构造器可以设置为protected以允许子类派生。</li>
<li>Singleton模式一般不要ICloneable接口，因为这可能会导致多个对象实例，与Singleton模式的初衷违背。</li>
<li>Singleton模式一般不要支持序列化，因为这也有可能导致多个对象实例，同样与Singleton模式的初衷违背。</li>
<li>Singleton模式只考虑到了对象创建的工作，没有考虑到对象效果的工作。全局静态的放到托管堆中还可以接受？</li>
<li>不能应对多线程环境，在多线程环境下，使用Singleton模式仍然有可能得到Singleton类的多个实例对象。</li>
</ol>
<h1 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h1><h2 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public enum FruitKind</span><br><span class="line">&#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Pear,</span><br><span class="line">&#125;</span><br><span class="line">public interface Fruit</span><br><span class="line">&#123;</span><br><span class="line">    void WhatIm();</span><br><span class="line">&#125;</span><br><span class="line">public class Apple : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pear : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am pear&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FruitFactory</span><br><span class="line">&#123;</span><br><span class="line">    public static Fruit CreateFruit(FruitKind type)</span><br><span class="line">    &#123;</span><br><span class="line">        switch(type)</span><br><span class="line">        &#123;</span><br><span class="line">            case FruitKind.Apple:</span><br><span class="line">                return new Apple();</span><br><span class="line">            case FruitKind.Pear:</span><br><span class="line">                return new Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Fruit a = FruitFactory.CreateFruit(FruitKind.Pear);</span><br><span class="line">        a.WhatIm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不太喜欢损失性能和不容易看到内部的逻辑，所以上述不太喜欢。上述存在一个问题，产品内部随便折腾没啥问题，但是做一个新的产品就蛋疼了。</p>
<h2 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h2><ol>
<li>抽象产品类</li>
<li>具体产品类</li>
<li>抽象工厂类</li>
<li>具体工厂类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public enum FruitKind</span><br><span class="line">&#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Pear,</span><br><span class="line">&#125;</span><br><span class="line">public interface Fruit</span><br><span class="line">&#123;</span><br><span class="line">    void WhatIm();</span><br><span class="line">&#125;</span><br><span class="line">public class Apple : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pear : Fruit</span><br><span class="line">&#123;</span><br><span class="line">    public void WhatIm()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;I am pear&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface FruitFactory</span><br><span class="line">&#123;</span><br><span class="line">    Fruit CreateFruit();</span><br><span class="line">&#125;</span><br><span class="line">public class PearFactory : FruitFactory</span><br><span class="line">&#123;</span><br><span class="line">    public Fruit CreateFruit()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码解耦了，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/11/Interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/Interface/" class="post-title-link" itemprop="url">面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 13:30:35" itemprop="dateCreated datePublished" datetime="2018-04-11T13:30:35+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接口(Interface)是一种规划，为你定义了一系列的规则和任务，但不去实现它<br>类和结构体可以继承多个接口<br>抽象类表示该类中可能已经有一些的具体定义<br>生成的库在这里：</p>
<pre><code>Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so
</code></pre><p>符号表在这里，需要把扩展名弄成.so，才能被bugly的符号工具转换。</p>
<pre><code>Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so.debug
</code></pre><p>C++代码生成到这里，最好保存这个目录，以便对应看调用栈：</p>
<pre><code>Temp\StagingArea\Il2Cpp\il2cppOutput
</code></pre><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>会把所有插入其中的数据都当成了object类型来处理。<br>弊端：1、不是类型安全的；2、存在装箱拆箱操作<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Add() <span class="comment">//向数组中添加一个元素</span></span><br><span class="line">Remove() <span class="comment">//删除数组中的一个元素</span></span><br><span class="line">RemoveAt(<span class="keyword">int</span> i);<span class="comment">//</span></span><br><span class="line"><span class="comment">//不是骨骼动画,可以用animator,/</span></span><br><span class="line"><span class="comment">//骨骼动画 animator只能用一个,</span></span><br><span class="line">Reverse()<span class="comment">//反转数组的元素</span></span><br><span class="line">Sort()<span class="comment">//从小到大排序数组的元素</span></span><br><span class="line">Clone()<span class="comment">//复制一个数组</span></span><br><span class="line"><span class="comment">//List</span></span><br><span class="line"><span class="comment">//可通过索引访问</span></span><br></pre></td></tr></table></figure></p>
<p>在决定使用List还是使用ArrayList 类(两者具有类似的功能)时,记住List类在大多数情况下执行的更好并且是类型安全的,<br>如果对List类型T使用值类型,则需要考虑实现和装箱问题<br>如果对类型T实用值类型,则编译器将特别针对该值类型生成List类的实现,这意味着不必对<br>再提醒一下，模板容器里不要使用枚举。<br>比如Dictionary之类的，枚举会boxing，产生无用的GC<br>就用int替代吧</p>
<ol>
<li>请描述游戏动画有哪几种，以及其原理。<br>答:主要有关节动画,单一网络模型动画(关键帧动画),骨骼动画.<br>关节动画把角色分为若干独立部分,一个部分对应一个网络模型,部分的动画连接成一个整体的动画,角色比较灵活Quake2中实用了这种动画.<br>单一网络模型动画由一个完整的网络模型构成,在动画序列的关键帧里记录各个顶点的原位置及其改变量,然后插值运算实现动画效果,角色动画较真实.<br>骨骼动画,广泛应用的动画方式,集成了以上两个方式的优点,骨骼按角色特点组成一定的层次结构,由关节相连,可做相对运动,皮肤作为单一网络蒙在骨骼之外,决定角色的外观,皮肤网络每一个顶点都会收到骨骼的影响,从而实现完美的动画.</li>
</ol>
<h1 id="alpha-blend-工作原理"><a href="#alpha-blend-工作原理" class="headerlink" title="alpha blend 工作原理"></a>alpha blend 工作原理</h1><p>alpha blend用于做半透明效果.Color=(源颜色 <em> 源系数)OP(目标颜色 </em> 目标系数);其中OP(混合方式)有加,减,反减,取最小,取最大</p>
<h2 id="OpenGL-Alpha混合"><a href="#OpenGL-Alpha混合" class="headerlink" title="OpenGL Alpha混合"></a>OpenGL Alpha混合</h2><p>假设一种不透明的东西的颜色是A，另一种透明的东西颜色是B，那么透过B看A，看上去的颜色C就是B和A的混合颜色，可以用以下公式来模拟，设B物体的透明度为alpha（取值为0-1，0为完全透明，1为完全不透明）</p>
<pre><code>R(C)=alpha*R(B)+(1-alpha)R(A)
G(C)=alpha*G(B)+(1-alpha)G(A)
B(C)=alpha*B(B)+(1-alpha)G(A)
</code></pre><ol>
<li><p>写光照计算中的diffuse的计算公式<br>答:漫反射光(diffuse)计算公式为:ldiffuse = Dintensity<em>Dcolor</em>N.L;(Dintensity)表示漫反射强度,Dcolor表示漫反射光颜色,N为该点的法向量,L为光源向量<br>其他,3D渲染中,物体表面的光照计算公式为:<br>I = 环境关(lambient) + 漫反射光(ldiffuse) + 镜面高光(lspecular);<br>其中,环境光(ambient)计算公式为:</p>
<p> lambient = Aintensity*Acolor;(Aintensity)表示环境光强度,Acolor表示环境光颜色</p>
</li>
</ol>
<p>镜面高光(specular)计算公式为:<br>lspecular = Sintensity<em>Scolor</em>(R.V)n;(Sintensity)表示镜面光照强度,Scolor表示镜面光颜色,R为光的反射向量,V为观察者向量</p>
<ol>
<li>MipMap是什么？作用？<br>答:在三维计算机图形的贴图渲染中有一个常用的技术成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为mipmap</li>
<li>用u3d实现2d游戏，有几种方式？<br>答：一种用UI实现(GUI,NGUI…)，一种是采用3d实体对象（plane），绘制在3d对象上，调节摄像机，采用平行投影模式或则固定视角。</li>
<li>u3d中碰撞器和触发器的区别？<br>答：触发器只是碰撞器身上的一个属性，碰撞器是触发器的载体。</li>
<li>物体发生碰撞的必要条件<br>答：需要检测碰撞的物体身上存在刚体组件（或被检测物体），也要碰撞器collider</li>
<li>CharacterController和Rigidbody的区别</li>
<li>物体发生碰撞时，有几个阶段，分别对应的函数<br>答：排除触发，有3种，OnCollisionEnter(),OnCollisionStay(); OnCollisionExit()</li>
<li>u3d中，几种施加力的方式，描述出来。<br>答：a)爆炸力（AddExplosionForce(force : float, forcePos : Vector3，radius : float, upwards : float, mode : ForceMode)），应用一个力到刚体来模拟爆炸效果,就是在爆炸力中心坐标position,搜索在radius范围内的刚体，对其释放力作用，超出radius范围的刚体不受力作用，爆炸力将随着刚体的距离线性减弱。<br>b)力AddForce(force : Vector3, mode : ForceMode),主要施力给一个刚，使其移动。<br>c)位置力AddForceAtPosition(force : Vector3, position : Vector3, mode : ForceMode), 在position施加一个力，施力的主体将会受到一个力和力矩。<br>d)相对力AddRelativeForce(force : Vector3, mode : ForceMode),类似于AddForce；</li>
<li>什么叫做链条关节<br>答:Hinge Joint ,他可以模拟两个物体见</li>
<li>物体自旋转使用的函数叫什么<br>答：transform.Rotate(eulerAngles : Vector3, relativeTo : Space = Space.self);</li>
<li>物体绕某点旋转使用函数叫什么<br>答：transform.RotateAround(point : Vector3, axis : Vector3, angles : float)</li>
<li>u3d提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数<br>答：PlayerPrefs.GetInt(key : string, defaultValue : int = 0);</li>
<li>unity3d提供了几种光源，分别是什么<br>答：平行光,点光源，聚光灯，环境光</li>
<li>unity3d从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。<br>答：void Awake(),void Start(), void Update(), void FixedUpdate(),void LateUpdate(), void OnGUI() ，void Reset(), OnDisable(), void OnDestroy()</li>
<li>物理更新一般在哪个系统函数里？<br>答：void FixedUpdate()</li>
<li>移动相机动作在哪个函数里，为什么在这个函数里。<br>答：void LateUpdate(),因为这个函数是在Update执行完毕才执行的，不然的话就有可能出现摄像机里面什么都看到的情况。</li>
<li>当游戏中需要频繁创建一个物体对象时，我们需要怎么做来节省内存。<br>Unity里有两种动态加载机制:一个是Resources.Load,另外一个通过AssetBundle,其实两者区别不大,Resources.Load就是从一个缺省打进程序包里的AssetBundle里加载资源,而一般AssetBundle文件需要你自己创建,运行时动态加载<br>AssetBundle运行时加载<br>AssetBundle.Unload(flase)是释放AssetBundle文件</li>
<li>一个场景放置多个camera并同时处于活动状态，会发生什么<br>23.简述prefab的用处和环境<br>24.如何销毁一个UnityEngine.Object以及其子类<br>25.为什么u3d会出现组件上数据丢失的情况<br>26.u3d下如何安全的在不同工程迁移asset数据<br>DrawCall优化<br>一 Mesh Renderer<br>二 Skinned Mesh Renderer<br>三 合并要求对比<br>四 总结<br>五 场景制作建议<br>DrawCall优化合并,即DrawCall Batching.通过减少Draw call数和对显卡性能的消耗来提高性能<br>一 Mesh Renderer<br>分为Dynamic Batching 和 Static Batching<br>Dynamic Batching<br>不需要任何操作,只要共享材质(即使是不同的Mesh模型也可以)<br>Unity中的内存种类实际上Unity游戏使用的内存一共有三种:程序代码,托管堆(Managed Heap)以及本机堆(Native Heap)<br>程序代码包括了所有的Unity引擎,使用的库,以及你所写的所有的游戏代码,在编译后,得到的运行文件将会被加载到设备中执行,并占用一定内存.<br>这部分内存实际上是没有办法去”管理的”</li>
</ol>
<p>法线贴图<br>一: 法线贴图的原理<br>光照效果很大程度上是由垂直于物体表面的法线决定的,因为法线影响反射光的方向,均匀垂直的法线是镜面贴图但是有时候我们会给一个平面使用砖墙贴图,砖墙应该是凹凸不平的,而如果让砖墙使用该平面的法线的话,画面就很假,<br>而如果按真实砖墙去做模型的话,即做高精度模型,一方面制作麻烦,另一方面运行时对性能的损耗很大.<br>法线贴图就是来解决这个问题的.法线贴图就是把法线信息存储在一张图里.使用发现贴图时,通常顶点数和三角形面数只有高精度模型的十分之一不到.<br>二: 法线贴图的实现<br>将材质贴图对应的法线绘制在一张贴图上,将贴图对应点的单位法线向量信息float3(x,y,z)存储在途中对应的颜色里<br>压缩法线贴图的好处:<br>压缩后的法线贴图,大小只有原来的1/4左右,故可以使用更大或者更多的贴图来提升画面品质.<br>Unity3D的法线贴图<br>Unity3D使用的压缩法线贴图是DXT5nm格式的,有A和G两个通道,对于法线(x,y,z) A对应x,G对应y<br>对压缩法线贴图的采样依然是如下函数</p>
<pre><code>float4 packedNormal = tex2D(_NormalMap, IN.uv_MainTex);
</code></pre><p>packedNormal.w对应A通道,既法线的x<br>packedNormal.y对应G通道,既法线的y<br>Unity3D热更新全书-加载(一)从AssetBundle说起<br>我们试全面分析一下Unity3D提供的资源加载机制</p>
<ol>
<li>Resourecs//内嵌资源,使用方法Resources.Load,可以加载任意种类的资源,不能动态修改</li>
<li>StreamingAssets//随包资源,使用方法IO或WWW.Load,WWW.Load可以加载任意种类资源,IO仅限bytes和text</li>
<li>WWW从网络下载并加载</li>
<li>WWW从网络加载AssetBundle<br>一和二显然不具有热更新的效果,这里就不做讨论<br>3 4都是从网络加载的,他们有什么区别呢<br>首先说3,这是没有缓冲的,我们显然不想让用户重复的浪费流量,不可取<br>然后是4,assetbundle提供了一个版本号来做缓冲对比,可以比较好的起到更新的目标<br>assetbundle原来就是Unity3D为我们准备的方案,难怪每本书都会大篇介绍AssetBundle,后文简称AB<br>每本书都告诉你,AB很强大,AB帮你解决了跨平台问题,帮你解决了依赖关系.<br>首先AB的确很好很强大,他能收纳Unity自己的所有资源种类,贴图,材质,shader预设<br>然后可以每平台支持,这就是第一个陷进,注意是每平台都支持,不是多平台支持<br>每个平台都要单独导出,而每个平台到底差了些什么呢?nothing<br>而最大的质量差异,源自贴图<br>有些平台贴图不压缩,有些平台贴图要压缩,而且根据不通的平台特性,套用不通的压缩算法,先压过再存到包里<br>这就是AB帮你干的最主要的事情<br>听起来很贴心呢,等等,你是不是忘了一个特定的命题,这个命题叫做UI<br>压缩的图片会有质量损失,UI贴图我们通常是不压缩的<br>然后UI还会触及到AB的另一个问题<br>以NGUI为例,NGUI的资源关系比较复杂,有贴图-&gt;图集-&gt;布局<br>不同的布局经常交叉应用贴图<br>如果用AB想把每个界面分开打包,给用户最小的资源更新量,这个任务可以用来灾难来形容<br>最终热更新推送给用户的东西是以文件为单位的,而AB在小粒度文件并且之间有较为复杂的应用关系这种需求的下的使用是一场灾难<br>AB对每个平台的差异编译不是可选的,而是强制的,假如你有web,ios,android,三个平台,无论如何你都要导出三次<br>没了AssetBundle,我们怎么办<br>把碎片文件下载回来,并且组装<br>对于UI这个情景,是完全可行的,把布局和图集保存为文本形式,把文本和贴图下载回来,然后组装<br>对于其他场景片段,在有动画和贴图需要压缩的情况下,AB依然是唯一的选择<br>unity没有提供在运行时压缩压缩贴图的手段,动画也不容易存储,只能运行时压缩DXT,只有pc和wp8支持<br>对于各种各样的资源加载回特别凌乱么,不会<br>其实本质上可以统一成bytes的处理<br>texture可以从bytes加载<br>字符串可以从bytes加载<br>AB可以从bytes加载<br>自定义二进制存储,本身就是bytes<br>Unity3D热更新全书-加载(二)如何在不用AssetBundle的前提下动态加载预设<br>Unity3D的主要构成大家都知道,首先是场景图,场景图上的节点构成一棵树<br>每个节点对应一个GameObject对象<br>然后每个GameObject有若干个组件<br>有一些组件会与资源产生关系,比如MeshRenderer会关联材质,材质回关联shader和贴图<br>场景图的一部分回保存为一个预设,prefab<br>有时候我们会需要预设去复用,而预设的加载似乎只能通过AB去打包,其实不然,这里我们有一个开源的库就可以解决这个问题<br>为什么不使用AB,可以见上一篇,加载(一),不使用AB一份资源全平台同意,也没有痛苦的打包时间,资源依赖也很容易处置</li>
</ol>
<p>物理更新一般在FixedUpdate里,每固定帧绘制时执行一次,和update不同的是FixedUpdate是渲染帧执行,如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降,FixedUpdate比较适用于物理引擎的计算,因为是跟每帧渲染有关,Update就比较适合做控制.<br>移动相机动作在LateUpdate函数,当所有Update结束才调用,比较适合用于命令脚本的执行,<br>当游戏中需要频繁创建一个物体对象时,做一个pool,游戏开始时预先实例化足够的数量,用的时候取,不用的时候回收.</p>
<ol>
<li>什么是渲染管道?<br>渲染管道中有很多步骤,都要将几何体从一个坐标系中变换到另一个坐标系中.<br>本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化<br>优化内存:</li>
<li>自带压缩类库</li>
<li>将暂时不用的以后还需要实用的物体隐藏起来而不是直接Destroy掉</li>
<li>释放AssetBundle占用的资源</li>
<li>降低模型的片面数,降低模型的骨骼数量,降低贴图的大小</li>
<li>使用光照贴图,使用多层次细节(LOD),使用着色器(Shader),使用预设(Prefab)<br>资源加载:</li>
<li>Resources.Load();</li>
<li>AssetBundle<br>localPosition:自身位置,相对于父级的变换位置,Position:在世界坐标transform的位置<br>静态构造函数不允许访问修饰符,也不接受任何参数<br>碰撞器(Collider)有碰撞效果,IsTrigger=false,可以调用OnCollisionEnter/Stay/Exit函数<br>触发器(Trigger)没有碰撞效果,IsTrigger=true,可以调用OnTriggerEnter/Stay/Exit函数</li>
<li>物体发生碰撞的必要条件?<br>必须带有collider碰撞起和rigibody刚体属性或者人物控制器其实人物控制器就包含了前两者,另外一个也要带有Collider,Collider分类:网格碰撞器,盒子碰撞器,胶囊碰撞器,球型碰撞器,地形碰撞器</li>
<li>CharacterController和Rigidbody的区别?<br>Rigidbody具有完全真是物理的特性,而CharacterController可以说是受限的Rigidbody,具有一定的物理效果但不是完全真实的.<br>4.物体发生碰撞时,几种施加力的方式,描述出来?<br>rigidbody.AddForce/AddForceAtPosition,都是rigidbody的成员函数</li>
<li>物体发生碰撞时,有几个阶段,分别对应的函数<br>三个阶段,OnCollsionEnter/Stay/Exit函数</li>
<li>Unity3d提供了几种光源,分别是什么<br>共4中,DirectrionaLight,PointLight,SpotLight,AreaLight(用于烘培)</li>
<li>使用Unity3d实现2d游戏,有几种方式?<br>(1).使用本身GUI<br>(2).把相机的Projection(投影)值调位Orthographic(正交投影),不考虑z轴;<br>(3).使用2d插件,如:2DTollKit<br>9.下列代码在运行中回产生几个临时对象?<br>string a = new string(“abc”);<br>a = (a.ToUpper() + “123”).SubString(0, 2);<br>答:其实在C#第一行是会出错的(Java中倒是可行),应该这样初始化<br>string b = new string(new char[]{‘a’, ‘b’, ‘c’}}</li>
<li>请简述关键字Sealed用在类声明和函数声明时的作用<br>答:类声明时可防止其他类继承此类,在方法中声明则可防止派生类重写此方法</li>
<li>简述四元数的作用,四元数对欧拉角的优点?<br>答:四元数用于表示旋转<br>相对于欧拉角的优点:<br>(1).能进行增量旋转<br>(2).避免方向锁<br>(3)给定方位的表达方式有两种,互为负(欧拉角有无数种表达方式)<br>12.如何安全的在不用工程间安全的迁移asset数据,三种方法<br>答<br>(1).将Assets目录和Library目录一起迁移<br>(2)导出包<br>(3)用unity自带的assert server功能<br>13.当一个细小的高速物体碰撞另一个较大的物体时,会出现什么情况?如何避免?<br>穿透(碰撞检测失败)<br>14.MipMap是什么?作用?<br>在三维计算机图形的贴图渲染中有一个常用的技术被成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成为</li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>实现原理：在运行时根据程序集和其中的类型得到元数据<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line">Assembly.Load(<span class="string">"程序集"</span>);<span class="comment">//加载一个程序集，返回类型是一个Assembly</span></span><br><span class="line"><span class="keyword">foreach</span>(Type type <span class="keyword">in</span> assembly.GetType())</span><br><span class="line">&#123;</span><br><span class="line">    stromh t = type.name;</span><br><span class="line">&#125;</span><br><span class="line">Type type = assembly.GetType(<span class="string">"程序集.类名"</span>); <span class="comment">//获取当前类的类型</span></span><br><span class="line"><span class="keyword">var</span> activator = System.Activator.CreateInstance(type); <span class="comment">// 创建此类型实例</span></span><br><span class="line">MethodInfo mInfo = type.GetMethod(<span class="string">"方法名"</span>);<span class="comment">//获取当前方法</span></span><br><span class="line">mInfo.Invok(<span class="literal">null</span>, 方法参数);</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/10/unity-nature-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/10/unity-nature-review/" class="post-title-link" itemprop="url">unity-nature-review</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-10 15:36:26" itemprop="dateCreated datePublished" datetime="2018-04-10T15:36:26+08:00">2018-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>是否有多维子材质：多维子材质材质测试，三个子材质，50个物体，使用多维子材质12帧，330个dc，343面。拆开之后20帧，154dc，134面。多维子材质Unity无法动态合并。<br>叠加模式贴图，可以不用Alpha通道<br>特效粒子贴图是否合并<br>是否有些粒子能使用序列帧，不过和视角有关，去掉alpha贴图合并。<br>动画boneweight,没有特殊需要的情况下受两个骨骼影响就够了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/Unix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/Unix/" class="post-title-link" itemprop="url">大端模式与小端模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 10:42:38" itemprop="dateCreated datePublished" datetime="2018-04-02T10:42:38+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><ul>
<li>Little-Endian         低位字节放在内存的低地址端，高位字节放在内存的高地址端。</li>
<li>Big-Endian            高位字节放在内存的高地址端，低位字节放在内存的低地址端。</li>
<li>Network byte order    TPC/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。</li>
</ul>
<h3 id="高-低地址端"><a href="#高-低地址端" class="headerlink" title="高/低地址端"></a>高/低地址端</h3><p>首先要知道C程序中内存的空间布局情况：在《C专家编程》和《Unix环境高级编程》中关于内存空间布局情况的说明，大致如下图：</p>
<p>——————————————— 最高内存地址 0xffffffff<br>栈底<br>栈<br>栈顶<br>NULL（空洞）<br>堆<br>未初始化的数据<br>正文段（代码段<br>——————————————— 最高内存地址 0x00000000</p>
<p>在内存分布中，栈是向下增长的，而堆是向上增长的。</p>
<p>加入在栈分配unisgned char buf[4]，他在栈上分布如下<br>栈底（高地址）<br>buf[3]<br>buf[2]<br>buf[1]<br>buf[0]<br>栈顶（低地址）</p>
<h3 id="高-低位字节"><a href="#高-低位字节" class="headerlink" title="高/低位字节"></a>高/低位字节</h3><p>在十进制中靠左边的是高位，靠右边的地址，在其它进制也是如此</p>
<p>unisgned int value = 0x12345678;</p>
<p>Big-Endian:低地址存放高位<br>栈底（高地址）<br>buf[3] (0x78)<br>buf[2] (0x56)<br>buf[1] (0x34)<br>buf[0] (0x12)<br>栈顶（低地址）</p>
<p>Litter-Endian:高地址存高位<br>栈顶（高地址）<br>buf[0] (0x78)<br>buf[1] (0x56)<br>buf[2] (0x34)<br>buf[3] (0x12)<br>栈底（低地址）</p>
<p><td bgcolor="orange"> 主机序（Host Order）就是遵循Little-Endian规则</td>。所以当两台主机之间通过TCP/IP协议进行通信的时候就需要调用相应的函数进行主机序（Little-Endian）和网络（Big-Endian）的转换。</p>
<h2 id="Big-Endian和Little-Endian优缺点"><a href="#Big-Endian和Little-Endian优缺点" class="headerlink" title="Big-Endian和Little-Endian优缺点"></a>Big-Endian和Little-Endian优缺点</h2><p>Big-Endian 优点：</p>
<ol>
<li>靠首先提取高位字节，总是可以在偏移位置为0的字节来确定这个数字是正数还是负数。</li>
<li>数值打印是按顺序存放的</li>
</ol>
<p>Litter-Endian 优点：</p>
<ol>
<li>数学计算，精度处理。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/Lua-5-1-refer-manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/Lua-5-1-refer-manual/" class="post-title-link" itemprop="url">Lua参考手册上半部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 10:42:38" itemprop="dateCreated datePublished" datetime="2018-04-02T10:42:38+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lua 是一个扩展式程序设计语言，它被设计成支持通用的过程式编程，并有相关数据描述的设施。 Lua 也能对面向对象编程，函数式编程，数据驱动式编程提供很好的支持。 它可以作为一个强大、轻量的脚本语言，供任何需要的程序使用。 Lua 以一个用 clean C 写成的库形式提供。（所谓 Clean C ，指的 ANSI C 和 C++ 中共通的一个子集）<br>作为一个扩展式语言，Lua 没有 “main” 程序的概念：它只能 嵌入 一个宿主程序中工作，这个宿主程序被称作 embedding program 或简称为 host 。 宿主程序可以通过调用函数执行一小段 Lua 代码，可以读写 Lua 变量，可以注入 C 函数让 Lua 代码调用。 这些扩展的 C 函数，可以大大的扩展了 Lua 可以处理事务的领域，这样就可以订制出各种语言， 而它们共享一个统一的句法格式的框架。 Lua 的官方发布版就包含了一个叫做 lua 的简单的宿主程序，它用 Lua 库提供了一个保证独立的 Lua 解释器。<br>Lua 是一个自由软件，它的使用许可决定了对它的使用过程一般没有任何保证。 这份手册中描述的东西的实现，可以在 Lua 的官方网站 www.lua.org 找到，<br>跟其它的许多参考手册一样，这份文档有些地方比较枯燥。 关于 Lua 的设计想法的探讨，可以看看 Lua 网站上提供的技术论文。 有关用 Lua 编程的细节介绍，可以读一下 Roberto 的书，Programming in Lua (Second Edition) 。</p>
<p>这一节从词法、语法、句法上描述 Lua 。 换句话说，这一节描述了哪些 token （符记）是有效的，它们如何被组合起来，这些组合方式有什么含义。<br>关于语言的构成概念将用常见的扩展 BNF 表达式写出。也就是这个样子： {a} 意思是 0 或多个 a ， [a] 意思是一个可选的 a 。 非最终的符号会保留原来的样子，关键字则看起来像这样 kword ， 其它最终的符号则写成 `=´ 。 完整的 Lua 语法可以在本手册最后找到。</p>
<p>Lua 中用到的 名字（也称作 标识符）可以是任何非数字开头的字母、数字、下划线组成的字符串。 这符合几乎所有编程语言中关于名字的定义。 （字母的定义依赖于当前环境：系统环境中定义的字母表中的字母都可以被用于标识符。） 标识符用来命名变量，或作为表的域名。</p>
<p>下面的关键字是保留的，不能用作名字：</p>
<pre><code>and       break     do        else      elseif
end       false     for       function  if
in        local     nil       not       or
repeat    return    then      true      until     while
</code></pre><p>Lua 是一个大小写敏感的语言： and 是一个保留字，但是 And 和 AND 则是两个不同的合法的名字。 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<p>下面这些是其它的 token ：</p>
<pre><code> +     -     *     /     %     ^     #
 ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
 (     )     {     }     [     ]
 ;     :     ,     .     ..    ...
</code></pre><p>字符串既可以用一对单引号引起，也可以是双引号，里面还可以包含类似 C 的转义符： ‘\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （表单）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\‘ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\’’ （单引号)。 而且，如果在一个反斜杠后跟了一个真正的换行符，其结果就是在字符串中产生一个换行符。 我们还可以用反斜杠加数字的形式 \ddd 来描述一个字符。这里， ddd 是一串最多三位的十进制数字。（注意，如果需要在这种描述方法后接一个是数字的字符， 那么反斜杠后必须写满三个数字。）Lua 中的字符串可以包含任何 8 位的值。包括用 ‘\0’ 表示的零。<br>只有在你需要把不同的引号、换行、反斜杠、或是零结束符这些字符置入字符串时， 你才必须使用转义符。别的任何字符都可以直接写在文本里。（一些控制符可以会影响文件系统造成某些问题， 但是不会引起 Lua 的任何问题。）<br>字符串还可以用一种长括号括起来的方式定义。 我们把两个正的方括号间插入 n 个等号定义为第 n 级正长括号。 就是说，0 级正的长括号写作 [[ ， 一级正的长括号写作 [=[ ，如此等等。 反的长扩展也作类似定义； 举个例子，4 级反的长括号写作 ]====] 。 一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。 整个词法分析过程将不受分行限制，不处理任何转意符，并且忽略掉任何不同级别的长括号。 这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。<br>另一个约定是，当正的长括号后面立即跟了一个换行符， 这个换行符就不包含在这个字符串内。 举个例子，假设一个系统使用 ASCII 码 （这时，’a’ 编码为 97 ，换行符编码为 10 ，’1’ 编码为 49 ）， 下面五种方式描述了完全相同的字符串：</p>
<pre><code> a = &#39;alo\n123&quot;&#39;
 a = &quot;alo\n123\&quot;&quot;
 a = &#39;\97lo\10\04923&quot;&#39;
 a = [[alo
 123&quot;]]
 a = [==[
 alo
 123&quot;]==]
</code></pre><p>数字常量可以分两部分写，十进制底数部分和十进制的指数部分。指数部分是可选的。 Lua 也支持十六进制整数常量，只需要在前面加上前缀 0x 。 下面是一些合法的数字常量的例子：</p>
<pre><code> 3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56
</code></pre><p>注释可以在除字符串内的任何地方是以两横 (—) 开始。 如果跟在两横后面的不是一个长括号，这就是一个短注释，它的作用范围直到行末； 否则就是一个长注释，其作用范围直到遇到反的长括号。 长注释通常被用来临时屏蔽代码块。<br>Lua 是一种 动态类型语言。 这意味着变量没有类型，只有值才有类型。 语言中不存在类型定义。而所有的值本身携带它们自己的类型信息。<br>Lua 中的所有值都是一致 (first-class) 的。 这意味着所有的值都可以被放在变量里，当作参数传递到另一个函数中，并被函数作为结果返回。<br>Lua 中有八种基本类型： nil, boolean, number, string, function, userdata, thread, and table. Nil 类型只有一种值 nil ，它的主要用途用于标表识和别的任何值的差异； 通常，当需要描述一个无意义的值时会用到它。 Boolean 类型只有两种值：false 和 true。 nil 和 false 都能导致条件为假；而另外所有的值都被当作真。 Number 表示实数（双精度浮点数）。 （编译一个其它内部数字类型的 Lua 解释器是件很容易的事；比如把内部数字类型改作 单精度浮点数或长整型。参见文件 luaconf.h 。） String 表示一串字符的数组。 Lua 是 8-bit clean 的： 字符串可以包含任何 8 位字符， 包括零结束符 (‘\0’) （参见 §2.1）。<br>Lua 可以调用（和处理）用 Lua 写的函数以及用 C 写的函数<br>userdata 类型用来将任意 C 数据保存在 Lua 变量中。 这个类型相当于一块原生的内存，除了赋值和相同性判断，Lua 没有为之预定义任何操作。 然而，通过使用 metatable （元表） ，程序员可以为 userdata 自定义一组操作。 userdata 不能在 Lua 中创建出来，也不能在 Lua 中修改。这样的操作只能通过 C API。 这一点保证了宿主程序完全掌管其中的数据。<br>thread 类型用来区别独立的执行线程，它被用来实现 coroutine （协同例程）。 不要把 Lua 线程跟操作系统的线程搞混。 Lua 可以在所有的系统上提供对 coroutine 的支持，即使系统并不支持线程。<br>table 类型实现了一个关联数组。也就是说， 数组可以用任何东西（除了nil）做索引，而不限于数字。 table 可以以不同类型的值构成；它可以包含所有的类型的值（除 nil 外）。 table 是 lua 中唯一的一种数据结构；它可以用来描述原始的数组、符号表、集合、 记录、图、树、等等。 用于表述记录时，lua 使用域名作为索引。 语言本身采用一种语法糖，支持以 a.name 的形式表示 a[“name”]。 有很多形式用于在 lua 中创建一个 table （参见 §2.5.7）。<br>跟索引一样， table 每个域中的值也可以是任何类型（除 nil外）。 特别的，因为函数本身也是值，所以 table 的域中也可以放函数。 这样 table 中就可以有一些 methods 了 。<br>table， function ，thread ，和 (full) userdata 这些类型的值是所谓的对象： 变量本身并不会真正的存放它们的值，而只是放了一个对对象的引用。 赋值，参数传递，函数返回，都是对这些对象的引用进行操作； 这些操作不会做暗地里做任何性质的拷贝。<br>库函数 type 可以返回一个描述给定值的类型的字符串。<br>Lua 提供运行时字符串到数字的自动转换。 任何对字符串的数学运算操作都会尝试用一般的转换规则把这个字符串转换成一个数字。 相反，无论何时，一个数字需要作为字符串来使用时，数字都会以合理的格式转换为字符串。 需要完全控制数字怎样转换为字符串，可以使用字符串库中的 format 函数 （参见 string.format）。<br>写上变量的地方意味着当以其保存的值来替代之。 Lua 中有三类变量：全局变量，局部变量，还有 table 的域。<br>一个单一的名字可以表示一个全局变量，也可以表示一个局部变量 （或者是一个函数的参数，这是一种特殊形式的局部变量）：</p>
<pre><code>var ::= Name
</code></pre><p>Name 就是所定义的标识符。<br>任何变量都被假定为全局变量，除非显式的以 local 修饰定义。 局部变量有其作用范围： 局部变量可以被定义在它作用范围中的函数自由使用。<br>在变量的首次赋值之前，变量的值均为 nil。<br>方括号被用来对 table 作索引：</p>
<pre><code>var ::= prefixexp `[´ exp `]´
</code></pre><p>对全局变量以及 table 域之访问的含义可以通过 metatable 来改变。 以取一个变量下标指向的量 t[i] 等价于调用 gettable_event(t,i)。 （参见 §2.8 ，有一份完整的关于 gettable_event 函数的说明。 这个函数并没有在 lua 中定义出来，也不能在 lua 中调用。 这里我们把它列出来只是方便说明。）</p>
<p>var.Name 这种语法只是一个语法糖，用来表示 var[“Name”]：</p>
<pre><code>var ::= prefixexp `.´ Name
</code></pre><p>所有的全局变量都是放在一个特定 lua table 的诸个域中，这个特定的 table 叫作 environment （环境）table 或者简称为 环境 （参见 §2.9）。 每个函数都有对一个环境的引用， 所以一个函数中可见的所有全局变量都放在这个函数所引用的环境表（environment table）中。 当一个函数被创建出来，它会从创建它的函数中继承其环境，你可以调用 getfenv 取得其环境。 如果想改变环境，可以调用 setfenv。 （对于 C 函数，你只能通过 debug 库来改变其环境； 参见 §5.9）。</p>
<p>对一个全局变量 x 的访问 等价于 _env.x，而这又可以等价于</p>
<pre><code>gettable_event(_env, &quot;x&quot;)
</code></pre><p>这里，_env 是当前运行的函数的环境。 （函数 gettable_event 的完整说明参见 §2.8。 这个函数并没有在 lua 中定义出来，也不能调用。 当然，_env 这个变量也同样没有在 Lua 中定义出来。 我们在这里使用它们，仅仅只是方便解释而已。）</p>
<p>2.4 - 语句段（Statement）<br>Lua 支持惯例形式的语句段，它和 Pascal 或是 C 很相象。 这个集合包括赋值，控制结构，函数调用，还有变量声明。</p>
<p>2.4.1 - Chunk（语句组）<br>Lua 的一个执行单元被称作 chunk。 一个 chunk 就是一串语句段，它们会被循序的执行。 每个语句段可以以一个分号结束：</p>
<pre><code>chunk ::= {stat [`;´]}
</code></pre><p>这儿不允许有空的语句段，所以 ‘;;’ 是非法的。</p>
<p>lua 把一个 chunk 当作一个拥有不定参数的匿名函数 （参见 §2.5.9）处理。 正是这样，chunk 内可以定义局部变量，接收参数，并且返回值。</p>
<p>chunk 可以被保存在一个文件中，也可以保存在宿主程序的一个字符串中。 当一个 chunk 被执行，首先它会被预编译成虚拟机中的指令序列， 然后被虚拟机解释运行这些指令。</p>
<p>chunk 也可以被预编译成二进制形式；细节参考程序 luac。 用源码形式提供的程序和被编译过的二进制形式的程序是可以相互替换的； Lua 会自动识别文件类型并做正确的处理。</p>
<p>语句块是一列语句段；从语法上来说，一个语句块跟一个 chunk 相同：</p>
<pre><code>block ::= chunk
</code></pre><p>一个语句块可以被显式的写成一个单独的语句段：</p>
<pre><code>stat ::= do block end
</code></pre><p>显式的语句块对于控制变量的作用范围很有用。 有时候，显式的语句块被用来在另一个语句块中插入 return 或是 break （参见 §2.4.4）。</p>
<p>Lua 允许多重赋值。 因此，赋值的语法定义是等号左边放一系列变量， 而等号右边放一系列的表达式。 两边的元素都用逗号间开：</p>
<pre><code>stat ::= varlist1 `=´ explist1
varlist1 ::= var {`,´ var}
explist1 ::= exp {`,´ exp}
</code></pre><p>在作赋值操作之前， 那一系列的右值会被对齐到左边变量需要的个数。 如果右值比需要的更多的话，多余的值就被扔掉。 如果右值的数量不够需求， 将会按所需扩展若干个 nil。 如果表达式列表以一个函数调用结束， 这个函数所返回的所有值都会在对齐操作之前被置入右值序列中。 （除非这个函数调用被用括号括了起来；参见 §2.5）。</p>
<p>赋值段首先会做运算完所有的表达式，然后仅仅做赋值操作。 因此，下面这段代码</p>
<pre><code> i = 3
 i, a[i] = i+1, 20
</code></pre><p>会把 a[3] 设置为 20，而不会影响到 a[4] 。 这是因为 a[i] 中的 i 在被赋值为 4 之前就被拿出来了（那时是 3 ）。 简单说 ，这样一行</p>
<pre><code> x, y = y, x
</code></pre><p>可以用来交换 x 和 y 中的值。</p>
<p>对全局变量以及 table 中的域的赋值操作的含义可以通过 metatable 来改变。 对变量下标指向的赋值，即 t[i] = val 等价于 settable_event(t,i,val)。 （关于函数 settable_event 的详细说明，参见 §2.8。 这个函数并没有在 Lua 中定义出来，也不可以被调用。 这里我们列出来，仅仅出于方便解释的目的）</p>
<p>对于全局变量的赋值 x = val 等价于 _env.x = val，这个又可以等价于</p>
<pre><code>settable_event(_env, &quot;x&quot;, val)
</code></pre><p>这里，_env 指的是正在运行中的函数的环境。 （变量 _env 并没有在 Lua 中定义出来。 我们仅仅出于解释的目的在这里写出来。）</p>
<p>if、 while、以及 repeat 这些控制结构符合通常的意义，而且也有类似的语法：</p>
<pre><code>stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
</code></pre><p>Lua 也有一个 for 语句，它有两种形式。<br>控制结构中的条件表达式可以返回任何值。 false 和 nil 两者都被认为是假条件。 所有不同于 nil 和 false 的其它值都被认为是真 （特别需要注意的是，数字 0 和空字符串也被认为是真）。<br>在 repeat–until 循环中， 内部语句块的结束点不是在 until 这个关键字处， 它还包括了其后的条件表达式。 因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。<br>return 被用于从函数或是 chunk（其实它就是一个函数）中 返回值。 函数和 chunk 可以返回不只一个值， 所以 return 的语法为</p>
<pre><code>stat ::= return [explist1]
</code></pre><p>break 被用来结束 while、 repeat、或 for 循环， 它将忽略掉循环中下面的语句段的运行：</p>
<pre><code>stat ::= break
</code></pre><p>break 跳出最内层的循环。<br>return 和 break 只能被写在一个语句块的最后一句。 如果你真的需要从语句块的中间 return 或是 break ， 你可以使用显式的声名一个内部语句块。 一般写作 do return end 或是 do break end， 可以这样写是因为现在 return 或 break 都成了一个语句块的最后一句了。</p>
<p>for 有两种形式：一种是数字形式，另一种是一般形式。</p>
<p>数字形式的 for 循环，通过一个数学运算不断的运行内部的代码块。 下面是它的语法：</p>
<pre><code>stat ::= for Name `=´ exp `,´ exp [`,´ exp] do block end
</code></pre><p>block 将把 name 作循环变量。从第一个 exp 开始起，直到第二个 exp 的值为止，其步长为 第三个 exp 。 更确切的说，一个 for 循环看起来是这个样子</p>
<pre><code> for v = e1, e2, e3 do block end
</code></pre><p>这等价于代码：</p>
<pre><code>do
   local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
   if not (var and limit and step) then error() end
   while (step &gt; 0 and var &lt;= limit) or (step &lt;= 0 and var &gt;= limit) do
     local v = var
     block
     var = var + step
   end
end
</code></pre><p>注意下面这几点：</p>
<p>所有三个控制表达式都只被运算一次，表达式的计算在循环开始之前。 这些表达式的结果必须是数字。<br>var 、limit 、以及 step 都是一些不可见的变量。 这里给它们起的名字都仅仅用于解释方便。<br>如果第三个表达式（步长）没有给出，会把步长设为 1 。<br>你可以用 break 来退出 for 循环。<br>循环变量 v 是一个循环内部的局部变量； 当 for 循环结束后，你就不能在使用它。 如果你需要这个值，在退出循环前把它赋给另一个变量。<br>一般形式的 for 通过一个叫作迭代器（iterators）的函数工作。 每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。 一般形式的 for 循环的语法如下：</p>
<pre><code>stat ::= for namelist in explist1 do block end
namelist ::= Name {`,´ Name}
</code></pre><p>for 语句好似这样</p>
<pre><code> for var_1, ···, var_n in explist do block end
</code></pre><p>它等价于这样一段代码：</p>
<pre><code> do
   local f, s, var = explist
   while true do
     local var_1, ···, var_n = f(s, var)
     var = var_1
     if var == nil then break end
     block
   end
 end
</code></pre><p>注意以下几点：</p>
<p>explist 只会被计算一次。 它返回三个值， 一个迭代器函数，一个状态，一个迭代器的初始值。<br>f、 s、 以及 var 都是不可见的变量。 这里给它们起的名字都只是为了解说方便。<br>你可以使用 break 来跳出 for 循环。<br>循环变量 var_i 对于循环来说是一个局部变量； 你不可以在 for 循环结束后继续使用。 如果你需要保留这些值，那么就在循环结束前赋值到别的变量里去。<br>2.4.6 - 把函数调用作为语句段<br>为了允许使用可能的副作用， 函数调用可以被作为一个语句段执行：</p>
<pre><code>stat ::= functioncall
</code></pre><p>在这种情况下，所有的返回值都被舍弃。 函数调用在 §2.5.8 中解释。</p>
<p>2.4.7 - 局部变量声名<br>局部变量可以在语句块中任何地方声名。 声名可以包含一个初始化赋值操作：</p>
<pre><code>stat ::= local namelist [`=´ explist1]
</code></pre><p>如果有的话，初始化赋值操作的行为等同于赋值操作（参见 §2.4.3）。 否则，所有的变量将被初始化为 nil。</p>
<p>一个 chunk 同时也是一个语句块（参见 §2.4.1）， 所以局部变量可以放在 chunk 中那些显式注明的语句块之外。 这些局部变量的作用范围从声明起一直延伸到 chunk 末尾。</p>
<p>局部变量的可见规则在 §2.6 中解释。</p>
<p>2.5 - 表达式<br>Lua 中有这些基本表达式：</p>
<pre><code>exp ::= prefixexp
exp ::= nil | false | true
exp ::= Number
exp ::= String
exp ::= function
exp ::= tableconstructor
exp ::= `...´
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | `(´ exp `)´
</code></pre><p>数字和字符串在 §2.1 中解释； 变量在 §2.3 中解释； 函数定义在 §2.5.9 中解释； 函数调用在 §2.5.8 中解释； table 的构造在 §2.5.7 中解释； 可变参数的表达式写作三个点 (‘…’) ，它只能被用在有可变参数的函数中； 这些在 §2.5.9 中解释。</p>
<p>二元操作符包含有数学运算操作符（参见 §2.5.1）， 比较操作符（参见 §2.5.2），逻辑操作符（参见 §2.5.3）， 以及连接操作符（参见 §2.5.4）。 一元操作符包括负号（参见see §2.5.1）， 取反 not（参见 §2.5.3）， 和取长度操作符（参见 §2.5.5）。</p>
<p>函数调用和可变参数表达式都可以放在多重返回值中。 如果表达式作为一个独立语句段出现（参见 §2.4.6） （这只能是一个函数调用）， 它们的返回列表将被对齐到零个元素，也就是忽略所有返回值。 如果表达式用于表达式列表的最后（或者是唯一）的元素， 就不会有任何的对齐操作（除非函数调用用括号括起来）。 在任何其它的情况下，Lua 将把表达式结果看成单一元素， 忽略除第一个之外的任何值。</p>
<p>这里有一些例子：</p>
<pre><code> f()                -- 调整到 0 个结果
 g(f(), x)          -- f() 被调整到一个结果
 g(x, f())          -- g 被传入 x 加上所有 f() 的返回值
 a,b,c = f(), x     -- f() 被调整到一个结果 （ c 在这里被赋为 nil ）
 a,b = ...          -- a 被赋值为可变参数中的第一个，
                    -- b 被赋值为第二个 （如果可变参数中并没有对应的值，
                    -- 这里 a 和 b 都有可能被赋为 nil）

 a,b,c = x, f()     -- f() 被调整为两个结果
 a,b,c = f()        -- f() 被调整为三个结果
 return f()         -- 返回 f() 返回的所有结果
 return ...         -- 返回所有从可变参数中接收来的值
 return x,y,f()     -- 返回 x, y, 以及所有 f() 的返回值
 {f()}              -- 用 f() 的所有返回值创建一个列表
 {...}              -- 用可变参数中的所有值创建一个列表
 {f(), nil}         -- f() 被调整为一个结果
</code></pre><p>被括号括起来的表达式永远被当作一个值。所以， (f(x,y,z)) 即使 f 返回多个值，这个表达式永远是一个单一值。 （(f(x,y,z)) 的值是 f 返回的第一个值。如果 f 不返回值的话，那么它的值就是 nil 。）</p>
<p>2.5.1 - 数学运算操作符<br>Lua 支持常见的数学运算操作符： 二元操作 + （加法）， - （减法），* （乘法）， / （除法）， % （取模），以及 ^ （幂）； 和一元操作 - （取负）。 如果对数字操作，或是可以转换为数字的字符串（参见 §2.2.1）， 所有这些操作都依赖它通常的含义。 幂操作可以对任何幂值都正常工作。比如， x^(-0.5) 将计算出 x 平方根的倒数。 取模操作被定义为</p>
<pre><code> a % b == a - math.floor(a/b)*b
</code></pre><p>这就是说，其结果是商相对负无穷圆整后的余数。（译注：负数对正数取模的结果为正数）</p>
<p>2.5.2 - 比较操作符<br>Lua 中的比较操作符有</p>
<pre><code> ==    ~=    &lt;     &gt;     &lt;=    &gt;=
</code></pre><p>这些操作的结果不是 false 就是 true。</p>
<p>等于操作 (==) 首先比较操作数的类型。 如果类型不同，结果就是 false。 否则，继续比较值。 数字和字符串都用常规的方式比较。 对象 （table ，userdata ，thread ，以及函数）以引用的形式比较： 两个对象只有在它们指向同一个东西时才认为相等。 每次你创建一个新对象（一个 table 或是 userdata ，thread 函数）， 它们都各不相同，即不同于上次创建的东西。</p>
<p>你可以改变 Lua 比较 table 和 userdata 的方式，这需要使用 “eq” 这个原方法 （参见 §2.8）。</p>
<p>§2.2.1 中提及的转换规则并不作用于比较操作。 所以， “0”==0 等于 false， 而且 t[0] 和 t[“0”] 描述的是 table 中不同的域。</p>
<p>操作符 ~= 完全等价于 (==) 操作的反值。</p>
<p>大小比较操作以以下方式进行。 如果参数都是数字，那么就直接做数字比较。 否则，如果参数都是字符串，就用字符串比较的方式进行。 再则，Lua 就试着调用 “lt” 或是 “le” 元方法 （参见 §2.8）。</p>
<p>2.5.3 - 逻辑操作符<br>Lua 中的逻辑操作符有 and, or, 以及 not。 和控制结构（参见 §2.4.4）一样， 所有的逻辑操作符把 false 和 nil 都作为假， 而其它的一切都当作真。</p>
<p>取反操作 not 总是返回 false 或 true 中的一个。 与操作符 and 在第一个参数为 false 或 nil 时 返回这第一个参数； 否则，and 返回第二个参数。 或操作符 or 在第一个参数不为 nil 也不为 false 时， 返回这第一个参数，否则返回第二个参数。 and 和 or 都遵循短路规则； 也就是说，第二个操作数只在需要的时候去求值。 这里有一些例子：</p>
<pre><code> 10 or 20            --&gt; 10
 10 or error()       --&gt; 10
 nil or &quot;a&quot;          --&gt; &quot;a&quot;
 nil and 10          --&gt; nil
 false and error()   --&gt; false
 false and nil       --&gt; false
 false or nil        --&gt; nil
 10 and 20           --&gt; 20
</code></pre><p>（在这本手册中， —&gt; 指前面表达式的结果。）</p>
<p>2.5.4 - 连接符<br>Lua 中字符串的连接操作符写作两个点 (‘..’)。 如果两个操作数都是字符串或都是数字，连接操作将以 §2.2.1 中提到的规则把其转换为字符串。 否则，会取调用元方法 “concat” （参见 §2.8）。</p>
<p>2.5.5 - 取长度操作符<br>取长度操作符写作一元操作 #。 字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。</p>
<p>table t 的长度被定义成一个整数下标 n 。 它满足 t[n] 不是 nil 而 t[n+1] 为 nil； 此外，如果 t[1] 为 nil ，n 就可能是零。 对于常规的数组，里面从 1 到 n 放着一些非空的值的时候， 它的长度就精确的为 n，即最后一个值的下标。 如果数组有一个“空洞” （就是说，nil 值被夹在非空值之间）， 那么 #t 可能是指向任何一个是 nil 值的前一个位置的下标 （就是说，任何一个 nil 值都有可能被当成数组的结束）。</p>
<p>2.5.6 - 优先级<br>Lua 中操作符的优先级写在下表中，从低到高优先级排序：</p>
<pre><code> or
 and
 &lt;     &gt;     &lt;=    &gt;=    ~=    ==
 ..
 +     -
 *     /     %
 not   #     - (unary)
 ^
</code></pre><p>通常，你可以用括号来改变运算次序。 连接操作符 (‘..’) 和幂操作 (‘^’) 是从右至左的。 其它所有的操作都是从左至右。</p>
<p>2.5.7 - Table 构造<br>table 构造子是一个构造 table 的表达式。 每次构造子被执行，都会构造出一个新的 table 。 构造子可以被用来构造一个空的 table， 也可以用来构造一个 table 并初始化其中的一些域。 一般的构造子的语法如下</p>
<pre><code>tableconstructor ::= `{´ [fieldlist] `}´
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
fieldsep ::= `,´ | `;´
</code></pre><p>每个形如 [exp1] = exp2 的域向 table 中增加新的一项， 其键值为 exp1 而值为 exp2。 形如 name = exp 的域等价于 [“name”] = exp。 最后，形如 exp 的域等价于 [i] = exp ， 这里的 i 是一个从 1 开始不断增长的数字。 这这个格式中的其它域不会破坏其记数。 举个例子：</p>
<pre><code> a = { [f(1)] = g; &quot;x&quot;, &quot;y&quot;; x = 1, f(x), [30] = 23; 45 }
</code></pre><p>等价于</p>
<pre><code> do
   local t = {}
   t[f(1)] = g
   t[1] = &quot;x&quot;         -- 1st exp
   t[2] = &quot;y&quot;         -- 2nd exp
   t.x = 1            -- t[&quot;x&quot;] = 1
   t[3] = f(x)        -- 3rd exp
   t[30] = 23
   t[4] = 45          -- 4th exp
   a = t
 end
</code></pre><p>如果表单中最后一个域的形式是 exp ， 而且其表达式是一个函数调用或者是一个可变参数， 那么这个表达式所有的返回值将连续的进入列表 （参见 §2.5.8）。 为了避免这一点，你可以用括号把函数调用（或是可变参数）括起来 （参见 §2.5）。</p>
<p>初始化域表可以在最后多一个分割符， 这样设计可以方便由机器生成代码。</p>
<p>2.5.8 - 函数调用<br>Lua 中的函数调用的语法如下：</p>
<pre><code>functioncall ::= prefixexp args
</code></pre><p>函数调用时，第一步，prefixexp 和 args 先被求值。 如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 “call” 就被调用， 第一个参数就是 prefixexp 的值，跟下来的是原来的调用参数 （参见 §2.8）。</p>
<p>这样的形式</p>
<pre><code>functioncall ::= prefixexp `:´ Name args
</code></pre><p>可以用来调用 “方法”。 这是 Lua 支持的一种语法糖。像 v:name(args) 这个样子，被解释成 v.name(v,args)， 这里 v 只会被求值一次。</p>
<p>参数的语法如下：</p>
<pre><code>args ::= `(´ [explist1] `)´
args ::= tableconstructor
args ::= String
</code></pre><p>所有参数的表达式求值都在函数调用之前。 这样的调用形式 f{fields} 是一种语法糖用于表示 f({fields})； 这里指参数列表是一个单一的新创建出来的列表。 而这样的形式 f’string’ （或是 f”string” 亦或是 f[[string]]） 也是一种语法糖，用于表示 f(‘string’)； 这里指参数列表是一个单独的字符串。</p>
<p>因为表达式语法在 Lua 中比较自由， 所以你不能在函数调用的 ‘(‘ 前换行。 这个限制可以避免语言中的一些歧义。 比如你这样写</p>
<pre><code> a = f
 (g).x(a)
</code></pre><p>Lua 将把它当作一个单一语句段， a = f(g).x(a) 。 因此，如果你真的想作为成两个语句段，你必须在它们之间写上一个分号。 如果你真的想调用 f， 你必须从 (g) 前移去换行。</p>
<p>这样一种调用形式：return functioncall 将触发一个尾调用。 Lua 实现了适当的尾部调用（或是适当的尾递归）： 在尾调用中， 被调用的函数重用调用它的函数的堆栈项。 因此，对于程序执行的嵌套尾调用的层数是没有限制的。 然而，尾调用将删除调用它的函数的任何调试信息。 注意，尾调用只发生在特定的语法下， 这时， return 只有单一函数调用作为参数； 这种语法使得调用函数的结果可以精确返回。 因此，下面这些例子都不是尾调用：</p>
<pre><code> return (f(x))        -- 返回值被调整为一个
 return 2 * f(x)
 return x, f(x)       -- 最加若干返回值
 f(x); return         -- 无返回值
 return x or f(x)     -- 返回值被调整为一个
</code></pre><p>2.5.9 - 函数定义<br>函数定义的语法如下：</p>
<pre><code>function ::= function funcbody
funcbody ::= `(´ [parlist1] `)´ block end
</code></pre><p>另外定义了一些语法糖简化函数定义的写法：</p>
<pre><code>stat ::= function funcname funcbody
stat ::= local function Name funcbody
funcname ::= Name {`.´ Name} [`:´ Name]
</code></pre><p>这样的写法：</p>
<pre><code> function f () body end
</code></pre><p>被转换成</p>
<pre><code> f = function () body end
</code></pre><p>这样的写法：</p>
<pre><code> function t.a.b.c.f () body end
</code></pre><p>被转换成</p>
<pre><code> t.a.b.c.f = function () body end
</code></pre><p>这样的写法：</p>
<pre><code> local function f () body end
</code></pre><p>被转换成</p>
<pre><code> local f; f = function () body end
</code></pre><p>注意，并不是转换成</p>
<pre><code> local f = function () body end
</code></pre><p>（这个差别只在函数体内需要引用 f 时才有。）</p>
<p>一个函数定义是一个可执行的表达式， 执行结果是一个类型为 function 的值。 当 Lua 预编译一个 chunk 的时候， chunk 作为一个函数，整个函数体也就被预编译了。 那么，无论何时 Lua 执行了函数定义， 这个函数本身就被实例化了（或者说是关闭了）。 这个函数的实例（或者说是 closure（闭包）） 是表达式的最终值。 相同函数的不同实例有可能引用不同的外部局部变量， 也可能拥有不同的环境表。</p>
<p>形参（函数定义需要的参数）是一些由实参（实际传入参数）的值初始化的局部变量：</p>
<pre><code>parlist1 ::= namelist [`,´ `...´] | `...´
</code></pre><p>当一个函数被调用， 如果函数没有被定义为接收不定长参数，即在形参列表的末尾注明三个点 (‘…’)， 那么实参列表就会被调整到形参列表的长度， 变长参数函数不会调整实参列表； 取而代之的是，它将把所有额外的参数放在一起通过变长参数表达式传递给函数， 其写法依旧是三个点。 这个表达式的值是一串实参值的列表，看起来就跟一个可以返回多个结果的函数一样。 如果一个变长参数表达式放在另一个表达式中使用，或是放在另一串表达式的中间， 那么它的返回值就会被调整为单个值。 若这个表达式放在了一系列表达式的最后一个，就不会做调整了（除非用括号给括了起来）。</p>
<p>我们先做如下定义，然后再来看一个例子：</p>
<pre><code> function f(a, b) end
 function g(a, b, ...) end
 function r() return 1,2,3 end
</code></pre><p>下面看看实参到形参数以及可变长参数的映射关系：</p>
<pre><code> CALL            PARAMETERS

 f(3)             a=3, b=nil
 f(3, 4)          a=3, b=4
 f(3, 4, 5)       a=3, b=4
 f(r(), 10)       a=1, b=10
 f(r())           a=1, b=2

 g(3)             a=3, b=nil, ... --&gt;  (nothing)
 g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
 g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
 g(5, r())        a=5, b=1,   ... --&gt;  2  3
</code></pre><p>结果由 return 来返回（参见 §2.4.4）。 如果执行到函数末尾依旧没有遇到任何 return 语句， 函数就不会返回任何结果。</p>
<p>冒号语法可以用来定义方法， 就是说，函数可以有一个隐式的形参 self。 因此，如下写法：</p>
<pre><code> function t.a.b.c:f (params) body end
</code></pre><p>是这样一种写法的语法糖：</p>
<pre><code> t.a.b.c.f = function (self, params) body end
</code></pre><p>2.6 - 可视规则<br>Lua 是一个有词法作用范围的语言。 变量的作用范围开始于声明它们之后的第一个语句段， 结束于包含这个声明的最内层语句块的结束点。 看下面这些例子：</p>
<pre><code> x = 10                -- 全局变量
 do                    -- 新的语句块
   local x = x         -- 新的一个 &#39;x&#39;, 它的值现在是 10
   print(x)            --&gt; 10
   x = x+1
   do                  -- 另一个语句块
     local x = x+1     -- 又一个 &#39;x&#39;
     print(x)          --&gt; 12
   end
   print(x)            --&gt; 11
 end
 print(x)              --&gt; 10  （取到的是全局的那一个）
</code></pre><p>注意这里，类似 local x = x 这样的声明， 新的 x 正在被声明，但是还没有进入它的作用范围， 所以第二个 x 指向的是外面一层的变量。</p>
<p>因为有这样一个词法作用范围的规则， 所以可以在函数内部自由的定义局部变量并使用它们。 当一个局部变量被更内层的函数中使用的时候， 它被内层函数称作 upvalue（上值），或是 外部局部变量。</p>
<p>注意，每次执行到一个 local 语句都会定义出一个新的局部变量。 看看这样一个例子：</p>
<pre><code> a = {}
 local x = 20
 for i=1,10 do
   local y = 0
   a[i] = function () y=y+1; return x+y end
 end
</code></pre><p>这个循环创建了十个 closure（这指十个匿名函数的实例）。 这些 closure 中的每一个都使用了不同的 y 变量， 而它们又共享了同一份 x。</p>
<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><pre><code>error(message[, level])
</code></pre><ul>
<li>Level = 1[默认]：为调用error位置(文件+行号)</li>
<li>Level = 2：指出哪个调用error的函数的函数</li>
<li>Level = 0：不添加错误位置信息<br>因为 Lua 是一个嵌入式的扩展语言， 所有的 Lua 动作都是从宿主程序的 C 代码调用 Lua 库 （参见 lua_pcall）中的一个函数开始的。 在 Lua 编译或运行的任何时候发生了错误，控制权都会交还给 C ， 而 C 可以来做一些恰当的措施（比如打印出一条错误信息）。<br>Lua 代码可以显式的调用 error 函数来产生一条错误。 如果你需要在 Lua 中捕获发生的错误， 你可以使用 pcall 函数。</li>
</ul>
<h3 id="Metatable"><a href="#Metatable" class="headerlink" title="Metatable"></a>Metatable</h3><p>Lua 中的每个值都可以用一个 metatable。 这个 metatable 就是一个原始的 Lua table ， 它用来定义原始值在特定操作下的行为。 你可以通过在 metatable 中的特定域设一些值来改变拥有这个 metatable 的值 的指定操作之行为。 举例来说，当一个非数字的值作加法操作的时候， Lua 会检查它的 metatable 中 “_<em>add” 域中的是否有一个函数。 如果有这么一个函数的话，Lua 调用这个函数来执行一次加法。<br>我们叫 metatable 中的键名为 事件 (event) ，把其中的值叫作 元方法 (metamethod)。 在上个例子中，事件是 “add” 而元方法就是那个执行加法操作的函数。<br>你可以通过 getmetatable 函数来查询到任何一个值的 metatable。<br>你可以通过 setmetatable 函数来替换掉 table 的 metatable 。 你不能从 Lua 中改变其它任何类型的值的 metatable （使用 debug 库例外）； 要这样做的话必须使用 C API 。<br>每个 table 和 userdata 拥有独立的 metatable （当然多个 table 和 userdata 可以共享一个相同的表作它们的 metatable）； 其它所有类型的值，每种类型都分别共享唯一的一个 metatable。 因此，所有的数字一起只有一个 metatable ，所有的字符串也是，等等。<br>一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为， metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。 对于这些操作，Lua 都将其关联上一个被称作事件的指定健。 当 Lua 需要对一个值发起这些操作中的一个时， 它会去检查值中 metatable 中是否有对应事件。 如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。<br>metatable 可以控制的操作已在下面列出来。 每个操作都用相应的名字区分。 每个操作的键名都是用操作名字加上两个下划线 ‘_</em>‘ 前缀的字符串； 举例来说，”add” 操作的键名就是字符串 “__add”。 这些操作的语义用一个 Lua 函数来描述解释器如何执行更为恰当。<br>这里展示的用 Lua 写的代码仅作解说用； 实际的行为已经硬编码在解释器中，其执行效率要远高于这些模拟代码。 这些用于描述的的代码中用到的函数 （ rawget ， tonumber ，等等。） 都可以在 §5.1 中找到。 特别注意，我们使用这样一个表达式来从给定对象中提取元方法</p>
<pre><code> metatable(obj)[event]
</code></pre><p>这个应该被解读作</p>
<pre><code> rawget(getmetatable(obj) or {}, event)
</code></pre><p>这就是说，访问一个元方法不再会触发任何的元方法， 而且访问一个没有 metatable 的对象也不会失败（而只是简单返回 nil）。</p>
<p>“add”: + 操作。<br>下面这个 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 首先，Lua 尝试第一个操作数。 如果这个东西的类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。</p>
<pre><code> function getbinhandler (op1, op2, event)
   return metatable(op1)[event] or metatable(op2)[event]
 end
</code></pre><p>通过这个函数， op1 + op2 的行为就是</p>
<pre><code> function add_event (op1, op2)
   local o1, o2 = tonumber(op1), tonumber(op2)
   if o1 and o2 then  -- 两个操作数都是数字？
     return o1 + o2   -- 这里的 &#39;+&#39; 是原生的 &#39;add&#39;
   else  -- 至少一个操作数不是数字时
     local h = getbinhandler(op1, op2, &quot;__add&quot;)
     if h then
       -- 以两个操作数来调用处理器
       return h(op1, op2)
     else  -- 没有处理器：缺省行为
       error(···)
     end
   end
 end
&quot;sub&quot;: - 操作。 其行为类似于 &quot;add&quot; 操作。
&quot;mul&quot;: * 操作。 其行为类似于 &quot;add&quot; 操作。
&quot;div&quot;: / 操作。 其行为类似于 &quot;add&quot; 操作。
&quot;mod&quot;: % 操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是这样的 o1 - floor(o1/o2)*o2
&quot;pow&quot;: ^ （幂）操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是调用 pow 函数（通过 C math 库）。
&quot;unm&quot;: 一元 - 操作。
function unm_event (op)
   local o = tonumber(op)
   if o then  -- 操作数是数字？
     return -o  -- 这里的 &#39;-&#39; 是一个原生的 &#39;unm&#39;
   else  -- 操作数不是数字。
     -- 尝试从操作数中得到处理器
     local h = metatable(op).__unm
     if h then
       -- 以操作数为参数调用处理器
       return h(op)
     else  -- 没有处理器：缺省行为
       error(···)
     end
   end
 end
&quot;concat&quot;: .. （连接）操作，
 function concat_event (op1, op2)
   if (type(op1) == &quot;string&quot; or type(op1) == &quot;number&quot;) and
      (type(op2) == &quot;string&quot; or type(op2) == &quot;number&quot;) then
     return op1 .. op2  -- 原生字符串连接
   else
     local h = getbinhandler(op1, op2, &quot;__concat&quot;)
     if h then
       return h(op1, op2)
     else
       error(···)
     end
   end
 end
&quot;len&quot;: # 操作。
 function len_event (op)
   if type(op) == &quot;string&quot; then
     return strlen(op)         -- 原生的取字符串长度
   elseif type(op) == &quot;table&quot; then
     return #op                -- 原生的取 table 长度
   else
     local h = metatable(op).__len
     if h then
       -- 调用操作数的处理器
       return h(op)
     else  -- 没有处理器：缺省行为
       error(···)
     end
   end
 end
</code></pre><p>关于 table 的长度参见 §2.5.5 。</p>
<p>“eq”: == 操作。 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作。 元方法仅仅在参于比较的两个对象类型相同且有对应操作相同的元方法时才起效。<br>     function getcomphandler (op1, op2, event)<br>       if type(op1) ~= type(op2) then return nil end<br>       local mm1 = metatable(op1)[event]<br>       local mm2 = metatable(op2)[event]<br>       if mm1 == mm2 then return mm1 else return nil end<br>     end<br>“eq” 事件按如下方式定义：</p>
<pre><code> function eq_event (op1, op2)
   if type(op1) ~= type(op2) then  -- 不同的类型？
     return false   -- 不同的对象
   end
   if op1 == op2 then   -- 原生的相等比较结果？
     return true   -- 对象相等
   end
   -- 尝试使用元方法
   local h = getcomphandler(op1, op2, &quot;__eq&quot;)
   if h then
     return h(op1, op2)
   else
     return false
   end
 end
</code></pre><p>a ~= b 等价于 not (a == b) 。</p>
<pre><code>&quot;lt&quot;: &lt; 操作。
 function lt_event (op1, op2)
   if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then
     return op1 &lt; op2   -- 数字比较
   elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then
     return op1 &lt; op2   -- 字符串按逐字符比较
   else
     local h = getcomphandler(op1, op2, &quot;__lt&quot;)
     if h then
       return h(op1, op2)
     else
       error(···);
     end
   end
 end
</code></pre><p>a &gt; b 等价于 b &lt; a.</p>
<pre><code>&quot;le&quot;: &lt;= 操作。
 function le_event (op1, op2)
   if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then
     return op1 &lt;= op2   -- 数字比较
   elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then
     return op1 &lt;= op2   -- 字符串按逐字符比较
   else
     local h = getcomphandler(op1, op2, &quot;__le&quot;)
     if h then
       return h(op1, op2)
     else
       h = getcomphandler(op1, op2, &quot;__lt&quot;)
       if h then
         return not h(op2, op1)
       else
         error(···);
       end
     end
   end
 end
</code></pre><p>a &gt;= b 等价于 b &lt;= a 。 注意，如果元方法 “le” 没有提供，Lua 就尝试 “lt” ， 它假定 a &lt;= b 等价于 not (b &lt; a) 。</p>
<p>“index”: 取下标操作用于访问 table[key] 。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gettable_event</span> <span class="params">(table, key)</span></span></span><br><span class="line">    <span class="keyword">local</span> h</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">table</span>) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> v = <span class="built_in">rawget</span>(<span class="built_in">table</span>, key)</span><br><span class="line">        <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> v <span class="keyword">end</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__index</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__index</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">error</span>(···);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(h) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="built_in">table</span>, key)      <span class="comment">-- 调用处理器</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> h[key]          <span class="comment">-- 或是重复上述操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="newindex"><a href="#newindex" class="headerlink" title="newindex"></a>newindex</h3><p>赋值给指定下标 table[key] = value</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">settable_event</span> <span class="params">(table, key, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> h</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">table</span>) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> v = <span class="built_in">rawget</span>(<span class="built_in">table</span>, key)</span><br><span class="line">        <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">            <span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value) </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__newindex</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">            <span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value) </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__newindex</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">error</span>(···)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(h) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="built_in">table</span>, key,value)    <span class="comment">-- 调用处理器</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        h[key] = value             <span class="comment">-- 或是重复上述操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>“call”: 当 Lua 调用一个值时调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function function_event (func, ...)</span><br><span class="line">  if type(func) == &quot;function&quot; then</span><br><span class="line">    return func(...)   -- 原生的调用</span><br><span class="line">  else</span><br><span class="line">    local h = metatable(func).__call</span><br><span class="line">    if h then</span><br><span class="line">      return h(func, ...)</span><br><span class="line">    else</span><br><span class="line">      error(···)</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="2-9-环境"><a href="#2-9-环境" class="headerlink" title="2.9 - 环境"></a>2.9 - 环境</h3><p>类型为 thread ，function ，以及 userdata 的对象，除了 metatable 外还可以用另外一个与之关联的被称作 它们的环境的一个表， 像 metatable 一样，环境也是一个常规的 table ，多个对象可以共享 同一个环境。<br>userdata 的环境在 Lua 中没有意义。 这个东西只是为了在程序员想把一个表关联到一个 userdata 上时提供便利。<br>关联在线程上的环境被称作全局环境。 全局环境被用作它其中的线程以及线程创建的非嵌套函数 （通过 loadfile ， loadstring 或是 load ）的缺省环境。 而且它可以被 C 代码直接访问（参见 §3.3）。<br>关联在 C 函数上的环境可以直接被 C 代码访问（参见 §3.3）。 它们会作为这个 C 函数中创建的其它函数的缺省环境。<br>关联在 Lua 函数上的环境用来接管在函数内对全局变量（参见 §2.3）的所有访问。 它们也会作为这个函数内创建的其它函数的缺省环境。<br>你可以通过调用 setfenv 来改变一个 Lua 函数 或是正在运行中的线程的环境。 而想操控其它对象（userdata、C 函数、其它线程）的环境的话，就必须使用 C API 。</p>
<h3 id="2-10-垃圾收集"><a href="#2-10-垃圾收集" class="headerlink" title="2.10 - 垃圾收集"></a>2.10 - 垃圾收集</h3><p>Lua 提供了一个自动的内存管理。 这就是说你不需要关心创建新对象的分配内存操作，也不需要在这些对象不再需要时的主动释放内存。 Lua 通过运行一个垃圾收集器来自动管理内存，以此一遍又一遍的回收死掉的对象 （这是指 Lua 中不再访问的到的对象）占用的内存。 Lua 中所有对象都被自动管理，包括： table, userdata、 函数、线程、和字符串。<br>Lua 实现了一个增量标记清除的收集器。 它用两个数字来控制垃圾收集周期： garbage-collector pause 和 garbage-collector step multiplier 。<br>garbage-collector pause 控制了收集器在开始一个新的收集周期之前要等待多久。 随着数字的增大就导致收集器工作工作的不那么主动。 小于 1 的值意味着收集器在新的周期开始时不再等待。 当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。<br>step multiplier 控制了收集器相对内存分配的速度。 更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。 小于 1 的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。 缺省值为 2 ，这意味着收集器将以内存分配器的两倍速运行。<br>你可以通过在 C 中调用 lua_gc 或是在 Lua 中调用 collectgarbage 来改变这些数字。 两者都接受百分比数值（因此传入参数 100 意味着实际值 1 ）。 通过这些函数，你也可以直接控制收集器（例如，停止或是重启）。</p>
<h3 id="2-10-1-垃圾收集的元方法"><a href="#2-10-1-垃圾收集的元方法" class="headerlink" title="2.10.1 - 垃圾收集的元方法"></a>2.10.1 - 垃圾收集的元方法</h3><p>使用 C API　， 你可以给 userdata （参见 §2.8）设置一个垃圾收集的元方法。 这个元方法也被称为结束子。 结束子允许你用额外的资源管理器和 Lua 的内存管理器协同工作 （比如关闭文件、网络连接、或是数据库连接，也可以说释放你自己的内存）。<br>一个 userdata 可被回收，若它的 metatable 中有 __gc 这个域　， 垃圾收集器就不立即收回它。 取而代之的是，Lua 把它们放到一个列表中。 最收集结束后，Lua 针对列表中的每个 userdata 执行了下面这个函数的等价操作：</p>
<pre><code>function gc_event (udata)
    local h = metatable(udata).__gc
    if h then
        h(udata)
    end
end
</code></pre><p>在每个垃圾收集周期的结尾，每个在当前周期被收集起来的 userdata 的结束子会以 它们构造时的逆序依次调用。 也就是说，收集列表中，最后一个在程序中被创建的 userdata 的 结束子会被第一个调用。</p>
<p>2.10.2 - Weak Table（弱表）<br>weak table 是一个这样的 table，它其中的元素都被弱引用。 弱引用将被垃圾收集器忽略掉， 换句话说， 如果对一个对象的引用只有弱引用， 垃圾收集器将回收这个对象。</p>
<p>weak table 的键和值都可以是 weak 的。 如果一个 table 只有键是 weak 的，那么将运行收集器回收它们的键， 但是会阻止回收器回收对应的值。 而一个 table 的键和值都是 weak 时，就即允许收集器回收键又允许收回值。 任何情况下，如果键和值中任一个被回收了，整个键值对就会从 table 中拿掉。 table 的 weak 特性可以通过在它的 metatable 中设置 <strong>mode 域来改变。 如果 </strong>mode 域中是一个包含有字符 ‘k’ 的字符串时， table 的键就是 weak 的。 如果 __mode 域中是一个包含有字符 ‘v’ 的字符串时， table 的值就是 weak 的。</p>
<p>在你把一个 table 当作一个 metatable 使用之后， 就不能再修改 __mode 域的值。 否则，受这个 metatable 控制的 table 的 weak 行为就成了未定义的。</p>
<p>2.11 - Coroutine （协同例程）<br>Lua 支持 coroutine ，这个东西也被称为协同式多线程 (collaborative multithreading)　。 Lua 为每个 coroutine 提供一个独立的运行线路。 然而和多线程系统中的线程不同，coroutine 只在显式的调用了 yield 函数时才会挂起。</p>
<p>创建一个 coroutine 需要调用一次 coroutine.create 。 它只接收单个参数，这个参数是 coroutine 的主函数。 create 函数仅仅创建一个新的 coroutine 然后返回它的控制器 （一个类型为 thread 的对象）； 它并不会启动 coroutine 的运行。</p>
<p>当你第一次调用 coroutine.resume 时， 所需传入的第一个参数就是 coroutine.create 的返回值。 这时，coroutine 从主函数的第一行开始运行。 接下来传入 coroutine.resume 的参数将被传进 coroutine 的主函数。 在 coroutine 开始运行后，它讲运行到自身终止或是遇到一个 yields 。</p>
<p>coroutine 可以通过两种方式来终止运行： 一种是正常退出，指它的主函数返回（最后一条指令被运行后，无论有没有显式的返回指令）; 另一种是非正常退出，它发生在未保护的错误发生的时候。 第一种情况中， coroutine.resume 返回 true ， 接下来会跟着 coroutine 主函数的一系列返回值。 第二种发生错误的情况下， coroutine.resume 返回 false ， 紧接着是一条错误信息。</p>
<p>coroutine 中切换出去，可以调用 coroutine.yield。 当 coroutine 切出，与之配合的 coroutine.resume 就立即返回， 甚至在 yield 发生在内层的函数调用中也可以（就是说， 这不限于发生在主函数中，也可以是主函数直接或间接调用的某个函数里）。 在 yield 的情况下，coroutine.resume 也是返回 true， 紧跟着那些被传入 coroutine.yield 的参数。 等到下次你在继续同样的 coroutine ，将从调用 yield 的断点处运行下去。 断点处 yield 的返回值将是 coroutine.resume 传入的参数。</p>
<p>类似 coroutine.create ， coroutine.wrap 这个函数也将创建一个 coroutine ， 但是它并不返回 coroutine 本身，而是返回一个函数取而代之。一旦你调用这个返回函数，就会切入 coroutine 运行。 所有传入这个函数的参数等同于传入 coroutine.resume 的参数。 coroutine.wrap 会返回所有应该由除第一个（错误代码的那个布尔量） 之外的由 coroutine.resume 返回的值。 和 coroutine.resume 不同， coroutine.wrap 不捕获任何错误； 所有的错误都应该由调用者自己传递。</p>
<p>看下面这段代码展示的一个例子：</p>
<pre><code> function foo (a)
   print(&quot;foo&quot;, a)
   return coroutine.yield(2*a)
 end

 co = coroutine.create(function (a,b)
       print(&quot;co-body&quot;, a, b)
       local r = foo(a+1)
       print(&quot;co-body&quot;, r)
       local r, s = coroutine.yield(a+b, a-b)
       print(&quot;co-body&quot;, r, s)
       return b, &quot;end&quot;
 end)

 print(&quot;main&quot;, coroutine.resume(co, 1, 10))
 print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;))
 print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;))
 print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;))
</code></pre><p>当你运行它，将得到如下输出结果：</p>
<pre><code> co-body 1       10
 foo     2

 main    true    4
 co-body r
 main    true    11      -9
 co-body x       y
 main    true    10      end
 main    false   cannot resume dead coroutine
</code></pre><p>3 - 程序接口（API）<br>这个部分描述了 Lua 的 C API ， 也就是宿主程序跟 Lua 通讯用的一组 C 函数。 所有的 API 函数按相关的类型以及常量都声明在头文件 lua.h 中。</p>
<p>虽然我们说的是“函数”，但一部分简单的 API 是以宏的形式提供的。 所有的这些宏都只使用它们的参数一次 （除了第一个参数，也就是 lua 状态机）， 因此你不需担心这些宏的展开会引起一些副作用。</p>
<p>在所有的 C 库中，Lua API 函数都不去检查参数的有效性和坚固性。 然而，你可以在编译 Lua 时加上打开一个宏开关来 开启 luaconf.h 文件中的宏 luai_apicheck 以改变这个行为。</p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>Lua 使用一个虚拟栈来和 C 传递值。 栈上的的每个元素都是一个 Lua 值 （nil，数字，字符串，等等）。</p>
<p>无论何时 Lua 调用 C，被调用的函数都得到一个新的栈， 这个栈独立于 C 函数本身的堆栈，也独立于以前的栈。 （译注：在 C 函数里，用 Lua API 不能访问到 Lua 状态机中本次调用之外的堆栈中的数据） 它里面包含了 Lua 传递给 C 函数的所有参数， 而 C 函数则把要返回的结果也放入堆栈以返回给调用者 （参见 lua_CFunction）。</p>
<p>方便起见，所有针对栈的 API 查询操作都不严格遵循栈的操作规则。 而是可以用一个索引来指向栈上的任何元素： 正的索引指的是栈上的绝对位置（从一开始）； 负的索引则指从栈顶开始的偏移量。 更详细的说明一下，如果堆栈有 n 个元素， 那么索引 1 表示第一个元素（也就是最先被压入堆栈的元素） 而索引 n 则指最后一个元素； 索引 -1 也是指最后一个元素（即栈顶的元素）， 索引 -n 是指第一个元素。 如果索引在 1 到栈顶之间（也就是，1 ≤ abs(index) ≤ top） 我们就说这是个有效的索引。</p>
<h3 id="堆栈尺寸"><a href="#堆栈尺寸" class="headerlink" title="堆栈尺寸"></a>堆栈尺寸</h3><p>当你使用 Lua API 时，就有责任保证其坚固性。 特别需要注意的是，你有责任控制不要堆栈溢出。你可以使用 lua_checkstack 这个函数来扩大可用堆栈的尺寸。<br>无论何时 Lua 调用 C ， 它都只保证 LUA_MINSTACK 这么多的堆栈空间可以使用。 LUA_MINSTACK 一般被定义为 20　，因此，只要你不是不断的把数据压栈，通常你不用关心堆栈大小。<br>所有的查询函数都可以接收一个索引，只要这个索引是任何栈提供的空间中的值。 栈能提供的最大空间是通过 lua_checkstack 来设置的。 这些索引被称作可接受的索引，通常我们把它定义为：</p>
<pre><code> (index &lt; 0 &amp;&amp; abs(index) &lt;= top) || (index &gt; 0 &amp;&amp; index &lt;= stackspace)
</code></pre><p>注意，0 永远都不是一个可接受的索引。（译注：下文中凡提到的索引，没有特别注明的话，都指可接受的索引。）</p>
<h3 id="LUA-GLOBALSINDEX"><a href="#LUA-GLOBALSINDEX" class="headerlink" title="LUA_GLOBALSINDEX"></a>LUA_GLOBALSINDEX</h3><p>除了特别声明外，任何一个函数都可以接受另一种有效的索引，它们被称作“伪索引”。 这个可以帮助 C 代码访问一些并不在栈上的 Lua 值。 伪索引被用来访问线程的环境，函数的环境，注册表，还有 C 函数的 upvalue。<br>线程的环境（也就是全局变量放的地方）通常在伪索引 LUA_GLOBALSINDEX 处。 正在运行的 C 函数的环境则放在伪索引 LUA_ENVIRONINDEX 之处。<br>可以用常规的 table 操作来访问和改变全局变量的值，只需要指定环境表的位置。 举例而言，要访问全局变量的值，这样做：</p>
<pre><code>lua_getfield(L, LUA_GLOBALSINDEX, varname);
</code></pre><h3 id="C-Closure"><a href="#C-Closure" class="headerlink" title="C Closure"></a>C Closure</h3><p>当C函数被创建出来，我们有可能会把一些值关联在一起， 也就是创建一个Cclosure； 这些被关联起来的值被叫做upvalue ，它们可以在函数被调用的时候访问的到。（参见lua_pushcclosure）。<br>无论何时去调用C函数，函数的upvalue都被放在指定的伪索引处。我们可以用<code>lua_upvalueindex</code>这个宏来生成这些伪索引。第一个关联到函数的值放在<code>lua_upvalueindex(1)</code>位置处，依次类推。任何情况下都可以用<code>lua_upvalueindex(n)</code>产生一个upvalue的索引，即使n大于实际的upvalue数量也可以。它都可以产生一个可接受但不一定有效的索引。</p>
<h3 id="LUA-REGISTRYINDEX"><a href="#LUA-REGISTRYINDEX" class="headerlink" title="LUA_REGISTRYINDEX"></a>LUA_REGISTRYINDEX</h3><p>Lua提供了一个注册表，这是一个预定义出来的表，可以用来保存任何C代码想保存的Lua值。这个表可以用伪索引<code>LUA_REGISTRYINDEX</code>来定位。 任何C库都可以在这张表里保存数据，为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名，或者可以取你自己C代码中的一个地址，以 light userdata 的形式做键。<br>注册表里的整数健被用于补充库中实现的引用系统的工作，一般说来不要把它们用于别的用途。</p>
<h3 id="C-中的错误处理"><a href="#C-中的错误处理" class="headerlink" title="C 中的错误处理"></a>C 中的错误处理</h3><p>在内部实现中，Lua 使用了 C 的 longjmp 机制来处理错误。 （如果你使用 C++ 的话，也可以选择换用异常；参见 luaconf.h 文件。） 当 Lua 碰到任何错误（比如内存分配错误、类型错误、语法错误、还有一些运行时错误） 它都会产生一个错误出去； 也就是调用一个 long jump 。 在保护环境下，Lua 使用 setjmp 来设置一个恢复点； 任何发生的错误都会激活最近的一个恢复点。<br>几乎所有的 API 函数都可能产生错误，例如内存分配错误。 但下面的一些函数运行在保护环境中（也就是说它们创建了一个保护环境再在其中运行）， 因此它们不会产生错误出来： lua_newstate, lua_close, lua_load, lua_pcall, and lua_cpcall。</p>
<p>在 C 函数里，你也可以通过调用 lua_error 产生一个错误。</p>
<h3 id="lua-Alloc"><a href="#lua-Alloc" class="headerlink" title="lua_Alloc"></a>lua_Alloc</h3><pre><code>typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
</code></pre><p>Lua 状态机中使用的内存分配器函数的类型。 内存分配函数必须提供一个功能类似于 realloc 但又不完全相同的函数。 它的参数有 ud ，一个由 lua_newstate 传给它的指针； ptr ，一个指向已分配出来或是将被重新分配或是要释放的内存块指针； osize ，内存块原来的尺寸； nsize ，新内存块的尺寸。 如果且只有 osize 是零时，ptr 为 NULL 。 当 nsize 是零，分配器必须返回 NULL； 如果 osize 不是零，分配器应当释放掉 ptr 指向的内存块。 当 nsize 不是零，若分配器不能满足请求时，分配器返回 NULL 。 当 nsize 不是零而 osize 是零时，分配器应该和 malloc 有相同的行为。 当 nsize 和 osize 都不是零时，分配器则应和 realloc 保持一样的行为。 Lua 假设分配器在 osize &gt;= nsize 时永远不会失败。</p>
<p>这里有一个简单的分配器函数的实现。 这个实现被放在补充库中，由 luaL_newstate 提供。</p>
<pre><code>static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) 
{
    (void)ud;  
    (void)osize;  /* not used */
    if (nsize == 0) 
    {
        free(ptr);
        return NULL;
    }
    else
        return realloc(ptr, nsize);
}
</code></pre><p>这段代码假设 free(NULL) 啥也不影响，而且 realloc(NULL, size) 等价于 malloc(size)。 这两点是 ANSI C 保证的行为。</p>
<h3 id="lua-atpanic"><a href="#lua-atpanic" class="headerlink" title="lua_atpanic"></a>lua_atpanic</h3><pre><code>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
</code></pre><p>设置一个新的 panic （恐慌） 函数，并返回前一个。<br>如果在保护环境之外发生了任何错误， Lua 就会调用一个 panic 函数，接着调用 exit(EXIT_FAILURE)， 这样就开始退出宿主程序。 你的 panic 函数可以永远不返回（例如作一次长跳转）来避免程序退出。<br>panic 函数可以从栈顶取到出错信息。</p>
<h3 id="lua-call"><a href="#lua-call" class="headerlink" title="lua_call"></a>lua_call</h3><pre><code>void lua_call(lua_State *L, int nargs, int nresults);
</code></pre><p>调用一个函数。要调用一个函数请遵循以下协议：首先，要调用的函数应该被压入堆栈；接着，把需要传递给这个函数的参数按正序压栈；这是指第一个参数首先压栈。 最后调用一下<code>lua_call</code>；nargs是你压入堆栈的参数个数。当函数调用完毕后，所有的参数以及函数本身都会出栈。而函数的返回值这时则被压入堆栈。返回值的个数将被调整为nresults个， 除非 nresults 被设置成 LUA_MULTRET。 在这种情况下，所有的返回值都被压入堆栈中。 Lua 会保证返回值都放入栈空间中。 函数返回值将按正序压栈（第一个返回值首先压栈）， 因此在调用结束后，最后一个返回值将被放在栈顶。<br>被调用函数内发生的错误将（通过 longjmp）一直上抛。<br>下面的例子中，这行 Lua 代码等价于在宿主程序用 C 代码做一些工作：</p>
<pre><code> a = f(&quot;how&quot;, t.x, 14)
</code></pre><p>这里是 C 里的代码：</p>
<pre><code> lua_getfield(L, LUA_GLOBALSINDEX, &quot;f&quot;);          /* 将调用的函数 */
 lua_pushstring(L, &quot;how&quot;);                          /* 第一个参数 */
 lua_getfield(L, LUA_GLOBALSINDEX, &quot;t&quot;);          /* table 的索引 */
 lua_getfield(L, -1, &quot;x&quot;);         /* 压入 t.x 的值（第 2 个参数）*/
 lua_remove(L, -2);                           /* 从堆栈中移去 &#39;t&#39; */
 lua_pushinteger(L, 14);                           /* 第 3 个参数 */
 lua_call(L, 3, 1); /* 调用 &#39;f&#39;，传入 3 个参数，并索取 1 个返回值 */
 lua_setfield(L, LUA_GLOBALSINDEX, &quot;a&quot;);      /* 设置全局变量 &#39;a&#39; */
</code></pre><p>注意上面这段代码是“平衡”的： 到了最后，堆栈恢复成原由的配置。 </p>
<h3 id="lua-CFunction"><a href="#lua-CFunction" class="headerlink" title="lua_CFunction"></a>lua_CFunction</h3><pre><code>typedef int (*lua_CFunction) (lua_State *L);
</code></pre><p>C 函数的类型。<br>为了正确的和 Lua 通讯，C 函数必须使用下列 定义了参数以及返回值传递方法的协议： C 函数通过 Lua 中的堆栈来接受参数，参数以正序入栈（第一个参数首先入栈）。 因此，当函数开始的时候， lua_gettop(L) 可以返回函数收到的参数个数。 第一个参数（如果有的话）在索引 1 的地方，而最后一个参数在索引 lua_gettop(L) 处。 当需要向 Lua 返回值的时候，C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入）， 然后返回这些返回值的个数。 在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。 和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。</p>
<p>下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和：</p>
<pre><code> static int foo (lua_State *L) {
   int n = lua_gettop(L);    /* 参数的个数 */
   lua_Number sum = 0;
   int i;
   for (i = 1; i &lt;= n; i++) {
     if (!lua_isnumber(L, i)) {
       lua_pushstring(L, &quot;incorrect argument&quot;);
       lua_error(L);
     }
     sum += lua_tonumber(L, i);
   }
   lua_pushnumber(L, sum/n);   /* 第一个返回值 */
   lua_pushnumber(L, sum);     /* 第二个返回值 */
   return 2;                   /* 返回值的个数 */
 }
</code></pre><h3 id="lua-checkstack"><a href="#lua-checkstack" class="headerlink" title="lua_checkstack"></a>lua_checkstack</h3><pre><code>int lua_checkstack (lua_State *L, int extra);
</code></pre><p>确保堆栈上至少有 extra 个空位。 如果不能把堆栈扩展到相应的尺寸，函数返回 false 。 这个函数永远不会缩小堆栈； 如果堆栈已经比需要的大了，那么就放在那里不会产生变化。</p>
<h3 id="lua-close"><a href="#lua-close" class="headerlink" title="lua_close"></a>lua_close</h3><pre><code>void lua_close (lua_State *L);
</code></pre><p>销毁指定 Lua 状态机中的所有对象（如果有垃圾收集相关的元方法的话，会调用它们），并且释放状态机中使用的所有动态内存。 在一些平台上，你可以不必调用这个函数， 因为当宿主程序结束的时候，所有的资源就自然被释放掉了。 另一方面，长期运行的程序，比如一个后台程序或是一个 web 服务器， 当不再需要它们的时候就应该释放掉相关状态机。这样可以避免状态机扩张的过大。</p>
<h3 id="lua-concat"><a href="#lua-concat" class="headerlink" title="lua_concat"></a>lua_concat</h3><pre><code>void lua_concat (lua_State *L, int n);
</code></pre><p>连接栈顶的 n 个值， 然后将这些值出栈，并把结果放在栈顶。如果 n 为 1 ，结果就是一个字符串放在栈上（即，函数什么都不做）； 如果 n 为 0 ，结果是一个空串。 连接依照 Lua 中创建语义完成（参见 §2.5.4 ）。</p>
<h3 id="lua-cpcall"><a href="#lua-cpcall" class="headerlink" title="lua_cpcall"></a>lua_cpcall</h3><pre><code>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
</code></pre><p>以保护模式调用 C 函数 func 。 func 只有能从堆栈上拿到一个参数，就是包含有 ud 的 light userdata。 当有错误时， lua_cpcall 返回和 lua_pcall 相同的错误代码， 并在栈顶留下错误对象； 否则它返回零，并不会修改堆栈。 所有从 func 内返回的值都会被扔掉。</p>
<h3 id="lua-createtable"><a href="#lua-createtable" class="headerlink" title="lua_createtable"></a>lua_createtable</h3><pre><code>void lua_createtable (lua_State *L, int narr, int nrec);
</code></pre><p>创建一个新的空 table 压入堆栈。 这个新 table 将被预分配 narr 个元素的数组空间 以及 nrec 个元素的非数组空间。 当你明确知道表中需要多少个元素时，预分配就非常有用。 如果你不知道，可以使用函数 lua_newtable。</p>
<h3 id="lua-dump"><a href="#lua-dump" class="headerlink" title="lua_dump"></a>lua_dump</h3><pre><code>int lua_dump (lua_State *L, lua_Writer writer, void *data);
</code></pre><p>把函数 dump 成二进制 chunk 。 函数接收栈顶的 Lua 函数做参数，然后生成它的二进制 chunk 。 若被 dump 出来的东西被再次加载，加载的结果就相当于原来的函数。 当它在产生 chunk 的时候，lua_dump 通过调用函数 writer （参见 lua_Writer） 来写入数据，后面的 data 参数会被传入 writer 。<br>最后一次由写入器 (writer) 返回值将作为这个函数的返回值返回； 0 表示没有错误。</p>
<p>这个函数不会把 Lua 返回弹出堆栈。</p>
<h3 id="lua-equal"><a href="#lua-equal" class="headerlink" title="lua_equal"></a>lua_equal</h3><pre><code>int lua_equal (lua_State *L, int index1, int index2);
</code></pre><p>如果依照 Lua 中 == 操作符语义，索引 index1 和 index2 中的值相同的话，返回 1 。 否则返回 0 。 如果任何一个索引无效也会返回 0。</p>
<h3 id="lua-error"><a href="#lua-error" class="headerlink" title="lua_error"></a>lua_error</h3><pre><code>int lua_error (lua_State *L);
</code></pre><p>产生一个 Lua 错误。 错误信息（实际上可以是任何类型的 Lua 值）必须被置入栈顶。 这个函数会做一次长跳转，因此它不会再返回。 （参见 luaL_error）。</p>
<h3 id="lua-gc"><a href="#lua-gc" class="headerlink" title="lua_gc"></a>lua_gc</h3><pre><code>int lua_gc (lua_State *L, int what, int data);
</code></pre><p>控制垃圾收集器。<br>这个函数根据其参数 what 发起几种不同的任务：</p>
<p>LUA_GCSTOP: 停止垃圾收集器。<br>LUA_GCRESTART: 重启垃圾收集器。<br>LUA_GCCOLLECT: 发起一次完整的垃圾收集循环。<br>LUA_GCCOUNT: 返回 Lua 使用的内存总量（以 K 字节为单位）。<br>LUA_GCCOUNTB: 返回当前内存使用量除以 1024 的余数。<br>LUA_GCSTEP: 发起一步增量垃圾收集。 步数由 data 控制（越大的值意味着越多步）， 而其具体含义（具体数字表示了多少）并未标准化。 如果你想控制这个步数，必须实验性的测试 data 的值。 如果这一步结束了一个垃圾收集周期，返回返回 1 。<br>LUA_GCSETPAUSE: 把 data/100 设置为 garbage-collector pause 的新值（参见 §2.10）。 函数返回以前的值。<br>LUA_GCSETSTEPMUL: 把 arg/100 设置成 step multiplier （参见 §2.10）。 函数返回以前的值。</p>
<h3 id="lua-getallocf"><a href="#lua-getallocf" class="headerlink" title="lua_getallocf"></a>lua_getallocf</h3><pre><code>lua_Alloc lua_getallocf (lua_State *L, void **ud);
</code></pre><p>返回给定状态机的内存分配器函数。 如果 ud 不是 NULL ，Lua 把调用 lua_newstate 时传入的那个指针放入 *ud 。</p>
<h3 id="lua-getfenv"><a href="#lua-getfenv" class="headerlink" title="lua_getfenv"></a>lua_getfenv</h3><pre><code>void lua_getfenv (lua_State *L, int index);
</code></pre><p>把索引处值的环境表压入堆栈。</p>
<h3 id="lua-getfield"><a href="#lua-getfield" class="headerlink" title="lua_getfield"></a>lua_getfield</h3><pre><code>void lua_getfield(lua_State *L, int index, const char *k);
</code></pre><p>把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法。</p>
<h3 id="lua-getglobal"><a href="#lua-getglobal" class="headerlink" title="lua_getglobal"></a>lua_getglobal</h3><pre><code>void lua_getglobal(lua_State *L, const char *name);
</code></pre><p>把全局变量name里的值压入堆栈。 这个是用一个宏定义出来的：</p>
<pre><code> #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
</code></pre><h3 id="lua-getmetatable"><a href="#lua-getmetatable" class="headerlink" title="lua_getmetatable"></a>lua_getmetatable</h3><pre><code>int lua_getmetatable (lua_State *L, int index);
</code></pre><p>把给定索引指向的值的元表压入堆栈。 如果索引无效，或是这个值没有元表， 函数将返回 0 并且不会向栈上压任何东西。</p>
<h3 id="lua-gettable"><a href="#lua-gettable" class="headerlink" title="lua_gettable"></a>lua_gettable</h3><pre><code>void lua_gettable (lua_State *L, int index);
</code></pre><p>把t[k] 值压入堆栈， 这里的t是指有效索引 index 指向的值， 而 k 则是栈顶放的值。<br>这个函数会弹出堆栈上的 key （把结果放在栈上相同位置）。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法。</p>
<h3 id="lua-gettop"><a href="#lua-gettop" class="headerlink" title="lua_gettop"></a>lua_gettop</h3><pre><code>int lua_gettop(lua_State *L);
</code></pre><p>返回栈顶元素的索引。 因为索引是从 1 开始编号的， 所以这个结果等于堆栈上的元素个数（因此返回 0 表示堆栈为空）。</p>
<h3 id="lua-insert"><a href="#lua-insert" class="headerlink" title="lua_insert"></a>lua_insert</h3><pre><code>void lua_insert (lua_State *L, int index);
</code></pre><p>把栈顶元素插入指定的有效索引处， 并依次移动这个索引之上的元素。 不要用伪索引来调用这个函数，因为伪索引不是真正指向堆栈上的位置。</p>
<h3 id="lua-Integer"><a href="#lua-Integer" class="headerlink" title="lua_Integer"></a>lua_Integer</h3><pre><code>typedef ptrdiff_t lua_Integer;
</code></pre><p>这个类型被用于 Lua API 接收整数值。<br>缺省时这个被定义为 ptrdiff_t ， 这个东西通常是机器能处理的最大整数类型。</p>
<h3 id="lua-isboolean"><a href="#lua-isboolean" class="headerlink" title="lua_isboolean"></a>lua_isboolean</h3><pre><code>int lua_isboolean (lua_State *L, int index);
</code></pre><p>当给定索引的值类型为 boolean 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-iscfunction"><a href="#lua-iscfunction" class="headerlink" title="lua_iscfunction"></a>lua_iscfunction</h3><pre><code>int lua_iscfunction (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 C 函数时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isfunction"><a href="#lua-isfunction" class="headerlink" title="lua_isfunction"></a>lua_isfunction</h3><pre><code>int lua_isfunction (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个函数（ C 或 Lua 函数均可）时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-islightuserdata"><a href="#lua-islightuserdata" class="headerlink" title="lua_islightuserdata"></a>lua_islightuserdata</h3><pre><code>int lua_islightuserdata (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 light userdata 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isnil"><a href="#lua-isnil" class="headerlink" title="lua_isnil"></a>lua_isnil</h3><pre><code>int lua_isnil (lua_State *L, int index);
</code></pre><p>当给定索引的值是 nil 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isnumber"><a href="#lua-isnumber" class="headerlink" title="lua_isnumber"></a>lua_isnumber</h3><pre><code>int lua_isnumber (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个数字，或是一个可转换为数字的字符串时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isstring"><a href="#lua-isstring" class="headerlink" title="lua_isstring"></a>lua_isstring</h3><pre><code>int lua_isstring (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个字符串或是一个数字（数字总能转换成字符串）时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-istable"><a href="#lua-istable" class="headerlink" title="lua_istable"></a>lua_istable</h3><pre><code>int lua_istable (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 table 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isthread"><a href="#lua-isthread" class="headerlink" title="lua_isthread"></a>lua_isthread</h3><pre><code>int lua_isthread (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 thread 时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-isuserdata"><a href="#lua-isuserdata" class="headerlink" title="lua_isuserdata"></a>lua_isuserdata</h3><pre><code>int lua_isuserdata (lua_State *L, int index);
</code></pre><p>当给定索引的值是一个 userdata （无论是完整的 userdata 还是 light userdata ）时，返回 1 ，否则返回 0 。</p>
<h3 id="lua-lessthan"><a href="#lua-lessthan" class="headerlink" title="lua_lessthan"></a>lua_lessthan</h3><pre><code>int lua_lessthan (lua_State *L, int index1, int index2);
</code></pre><p>如果索引 index1 处的值小于 索引 index2 处的值时，返回 1 ； 否则返回 0 。 其语义遵循 Lua 中的 &lt; 操作符（就是说，有可能调用元方法）。 如果任何一个索引无效，也会返回 0 。</p>
<h3 id="lua-load"><a href="#lua-load" class="headerlink" title="lua_load"></a>lua_load</h3><pre><code>int lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname);
</code></pre><p>加载一个 Lua chunk 。 如果没有错误， lua_load 把一个编译好的 chunk 作为一个 Lua 函数压入堆栈。 否则，压入出错信息。 lua_load 的返回值可以是：</p>
<p>0: 没有错误；<br>LUA_ERRSYNTAX: 在预编译时碰到语法错误；<br>LUA_ERRMEM: 内存分配错误。<br>这个函数仅仅加栽 chunk ；而不会去运行它。</p>
<p>lua_load 会自动检测 chunk 是文本的还是二进制的， 然后做对应的加载操作（参见程序 luac）。<br>lua_load 函数使用一个用户提供的 reader 函数来 读取 chunk （参见 lua_Reader）。 data 参数会被传入读取器函数。<br>chunkname 这个参数可以赋予 chunk 一个名字， 这个名字被用于出错信息和调试信息。</p>
<h3 id="lua-newstate"><a href="#lua-newstate" class="headerlink" title="lua_newstate"></a>lua_newstate</h3><pre><code>lua_State *lua_newstate (lua_Alloc f, void *ud);
</code></pre><p>创建的一个新的独立的状态机。 如果创建不了（因为内存问题）返回 NULL 。 参数 f 是一个分配器函数； Lua 将通过这个函数做状态机内所有的内存分配操作。 第二个参数 ud ，这个指针将在每次调用分配器时被直接传入。</p>
<h3 id="lua-newtable"><a href="#lua-newtable" class="headerlink" title="lua_newtable"></a>lua_newtable</h3><pre><code>void lua_newtable (lua_State *L);
</code></pre><p>创建一个空table，并将之压入堆栈。它等价于<code>lua_createtable(L, 0, 0)</code>。</p>
<h3 id="lua-pushglobaltable"><a href="#lua-pushglobaltable" class="headerlink" title="lua_pushglobaltable"></a>lua_pushglobaltable</h3><p>[-0, +1, –]</p>
<pre><code>void lua_pushglobaltable (lua_State *L);
</code></pre><p>Pushes the global environment onto the stack. </p>
<h3 id="lua-newthread"><a href="#lua-newthread" class="headerlink" title="lua_newthread"></a>lua_newthread</h3><pre><code>lua_State *lua_newthread (lua_State *L);
</code></pre><p>创建一个新线程，并将其压入堆栈， 并返回维护这个线程的 lua_State 指针。 这个函数返回的新状态机共享原有状态机中的所有对象（比如一些 table）， 但是它有独立的执行堆栈。<br>没有显式的函数可以用来关闭或销毁掉一个线程。 线程跟其它 Lua 对象一样是垃圾收集的条目之一。</p>
<h3 id="lua-newuserdata"><a href="#lua-newuserdata" class="headerlink" title="lua_newuserdata"></a>lua_newuserdata</h3><pre><code>void *lua_newuserdata (lua_State *L, size_t size);
</code></pre><p>这个函数分配分配一块指定大小的内存块， 把内存块地址作为一个完整的 userdata 压入堆栈，并返回这个地址。<br>userdata 代表 Lua 中的 C 值。 完整的 userdata 代表一块内存。 它是一个对象（就像 table 那样的对象）： 你必须创建它，它有着自己的元表，而且它在被回收时，可以被监测到。 一个完整的 userdata 只和它自己相等（在等于的原生作用下）。<br>当 Lua 通过 gc 元方法回收一个完整的 userdata 时， Lua 调用这个元方法并把 userdata 标记为已终止。 等到这个 userdata 再次被收集的时候，Lua 会释放掉相关的内存。</p>
<h3 id="lua-next"><a href="#lua-next" class="headerlink" title="lua_next"></a>lua_next</h3><pre><code>int lua_next (lua_State *L, int index);
</code></pre><p>从栈上弹出一个 key（键）， 然后把索引指定的表中 key-value（健值）对压入堆栈 （指定 key 后面的下一 (next) 对）。 如果表中以无更多元素， 那么 lua_next 将返回 0 （什么也不压入堆栈）。<br>典型的遍历方法是这样的：</p>
<pre><code>/* table 放在索引 &#39;t&#39; 处 */
lua_pushnil(L);  /* 第一个 key */
while (lua_next(L, t) != 0) {
    /* 用一下 &#39;key&#39; （在索引 -2 处） 和 &#39;value&#39; （在索引 -1 处） */
    printf(&quot;%s - %s\n&quot;,
    lua_typename(L, lua_type(L, -2)),
    lua_typename(L, lua_type(L, -1)));
    /* 移除 &#39;value&#39; ；保留 &#39;key&#39; 做下一次迭代 */
    lua_pop(L, 1);
}
</code></pre><p>在遍历一张表的时候， 不要直接对 key 调用 lua_tolstring ， 除非你知道这个 key 一定是一个字符串。 调用 lua_tolstring 有可能改变给定索引位置的值； 这会对下一次调用 lua_next 造成影响。</p>
<h3 id="lua-Number"><a href="#lua-Number" class="headerlink" title="lua_Number"></a>lua_Number</h3><pre><code>typedef double lua_Number;
</code></pre><p>Lua 中数字的类型。 确省是 double ，但是你可以在 luaconf.h 中修改它。<br>通过修改配置文件你可以改变 Lua 让它操作其它数字类型（例如：float 或是 long ）。</p>
<h3 id="lua-objlen-amp-luaS-rawlen"><a href="#lua-objlen-amp-luaS-rawlen" class="headerlink" title="lua_objlen &amp; luaS_rawlen"></a>lua_objlen &amp; luaS_rawlen</h3><pre><code>size_t lua_objlen (lua_State *L, int index); -- 5.1
size_t lua_rawlen (lua_State *L, int index); -- 5.3
</code></pre><p>返回指定的索引处的值的长度。 对于 string ，那就是字符串的长度； 对于 table ，是取长度操作符 (‘#’) 的结果； 对于 userdata ，就是为其分配的内存块的尺寸； 对于其它值，为 0 。</p>
<h3 id="lua-pcall"><a href="#lua-pcall" class="headerlink" title="lua_pcall"></a>lua_pcall</h3><pre><code>lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
</code></pre><p>以保护模式调用一个函数。<br>nargs 和 nresults 的含义与 lua_call 中的相同。 如果在调用过程中没有发生错误， lua_pcall 的行为和 lua_call 完全一致。 但是，如果有错误发生的话， lua_pcall 会捕获它， 然后把单一的值（错误信息）压入堆栈，然后返回错误码。 同 lua_call 一样， lua_pcall 总是把函数本身和它的参数从栈上移除。<br>如果 errfunc 是 0 ， 返回在栈顶的错误信息就和原始错误信息完全一致。 否则，errfunc 就被当成是错误处理函数在栈上的索引。 （在当前的实现里，这个索引不能是伪索引。） 在发生运行时错误时， 这个函数会被调用而参数就是错误信息。 错误处理函数的返回值将被 lua_pcall 作为出错信息返回在堆栈上。<br>典型的用法中，错误处理函数被用来在出错信息上加上更多的调试信息，比如栈跟踪信息 (stack traceback) 。 这些信息在 lua_pcall 返回后，因为栈已经展开 (unwound) ， 所以收集不到了。<br>lua_pcall 函数在调用成功时返回 0 ， 否则返回以下（定义在 lua.h 中的）错误代码中的一个：</p>
<p>LUA_ERRRUN: 运行时错误。<br>LUA_ERRMEM: 内存分配错误。 对于这种错，Lua 调用不了错误处理函数。<br>LUA_ERRERR: 在运行错误处理函数时发生的错误。</p>
<h3 id="lua-pop"><a href="#lua-pop" class="headerlink" title="lua_pop"></a>lua_pop</h3><pre><code>void lua_pop (lua_State *L, int n);
</code></pre><p>从堆栈中弹出 n 个元素。</p>
<h3 id="lua-pushboolean"><a href="#lua-pushboolean" class="headerlink" title="lua_pushboolean"></a>lua_pushboolean</h3><pre><code>void lua_pushboolean (lua_State *L, int b);
</code></pre><p>把 b 作为一个 boolean 值压入堆栈。</p>
<h3 id="lua-pushcclosure"><a href="#lua-pushcclosure" class="headerlink" title="lua_pushcclosure"></a>lua_pushcclosure</h3><pre><code>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
</code></pre><p>把一个新的<code>C closure</code>压入堆栈。当创建了一个C函数后，你可以给它关联一些值，这样就是在创建一个<code>C closure</code>；接下来无论函数何时被调用，这些值都可以被这个函数访问到。为了将一些值关联到一个C函数上，首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。接下来调用<code>lua_pushcclosure</code>来创建出closure并把这个C函数压到堆栈上。参数n告之函数有多少个值需要关联到函数上。<code>lua_pushcclosure</code>也会把这些值从栈上弹出。</p>
<h3 id="lua-pushcfunction"><a href="#lua-pushcfunction" class="headerlink" title="lua_pushcfunction"></a>lua_pushcfunction</h3><pre><code>void lua_pushcfunction (lua_State *L, lua_CFunction f);
</code></pre><p>将一个 C 函数压入堆栈。 这个函数接收一个 C 函数指针，并将一个类型为 function 的 Lua 值 压入堆栈。当这个栈顶的值被调用时，将触发对应的 C 函数。<br>注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值 （参见 lua_CFunction）。</p>
<p>lua_pushcfunction 是作为一个宏定义出现的：</p>
<pre><code> #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</code></pre><h3 id="lua-pushfstring"><a href="#lua-pushfstring" class="headerlink" title="lua_pushfstring"></a>lua_pushfstring</h3><pre><code>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
</code></pre><p>把一个格式化过的字符串压入堆栈，然后返回这个字符串的指针。 它和 C 函数 sprintf 比较像，不过有一些重要的区别：<br>摸你需要为结果分配空间： 其结果是一个 Lua 字符串，由 Lua 来关心其内存分配 （同时通过垃圾收集来释放内存）。<br>这个转换非常的受限。 不支持 flag ，宽度，或是指定精度。 它只支持下面这些： ‘%%’ （插入一个 ‘%’）， ‘%s’ （插入一个带零终止符的字符串，没有长度限制）， ‘%f’ （插入一个 lua_Number）， ‘%p’ （插入一个指针或是一个十六进制数）， ‘%d’ （插入一个 int)， ‘%c’ （把一个 int 作为一个字符插入）。</p>
<h3 id="lua-pushinteger"><a href="#lua-pushinteger" class="headerlink" title="lua_pushinteger"></a>lua_pushinteger</h3><pre><code>void lua_pushinteger (lua_State *L, lua_Integer n);
</code></pre><p>把 n 作为一个数字压栈。</p>
<h2 id="lua-pushlightuserdata"><a href="#lua-pushlightuserdata" class="headerlink" title="lua_pushlightuserdata"></a>lua_pushlightuserdata</h2><pre><code>void lua_pushlightuserdata (lua_State *L, void *p);
</code></pre><p>把一个 light userdata 压栈。<br>userdata 在 Lua 中表示一个 C 值。 light userdata 表示一个指针。 它是一个像数字一样的值： 你不需要专门创建它，它也没有独立的 metatable ， 而且也不会被收集（因为从来不需要创建）。 只要表示的 C 地址相同，两个 light userdata 就相等。</p>
<h3 id="lua-pushlstring"><a href="#lua-pushlstring" class="headerlink" title="lua_pushlstring"></a>lua_pushlstring</h3><pre><code>void lua_pushlstring (lua_State *L, const char *s, size_t len);
</code></pre><p>把指针 s 指向的长度为 len 的字符串压栈。 Lua 对这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串内可以保存有零字符。</p>
<h3 id="lua-pushnil"><a href="#lua-pushnil" class="headerlink" title="lua_pushnil"></a>lua_pushnil</h3><pre><code>void lua_pushnil (lua_State *L);
</code></pre><p>把一个 nil 压栈。</p>
<h3 id="lua-pushnumber"><a href="#lua-pushnumber" class="headerlink" title="lua_pushnumber"></a>lua_pushnumber</h3><pre><code>void lua_pushnumber (lua_State *L, lua_Number n);
</code></pre><p>把一个数字 n 压栈。</p>
<h3 id="lua-pushstring"><a href="#lua-pushstring" class="headerlink" title="lua_pushstring"></a>lua_pushstring</h3><pre><code>void lua_pushstring (lua_State *L, const char *s);
</code></pre><p>把指针s指向的以零结尾的字符串压栈。 Lua 这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串中不能包含有零字符；第一个碰到的零字符会认为是字符串的结束。</p>
<h3 id="lua-pushthread"><a href="#lua-pushthread" class="headerlink" title="lua_pushthread"></a>lua_pushthread</h3><pre><code>int lua_pushthread (lua_State *L);
</code></pre><p>把 L 中提供的线程压栈。 如果这个线程是当前状态机的主线程的话，返回 1 。</p>
<h3 id="lua-pushvalue"><a href="#lua-pushvalue" class="headerlink" title="lua_pushvalue"></a>lua_pushvalue</h3><pre><code>void lua_pushvalue(lua_State *L, int index);
</code></pre><p>把堆栈上给定有效处索引处的元素作一个拷贝压栈。</p>
<h3 id="lua-pushvfstring"><a href="#lua-pushvfstring" class="headerlink" title="lua_pushvfstring"></a>lua_pushvfstring</h3><pre><code>const char *lua_pushvfstring (lua_State *L, const char *fmt, va_list argp);
</code></pre><p>等价于 lua_pushfstring， 不过是用 va_list 接收参数，而不是用可变数量的实际参数。</p>
<h3 id="lua-rawequal"><a href="#lua-rawequal" class="headerlink" title="lua_rawequal"></a>lua_rawequal</h3><pre><code>int lua_rawequal (lua_State *L, int index1, int index2);
</code></pre><p>如果两个索引 index1 和 index2 处的值简单地相等 （不调用元方法）则返回 1 。 否则返回 0 。 如果任何一个索引无效也返回 0 。</p>
<h3 id="lua-rawget"><a href="#lua-rawget" class="headerlink" title="lua_rawget"></a>lua_rawget</h3><pre><code>void lua_rawget (lua_State *L, int index);
</code></pre><p>类似于 <code>lua_gettable</code>，但是作一次直接访问（不触发元方法）。</p>
<h3 id="lua-rawgeti"><a href="#lua-rawgeti" class="headerlink" title="lua_rawgeti"></a>lua_rawgeti</h3><pre><code>void lua_rawgeti (lua_State *L, int index, int n);
</code></pre><p>把 t[n] 的值压栈， 这里的 t 是指给定索引 index 处的一个值。这是一个直接访问；就是说，它不会触发元方法。</p>
<h3 id="lua-rawset"><a href="#lua-rawset" class="headerlink" title="lua_rawset"></a>lua_rawset</h3><pre><code>void lua_rawset (lua_State *L, int index);
</code></pre><p>类似于 lua_settable ，但是是作一个直接赋值（不触发元方法）。</p>
<h3 id="lua-rawseti"><a href="#lua-rawseti" class="headerlink" title="lua_rawseti"></a>lua_rawseti</h3><pre><code>void lua_rawseti (lua_State *L, int index, int n);
</code></pre><p>等价于<code>t[n] = v</code>，这里的 t 是指给定索引index 处的一个值， 而 v 是栈顶的值。函数将把这个值弹出栈。 赋值操作是直接的；就是说，不会触发元方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2018/04/02/CSharp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/CSharp/" class="post-title-link" itemprop="url">CSharp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 09:46:52" itemprop="dateCreated datePublished" datetime="2018-04-02T09:46:52+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp/" itemprop="url" rel="index"><span itemprop="name">CSharp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="internal、sealed"><a href="#internal、sealed" class="headerlink" title="internal、sealed"></a>internal、sealed</h1><p><strong>internal</strong>：本应用程序使用，其它进程无法使用</p>
<p><strong>sealed（密封）</strong>：由它修饰的类、方法、属性将不能被继承或是重写。sealed 必须和override一起使用<br>sealed修饰符表示密封用于类时，表示该类<font color="red"><strong>不能被继承</strong></font>，不能和abstract同时使用，<font color="red"><strong>不能被实例化</strong></font>。密封类不能用作基类、也不能继承，而抽象类总是希望被继承的。</p>
<h1 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h1><p>fixed 语句可防止垃圾回收器重新定位可移动的变量。 fixed 语句仅允许存在于不安全的上下文中。 Fixed 还可用于创建固定大小的缓冲区。</p>
<p>fixed 语句将为托管变量设置一个指针，并在该语句的执行过程中“单边锁定”该变量。 如果没有 fixed，指向可移动的托管变量的指针将几乎没有什么用处，因为垃圾回收可能会不可预见地重新定位变量。 C# 编译器只允许将指针分配给 fixed 语句中的托管变量。</p>
<ol>
<li>不支持持多继承，C#类始终继承一个基类（如果未在声明中指定一个基类，则继承自System.Object)</li>
<li>如果对类没有定义显示构造函数，则编译器将提供默认的构造函数，以初始化这些类的成员字段。但是，如果显式添加了构造函数，就可以有效控制整个构造过程。派生类通过使用:base()语法可以显式调用基类的构造函数</li>
<li>override 具有override关键字修饰符的方法是对基类中同名方法的新实现，基类中的同名方法必须声明为virtual或abstract类型。给基类中的方法添加virtual关键字表示可以重写它的实现。new static 和 virtual关键字不能与override访问修饰符同时使用。</li>
<li>virtual 支持多态，不能与static override同时使用</li>
<li>abstract 一个抽象类包含抽象方法和非抽象方法，抽象方法只存放函数原型，不涉及主体代码，override关键字可在派生类中抽象方法，经override声明重写的方法称为重写基类方法，其签名必须与override方法的签名相同。只是不能被实例化，除此以外具有类的其他特性，重要的是抽象类可以包含抽象方法，这是普通类所不能的。抽象方法只能声明于抽象方法中，且不包含任何实现，派生类必须覆盖它们。</li>
<li>interface 包含未实现的方法声明，派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员，接口包含属性，索引器事件</li>
</ol>
<h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><p>索引器允许类或者结构的实例按照于数组相同的方法进行索引取值，索引器与属性类似，不同的是索引器的访问时带参的</p>
<ul>
<li>索引器的索引值(Index)类型不受限制</li>
<li>索引器允许重载</li>
<li>索引器不是一个变量</li>
</ul>
<h2 id="索引器和属性的不同点"><a href="#索引器和属性的不同点" class="headerlink" title="索引器和属性的不同点"></a>索引器和属性的不同点</h2><ul>
<li>属性以名称来标识，索引器以函数形式标识</li>
<li>索引器可以被重载，属性不可以</li>
<li>索引器不能声明为static，属性可以</li>
</ul>
<h1 id="interface、abstract"><a href="#interface、abstract" class="headerlink" title="interface、abstract"></a>interface、abstract</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>abstract</th>
<th>interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>能否实例化</td>
<td>不能</td>
<td>不能</td>
</tr>
</tbody>
</table>
</div>
<h2 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h2><ul>
<li>类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫抽象类，而接口只是一个行为的规范或规定，</li>
<li>接口基本上不具备类型的任何具体特点，它仅仅承诺了能够调用的方法</li>
<li>抽象类比较细，而接口比较简单</li>
</ul>
<h2 id="抽象类和接口的使用"><a href="#抽象类和接口的使用" class="headerlink" title="抽象类和接口的使用"></a>抽象类和接口的使用</h2><ul>
<li>如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本。</li>
<li>抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能</li>
</ul>
<h1 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h1><p>提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在于非托管代码交互时使用的其他方法</p>
<p>命名空间：System.Runtime.InteropServices<br>程序集：mscorlib</p>
<p>AllocHGlobal(int32); // 通过使用指定的字节数，从进程的非托管内存中分配内存<br>SizeOf(Type)返回非托管类型的大小(以字节为单位)</p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PGExt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">PG_GetComponent</span>(<span class="params"><span class="keyword">this</span> List&lt;Component&gt; components</span>) <span class="keyword">where</span> T : Component</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">        <span class="keyword">int</span> c = components.Count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> p = components[i] <span class="keyword">as</span> T;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">object</span>)p != <span class="literal">null</span>) <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这里会有一个this关键字，做什么用？其实这就是扩展方法！这个扩展方法在静态类中声明，定义一个静态方法，其中第一个参数定义可它的扩展类型，PG_GetComponent方法扩展了List类，因为它的第一个参数定义了List类型，为了区分扩展方法和一般的静态方法，扩展方法还需要给第一个参数使用this关键字。</p>
<p>现在就可以使用带List类型的PG_GetComponent方法了：</p>
<pre><code>var mf = cacheComponents.PG_GetComponent&lt;MeshFilter&gt;();
</code></pre><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile关键字指示一个字段可以由多个同时执行的线程修改。声明volatile的字段不受编译器优化的限制。这样可以确保该字段在任何时间呈现的都是最新的值。<br>volatile修饰符通常用于由多个线程访问但不使用lock语句对访问进行序列化的字段。<br>volatile关键字可应用于以下类型的字段：</p>
<ul>
<li>引用类型</li>
<li>指针类型（在不安全的上下文中）。请注意，虽然指针本身可以是可变的，但是它指向的对象不能是可变的。换句话说，无法声明“指向可变对象的指针”。</li>
<li>类型，如sbyte、byte、short、ushort、int、uint、。</li>
<li>引用类型的泛型类型参数。</li>
<li>IntPtr和UIntPtr</li>
</ul>
<h1 id="事件和委托"><a href="#事件和委托" class="headerlink" title="事件和委托"></a>事件和委托</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Print print; <span class="comment">// 去掉event就是一个委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (print == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> Test();</span><br><span class="line">        obj.print += Print1; <span class="comment">// 事件无法使用=</span></span><br><span class="line">        obj.print += Print2; <span class="comment">// 委托会清掉之前的关联</span></span><br><span class="line">        obj.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件实际上是一个特殊的委托实例，不用事件也没有关系。实际上事件只是削弱了委托的功能，event在编辑器角度保护了程序的安全，因为你只能用+=、-=来注册事件了，而不能使用=为事件关联方法。（在委托中还可以使用=来绑定方法，不过=是一种破坏性代码，不管之前是否已经绑定方法，他都会将其清除）</p>
<p>extern:指示方法在外部实现</p>
<h1 id="堆栈和堆-Heap-amp-Stack"><a href="#堆栈和堆-Heap-amp-Stack" class="headerlink" title="堆栈和堆 Heap &amp; Stack"></a>堆栈和堆 Heap &amp; Stack</h1><p>首先堆栈和堆（托管堆）都在进程的虚拟内存中。（在32位处理器上每个进程的虚拟内存为4GB）<br>栈是内存中完全用于存储局部变量或成员（值类型数据）的高效区域，但其大小有限制。<br>托管堆占内存比栈大得多，当访问速度较慢。托管堆只用于分配内存。<br>在创建值类型数据时，在栈上分配内存；<br>当创建引用型类型数据时，在托管堆上分配并返回对象的引用。注意这个对象的引用，像其他局部变量一样也是保存在栈中，该引用指向的值则位于托管堆中。<br>如果创建一个包含值类型的引用类型，比如数组，其元素的值也是存放在托管堆中的某个地方，由使用该实体的变量引用；而值类型存储在使用它们的地方，有几处在使用，就有几个副本存在。<br>对于引用类型，如果在声明变量的时候没有使用new运算符，运行时不会给它分配托管堆的内存空间，而是在栈上给它分配一个包含null的值的引用。对于值类型，运行时会给它分配栈上的空间，并且调用构造函数来初始化对象的状态。</p>
<h2 id="堆栈stack"><a href="#堆栈stack" class="headerlink" title="堆栈stack"></a>堆栈stack</h2><p>堆栈中存储值类型<br>堆栈实际上是向下填充，即由高内存地址指向低内存地址填充。<br>堆栈的工作方式是先分配内存的变量后后释放（先进后出原则）。<br>堆栈的变量是从下向上释放，这样就保证了堆栈中先进后出的规则不与变量的生命周期起冲突<br>堆栈的性能非常高，但是对于所有的变量来说不太灵活，而且变量的生命周期必须嵌套。<br>通常我们希望使用一种方法分配内存来存储数据，并且方法退出后很长一段时间内数据仍然可以使用。此时就要用到堆（托管堆）</p>
<h2 id="堆（托管堆）heap"><a href="#堆（托管堆）heap" class="headerlink" title="堆（托管堆）heap"></a>堆（托管堆）heap</h2><p><font color="blue">堆（托管堆）存储引用类型。</font><br>引用类型共有四种：类类型、接口类型、数组类型和委托类型。<br>所有引用类型变量所引用的对象，其内存都是托管堆中分配的。<br>严格地说，我们常说的“对象变量”其实是类类型的引用变量。但在实际中人们经常将引用类型的变量简称为“对象变量”，用它来指代所有四种类型的引用变量。<br>此堆非彼堆，.NET中的堆由垃圾收集器自动管理。<br>与堆栈不同，堆是从下往上分配，所以自动的空间都在已用空间的上面。<br>比如创建一个对象：</p>
<pre><code>Customer cus;
cus = new Customer();
</code></pre><p>声明一个Customer的引用cus，在堆栈上给这个引用分配存储空间。这仅仅只是一个引用，不是实际的Customer对象！<br>cus占4个字节的空间，包含了存储Customer的引用地址。<br>接着分配堆上的内存以存储Customer对象的实例，假定Customer对象的实例是32字节，为了在堆上找到一个存储Customer对象的存储位置。<br>.NET运行库在堆中搜索第一个从未使用的，32字节的连续块存储Customer对象的实例。<br>然后把分配给Customer对象实例的地址赋给cus变量。</p>
<p>从这个例子中可以看出，建立对象引用的过程比建立值变量的过程复杂，且不能避免性能的降低！<br>实际上就是.NET运行库中保存堆的状态信息，在堆中添加新数据时，堆栈中的引用变量也要更新。性能上损失很多。<br>有种机制在分配变量内存的时候，不会受到堆栈的限制：把一个引用变量的值赋给一个相同类型的变量，那么这两个变量就引用同一个堆中对象。<br>当一个应用变量出作用域时，它会从堆栈中删除。但引用对象的数据仍然保留在堆中，一直到程序结束或者该数据不被任何变量应用时，垃圾收集器会删除它。</p>
<p>装箱转化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Boxing</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 110;</span><br><span class="line">        object obj = i;</span><br><span class="line">        Console.WriteLine(&quot;i=&#123;0&#125;,obj = &#123;1&#125;&quot;,i,obj);</span><br><span class="line">        obj = 330;</span><br><span class="line">        Console.WriteLine(&quot;i = &#123;0&#125;,obj=&#123;1&#125;&quot;,i,obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义整数类型变量的时候，这个变量占用的内存是内存占中分配的，第二句是装箱操作将变量110存放到了内存堆中，而定义object对象类型的变量Obj则在内存栈中，并指向int类型的数值110，而该数值是赋给变量i的数值副本。<br>内存格局通常分为四个区<br>全局数据区：存放全局变量，静态数据，常量<br>代码区：存放所有的程序代码<br>栈区：存放为运行而分配的局部变量，参数，返回数据，返回地址等。</p>
<p>值类型变量和引用类型变量的内存分配模型也不一样。为了理解清楚这个问题，首先先区分两种不同类型的内存区域：线程堆栈（Thread Stack）和托管堆（Managed Heap）。每个正在运行的程序都对应着一个进程（process），在一个进程内部，可以有一个或多个线程（thread），每个线程都拥有一块“自留地”，称为“线程堆栈”，大小为1M，用于保存自身的一些数据，比如函数中定义的局部变量、函数调用的传参值，这部分内存区域的分配与回收不需要人为干涉。</p>
<p><font color="blue">所有值类型的变量都是在线程堆栈中分配的。</font><br>另一块内存区域成为“堆（heap）”，在.NET托管环境下，堆由CLR进行管理，所以又称为“托管堆（managed heap）”。</p>
<p><font color="red">用new关键字创建的类的对象时，分配给对象的内存单元就位于托管堆中。</font><br>在程序中我们可以随意地使用new 关键字创建多个对象，因此，托管堆中的内存资源是可以动态申请并使用的，当然使用完了必须归还。</p>
<p>对象变量的相互赋值不会导致对象自身被复制，其结果是两个对象变量指向同一对象。另外，由于对象变量是一个局部变量，因为，对象变量本身是位于线程堆栈中的。<br>严格区分<strong>对象变量</strong>和<strong>对象变量所引用的对象</strong>，是面向对象编程的关键之一。</p>
<h2 id="托管堆"><a href="#托管堆" class="headerlink" title="托管堆"></a>托管堆</h2><p>.NET框架包含一个托管堆，所有的.NET语言在分配引用类型对象时都要使用它。像值类型这样的轻量级对象始终分配在栈中，但是所有的<strong>类实例</strong>和<strong>数组</strong>都被生成在一个内存池中，这个内存池就是托管堆。</p>
<p>垃圾收集器算法：</p>
<ul>
<li>将所有的托管内存标记为垃圾</li>
<li>寻找正被使用的内存块，并将他们标记为有效</li>
<li>释放所有没有被使用的内存块</li>
<li>整理堆以减少碎片</li>
</ul>
<h2 id="托管堆优化"><a href="#托管堆优化" class="headerlink" title="托管堆优化"></a>托管堆优化</h2><p>看上去很简单，但是垃圾收集器实际采用的步骤和堆管理系统的其它部分并非微不足道，其中尝尝涉及为提高性能而作的优化设计。举例来说，垃圾收集遍历整个内存池具有很高的开销。然而，研究表明大部分的托管堆上分配的对象只有很短的生存期，因此堆被分为三个段，称作generations。新分配的对象被放在generation 0中。这个generation是最先被回收的-在这个generation中最有可能找到不再使用的内存，由于它的尺寸很小（小到足以放进处理器的L2 cache中），因此在它里面的回收将是最快和最高效的。<br>托管堆的另外一种优化操作与locality of reference规则有关。该规则表明，一起分配的对象经常被一起使用。如果对象们在堆中位置很紧凑的话，高速缓存的性能将会得到提高。由于托管堆的天性，对象们总是被分配在连续的地址上，托管堆总是保持紧凑，结果使得对象们始终彼此靠近，永远不会分得很远。这一点与标准提供的非托管代码形成了鲜明的对比，在标准堆中，堆很容易变成碎片，而且一起分配的对象经常分得很远。<br>还有一种优化是与大对象有关的。通常，大对象具有很长的生存期。当一个大对象在.NET托管堆中产生时，它被分配在堆的一个特殊部分中，这部分堆永远不会被整理。因此移动大对象所带来的开销超过了整理这部分堆所能提高的性能。</p>
<h2 id="关于外部资源（External-Resources）的问题"><a href="#关于外部资源（External-Resources）的问题" class="headerlink" title="关于外部资源（External Resources）的问题"></a>关于外部资源（External Resources）的问题</h2><p>垃圾收集器能够有效地管理从托管堆中释放的资源，但是资源回收操作只有在内存紧张而触发一个回收动作时才执行。那么，累时怎样来管理像数据库连接或者窗口句柄这样有限的资源的呢？等待，直到垃圾回收被触发之后在清理数据库连接或者文件句柄并不是一个好方法，这会严重降低系统的性能。<br>所有拥有外部资源的类，在这些资源已经不再用到的时候，都应当执行Close或者Dispose方法。<br>需要清理外部资源的类还应当实现一个终止操作（finalizer）。在C#中，创建终止操作的首选方式是在析构函数中实现，而在Framework层，终止操作的实现则是通过重载System.Object.Finalize方法。以下两种实现终止操作的方法是等效的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~OverdueBookLocator()</span><br><span class="line">&#123;</span><br><span class="line">    Dispose(false);</span><br><span class="line">&#125;</span><br><span class="line">public void Finalize()</span><br><span class="line">&#123;</span><br><span class="line">    base.Finalize();</span><br><span class="line">    Dispose(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C#中，同时在Finalize方法和析构函数实现终止操作将会导致错误的产生。<br>除非你有足够的理由，否则你不应该创建析构函数或者Finalize方法。终止操作会降低系统的性能，并且增加执行期的内存开销。同时，由于终止操作被执行的方式，你并不能保证何时一个终止操作被执行。</p>
<h2 id="内存分配和垃圾回收的细节"><a href="#内存分配和垃圾回收的细节" class="headerlink" title="内存分配和垃圾回收的细节"></a>内存分配和垃圾回收的细节</h2><p>对GC有了一个总体印象之后，让我们来讨论关于托管堆中的分配与回收工作的细节。托管堆看起来与我们已经熟悉的C++编程中的传统的堆一点都不像。在传统的堆中，数据结构习惯于使用大块的空闲内存。在其中查找特定大小的内存块是一件很耗时的工作，尤其是当内存中充满碎片的时候。与此不同，在托管堆中，内存被组成连续的数组，指针总是巡着已经被使用的内存和未被使用的内存之间的边界移动。当内存被分配的时候，指针只是简单地递增—由此而来的一个好处是，分配操作的效率得到了很大的提升。<br>当对象被分配的时候，它们一开始被generation 0中。当generation 0的大小快要达到它的上限的时候，一个只在generation 0中执行的回收操作被触发。由于generation 0的大小很小，因此这将是一个非常快的GC过程。这个GC过程的结果是将generation 0彻底的刷新了一遍。不再使用的对象被释放，正在使用的对象被整理并移入generation 1中。<br>当generation 1的大小随着generation 0中移入的对象数量的增加而接近它的上限的时候，一个回收动作被触发在generation 0和generation 1中执行GC过程。如同在generation 0中一样，不再使用的对象被释放，正在被使用的对象被整理并移入下一个generation中。大部分GC过程的主要目标是generation 0，因为在generation 0中最优可能存在大量的已不再使用的临时对象。对generation 2的回收过程具有很高的开销，并且此过程只有在generation 0和generation 1的GC过程不能释放足够的内存时才会被触发。如果对generation 2的GC过程仍然不能释放足够的内存，那么系统就会抛出OutOfMemoryException异常。<br>带有终止操作的对象的垃圾收集过程要稍微复杂一些。当一个带有终止操作的对象被标记为垃圾时，它并不会被立即释放。相反，它会被放置一个终止队列（finalizetion queue）中，此队列为这个对象建立一个引用，来避免这个对象被回收。后台线程为队列中的每个对象执行它们各自的终止操作，并且将已经执行过终止操作的对象从终止队列中删除。只有那些已经执行过终止操作的对象才会在下一次垃圾回收过程中被内存中删除。这样做的一个后果是，等待被终止的对象有可能在它被清除之前，被移入更高一级的generation中，从而增加它被清除的延迟时间。<br>需要执行终止操作的对象应当事先IDisposable接口，以便程序通过此接口快速执行终止动作。IDisposable接口包含一个Dispose方法。这个方法被用来释放外部资源并抑制终止操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class OverdueBookLocator:IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    ~OverdueBookLocator()</span><br><span class="line">    &#123;</span><br><span class="line">        InternalDispose(false);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">        InternalDispose(true);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void InternalDispose(bool disposing)</span><br><span class="line">    &#123;</span><br><span class="line">        if (disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            GC.SuppressFinalize(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="栈和托管堆"><a href="#栈和托管堆" class="headerlink" title="栈和托管堆"></a>栈和托管堆</h2><p>通用类型系统（CTS）区分两种基本类型：值类型和引用类型。它们之间的根本区别在于它们在内存中的存储方式。.NET使用两种不同的物理内存来存储数据<font color="orange">栈和托管堆</font><br><img src="/2018/04/02/CSharp/1.png"><br>值类型总是内存中占用一个预定义的字节数（例如，int类型占4个字节，而string类型占用的字节数会根据字符串的长度而不同）。当声明一个值类型变量时，会在栈中分配适当大小的内存（除了引用类型的值类型成员外，如类的int字段）。内存中的这个空间用来存储变量所包含的值。.NET维护一个栈指针，它包含栈中下一个可用的内存空间的地址。当一个变量离开作用域时，栈指针指向下移动被释放变量所占用的字节数。所以它仍指向下一个可用地址。<br>引用变量也利用栈，但这时候栈包含的只是对另一个内存位置的引用，而不是实际值。这个位置是托管堆中的一个地址，和栈一样，他也维护一个指针，包含堆中下一个可用的内存地址。但是，堆不是先入后出的，因为对对象的引用可在我们的程序中传递（例如，作为参数传递给方法调用）。堆中的对象不会在程序的一个预定点离开作用域。为了在不适用在堆中分配的内存时将它释放。.NET定期执行垃圾回收器，垃圾垃圾递归检查应用程序中所有对象的引用。引用不再有效的对象使用的内存无法从程序中访问，该内存就可以回收。</p>
<h2 id="类型层次结构"><a href="#类型层次结构" class="headerlink" title="类型层次结构"></a>类型层次结构</h2><p>CTS定义了一种类型层级结构，该结构不仅仅描述了不同预定义类型，还指出了用户定义类型的层次结构的位置。</p>
<img src="/2018/04/02/CSharp/2.png">
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>可以定义除Char以外的所有整数类型，默认类型是int<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="readonly与const"><a href="#readonly与const" class="headerlink" title="readonly与const"></a>readonly与const</h1><p>readonly是运行时常量，程序运行时进行赋值，赋值完之后无法更改，也被称为只读变量。<br>const表示编译时常量，程序编译时将对常量值进行解析，并将所有常量值引用替换为相应值。</p>
<h1 id="using-语句"><a href="#using-语句" class="headerlink" title="using 语句"></a>using 语句</h1><p>提供可确保正确使用IDisposable对象的方便语法。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Font font1 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">byte</span> charset = font1.GdiCharSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>File和Font是访问非托管资源（本例中为文件句柄和设备上下文）的托管类型的示例。有许多其他类别的非托管资源和封装这些资源的类库类型。所有此类型都必须实现IDisposable接口。<br>IDisposable对象的生存期限于单个方法时，应在using语句中声明并实例化它。using语句按照正确的方式调用对象上的Dispose方法，并（在按照前面所示方式使用它时）会导致在调用Dispose时对象自身处于范围之外。在using块中，对象是只读的并且无法进行修改或重新分配。</p>
<p>using语句可确保调用Dispose，即使using块中发生异常也是如此。通过将对象放入try块中，然后调用finally块中的Dispose，可以实现相同的结果；实际上，这就是编译器转换using语句的方式。前面的代码示例在编译时将扩展到以下代码（请注意，使用额外的大括号为对象创建有限范围）；<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Font font1 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span> charset = font1.GdiCharSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (font1 != <span class="literal">null</span>)</span><br><span class="line">            ((IDsiposable)font1).Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可在using语句中声明一个类型的多个实例，如下面的示例中所示：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Font font3 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>), font4 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use font3 and font4.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在实例化资源对象，然后将变量传递到using语句，但这不是最佳做法。在这种情况下，控件退出using块以后，对象保留在作用域中，但是可能没有访问其未托管资源的劝降。换句话说，它不再是完全初始化的。如果尝试在using块外部使用该对象，则可能导致引发异常。因此，通常最好在using语句中实例化该对象并将其范围限制在using块中。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Font font2 = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, <span class="number">10.0f</span>);</span><br><span class="line"><span class="keyword">using</span> (font2) <span class="comment">// not recommended</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use font2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// font2 is still in scope</span></span><br><span class="line"><span class="comment">// but the method call throws an exception</span></span><br><span class="line"><span class="keyword">float</span> f = font2.GetHeight();</span><br></pre></td></tr></table></figure></p>
<h1 id="HashTable-HashSet和Dictionary的区别"><a href="#HashTable-HashSet和Dictionary的区别" class="headerlink" title="HashTable HashSet和Dictionary的区别"></a>HashTable HashSet和Dictionary的区别</h1><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>哈希表(HashTable)表示键/值对的集合.在.NET Framework中,HashTable是System.Collections命名空间提供的一个容器,用于处理和表现类似key-value的键值对,其中key通常可用来快速查找,同时key是区分大小写;value用于存储对应于key的值.hashtable中key-value键值对均为object类型,所以hashtable可以支持任何类型的keyvalue键值对,任何非null对象都可以用作键值对.<br>在哈希表添加一个key/键值对:HashTableObject.Add(key,);<br>在哈希表中去除某个key/键值对:HashTableObject.Remove(key);<br>从哈希表中移除所有元素:HashtableObject.Clear();<br>判断哈希表是否包含特定键key:HashtableObject.Contains(key);</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet<t>类主要是设计用来做高性能集运算的,例如对两个集合求交集,并集,差集等.集合中包含一组不重复出现且无特性顺序的元素,HashSet拒绝接受重复的对象.<br>HashSet<t>的一些特性如下:</t></t></p>
<ol>
<li>HashSet<t>中的值不能重复且没有顺序</t></li>
<li>HashSet<t>的容量会按需自动添加</t></li>
</ol>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>Dictionary表示键值的集合.<br><code>Dictionary&lt;string,string&gt;</code>是一个泛型<br>他本身有集合的功能有时候可以把它堪称数组<br>它的结构是这样的:<code>Dictionary&lt;[key],[value]&gt;</code><br>它的特点是存入对象是需要与[key]值一一对应的存入该泛型<br>通过某一个一定的<code>[key]</code>去找对应的值</p>
<h2 id="HashTable和Dictionary的区别"><a href="#HashTable和Dictionary的区别" class="headerlink" title="HashTable和Dictionary的区别"></a>HashTable和Dictionary的区别</h2><ol>
<li>HashTable不支持泛型,而Dictionary支持泛型</li>
<li>HashTable的元素属于Object类型,所以在存储或检索值类型时通常发生装箱和拆箱的操作,所以你可能需要进行类型转换的操作,而且对于int,float这些值类型还需要进行装箱等操作,非常耗时.</li>
<li>单线程程序中推荐使用Dictionary,有泛型优势,且读取速度较快,容量利用更充分.多线程程序中推荐使用Hashtable,默认的hashtable允许单线程写入,多线程读取,对hashtable进一步调用<code>synchronized()</code>方法可以获得完全线程安全的类型,而Dictionary非线程安全,必须人为使用lock语句进行保护,效率搭建.</li>
<li>在通过代码测试的时候发现key是整数型Dictionary的效率比hashtable快,如果key是字符串型,Dictionary的效率没有hashtable快.<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IntMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">    Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dictionary.Add(i,i);</span><br><span class="line">        hashtable.Add(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = dictionary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line">    stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">object</span> <span class="keyword">value</span> = hashtable[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StringMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line">    Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dictionary.Add(i.ToString(),<span class="string">"aaa"</span>);</span><br><span class="line">        hashtable.Add(i.ToString(), <span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> vale = dictionary[i.ToString()];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line">    stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">object</span> <span class="keyword">value</span> = hashtable[i.ToString()];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(stopwatch.ElapsedMilliseconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2018/04/02/CSharp/1.jpg">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
