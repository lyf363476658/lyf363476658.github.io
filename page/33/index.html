<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"LAEJN7HTXI","apiKey":"db483f3dceb8b9b4ac8ca1fcf782c13e","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/33/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/33/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/10/05/2d-outline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/05/2d-outline/" class="post-title-link" itemprop="url">Unity 2D Outline</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-05 23:25:51" itemprop="dateCreated datePublished" datetime="2017-10-05T23:25:51+08:00">2017-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/10/05/2d-outline/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/10/05/2d-outline/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="像素着色器描边："><a href="#像素着色器描边：" class="headerlink" title="像素着色器描边："></a>像素着色器描边：</h1><p>首先最直观的想法，就是使用fragment shader找出2D角色贴图透明像素和非透明像素的边界，然后通过边界周边Alpha值Blur的方式，给边界上描边色。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Hidden/NewImageEffectShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">        _Offset (<span class="string">"Offset"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.1</span> <span class="comment">// 偏移</span></span><br><span class="line">        _Color (<span class="string">"Color"</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 边缘色</span></span><br><span class="line">        _AlphaThreshold(<span class="string">"Alpha Threshold"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;<span class="string">"Queue"</span>=<span class="string">"Transparent"</span>&#125;</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            </span><br><span class="line">            #include <span class="string">"UnityCG.cginc"</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float2 uv[<span class="number">5</span>] : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Offset; <span class="comment">// 偏移</span></span><br><span class="line">            fixed4 _Color; <span class="comment">// 边缘色</span></span><br><span class="line">            fixed _AlphaThreshold; <span class="comment">// Alpha 阀值</span></span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv[<span class="number">0</span>] = v.uv;</span><br><span class="line">                o.uv[<span class="number">1</span>] = v.uv + float2(<span class="number">0</span>, _Offset);<span class="comment">// 上</span></span><br><span class="line">                o.uv[<span class="number">2</span>] = v.uv + float2(<span class="number">0</span>, -_Offset); <span class="comment">// 下</span></span><br><span class="line">                o.uv[<span class="number">3</span>] = v.uv + float2(-_Offset, <span class="number">0</span>); <span class="comment">// 左</span></span><br><span class="line">                o.uv[<span class="number">4</span>] = v.uv + float2(_Offset, <span class="number">0</span>); <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv[<span class="number">0</span>]);</span><br><span class="line">                fixed alpha = col.a;</span><br><span class="line">                fixed p1 = tex2D(_MainTex, i.uv[<span class="number">1</span>]).a;</span><br><span class="line">                fixed p2 = tex2D(_MainTex, i.uv[<span class="number">2</span>]).a;</span><br><span class="line">                fixed p3 = tex2D(_MainTex, i.uv[<span class="number">3</span>]).a;</span><br><span class="line">                fixed p4 = tex2D(_MainTex, i.uv[<span class="number">4</span>]).a;</span><br><span class="line">                alpha = (alpha + p1 + p2 + p3 + p4) / <span class="number">5</span>;</span><br><span class="line">                fixed ret = step(alpha, _AlphaThreshold);</span><br><span class="line">                col.rgb = ret * _Color.rgb + col.rgb * (<span class="number">1</span>-ret);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/NewImageEffectShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Edge (&quot;Edge&quot;, Range(0,0.5)) = 0.1 // 边缘</span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (1,0,0,1) // 边缘色</span><br><span class="line">        _FlowColor (&quot;Flow Color&quot;, Color) = (0,1,0,1) // 流动色</span><br><span class="line">        _Speed (&quot;Speed&quot;, Range(0, 2)) = 1 // 旋转速度</span><br><span class="line">        _MainTex(&quot;MainTex&quot;, 2D) = &quot;white&quot; &#123;&#125; // 主纹理</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot; = &quot;Transparent&quot;&#125;</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0; // 纹理uv坐标</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Edge; // 边缘阀值</span><br><span class="line">            fixed4 _EdgeColor; // 边缘色</span><br><span class="line">            fixed4 _FlowColor; // 流动色</span><br><span class="line">            fixed _Speed; // 旋转速度</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed x = i.uv.x;</span><br><span class="line">                fixed y = i.uv.y;</span><br><span class="line">                if (x &lt; _Edge || abs(1 - x) &lt; _Edge || y &lt; _Edge || abs(1 - y) &lt; _Edge) // 求边缘</span><br><span class="line">                &#123;</span><br><span class="line">                    x -= 0.5;</span><br><span class="line">                    y -= 0.5;</span><br><span class="line">                    fixed w = _Speed * _Time.y;</span><br><span class="line">                    fixed temp = saturate(x* cos(w) - y* sin(w));</span><br><span class="line">                    return (temp )* _EdgeColor + (1-temp)*_FlowColor;</span><br><span class="line">                &#125;</span><br><span class="line">                return tex2D(_MainTex, i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后处理-像素着色器描边："><a href="#后处理-像素着色器描边：" class="headerlink" title="后处理+像素着色器描边："></a>后处理+像素着色器描边：</h1><p>　　于是，很自然的想到，使用Postprocessing 的方式来处理屏幕最终渲染出来的仅包含有需要描边的角色的图片，然后进行上述的fragment描边处理。<br>　　首先，在场景中添加一个专用的描边相机，Depth设为比默认相机高一级，视口大小、位置全部和默认相机一致。另外给场景物体添加一个”Outline1”layer，设置到专用相机的cullingmask，需要描边的角色的layer都设置为”Outline1”。</p>
<p>　　这个时候专用相机只渲染描边物体，然后给相机添加Monobehavior脚本，在OnRenderImage里对相机渲染的图像进行像素着色器的描边处理，得到如下效果：<br>　　描边效果的确是预期的效果，但是还是有两个问题：<br>　　一个是：由于我们游戏UI是使用Screen space - camera的方式，它和游戏中对象都是在默认相机渲染的，专用相机的depth比默认相机高一级，所以所有渲染内容都会在UI层次之上，这显然也不是我们想要的。<br>　　另一个是：角色的不同行动状态需要用不同的描边颜色来区分，上述方式只支持一种描边颜色。</p>
<h1 id="RenderTarget-像素着色器描边："><a href="#RenderTarget-像素着色器描边：" class="headerlink" title="RenderTarget + 像素着色器描边："></a>RenderTarget + 像素着色器描边：</h1><p>　　现在我们着重来解决上述两个问题：<br>第一个遮挡UI的问题：<br>　　描边效果需要在默认相机中进行z轴排序，让其渲染在UI之后，所以，我们需要让描边效果作为一个默认相机渲染的常规游戏对象放到游戏中。于是，我想到的是给它创建一个和屏幕尺寸同大小的Mesh，再将描边渲染的图片放到Mesh上，所以，做法是给专用相机分配一个屏幕尺寸同大小的RenderTarget，然后将RenderTarget渲染到创建的Mesh上。如下图所示，该Mesh在骨骼动画和相机之间创建。</p>
<p>第二个颜色区分的问题：<br>　　查询Unity Camera的API有两个回调接口可以用：<br>　　OnPreRender 在相机渲染场景之前被调用。<br>　　OnPostRender 在相机完成场景渲染之后被调用。<br>　　我们给专用相机添加这两个回调，<br>在OnPreRender里：<br>　　给所有需要描边的物体更换Material，该Material负责绘制该物体的状态纯颜色到RenderTarget上，并保存原有Material。<br>在OnPostRender里：<br>　　将原有Material又置换回来供默认相机正常渲染。得到的RenderTarget如下，<br>　　这个时候，再用像素着色器对应用了RenderTarget的Mesh进行描边，得到如下效果</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/10/05/pixel-and-voxel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/05/pixel-and-voxel/" class="post-title-link" itemprop="url">pixel-and-voxel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-05 22:55:00" itemprop="dateCreated datePublished" datetime="2017-10-05T22:55:00+08:00">2017-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/10/05/pixel-and-voxel/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/10/05/pixel-and-voxel/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址: <a href="https://medium.com/retronator-magazine/pixels-and-voxels-the-long-answer-5889ecc18190#.8gf6zy8mc" target="_blank" rel="noopener">https://medium.com/retronator-magazine/pixels-and-voxels-the-long-answer-5889ecc18190#.8gf6zy8mc</a></p>
<p>伪3D等轴游戏 赛达尔, Sir Carma, 2016</p>
<p>像素和体素，一个详细的答案<br>Retronator Stray Pixels</p>
<p>像素和体素的区别是什么？</p>
<p>我很清楚他的问题。你会在生活中看到类似像素大战电影海报这样的东西，而你会对此产生困惑。它是像素吗？还是体素？它是一只鸟？还是一架飞机？这个东西一定不简单。<br>不必害怕，我来解释这个问题。当你阅读完这篇文章后你会知道所有关于像素和体素的知识以及它们之间的联系。</p>
<p>首先我先介绍一点背景知识以便你更好的了解该领域的全貌。在计算机中有两种表示图像的方法：向量和栅格（raster）。</p>
<p>向量图像（左）的数学准确性和栅格图像（右）的离散性<br>向量图像使用各种表示直线，曲线和不同形状的数学方程描述图像。相反，栅格图像将图像描述为一个含有颜色值的数组，该数组中的颜色值依次被放置在一个网格系统中。</p>
<p>计算机图像学中的第二个区别在于2D和3D空间之间的差别。算上向量/栅格的区别总共有四种情况：</p>
<p>大家都喜欢象限！<br>向量图像<br>在2D向量图像中，直线或不同形状上的每个点都由具有两个分量（x和y）的向量来表示。这就是它被称为2D的原因（两个分量——两个维度）。</p>
<p>2D向量是这样表示2D向量图像中每个点的<br>以下是一张所谓的低多边形2D向量图像</p>
<p>伟大梦想着乌鲁鲁（Uluru the Mighty Dreamer）, Anh Tran, 2015<br>它完全使用了2D多边形（在这个情况中为三角形）。低多边形这个术语意味着制成图像所需的多边形数量相对较少。这使得三角形容易被识别出来。<br>我们加入一个维度。在3D向量图像中情况相同，但是每个向量使用了三个分量（x，y，z）。三个分量——三个维度。<br>我们看一张3D低多边形的作品。</p>
<p>iOS概念游戏 赛道, Timothy J. Reynolds, 2013</p>
<p>之前的Ayers Rock的2D图像和这里的3D跑道之间的区别在于我们可以在我们想要的任意位置看这个跑道。</p>
<p>iOS概念游戏 赛道 (另外视角), Timothy J. Reynolds, 2013<br>为了在你的屏幕（一个2D平面）上显示跑道，我们需要一个特定的视点（viewpoint）然后从那一点将3D几何体投影到2D中。</p>
<p>从3D向2D的变换叫做投影<br>这是我们得到一个特定2D图片的方法。</p>
<p>但是我们可以使用一个小技巧来在2D中显示3D几何体的体积特征——我们可以制作一个动画，将我们的视点设置为绕物体旋转（或者固定视点，旋转物体，如下图所示）</p>
<p>旅行车, Timothy J. Reynolds, 2013<br>耶！我们真的看到了3D，不需要3D眼镜！</p>
<p>栅格图像<br>这只是热身。向量暂告一段落，我们继续看看栅格图像如何处理2D和3D。<br>在2D栅格图像中，图片被分为若干行列的小方格，这些小方格大小相等。</p>
<p>Turbo Esprit Sprite, Matej ‘Retro’ Jan, 2014<br>每个单元被称作一个像素（来自图片的元素）。除了网格中的2D坐标（x，y）它的主要性质还有那个坐标的颜色。</p>
<p>我们已经见过低多边形向量方法如何使用易于辨认的大多边形。如果我们在栅格图像中也这样做（使用明显的大像素）我们得到了像素艺术。</p>
<p>Tribute (修正版), Matej ‘Retro’ Jan, 2005, 2012<br>对于2D像素图片来说，尽管它们想要表示三维物体（一个Lotus Esprit 或者一个X-wing），但是它们被直接画到了2D像素网格上。你不能像前面旋转3D向量小汽车那样旋转这张图片。同样，文章开始的那张Ayers Rock图片也不能被旋转。尽管是由多边形构成的，它们没有被放置在3D空间内，而是直接被放在2D中。</p>
<p>目前我们已经介绍完了2D和3D向量图像以及2D栅格图像。最后我们介绍3D栅格图像。</p>
<p>即将介绍激动人心的东西！<br>在3D栅格图像中，体积被均匀分到行和列中，覆盖了全部三个不同的方向（上下，左右，里外）。这样3D空间被分为许多小立方体，称为体素（体积元素或者体积像素）。每个体素由一个3D坐标和位于该坐标的颜色定义。</p>
<p>和像素艺术（指的是精心安排像素位置的艺术）一样，我们现在有了体素艺术，其中每个小方块都需仔细安排。</p>
<p>星球大战场景, Sir Carma, 2015<br>太像乐高了，你不这么认为吗？<br>注意由于我们在3D场景中，我们可以从各种方向观察体素。这是从另一个角度看Tatooine的体素。</p>
<p>星球大战场景 (从另一视点观测), Sir Carma, 2015</p>
<p>我们甚至可以做动画！这是Sir Carma的动画体素角色中的一个例子：</p>
<p>骑士快跑（Knight Run）, Sir Carma, 2015<br>将它和2D像素艺术角色作比较：</p>
<p>最后元素（Last Element）中的精灵, Glauber Kotaki, 2015<br>你可以看出在体素艺术中，动画是如何改变小方块——也就是体素——的外表（颜色）的，以及在像素艺术中颜色的改变是如何发生在小方块——像素上的。<br>现在你知道了像素和体素之间的差别（以及更多……哈哈，对于这一点很抱歉）。<br>但是还没完。瞧，我之所以解释向量/栅格，以及2D/3D是因为在现代显示设备上，每种图像类型最后都会被显示为2D栅格图片。</p>
<p>我们在一本像素艺术杂志中提及这个的原因是我们可以使用这类变换来创造出现代像素艺术的风格，此风格使用非像素艺术象限中的艺术资源。<br>“我可以使用体素或3D模型制作像素图像？”你觉得呢？没错就是这样！巧妙地运用着色和渲染技术可以使我们创造出独特的视觉风格，将像素艺术带入到未来。<br>向量的显示和投影<br>上面的图示并不全部正确。有一种直接显示2D向量图像的方法，它使用了一个小技巧。</p>
<p>一张2D向量图像只能直接显示在一个向量显示器上，和Atari的街机游戏太空射击使用的那些一样。</p>
<p>太空射击, Atari, 1979<br>这是它实际看上去的样子（示波器上显示的是一款类似于太空射击的游戏）</p>
<p>太空岩石(游戏), Autopilot, 见 Wikimedia Commons [CC BY-SA 3.0]<br>我们还可以这样显示3D向量图像（通常被称为3D模型）。<br>与之前提到的一样，3D模型首先需要被投影到两个维度上，产生一张可以显示在向量显示器上的2D向量图像。</p>
<p>VEC9, Andrew Reitano &amp; Todd Bailey, 2013<br>我极度推荐观看VEC9宣传片以及80年代的硬汉片：<br><a href="https://youtu.be/rSPixmsLfn4" target="_blank" rel="noopener">https://youtu.be/rSPixmsLfn4</a></p>
<p>VEC9, Andrew Reitano &amp; Todd Bailey, 2013</p>
<p>栅格化处理<br>如今你很难在博物馆以外的地方找到一个向量显示器。相反，我们使用像素进行显示！</p>
<p>RGB LCD, Luís Flávio Loureiro dos Santos, 见 Wikimedia Commons [CC BY 3.0]<br>一个现代LCD显示器通过开启和关闭（或半开半关）小的红绿蓝LCD（液晶显示器）创造出不同的颜色。以免你有疑问，CRT（阴极射线管）原理类似，只不过它们使用三种荧光体进行搭配以便电子束撞击的时候产生红绿蓝三种颜色。</p>
<p>CRT 荧光点, 见 Wikipedia [CC-SA]</p>
<p>那么我们该如何将一张向量图片显示在一个栅格显示器上呢？嗯，从2D向量图片到2D栅格图片，图片需要被渲染或者被栅格化处理。每个多边形（通常一个三角形）被渲染为网格中的一个像素。</p>
<p>使用抽样法进行栅格化处理, Making WebGL Dance的一张幻灯片, Steven Wittens, 2013</p>
<p>这可以被拓展到在栅格显示器上渲染3D模型。首先，3D三角形被投影为2D三角形。然后2D向量三角形被栅格化处理为像素。</p>
<p>星际火狐, Nintendo, 1993</p>
<p>三角化<br>那么体素呢？现在体素艺术使用的最常见方法是将每个体素表示为一个3D向量方块，为此我们可以创建一个沿体素方块边缘摆放三角形的3D模型</p>
<p>世界上最激动人心的3D模型, Matej ‘Retro’ Jan, 2016</p>
<p>和之前一样，3D三角形接着被投影到2D图像空间中最后被栅格化处理来显示一张2D栅格图像。</p>
<p>旋转的方块 (技术演示), Matej ‘Retro’ Jan, 2016<br>这是我们现在得到最常见的体素艺术风格的方法，几乎完全使用免费建模工具MagicaVoxel完成。</p>
<p>长发公主的塔（Rapunzel tower）, Thibault Simar, 2016</p>
<p>无题, Argo San, 2016</p>
<p>口袋妖怪的体素, Playiku, 2016</p>
<p>猫咪 vs 体素, Stefan Smiljkovic, 2016</p>
<p>战壕奔跑（Trench Run）, Gabriel de Laubier, 2015</p>
<p>体素气球, Gabriel de Laubier, 2015</p>
<p>空中追击, Sir Carma, 2015</p>
<p>塔拉克村庄（Talaak village）, Sir Carma, 2016</p>
<p>Latica悬崖, Sir Carma, 2015</p>
<p>光线投射<br>其实我们可以不采用立方体方法。每个体素都可以被认为是3D空间中的一个点，那个位置的一个blob（二进制大对象）体积。你可以通过在2D空间中的一个位置放置一个（或多个）像素来直接在2D空间中画出每个体素。或者相反——你可以选择屏幕中的一个像素然后找出场景中出现在那个位置的体素。</p>
<p>该逆向方法被称为光线投射。你可以从视点向场景内投射一束光线然后找出击中的体素。事实上，你可以射出多个射线来扫过全部的视界。</p>
<p>使用鱼眼矫正的简单光线投射, Kieff, 见 Wikimedia Commons [public domain]</p>
<p>这个技巧被首次使用在德军司令部中，其中它的体素全部是房间中的小方块，所以这只是另一种将体素作为小方块进行渲染的方法。不过它的速度很快，因为你只需将一整列的像素投射到屏幕中。这本质上是一个2D过程，也就是为什么我们有时将这类3D图像称为2.5D（某种程度上讲第三个维度是假的，因为它是沿着突出的2D平面的）。</p>
<p>德军司令部, id Software, 1992</p>
<p>不过通常我们不认为Wolfenstein使用了体素。我们必须让单元足够小并让它们有不同的高度。于是到了90年代我们有了经典体素图像引擎。</p>
<p>超级科曼奇, NovaLogic, 1992</p>
<p>一开始体素只被用于地形制作。它们必须简化物体使得全部的体积信息只有存储在2D图像（又被称为高度贴图）中的地形高度。</p>
<p>一个高度贴图（左）告诉我们体素的垂直高度有多少（黑代表低，白代表高）</p>
<p>将体素信息限制在高度贴图中意味着不能有类似于突出的悬崖的东西。但是已经很好了，地形含有的的细节数量是所有之前游戏不能企及的。</p>
<p>三角洲特种部队, NovaLogic, 1998</p>
<p>时空英豪, Appeal, 1999</p>
<p>体素的结束<br>光线投影不是90年代的游戏渲染体素信息所用的唯一方法。其它的方法各有优势，例如支持可以毁坏的地形或者可以渲染汽车或者人物。这些在当时都是最先进的方法了！讽刺的是，这种富有创造的多样性也预示着这项技术迎来迟暮。</p>
<p>万杰赛车, K-D Lab, 1998<br>问题是，直到2000年底图形加速卡诞生了。这些硬件专门处理投影和栅格化3D多边形（现在我们管这些芯片叫做图像处理单元或GPU）。它们渲染三角形的速度飞快，不过这也是它们所能做的全部工作了。自定义体素渲染算法，包括光线投射，在它们的能力之外。</p>
<p>Hexplore, Doki Denki Studio, 1998<br>体素引擎继续在CPU（中央处理单元）上实现，但是CPU另外还要接管剩余的工作，包括物理模拟，游戏流程和人工智能。在GPU上处理图像的主要原因是将渲染放在一张单独的芯片上完成，提高渲染速度的同时还给予了CPU更多的空间做更复杂的模拟。体素引擎跟不上多边形图像的性能所以死翘翘了……</p>
<p>……直到大约十年后有一款游戏将它们带到了一个新的受欢迎程度。它摒弃了旧的方法，为“将体素作为小方块”方法铺平了道路。现在这可以有效地使用GPU进行渲染而其它的皆成为历史。</p>
<p>我的世界, Mojang, 2009–今</p>
<p>定义<br>我们总结一下我们学到的内容，然后使用一点数学知识回答一开始的关于什么是像素和体素的问题。</p>
<p>一个像素是将2D空间分割为离散的，均匀的（大小相同的）区域时得到的最小单位。</p>
<p>每个像素可以使用一个两个分量均为整数的向量来表示。这是为什么像素空间是离散的，而不是像连续的向量图像那样每个坐标都是一个实数（使用浮点数表示）。</p>
<p>相似地，一个体素是将3D空间分割为离散的，均匀的区域时得到的最小单位。<br>这下你明白了。</p>
<p>我说完了吗？还没有，我还没说完。</p>
<p>被定义得如此宽泛，像素和体素可以以许多不同的方式出现，而我们可以创造性地将概念以各种形式表达出来。尤其，我们考虑综合了4象限的栅格/向量，2D/3D。</p>
<p>纯2D图像</p>
<p>在早些时候如果你想将2D 精灵（sprite）画到屏幕上你必须将一块储存精灵颜色的内存直接复制到另一块储存屏幕显示颜色的内存中（这个复制过程也被称为位块转换，或者叫bit BLT）。如今几乎没人单纯使用这种方法进行2D渲染了。幻想主机PICO-8作为现代的范本向过去那个位块转移作为唯一方法的时代致敬。</p>
<p>PICO-8, Lexallofle Games (以及各自特征小车的作者), 2014–今</p>
<p>3D图像中的纹理</p>
<p>如今大多图像引擎在基础层次使用向量，因为GPU就是这样工作的。在这个系统中使2D图像出现在屏幕上的主要方法是使用一种叫做纹理映射的方法将它们画在多边形上。</p>
<p>纹理是2D栅格图片，可以被放置在（或被映射到）3D多边形上。</p>
<p>这是大多数3D视频游戏（广泛上讲还有3D图像）在制作中所采用的最简单的方法。</p>
<p>例如，这是一个高多边形的3D模型，我们加入一张高分辨率的纹理：</p>
<p>镜之边缘：催化剂  Keyart, Per Haagensen, 2016</p>
<p>由于我们使用平滑的多边形着色和纹理映射我们甚至不需要那么多的三角形来创造出人物好看的外表。这是一个低多边形3D模型外加一个高分辨率的纹理。</p>
<p>低多边形的工匠, Mark Henriksen, 2015<br>当我们也将高分辨率纹理转换为低分辨率时，我们得到了类似于下面这个低多边形3D模型和一个像素艺术纹理：</p>
<p>漂移阶段, 2014–今 (正在制作中)<br>这个情况最出色的例子当然是我的世界了。尽管我的世界的块根据定义是体素（它们是游戏中最小的离散体积单位），但是它们以各种低多边形模型和像素艺术纹理代表的类型出现。尽管它们是一个个的小块，它们中的许多都不是简单的立方体。</p>
<p>我的世界, Mojang, 2009–今</p>
<p>这样所有的3D模型情况就都讲完了（高多边形3D模型和低分辨率纹理的组合并不是很常见，但是如果错了请纠正我）</p>
<p>镜之边缘(左上), 马克思佩恩(左下) 和我的世界 (右下)</p>
<p>2D图像中的纹理</p>
<p>回到2D！当我们将纹理投影应用到2D矩形上时，我们得到了现在常见的2D游戏。使用当今的硬件，每张2D图像（在这种情况下常被称为精灵）被放在一个由两个三角形组成的矩形中进行显示。两个三角形（加起来也被称为一个四边形）通过映射到它们上面的精灵进行渲染，使得图像出现在正确的位置。</p>
<p>人物图像的一部分(左) 被纹理映射到动画四边形中(右)。羽毛球, Matej ‘Retro’ Jan, 2006</p>
<p>高分辨率图像就很直接了……</p>
<p>时空幻境, Number None, 2008</p>
<p>地狱边境, Playdead, 2010<br>……但是低分辨率，像素艺术纹理就稍微复杂一些了。它完全取决于我们采用什么显示分辨率来渲染精灵。</p>
<p>时空幻境(左上), 通往天空的路(右上), 王国(右下)</p>
<p>我们已经见识到了可以将像素艺术纹理应用到一个低多边形3D模型上，但是仍使用高分辨率进行渲染。考虑一下我的世界。低多边形模型，低分辨率16x16像素纹理，放在一个显示分辨率为1920x1080的场景中。</p>
<p>我的世界, Mojang, 2009–今</p>
<p>同样2D多边形也可以这样做。我们使用一张像素艺术图片，将它放在一个2D四边形上，然后将它渲染到高分辨率屏幕上，这样一来源图像中的每个像素都包含了显示中的多个像素。</p>
<p>迈阿密热线, Dennaton Games, 2012</p>
<p>我们将此风格称为大像素艺术风格。每个精灵像素按照大于显示像素进行渲染，以便它在图像中作为一个大方块出现。</p>
<p>每个源精灵像素被渲染为3x3显示像素， 登月者, Ben Porter, 2011–今 （正在制作中)</p>
<p>大像素风格在精灵被旋转或倾斜时变得明显：</p>
<p>通往天空的路, Johannes ‘Dek’ Märtterer, 2011–今 (正在制作中)</p>
<p>看看上图中的树叶，然后将它和低分辨率渲染下的旋转精灵进行对比。</p>
<p>王国, Noio &amp; Licorice, 2015</p>
<p>你看到水轮的像素是如何水平/垂直排列开来的，而在通往天空的路中树叶，小鸟，和桥梁的大像素都被调整了角度和做了变换吗？</p>
<p>王国在低分辨率下渲染整个游戏然后只将结果图像放大（调大尺度）到显示分辨率。另一方面，通往天空的路，迈阿密热线和登月者直接将精灵渲染到高分辨率显示。</p>
<p>回到3D<br>王国是一款2D游戏，但是它所采用的方法也能放到3D中。</p>
<p>我们可以使用像素艺术纹理的3D模型，但是在低分辨率中渲染它们，我们得到如下：</p>
<p>像素艺术学院技术演示, Matej ‘Retro’ Jan, 2016<br>你会发现我们正确地得到了带有投射阴影的3D着色。尽管结果看上去像2D像素艺术，但它实际上是一个使用像素艺术纹理在低分辨率下进行渲染得到的3D场景。</p>
<p>像素艺术学院技术演示 (场景视觉), Matej ‘Retro’ Jan, 2016</p>
<p>基于向量（使用骨骼绑定）的动画也可以利用这个优势。这是它们在大像素风格中的样子：</p>
<p>动画绑定, Matej ‘Retro’ Jan, 2016</p>
<p>但是当在低分辨率下渲染时，它们显得更像像素艺术，排成一列的像素和上面的王国相似。</p>
<p>像素艺术学院动画测试, Matej ‘Retro’ Jan, 2016</p>
<p>这和手绘的、一帧一帧的动画相差甚远，但是具有一定的美感，让人想起了90年代的rotoscope（动态遮罩）动画。</p>
<p>波斯王子, Jordan Mechner, 1989</p>
<p>3D效果<br>回到高分辨率，一个充分利用3D优势的游戏是Odd Tales的Last Night</p>
<p>最后一夜中的WIP场景, Tim Soret, 2016</p>
<p>这样他们构建了一个可以从不同角度观察的三维世界。</p>
<p>最后一夜中的3D场景构建, Tim Soret, 2016</p>
<p>另一个动态3D光照的例子是拥有优秀场景但是命运不佳的游戏致命快递。</p>
<p>致命快递, Maksym Pashanin, 2013–2014 (未发布)</p>
<p>虽然美术资源仍是2D的，但是它们还包括了从多个方向的着色的图片。这些是使用类似于Sprite Lamp这样的工具进行处理的，并且任何位置的光源都会产生精灵的平滑照明。</p>
<p>来自于体素的像素艺术<br>以上方法的问题在于只有精灵的着色可以准确完成，而它们投射的阴影缺少所需的3D几何因此不能正确生成。为此你还是需要体积信息。又到体素了！</p>
<p>这种方法一个很棒的例子是最近宣布的Pathway：</p>
<p>道路（Pathway）, Robotality, 2016 (正在制作中)</p>
<p>图像看上去完全像是在使用像素艺术精灵，但是其背后的信息却是体积的。和90年代试图看上去更现代和更现实的体素引擎不同，Robotality的开发者最多只将体素和显示像素的大小相匹配。这制造了一个巧妙的伪装，使它看上去像像素艺术，但是实际上它们拥有所有的3D信息来创造出完全正确的动态光照。</p>
<p>不过使用体素几何产生像素艺术并不完全是个新方法。之前FEZ使用了被其称之为三像素（3d 像素）的方法。三像素就是被综合为16x16x16方格（3d方格）的体素。</p>
<p>FEZ的游戏开发截图, Polytron, 2007</p>
<p>当一个FEZ场景在游戏中被渲染时我们基本上看到的是一个2D正交投影，这样他们既达到了传统像素艺术的外观又加入了FEZ标志性的视角旋转功能。</p>
<p>FEZ GDC ’09年宣传片, Polytron Corporation, 2009</p>
<p>FEZ, Polytron Corporation, 2012</p>
<p>纯体素<br>最终，由于我们绕了一大圈终于回到了体素几何上，我们可以完全不管像素，仅在3D空间中渲染纯离散体素（使用不带任何纹理的立方体方法）。</p>
<p>Lexallofle’s Voxatron 是这个空间内的游戏名字.</p>
<p>Voxatron, Lexallofle Games, 2010–今(正在制作中)</p>
<p>你注意到Lexallofle虚拟主机中的一个主题了吗？Pico-8有一个纯2D图像引擎而Voxatron则有一个3D体素的。它们是完美的搭档。</p>
<p>Voxatron, Lexallofle Games, 2010–今 (正在制作中)<br>Voxatron是少数几个（如果不是唯一的话）真正使用3D空间的纯离散分割的游戏。但是与之相似的大像素风格却应用于许多游戏中，尤其在移动设备中。</p>
<p>天天过马路, Hipster Whale, 2014</p>
<p>Shooty Skies, Mighty Games, 2016</p>
<p>吃豆人256, Hipster Whale, 2015<br>我们绕了一整圈回到了Sir Carma。在成为最著名的体素艺术师后，他现在在使用Unity将仅含体素的美学推向更高的高度，得到各种视觉效果，和Odd Tales对于像素艺术做出的贡献一样。</p>
<p>返回之路, Sir Carma, 2016 (正在制作中)</p>
<p>返回之路, Sir Carma, 2016 (正在制作中)<br>有人知道Voxel Zelda/Atic Atac吗?</p>
<p>返回之路, Sir Carma, 2016 (正在制作中)<br>好了，我们介绍了2D/3D/栅格/向量/低分辨率/高分辨所有我能想到的组合。我确定我忘记了一些内容，但是我更确定未来会有更多有趣的方法，但是目前这样就不错了。</p>
<p>我希望你们阅读愉快——为我们一路到尾欢呼！我希望你更深刻地了解了像素和体素图像，以及对它们下一步如何发展有了一些创造性的想法。想要更多有关像素艺术特征的信息你可以在Tumblr，Twitter，和Facebook上关注Retronator。每天都有新发现哦！<br>—Retro</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/10/04/assetSplit-dynamicLoad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/04/assetSplit-dynamicLoad/" class="post-title-link" itemprop="url">大规模场景的资源拆分合动态加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-04 20:31:13" itemprop="dateCreated datePublished" datetime="2017-10-04T20:31:13+08:00">2017-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/10/04/assetSplit-dynamicLoad/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/10/04/assetSplit-dynamicLoad/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ul>
<li><strong><em>资源拆分</em></strong>    <ul>
<li>地形，地表</li>
</ul>
</li>
<li><strong><em>动态加载/卸载</em></strong></li>
<li><strong><em>打包策略</em></strong><h1 id="资源拆分"><a href="#资源拆分" class="headerlink" title="资源拆分"></a>资源拆分</h1></li>
<li>地形资源拆分<ul>
<li>Unity原始地形有网格尺寸的限制（4096）</li>
<li>Mesh地形有面片数限制</li>
<li>降低内存占用，仅需载入部分地形数据</li>
<li>降低渲染面片数，视域体剔除</li>
<li>制作大规模地形<ul>
<li>Terrain Composer 2</li>
<li>T4M</li>
<li>建模软件…</li>
</ul>
</li>
<li>拆分现有地形<ul>
<li>Terrain Slicing &amp; Dynamic Loading Kit</li>
<li>地形数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th>filed</th>
<th style="text-align:center">meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>basemapDistance</td>
<td style="text-align:center">Heightmap patches beyond basemap distance will use a preomputed low res basemap.</td>
</tr>
<tr>
<td>castShadows</td>
<td style="text-align:center">Should terrain cast shadows?</td>
</tr>
<tr>
<td>ollectDetailPatches</td>
<td style="text-align:center">Collect Detail patches from memory.</td>
</tr>
<tr>
<td>detailObjectDensity</td>
<td style="text-align:center">Density of detail objects.</td>
</tr>
<tr>
<td>detailObjectDistance</td>
<td style="text-align:center">Detail objets will be displayed up to this distance.</td>
</tr>
<tr>
<td>heightmapMaxmumLOD</td>
<td style="text-align:center">Lets you essentially lower the heightmap resolution used for rendering.</td>
</tr>
<tr>
<td>heightmapPixelError</td>
<td style="text-align:center">An approximation of how many pixels the terrain will pop in the worst case when switching lod.</td>
</tr>
<tr>
<td>lightmapindex</td>
<td style="text-align:center">The index of the lightmap applied to this renderer.</td>
</tr>
<tr>
<td>terrainData</td>
<td style="text-align:center">The Terrain Data that stres htightmaps,terrain textures,detail meshes and trees.</td>
</tr>
<tr>
<td>treeBillboardDistance</td>
<td style="text-align:center">Distance from the camera where trees will be rendered as billboards only.</td>
</tr>
<tr>
<td>terrCrossFadeLength</td>
<td style="text-align:center">Total distance delta that trees will use to transition from billboard orientation to to mesh orientation.</td>
</tr>
<tr>
<td>treeDistance</td>
<td style="text-align:center">The maximum distance at which trees are rendered.</td>
</tr>
<tr>
<td>treeMaximumFullLODCount</td>
<td style="text-align:center">Maximum number of trees rendered at full LOD.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Lightmap<ul>
<li>拆分后重新烘培</li>
<li>切分烘培好的Lightmap<ul>
<li>exr 格式，FreeImage</li>
</ul>
</li>
</ul>
</li>
<li>切割跨地形的大模型</li>
<li>按地形块分组<h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1></li>
<li><p>关键在于：流畅</p>
<ul>
<li>卡顿分析</li>
<li>Instantiate 前自动加载未加载的引用资源<ul>
<li>Shader(Fallback)</li>
<li>Texture</li>
<li>Mesh</li>
<li>AnimationClip</li>
</ul>
</li>
<li>预加载资源<ul>
<li>Shader(Fallback)</li>
<li>Texture</li>
</ul>
</li>
<li>预加载资源异步加载<ul>
<li>Resources.LoadAsync</li>
<li>AssetBundle.LoadAsync</li>
</ul>
</li>
<li>实例化引起的序列化操作(Loading.LoadFileHeaders)<ul>
<li>避免一次性实例化过多的粒子系统（预加载）</li>
<li>避免层级复杂，组件Awake过多</li>
<li>尝试拆分Prefab，流失Instantiate</li>
</ul>
</li>
<li>加载策略(Assetbundle)<ul>
<li>Shared包常驻内存<ul>
<li>大纹理等资源采用LoadFromCacheOrDownload</li>
<li>Material/Mesh等可采用new WWW</li>
</ul>
</li>
</ul>
</li>
<li>卸载策略（AssetBundle）<ul>
<li>Prefab 包<ul>
<li>GameObject可通过Destroy来销毁</li>
<li>TerrainData,Object等可通过Resources.UnloadAsset来进行卸载</li>
</ul>
</li>
<li>Shared包<ul>
<li>建议在确认不适用或切换场景时进行卸载</li>
<li>切换场景时调用UnloadUnusedAssets来卸载Texture，Mesh等加载的共享资源</li>
</ul>
</li>
</ul>
</li>
<li>注意事项<ul>
<li>加载方式<ul>
<li>九宫格<ul>
<li>适用于非自由视角</li>
</ul>
</li>
<li>建立缓冲池，防止反复实例化。</li>
<li>Load vs LoadAsync</li>
<li>进场景预加载，推荐Load</li>
<li>游戏中，推荐LoadAsync</li>
</ul>
</li>
<li>Lightmap动态加载<ul>
<li>LightmapSettings</li>
<li>lightmapindex/lightmapScaleOffset</li>
<li>Shader Stripping</li>
</ul>
</li>
<li>Terrain动态加载<ul>
<li>Lightmapld</li>
<li>Terrain.SetNeighbors</li>
</ul>
</li>
<li>动态 Static Batching (StaticBatchingUtility)<ul>
<li>运行时CPU/堆内存开销较大</li>
<li>优先推荐手动拼合</li>
<li>推荐分组拼合</li>
</ul>
</li>
<li>防止资源泄露<ul>
<li>运行时创建<ul>
<li>new Material,Mesh</li>
<li>Material set</li>
</ul>
</li>
<li>AssetBundle重复加载<ul>
<li>共享资源<ul>
<li>Texture,Mesh,Font</li>
<li>Prefab</li>
</ul>
</li>
</ul>
</li>
<li>隐形资源<ul>
<li>TerrainData/AlphaMap<h1 id="打包策略"><a href="#打包策略" class="headerlink" title="打包策略"></a>打包策略</h1></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>地形资源</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">Object</span>&gt; groundObjs = <span class="keyword">new</span> List&lt;<span class="built_in">Object</span>&gt;();</span><br><span class="line">groundObjs.AddRange(Resources.LoadAll(BundleConfig.GroundObjectsPath, <span class="keyword">typeof</span>(Texture2D)));</span><br><span class="line">groundObjs.AddRange(Resources.LoadAll(BundleConfig.GroundObjectsPath, <span class="keyword">typeof</span>(GameObject)));</span><br><span class="line"></span><br><span class="line">BuildPipeline.PushAssetDependencies();</span><br></pre></td></tr></table></figure>
</li>
<li><p>地表资源</p>
<ul>
<li>复杂资源拆分<ul>
<li>“流失”实例化</li>
</ul>
</li>
<li>按地形块分组打包</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/10/03/lightmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/03/lightmap/" class="post-title-link" itemprop="url">光照贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-03 16:28:04" itemprop="dateCreated datePublished" datetime="2017-10-03T16:28:04+08:00">2017-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/theGIbook/" itemprop="url" rel="index"><span itemprop="name">theGIbook</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/10/03/lightmap/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/10/03/lightmap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在很多情况下，我们为了提高渲染效率，一般都会让美术同学在制作场景时，设置场景相关节点的lightmap static属性，提前给整个场景烘培出静态的光照贴图lightmap，烘培的数据保存在场景目录下的LightmapSnapshot文件中，主要包括的数据有：<br>lightmaps：烘培出的光照贴图数组；<br>gameobject uid：被烘焙的gameobject的唯一标识；<br>renderer的lightmapIndex：被烘培的gameobject的renderer组件所指向的光照贴图用于采样的区域坐标和宽高。<br>这个文件目前没有相关api读写，如果你想烘培完场景之后，把场景里面的gameobject抽出来做prefab，等切换玩场景之后再用于动态加载是不可行的，因为抽出来的prefab咋Instantiate之后将会是一个新的gameobject，uid自然和LightmapSnapshot文件里面记录的不一样，导致找不到对应的光照数据而造成模式没光照变暗或渲染错乱。<br>还有一种比较常见的需求是，在游戏运行时，通过更换光照贴图数据，营造场景在不同时间或季节的光照氛围，例如白天和黑夜。</p>
<p>由于漫反射表面的颜色可以由单个RGB颜色值描述，其记载的是辐射照度值，如果光源和整个场景是静态的，则这个辐射照度值为一个常数，因此可以被预存起来，我们称记录辐射照度值的纹理为一个辐射照度贴图（irradiance maps）或光照贴图（light maps），由于光照传输是线性的，因此其它动态光源所形成的光照可以在这个辐射照度值上进行累加。光照贴图仍然是先阶段实时渲染中漫反射间接光照的主流解决方案[Unity,2017b,Unreal Engine 4,2018b,Iwanicki and Sloan,2017]，它最早被用于[Abrash,1997]中，光照贴图的概念如图11.31所示。<br><img src="/2017/10/03/lightmap/Lightmapped_Scene_with_Lightmap.png"><br><strong>图 11.31：</strong>一个简单的场景（左）及其光照贴图（右），由此可以看出光照贴图的分辨率很低，因此它通常用来存储间接光照（图片来自Wikipedia）</p>
<p>在像素着色器中，每个像素都需要读取光照贴图中的一个辐射照度值；而另一方面，漫反射表面的每个像素还存储了一个漫反射系数值，它也是一个常数值。直观上思考，我们希望将这两个值预乘起来，形成一个直接的出射辐射亮度值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/10/02/ABTheory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/02/ABTheory/" class="post-title-link" itemprop="url">AssetBundle管理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-02 15:04:40" itemprop="dateCreated datePublished" datetime="2017-10-02T15:04:40+08:00">2017-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/10/02/ABTheory/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/10/02/ABTheory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是AssetBundle"><a href="#什么是AssetBundle" class="headerlink" title="什么是AssetBundle"></a>什么是AssetBundle</h1><p>AssetBundle就像一个Zip压缩文件，里面存放着一些数据对象。它包含一些平台相关的运行时序列化对象。</p>
<p>Bundle之间也存在着依赖。AssetBundle带有三种压缩选项：不压缩，LZMA，LZ4。默认的就是LZMA，而BuildAssetBundleOptions.ChunkBasedCompression就是LZ4的压缩形式。另外我们有两种类型的Bundle，一种是我们场景的Bundle（*.unity打包的常务），另一种是松散的Bundle。</p>
<h1 id="WebExtract-amp-Binary2Text"><a href="#WebExtract-amp-Binary2Text" class="headerlink" title="WebExtract &amp; Binary2Text"></a>WebExtract &amp; Binary2Text</h1><p>AssetBundle对于大家来说会是一个黑盒子，其实在Unity的安装目录下（Data/Tools）有WebExtract &amp; Binary2Text这两个工具，可以帮你把AssetBundle这个黑盒子打开。例如：升级版本AssetBundle变大了，二次构建AssetBundle出现差异了，AssetBundle内到底包含了那些资源等。</p>
<p>对于构建出来的AssetBundle，我们先通过WebExtract来解开，这时候可以得到一个文件夹，里面包含一些文件。</p>
<pre><code>Usage: WebExtractor &lt;unitywebfile&gt;
</code></pre><h1 id="AssetBundle加载基础"><a href="#AssetBundle加载基础" class="headerlink" title="AssetBundle加载基础"></a>AssetBundle加载基础</h1><p>通过AssetBundle加载资源，分为两步，第一步获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细的描述。</p>
<h2 id="获取AssetBundle对象常用的API"><a href="#获取AssetBundle对象常用的API" class="headerlink" title="获取AssetBundle对象常用的API"></a>获取AssetBundle对象常用的API</h2><h3 id="直接获取AssetBundle"><a href="#直接获取AssetBundle" class="headerlink" title="直接获取AssetBundle:"></a>直接获取AssetBundle:</h3><ul>
<li>public static AssetBundle CreateFromFile(string path);<br>通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的创建方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中过去。</li>
<li>public static AssetBundleCreateRequest CreateFromMemory(byte[] binary);<br>通过Bundle的二进制数据，异步创建AssetBundle对象。完成后会在内存中创建较大的WebStream。调用时，Bundle的解压时异步进行的，因此对于未压缩的Bundle文件，该接口与CreateFromMemoryImmediate等价。</li>
<li>public static AssetBundle CreateFromMemoryImmediate(byte[] binary);<br>该接口是CreateFromMemory的同步版本。</li>
<li>注：5.3下分别改名为LoadFromFile,LoadFromMemory,LoadFromMemoryAsync并增加了LoadFromFileAsync，且机制也有一定的变化，可详见Unity官方文档。</li>
</ul>
<h2 id="从AssetBundle加载资源的常用API"><a href="#从AssetBundle加载资源的常用API" class="headerlink" title="从AssetBundle加载资源的常用API"></a>从AssetBundle加载资源的常用API</h2><ul>
<li>public ObjectLoad(string name, Type type);<br>通过给定的名字和资源类型，加载资源。加载时会自动在家其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。</li>
<li>public Object[] LoadAll(Type type);<br>一次性加载Bundle中给定资源类型的所有资源。</li>
<li><p>public AssetBundleRequest LoadAsync(string name, Type type);该接口是Load的异步版本。</p>
</li>
<li><p>注：5.x下分别改名为LoadAsset,LoadAllAssets,LoadAssetAsync，并增加了LoadAllAssetsAsync。</p>
</li>
</ul>
<h1 id="AssetBundle加载进阶"><a href="#AssetBundle加载进阶" class="headerlink" title="AssetBundle加载进阶"></a>AssetBundle加载进阶</h1><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>CreateFromFile只能适用于未压缩的AssetBundle,而Android系统下StreamingAssets是在压缩目录(.jar)中，因此需要先将未压缩的AssetBundle放到SD卡中国才能对其使用CreateFromFile。</li>
<li>iOS系统有256个开启文件的上限，因此，内存中通过CreateFromFile加载的AssetBundle对象也会低于该值。</li>
<li>CreateFromFile的调用会增加ResistenManager.Remapper的大小，而PersistentManager负责维护资源的持久化存储，Remapper保存的是加载到内存的资源HeapID与源数据FileID的映射关系，它是一个MemoryPool,其行为类似Mono堆内存，只增不减，因此需要对两个接口的使用做合理的规划。</li>
<li>对于存在依赖关系的Bundle包，在加载时主要注意顺序，举例来说，假设CanvasA在BundleA中，所依赖的AtlasB在BundleB中，为了确保资源正确引用，那么最晚创建BundleB的AssetBundle对象的时间点是在实例化CanvasA之前，即，创建BundleA的AssetBundle对象时，Load(“CanvasA”)时，BundleB的AssetBundle对象都可以不在内存中。<br><img src="/2017/10/02/ABTheory/dependbundle.png"></li>
<li>根据经验，建议AssetBundle文件的大小不超过1MB，因为在普遍情况下Bundle的加载时间与其大小并非呈线性关系，过大的Bundle可能引起较大的加载开销。</li>
<li>由于WWW对象的加载是异步的，因此逐个加载容易出现下图中CPU空间的情况（选中帧处Vsync占了大部分）此时建议适当的同时加载多个对象，以增加CPU的使用率，同时加快加载的完成。<br><img src="/2017/10/02/ABTheory/dependbundle.png"></li>
</ul>
<h1 id="AssetBundle卸载"><a href="#AssetBundle卸载" class="headerlink" title="AssetBundle卸载"></a>AssetBundle卸载</h1><p>前文提到了通过AssetBundle加载资源时的内存分配情况，下面，我们结合常用的API介绍如何将已分配的内存进行卸载，最终达到清空所有相关内存的目的。</p>
<h2 id="一·内存分析"><a href="#一·内存分析" class="headerlink" title="一·内存分析"></a>一·内存分析</h2><p><img src="/2017/10/02/ABTheory/dependbundle.png"></p>
<p>在上图中的右侧，我们列出了各种内存物件的卸载方式：</p>
<ul>
<li>场景物件(GameObject):这类物件可通过Destroy函数进行卸载；</li>
<li>资源(包括Prefab):除了Prefab以外，资源文件可以通过三种方式来卸载<br>1）通过Resources.UnloadAsset卸载指定的资源，CPU开销小；<br>2）通过Resources.UnloadUnusedAssets一次性卸载所有未被引用的资源，CPU开销大；<br>3）通过Resources.Unload(true)在卸载AssetBundle对象时，将加载出来的资源一起卸载。<br>而对于Prefab,目前仅能通过DestroyImmediate来卸载，且卸载后，必须重新加载AssetBundle才能重新加载该Prefab。由于内存开销较小，通常不建议进行针对性的卸载。</li>
<li>WWW对象：调用对象的Dispose函数或将其置为null即可；</li>
<li>WebStream:在卸载WWW对象以及对应的AssetBundle对象后，这部分内存即会被引擎自动卸载；</li>
<li>SerializedFile:卸载AssetBundle后，这部分内存会被引擎自动卸载;</li>
<li>AssetBundle对象：AssetBundle的卸载方式有两种：<br>1）通过AssetBundle.Unload(false),卸载AssetBundle对象时保留内存中已加载的资源；<br>2)通过AssetBundle.Unload(true),卸载AssetBundle对象时卸载内存中已加载的资源，由于该方法容易引起资源引用丢失，因此并不建议经常使用；<h2 id="二·注意点"><a href="#二·注意点" class="headerlink" title="二·注意点"></a>二·注意点</h2>在通过AssetBundle.Unload(false)卸载AssetBundle对象后，如果重新创建该对象并加载之前加载过的资源的时候，会出现冗余，即两份相同的资源。</li>
</ul>
<p>被脚本静态变量引用的资源，在调用Resources.UnloadUnusedAssets时，并不会被卸载，在Profiler中能够看到其引用情况。</p>
<h1 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h1><p>通过以上的讲解，相信您对AssetBundle的加载和卸载有了明确的了解。下面，我们简单地做一下API选择上的推荐：</p>
<ul>
<li>对于加载完后即卸载的Bundle文件，则分两种情况：优先考虑速度（加载场景时）和优先考虑流畅度（游戏进行时）。<br>1）加载场景的情况下，需要注意的是避免WWW对象的逐个加载导致的CPU空间，可以考虑使用加载速度较快的WWW.LoadFromCacheOrDownload或AssetBundle.CreateFromFile，但需要避免后续大量地进行Load资源的操作，引起IO开销（可以尝试直接LoadAll）。<br>2）游戏进行的情况下，则需要避免使用同步操作引起卡顿，因此可以考虑使用new WWW配合AssetBundle.LoadAsync来进行平滑的资源加载，但需要注意的是，对于Shader，较大的Texture等资源，其初始化操作通常很耗时，容易引起卡顿，因此建议将这类资源在加载场景时进行预加载。</li>
<li>只在Bundle需要加密的情况下，考虑使用CreateFromMemory，因为该接口加载速度较慢。</li>
<li>尽量避免在游戏进行中调用Resources.UnloadUnusedAssets(),因为该接口开销较大，容易引起卡顿，可尝试使用Resources.Unload(obj)来逐个进行卸载，以保证游戏的流畅度。</li>
</ul>
<p><strong>需要说明的是，以上内存管理交适合于Unity5.3之前的版本。Unity引擎在5.3中对AssetBundle的内存占用进行了一定的调整，目前我们也在进一步的学习和研究中。</strong></p>
<p>原文链接：<a href="https://blog.uwa4d.com/archives/ABTheory.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/ABTheory.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/29/AI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/29/AI/" class="post-title-link" itemprop="url">AI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-29 19:44:39" itemprop="dateCreated datePublished" datetime="2017-09-29T19:44:39+08:00">2017-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/09/29/AI/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/09/29/AI/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ML（机器学习）与AI-人工智能）"><a href="#ML（机器学习）与AI-人工智能）" class="headerlink" title="ML（机器学习）与AI(人工智能）"></a>ML（机器学习）与AI(人工智能）</h1><p>首先来介绍下Machine Learning(机器学习，下文简称ML）和游戏Artificial Intelligence(人工智能，下文简称AI）间的关系。现存的大部分游戏AI都是手工源码，由大量决策树组成，有时会包含多达数千条规则。而且必须由手工维护和测试。而ML所依赖的算法可以自动从原始数据寻找规律，无需专家预先定义数据的解读方式。</p>
<p>以图片内容分类这个计算机视觉问题为例。直到几年前，专家们仍然通过手工编写过滤器，提取图像的有用特征，用于分辨某个图像中包含的是猫还是狗。而ML，特别是i最新的深度学习方法，仅需图像和类型标签，就可以自动学习有用的特征。我们相信这种自动化学习不仅可以扩展Unity平台的应用范围，例如用于ML场景模拟，还可以帮助所有开发者简化和加速游戏的开发过程。</p>
<p>这种自动化学习尤其可以应用于游戏代理（即NPC）的行为方面。我们可以使用Reinforcement Learning(增强学习，简称RL）来训练代理，预估某一环境中施行特定行为的价值。一旦训练完成，代理即可以最佳行为模式做出反应，无需通过程序对行为进行显示的编码。</p>
<h1 id="采用老虎机算法的增强学习"><a href="#采用老虎机算法的增强学习" class="headerlink" title="采用老虎机算法的增强学习"></a>采用老虎机算法的增强学习</h1><p>RL背后的一个核心概念是价值估计，并据此进行相应动作。在继续深入之前，最好先了解一些术语。</p>
<p>在RL中，实施动作的个体被称为agent(代理),它使用policy(策略)进行动作决策。一个代理通常嵌入一个environment中，并在任意给定的时刻都处于某个特定的state(状态).从哪个状态，它可以进行一系列actions(动作）。某个给定状态的value(值)指的是处于该状态的最终回报价值。在某个状态的value(值)指的是处于该状态的最终回报值。在某个状态执行一个动作可以让代理进入另一个新的状态，获得一个reward(回报),或者同事拥有两者。所有的RL代理都在尽可能最大化累计回报。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/29/Real-Time-Rendering-3rd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/29/Real-Time-Rendering-3rd/" class="post-title-link" itemprop="url">Real Time Rendering 3rd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-29 15:13:03" itemprop="dateCreated datePublished" datetime="2017-09-29T15:13:03+08:00">2017-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/09/29/Real-Time-Rendering-3rd/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/09/29/Real-Time-Rendering-3rd/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><img src="/2017/09/29/Real-Time-Rendering-3rd/overview.png" alt="overview"><br>url: www.realtimerendering.com</p>
<h1 id="The-Graphics-Rendering-Pipeline"><a href="#The-Graphics-Rendering-Pipeline" class="headerlink" title="The Graphics Rendering Pipeline"></a>The Graphics Rendering Pipeline</h1><p><img src="/2017/09/29/Real-Time-Rendering-3rd/tgrp.png"></p>
<h2 id="核心内容分节提炼"><a href="#核心内容分节提炼" class="headerlink" title="核心内容分节提炼"></a>核心内容分节提炼</h2><h3 id="图像渲染管线架构概述-Architecture"><a href="#图像渲染管线架构概述-Architecture" class="headerlink" title="图像渲染管线架构概述 Architecture"></a>图像渲染管线架构概述 Architecture</h3><p>渲染管线的主要功能就是决定在给虚拟相机，三维物体，光源，照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。</p>
<p><img src="/2017/09/29/Real-Time-Rendering-3rd/viewport.png"><br>上图，相机放在棱锥的顶端（四条线段的交汇点），只有可视体内部的图元会被渲染。<br>在概念上可以将图形渲染管线分为三个阶段：</p>
<ul>
<li>应用程序阶段（The Application Stage)</li>
<li>几何阶段(The Geometry Stage)</li>
<li>光栅化阶段(The Rasterizer Stage)</li>
</ul>
<p>绘制管线的基本结构包括3个阶段：应用程序，几何，光栅化。</p>
<p>几个要点：</p>
<ul>
<li>每个阶段本身也可能是一条管线，如图中的几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的光栅化阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。</li>
<li><p>最慢的管线阶段决定绘制速度，即图像的更新速度，这种速度一般用FPS表示，也就是帧率。</p>
<h3 id="应用程序阶段（The-Application-Stage）"><a href="#应用程序阶段（The-Application-Stage）" class="headerlink" title="应用程序阶段（The Application Stage）"></a>应用程序阶段（The Application Stage）</h3></li>
<li><p>应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件的基础上，因此要改变实现过程会非常困难。</p>
</li>
<li>正因应用程序阶段是软件方式实现，因此不能像集合和光栅化阶段那样继续分为诺干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在CPU设计商，称这种形式为超标量体系(superscalar)结构，因为它可以在同一个阶段同一个时间做不同的几件事情。</li>
<li>应用程序阶段通常实现的方法有碰撞检测，加速算法，输入检测，动画，力反馈以及纹理动画，变化仿真，几何变形，以及一些不在其他阶段执行的计算，如层次堆裁剪等加速算法就可以在这里实现。</li>
<li>应用程序阶段的主要任务：在应用程序阶段的末端，将需要在屏幕(具体形式取决于具体输入设备)显示出来绘制的几何体(也就是绘制图元,rendering primitives,如点，线，矩形等)输入到绘制管线的下一个阶段。</li>
<li>对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段-几何阶段。<h3 id="几何阶段-The-Geometry-Stage"><a href="#几何阶段-The-Geometry-Stage" class="headerlink" title="几何阶段 The Geometry Stage"></a>几何阶段 The Geometry Stage</h3></li>
</ul>
<p>几何阶段主要负责大部分多边形操作和顶点操作。</p>
<h1 id="GPU渲染管线和可编程着色器"><a href="#GPU渲染管线和可编程着色器" class="headerlink" title="GPU渲染管线和可编程着色器"></a>GPU渲染管线和可编程着色器</h1><h2 id="GPU渲染管线流程图"><a href="#GPU渲染管线流程图" class="headerlink" title="GPU渲染管线流程图"></a>GPU渲染管线流程图</h2><img src="/2017/09/29/Real-Time-Rendering-3rd/1.png"> <img src="/2017/09/29/Real-Time-Rendering-3rd/2.jpg"> 
<p>其中：</p>
<ul>
<li>绿色的阶段都是完全可以编程的。</li>
<li>黄色的阶段可配置，但不可编程。</li>
<li>蓝色的阶段完全固定。</li>
</ul>
<h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器（The Vertex Shader）是完全可编程的阶段，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器的必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。</p>
<h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>几何着色器（The Geometry Shader）位于顶点着色器之后，允许GPU高效的创建和销毁几何图元。几何着色器是可选的，完全可编程的阶段，主要对图元（点、线、三角形）的顶点进行操作。几何着色器接受顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化的其他处理后，会发送给片段着色器。<br>几何着色器可以改变信新传递进来的图元的拓扑结构，且几何着色器可以接受任何拓扑类型的图元，但是只能输出点、折线（line strip）和三角形条（triangle strips）。</p>
<h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p>裁剪（Clipping）属于可配置的功能阶段，在此阶段可选运行的裁剪方式，以及添加自定义的裁剪面。</p>
<h3 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h3><p>屏幕映射（Screen Mapping）、三角形设置（Triangle Setup）和三角形遍历（Triangle Traversal）阶段是固定功能阶段。</p>
<h3 id="像素着色器"><a href="#像素着色器" class="headerlink" title="像素着色器"></a>像素着色器</h3><p>像素着色器（Pixel Shader，Direct3D中的叫法）常常又称为片段着色器，片元着色器（Fragment Shader，OpenGL中的叫法），是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。<br>像素着色器常用来处理场景光照和与之相关的效果，如凹凸纹理映射和调色。称之为片段着色器似乎更加准确，因为对于着色器的调用和屏幕上的像素并非是一一对应的。比如，对于一个像素，片段着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。<br>需要注意，像素着色器通常在最终合并阶段设置片段颜色以进行合并，而深度值也可以由像素着色器修改。模版缓冲（stencil buffer）值是不是修改的，而是将其传递给合并阶段（Merge Stage）。在SM 2.0以及以上版本，像素着色器也可以丢弃（discard）传入的片段数据，即不产生输出。这样的操作会消耗性能，因为通常在这种情况下不能使用由GPU执行的优化。诸如雾计算和alpha测试的操作已经从合并操作转移到SM 4.0中的像素着色器里计算。<br>可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在Shader Model 4.0中，共有16个向量（每个向量含有4个值）可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出32个向量到像素着色器中。像素着色器的追加输入是Shader Model 3.0中引入的。例如，三角形的哪一面是可见的通过输入标志来假如的。这个值对于在单个通道中的正面和背面渲染不同材质十分重要。而且像素着色器也可以获得片段的屏幕位置。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并阶段（The Merger Stage）处于完全可编程和固定功能之间，尽管不能编程，但是高度可配置，可以进行一系列的啊哦做。其除了进行合并操作，还分管颜色修改（Color Modifying），Z缓冲（Z-Buffer），混合（Blend），模版（Stencil）和相关缓存的处理。</p>
<h2 id="可编程着色模型"><a href="#可编程着色模型" class="headerlink" title="可编程着色模型"></a>可编程着色模型</h2><ul>
<li>现代着色阶段（比如支持Shader Model 4.0，DirectX 10以及之后）使用了通用着色核心（common-shader core），这就表明顶点，片段，几何着色器共享一套编程模型。</li>
<li>早起的着色模型可以用汇编语言直接编程，但DX10之后，汇编就只在调试输出阶段可见，改用高级着色语言。</li>
<li>目前的着色语言都是C-like的着色语言，比如HLSL，CG和GLSL，其被编译成独立于机器的汇编语言，也称为中间语言（IL）。这些汇编语言在单独的阶段，通常实在驱动中，被转化成实际的机器语言。这样的安排可以兼容不同的硬件实现。这些汇编语言可以被看做是定义一个作为着色语言编译器的虚拟机。这个虚拟机是一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。</li>
<li><p>着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编译一系列指令的处理器。考虑到很多图形操作都使用短矢量（最高四位），处理器拥有4路SIMD（single-instruction multiple-data，单指令多数据）兼容性。每个寄存器包含四个独立的值。32位单精度浮点的标量和矢量是其基本数据类型；也随后支持32位整型。浮点矢量通常包含数据如位置（xyzw），法线，矩阵行，颜色（rgba），或者纹理坐标（uvwq）。而整型通常用来表示，计数器，索引，或者位掩码。也支持综合数据类型比如结构体，数组，和矩阵。而为了便于使用向量，向量操作如调和（swizzling，也就是向量分量和重新排序或复制），和屏蔽（masking，只是用指定的矢量元素），也能够支持。</p>
<img src="/2017/09/29/Real-Time-Rendering-3rd/3.jpg">
<p>上图为DX10下的通用Shader核心虚拟机架构以及寄存器布局。每个资源旁边显示最大可用编号。其中，用两个斜杠分开的三个数值，分别是顶点、几何、像素着色器对应的可用最大数量。</p>
</li>
<li><p>一个绘制调用（Draw Call）会调用图形API来绘制一系列的图元，会驱使图形管线的运行。</p>
</li>
<li>每个可编程着色阶段拥有两种类型的输入：<ul>
<li>uniform输入，在一个draw call中保持不变的值（但在不同draw call之间可以改变）</li>
<li>varying输入，shader里对每个顶点和像素的处理都不同的值。纹理是特殊的uniform输入，曾经一直是一张应用到表面的彩色图片，但现在可以认为是存储着大量数据的数组。</li>
</ul>
</li>
<li>在现代GPU上，图形运算中常见的运算操作执行速度非常快。通常情况下，最快的操作是标量和向量的乘法和加法，以及他们的组合，如乘加运算（multiply-add）和点乘（dot-product）运算。其它操作，比如倒数（reciprocal），平方根（square root），正弦（sine），余弦（cosine），指数（exponentiation），对数（logarithm）运算，往往会稍微更加昂贵，但依然相当快捷。纹理操作非常高效，但他们的性能可能受到诸如等待检索结果的时间等因素的限制。</li>
<li>着色语言表示出了大多数常见的操作（比如加法和乘法通过运算符+和*来表示）。其余的操作用固有的函数，比如atan()，dot()，log()等。更复杂的操作也存在内建函数，比如矢量归一化（vector normalization），反射（reflection）、叉乘（cross products）、矩阵的转置（matrix transpose）和行列式（determinant）等。</li>
<li>流控制（flow control）是指使用分支指令来改变代码执行流程的操作。这些指令用于实现高级语言结构，如“if”和“case”语句，以及各种类型的循环。Shader支持两种类型的流控制。静态流控制（Static flow control）是基于统一输入的值。这意味着代码的流在调用时是恒定的。静态流控制的主要好处是允许在不同的情况下使用相同的着色器（例如，不同数量的光源）。动态流控制（Dynamic flow control）基于不同的输入值。但动态流控制远比静态流量控制更强大但同时也需要更高的开销，特别是在调用shader之间，代码流不规律改变的时候。而评估一个shader的性能，是评估其在一段时间内处理顶点或像素的个数。如果流对某些元素选择“if”分支，而对其他元素选择“else”分支，这两个分支必须对所有元素进行评估（并且每个元素的未使用分支将被丢弃）。</li>
<li>Shader程序可以在程序加载或运行时离线编译。和任何编辑器一样，有生成不同输出文件和使用不同优先级别的选项。一个编译过的Shader作为字符串或者文本来存储，并通过驱动程序传递给GPU。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>SM 2.0/2.X</th>
<th>SM 3.0</th>
<th>SM 4.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>引入版本</td>
<td>DX 9.0,2002</td>
<td>DX 9.0c,2004</td>
<td>DX 10,2007</td>
</tr>
<tr>
<td>VS指令槽位</td>
<td>256</td>
<td>≥512</td>
<td>4096</td>
</tr>
<tr>
<td>VS最大执行步长</td>
<td>65536</td>
<td>65536</td>
<td>∞</td>
</tr>
<tr>
<td>PS指令槽位</td>
<td>≥96</td>
<td>≥512</td>
<td>≥65536</td>
</tr>
<tr>
<td>PS最大执行步长</td>
<td>≥96</td>
<td>65536</td>
<td>∞</td>
</tr>
<tr>
<td>临时寄存器</td>
<td>≥12</td>
<td>32</td>
<td>4096</td>
</tr>
<tr>
<td>VS常量寄存器</td>
<td>≥256</td>
<td>≥256</td>
<td>14×4096</td>
</tr>
<tr>
<td>PS常量寄存器</td>
<td>32</td>
<td>224</td>
<td>14×4096</td>
</tr>
<tr>
<td>流程控制，判断</td>
<td>Optional</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>VS纹理贴图</td>
<td>None</td>
<td>4</td>
<td>128×512</td>
</tr>
<tr>
<td>PS纹理贴图</td>
<td>16</td>
<td>16</td>
<td>128×512</td>
</tr>
<tr>
<td>整数支持</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>VS输入寄存器</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>插值寄存器</td>
<td>8</td>
<td>10</td>
<td>16/32</td>
</tr>
<tr>
<td>PS输出寄存器</td>
<td>4</td>
<td>4</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/26/Unity-Weather/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/26/Unity-Weather/" class="post-title-link" itemprop="url">Unity-Weather</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-26 06:58:54" itemprop="dateCreated datePublished" datetime="2017-09-26T06:58:54+08:00">2017-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/09/26/Unity-Weather/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/09/26/Unity-Weather/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>抄：<a href="https://zhuanlan.zhihu.com/p/29668925" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29668925</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/24/3的3D流水线处理流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/24/3的3D流水线处理流程/" class="post-title-link" itemprop="url">UE3的3D渲染流水线处理流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-24 10:56:00" itemprop="dateCreated datePublished" datetime="2017-09-24T10:56:00+08:00">2017-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/虚幻引擎/" itemprop="url" rel="index"><span itemprop="name">虚幻引擎</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/09/24/3的3D流水线处理流程/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/09/24/3的3D流水线处理流程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><p>3D渲染流水线也类似一个工厂的流水线，它的原材料是一系列的3D网格数据，最终产品就是显示在2D屏幕的3D场景。<br>3D渲染流水线的处理和照相机的原理很像，它们都同样是通过将3D世界的内容放置到2D平面上，通过2D的方式来展示3D世界，<br>顶点管线中有这么几个坐标空间：局部空间-&gt;世界空间-&gt;相机空间-&gt;投影空间-&gt;屏幕空间(视口空间),初始的网格数据是在局部空间中的，顶点管线将其从局部空间变换到屏幕空间作为输入供”像素管线”处理。比如局部空间内，一个人物的骨骼模型，它的中心点就是根骨骼的位置，在进行骨骼层次计算的时候，根谷歌放在中心位置是易于计算的，如果将其放置到世界空间中进行骨骼计算，那么根骨骼的位置不在原点且朝向也不为0，计算起来相当复杂。而世界空间中，易于描述场景中各个物体间的关系，易于作碰撞处理，伤害计算，顶点光照计算等。在相机空间中，容易描述被观察物体与观察者之间的关系，利用相机视锥体对物体进行裁剪，把观察不到的物体剔除掉。</p>
<p>VertexShader—顶点着色器是用来替换这个阶段中固定管线的定点变换及光照计算的，传统管线处理顶点及光照的方式都是固定流程的，所以固定管线下的3D程序特效都有很大的局限性，引入顶点着色器之后，顶点在空间中的变换以及光照处理都可以可编程化了。顶点着色器主要是用来改变顶点固定流程中的变换过程，所以使用顶点着色器表现出来的大多是几何外形的变化以及顶点的光照，纹理等数据的变化。</p>
<p>在UE3中，是不能直接编写Shader语言的，UE3中把所有的Shader特效都绑定到材质中，只能通过材质编辑器来间接的编辑顶点着色器和像素着色器内容。UE3中修改顶点着色器的方式也是在材质编辑器中进行的，其中比较典型的一个输入节点叫做WorldPositionOffset，它就是在顶点管道阶段对材质对应的网络物体顶点进行编辑的一个节点，对应到底层是修改了该材质对应的顶点着色器代码(通过HLSL按钮能够看到该材质对应的Shader代码</p>
<p>这个阶段会逐像素地处理该像素的纹理映射，光照颜色，alpha融合，深度测试，模板测试等，并且根据该像素的距离信息进行雾化公式的应用，所以，顾名思义，像素管道主要处理的是像素信息，最终输出像素最终的颜色。</p>
<p>传统的3D管线只能通过有限几个图形API接口来操作像素，比如DX中设置多纹理的一些接口以及Alpha融合的接口，能够操作的范围很有限。</p>
<p>像素着色器所替换固定流水线的功能就是在这个阶段，在引入像素着色器之后，就可以根据需要对像素做许多自由的处理，因为帧缓存内的像素信息不止包含该像素的颜色、Alpha值、深度信息和模版信息，还可以包含该像素对应的法线贴图信息、高光贴图信息、凹凸贴图信息等（这些贴图实际上保存的是一系列向量信息），通过传入一定的参数，比如时间信息、物理量等，就能制作出各种贴近现实的精美特效。</p>
<p>UE3中的像素着色器也是通过材质编辑器中的表达式来处理的，UE3材质编辑器中的大部分输入节点都是用于处理像素着色的，如图所示</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/24/UGUIvsNGUI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/24/UGUIvsNGUI/" class="post-title-link" itemprop="url">UGUI vs NGUI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-24 10:56:00" itemprop="dateCreated datePublished" datetime="2017-09-24T10:56:00+08:00">2017-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/09/24/UGUIvsNGUI/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/09/24/UGUIvsNGUI/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="table-container">
<table>
<thead>
<tr>
<th>Tables</th>
<th>NGUI</th>
<th>UGUI</th>
</tr>
</thead>
<tbody>
<tr>
<td>锚点</td>
<td>Anchor</td>
<td>RectTransform Anchor</td>
</tr>
<tr>
<td>图片</td>
<td>Sprite</td>
<td>Image</td>
</tr>
<tr>
<td>文字</td>
<td>Label</td>
<td>Text</td>
</tr>
<tr>
<td>根节点</td>
<td>UIRoot</td>
<td>Canvas</td>
</tr>
<tr>
<td>UI面板</td>
<td>Panel</td>
<td>Canvas</td>
</tr>
<tr>
<td>UI容器</td>
<td>Lets you essentially lower the heightmap resolution used for rendering.</td>
</tr>
<tr>
<td>heightmapPixelError</td>
<td>An approximation of how many pixels the terrain will pop in the worst case when switching lod.</td>
</tr>
<tr>
<td>lightmapindex</td>
<td>The index of the lightmap applied to this renderer.</td>
</tr>
<tr>
<td>terrainData</td>
<td>The Terrain Data that stres htightmaps,terrain textures,detail meshes and trees.</td>
</tr>
<tr>
<td>treeBillboardDistance</td>
<td>Distance from the camera where trees will be rendered as billboards only.</td>
</tr>
<tr>
<td>terrCrossFadeLength</td>
<td>Total distance delta that trees will use to transition from billboard orientation to to mesh orientation.</td>
</tr>
<tr>
<td>treeDistance</td>
<td>The maximum distance at which trees are rendered.</td>
</tr>
<tr>
<td>treeMaximumFullLODCount</td>
<td>Maximum number of trees rendered at full LOD.</td>
</tr>
</tbody>
</table>
</div>
<h1 id="NGUI"><a href="#NGUI" class="headerlink" title="NGUI"></a>NGUI</h1><img src="/2017/09/24/UGUIvsNGUI/1.jpg">
<p>上图是UIWidget，UIGeometry和UIDrawCall的关系图<br>UIPanel用来收集和管理它下面所有的widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能被渲染出来。可以把UIPanel当作Renderer。</p>
<p>每一个UIWidget都有一个UIGeometry，但是并不都有一个UIDrawCall，而是要通过Batch合并达到减少DrawCall的数量。<br>所有Panel都有一个Depth值，会影响所有它包含的widget。Panel的depth权重要高于widget的depth权重，但是低于render queue。</p>
<p>当勾选static的时候，该panel下面所有的widget都不会被移动，这样可以提高性能。此时，NGUI会忽略所有的position/rotation/scale改变。所以在运行时移动widget不会有效。</p>
<h3 id="UIDrawCall"><a href="#UIDrawCall" class="headerlink" title="UIDrawCall"></a>UIDrawCall</h3><p>1.成员变量<br>a) List<uidrawcall> mActiveList和mInactiveList，mActiveList保持当前激活的UIDrawCall，mInactiveList主要是用于回收UIDrawCall.Destroy()的UIDrawCall，以达到循环利用避免内存的反复申请和释放，减少GC的次数。<br>b) Material mMaterial和mDynamicMat，mMaterial是图集的Material，mDynamicMat是实际采用的Material，因为UIPanel的Clipping有AlphaClip和SoftClip这两个是要通过切换Shader实现的，所以需要对应动态创建一个Material，这个就是mDynamicMat的存在。<br>c) bool mRebuildMat和isDirty，这两者表示UIDrawCall所处的状态，当改变UIDrawCall的Material和Shader，mRebuildMat就变成true，就会引起RebuildMaterial()的调用。isDirty若为true，表示UIDrawCall要进行重写“填充”，调用Set函数。</uidrawcall></p>
<p>负责将uv、顶点、color等信息输入到mesh中，继而绘制图形。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateGeometry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFilter == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mFilter = gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">        mMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">        mTriangles = (verts.size &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        mMesh.verticess = verts.buffer;</span><br><span class="line">        mMesh.uv = uvs.buffer;</span><br><span class="line">        mFilter.mesh = mMesh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mRenderer = gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    UpdateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上所有的buffer都是用BetterList来存储的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateMaterial</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDynamicMat == <span class="literal">null</span> || mRebuildMat || mClipCount != panel.clipCount)</span><br><span class="line">    &#123;</span><br><span class="line">        RebuildMaterial();</span><br><span class="line">        mRebuildMat = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mSharedMat != mDynamicMat)</span><br><span class="line">    &#123;</span><br><span class="line">        mSharedMaterials = <span class="keyword">new</span> Material[]&#123;mDynamicMat&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RebuildMaterial</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化DrawCall<br>使用相同material的连续UIWidget(UILbale,UISprite)共用一个UIDrawCall。对UIWidget.list进行排序，使得相同的material的UIWidget在UIWidget.list相连，而UIWidget.list是根据UIWidget的depth进行排序。（但是这样不会改变渲染顺序吗？）<br>1) 修改UIWidget(UILabel,UISprite)的depth，限定好UIWidget.list的排序<br>2) 重写UIWidget的CompareFunc方法。<br>夹层问题</p>
<h3 id="UIRoot"><a href="#UIRoot" class="headerlink" title="UIRoot"></a>UIRoot</h3><p>UIRoot的作用是缩放UI</p>
<p>PixelPerfect        保持原分辨率<br>FiexedSize          根据比例缩放<br>FixedSizeOnMobile   PC保持原分辨率，Mobile缩放</p>
<h3 id="UICamera"><a href="#UICamera" class="headerlink" title="UICamera"></a>UICamera</h3><p> 带有这个组件渲染出来的物体可以接受NGUI事件</p>
<h3 id="UIPanel"><a href="#UIPanel" class="headerlink" title="UIPanel"></a>UIPanel</h3><p>Panel的集合，一个Panel中包含多个Widget，负责更新会决定何时绘制Widget。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> List&lt;UIPanel&gt; list = <span class="keyword">new</span> List&lt;UIPanel&gt;();</span><br><span class="line"><span class="keyword">public</span> RenderQueue renderQueue = RenderQueue.Automatic; <span class="comment">//渲染次序类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> startingRenderQueue = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">public</span> List&lt;UIWidget&gt; widgets = <span class="keyword">new</span> List&lt;UIWidget&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;UIDrawCall&gt; drawcalls = <span class="keyword">new</span> List&lt;UIDrawCall&gt;();</span><br><span class="line"><span class="keyword">int</span> mDepth = <span class="number">0</span>; <span class="comment">// 深度</span></span><br><span class="line"><span class="keyword">int</span> mSortingOrder; <span class="comment">// 队列排序值</span></span><br><span class="line"><span class="keyword">bool</span> mRebuild = <span class="literal">false</span>;<span class="comment">//如果为true，需要重构所有的Drawcall，Panel中的OnEnable、RemoveWidget、AddWidget等和改变depth会将该值设置为true。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mUpdateFrame != Time.frameCount)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/09/24/UGUIvsNGUI/2.jpg" title="LateUpdate调用图">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/32/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/34/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DTWMWSlnxcXcuUgR1H2qlVt9-gzGzoHsz',
      appKey     : 'Ms2yHVyCinQmWnsKtVv7NOHR',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
