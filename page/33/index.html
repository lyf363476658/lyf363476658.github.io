<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/page/33/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/page/33/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/10/03/lightmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/03/lightmap/" class="post-title-link" itemprop="url">光照贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-03 16:28:04" itemprop="dateCreated datePublished" datetime="2017-10-03T16:28:04+08:00">2017-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/theGIbook/" itemprop="url" rel="index"><span itemprop="name">theGIbook</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在很多情况下，我们为了提高渲染效率，一般都会让美术同学在制作场景时，设置场景相关节点的lightmap static属性，提前给整个场景烘培出静态的光照贴图lightmap，烘培的数据保存在场景目录下的LightmapSnapshot文件中，主要包括的数据有：<br>lightmaps：烘培出的光照贴图数组；<br>gameobject uid：被烘焙的gameobject的唯一标识；<br>renderer的lightmapIndex：被烘培的gameobject的renderer组件所指向的光照贴图用于采样的区域坐标和宽高。<br>这个文件目前没有相关api读写，如果你想烘培完场景之后，把场景里面的gameobject抽出来做prefab，等切换玩场景之后再用于动态加载是不可行的，因为抽出来的prefab咋Instantiate之后将会是一个新的gameobject，uid自然和LightmapSnapshot文件里面记录的不一样，导致找不到对应的光照数据而造成模式没光照变暗或渲染错乱。<br>还有一种比较常见的需求是，在游戏运行时，通过更换光照贴图数据，营造场景在不同时间或季节的光照氛围，例如白天和黑夜。</p>
<p>由于漫反射表面的颜色可以由单个RGB颜色值描述，其记载的是辐射照度值，如果光源和整个场景是静态的，则这个辐射照度值为一个常数，因此可以被预存起来，我们称记录辐射照度值的纹理为一个辐射照度贴图（irradiance maps）或光照贴图（light maps），由于光照传输是线性的，因此其它动态光源所形成的光照可以在这个辐射照度值上进行累加。光照贴图仍然是先阶段实时渲染中漫反射间接光照的主流解决方案[Unity,2017b,Unreal Engine 4,2018b,Iwanicki and Sloan,2017]，它最早被用于[Abrash,1997]中，光照贴图的概念如图11.31所示。<br><img src="/2017/10/03/lightmap/Lightmapped_Scene_with_Lightmap.png"><br><strong>图 11.31：</strong>一个简单的场景（左）及其光照贴图（右），由此可以看出光照贴图的分辨率很低，因此它通常用来存储间接光照（图片来自Wikipedia）</p>
<p>在像素着色器中，每个像素都需要读取光照贴图中的一个辐射照度值；而另一方面，漫反射表面的每个像素还存储了一个漫反射系数值，它也是一个常数值。直观上思考，我们希望将这两个值预乘起来，形成一个直接的出射辐射亮度值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/10/02/ABTheory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/02/ABTheory/" class="post-title-link" itemprop="url">AssetBundle管理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-02 15:04:40" itemprop="dateCreated datePublished" datetime="2017-10-02T15:04:40+08:00">2017-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是AssetBundle"><a href="#什么是AssetBundle" class="headerlink" title="什么是AssetBundle"></a>什么是AssetBundle</h1><p>AssetBundle就像一个Zip压缩文件，里面存放着一些数据对象。它包含一些平台相关的运行时序列化对象。</p>
<p>Bundle之间也存在着依赖。AssetBundle带有三种压缩选项：不压缩，LZMA，LZ4。默认的就是LZMA，而BuildAssetBundleOptions.ChunkBasedCompression就是LZ4的压缩形式。另外我们有两种类型的Bundle，一种是我们场景的Bundle（*.unity打包的常务），另一种是松散的Bundle。</p>
<h1 id="WebExtract-amp-Binary2Text"><a href="#WebExtract-amp-Binary2Text" class="headerlink" title="WebExtract &amp; Binary2Text"></a>WebExtract &amp; Binary2Text</h1><p>AssetBundle对于大家来说会是一个黑盒子，其实在Unity的安装目录下（Data/Tools）有WebExtract &amp; Binary2Text这两个工具，可以帮你把AssetBundle这个黑盒子打开。例如：升级版本AssetBundle变大了，二次构建AssetBundle出现差异了，AssetBundle内到底包含了那些资源等。</p>
<p>对于构建出来的AssetBundle，我们先通过WebExtract来解开，这时候可以得到一个文件夹，里面包含一些文件。</p>
<pre><code>Usage: WebExtractor &lt;unitywebfile&gt;
</code></pre><h1 id="AssetBundle加载基础"><a href="#AssetBundle加载基础" class="headerlink" title="AssetBundle加载基础"></a>AssetBundle加载基础</h1><p>通过AssetBundle加载资源，分为两步，第一步获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细的描述。</p>
<h2 id="获取AssetBundle对象常用的API"><a href="#获取AssetBundle对象常用的API" class="headerlink" title="获取AssetBundle对象常用的API"></a>获取AssetBundle对象常用的API</h2><h3 id="直接获取AssetBundle"><a href="#直接获取AssetBundle" class="headerlink" title="直接获取AssetBundle:"></a>直接获取AssetBundle:</h3><ul>
<li>public static AssetBundle CreateFromFile(string path);<br>通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的创建方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中过去。</li>
<li>public static AssetBundleCreateRequest CreateFromMemory(byte[] binary);<br>通过Bundle的二进制数据，异步创建AssetBundle对象。完成后会在内存中创建较大的WebStream。调用时，Bundle的解压时异步进行的，因此对于未压缩的Bundle文件，该接口与CreateFromMemoryImmediate等价。</li>
<li>public static AssetBundle CreateFromMemoryImmediate(byte[] binary);<br>该接口是CreateFromMemory的同步版本。</li>
<li>注：5.3下分别改名为LoadFromFile,LoadFromMemory,LoadFromMemoryAsync并增加了LoadFromFileAsync，且机制也有一定的变化，可详见Unity官方文档。</li>
</ul>
<h2 id="从AssetBundle加载资源的常用API"><a href="#从AssetBundle加载资源的常用API" class="headerlink" title="从AssetBundle加载资源的常用API"></a>从AssetBundle加载资源的常用API</h2><ul>
<li>public ObjectLoad(string name, Type type);<br>通过给定的名字和资源类型，加载资源。加载时会自动在家其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。</li>
<li>public Object[] LoadAll(Type type);<br>一次性加载Bundle中给定资源类型的所有资源。</li>
<li><p>public AssetBundleRequest LoadAsync(string name, Type type);该接口是Load的异步版本。</p>
</li>
<li><p>注：5.x下分别改名为LoadAsset,LoadAllAssets,LoadAssetAsync，并增加了LoadAllAssetsAsync。</p>
</li>
</ul>
<h1 id="AssetBundle加载进阶"><a href="#AssetBundle加载进阶" class="headerlink" title="AssetBundle加载进阶"></a>AssetBundle加载进阶</h1><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>CreateFromFile只能适用于未压缩的AssetBundle,而Android系统下StreamingAssets是在压缩目录(.jar)中，因此需要先将未压缩的AssetBundle放到SD卡中国才能对其使用CreateFromFile。</li>
<li>iOS系统有256个开启文件的上限，因此，内存中通过CreateFromFile加载的AssetBundle对象也会低于该值。</li>
<li>CreateFromFile的调用会增加ResistenManager.Remapper的大小，而PersistentManager负责维护资源的持久化存储，Remapper保存的是加载到内存的资源HeapID与源数据FileID的映射关系，它是一个MemoryPool,其行为类似Mono堆内存，只增不减，因此需要对两个接口的使用做合理的规划。</li>
<li>对于存在依赖关系的Bundle包，在加载时主要注意顺序，举例来说，假设CanvasA在BundleA中，所依赖的AtlasB在BundleB中，为了确保资源正确引用，那么最晚创建BundleB的AssetBundle对象的时间点是在实例化CanvasA之前，即，创建BundleA的AssetBundle对象时，Load(“CanvasA”)时，BundleB的AssetBundle对象都可以不在内存中。<br><img src="/2017/10/02/ABTheory/dependbundle.png"></li>
<li>根据经验，建议AssetBundle文件的大小不超过1MB，因为在普遍情况下Bundle的加载时间与其大小并非呈线性关系，过大的Bundle可能引起较大的加载开销。</li>
<li>由于WWW对象的加载是异步的，因此逐个加载容易出现下图中CPU空间的情况（选中帧处Vsync占了大部分）此时建议适当的同时加载多个对象，以增加CPU的使用率，同时加快加载的完成。<br><img src="/2017/10/02/ABTheory/dependbundle.png"></li>
</ul>
<h1 id="AssetBundle卸载"><a href="#AssetBundle卸载" class="headerlink" title="AssetBundle卸载"></a>AssetBundle卸载</h1><p>前文提到了通过AssetBundle加载资源时的内存分配情况，下面，我们结合常用的API介绍如何将已分配的内存进行卸载，最终达到清空所有相关内存的目的。</p>
<h2 id="一·内存分析"><a href="#一·内存分析" class="headerlink" title="一·内存分析"></a>一·内存分析</h2><p><img src="/2017/10/02/ABTheory/dependbundle.png"></p>
<p>在上图中的右侧，我们列出了各种内存物件的卸载方式：</p>
<ul>
<li>场景物件(GameObject):这类物件可通过Destroy函数进行卸载；</li>
<li>资源(包括Prefab):除了Prefab以外，资源文件可以通过三种方式来卸载<br>1）通过Resources.UnloadAsset卸载指定的资源，CPU开销小；<br>2）通过Resources.UnloadUnusedAssets一次性卸载所有未被引用的资源，CPU开销大；<br>3）通过Resources.Unload(true)在卸载AssetBundle对象时，将加载出来的资源一起卸载。<br>而对于Prefab,目前仅能通过DestroyImmediate来卸载，且卸载后，必须重新加载AssetBundle才能重新加载该Prefab。由于内存开销较小，通常不建议进行针对性的卸载。</li>
<li>WWW对象：调用对象的Dispose函数或将其置为null即可；</li>
<li>WebStream:在卸载WWW对象以及对应的AssetBundle对象后，这部分内存即会被引擎自动卸载；</li>
<li>SerializedFile:卸载AssetBundle后，这部分内存会被引擎自动卸载;</li>
<li>AssetBundle对象：AssetBundle的卸载方式有两种：<br>1）通过AssetBundle.Unload(false),卸载AssetBundle对象时保留内存中已加载的资源；<br>2)通过AssetBundle.Unload(true),卸载AssetBundle对象时卸载内存中已加载的资源，由于该方法容易引起资源引用丢失，因此并不建议经常使用；<h2 id="二·注意点"><a href="#二·注意点" class="headerlink" title="二·注意点"></a>二·注意点</h2>在通过AssetBundle.Unload(false)卸载AssetBundle对象后，如果重新创建该对象并加载之前加载过的资源的时候，会出现冗余，即两份相同的资源。</li>
</ul>
<p>被脚本静态变量引用的资源，在调用Resources.UnloadUnusedAssets时，并不会被卸载，在Profiler中能够看到其引用情况。</p>
<h1 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h1><p>通过以上的讲解，相信您对AssetBundle的加载和卸载有了明确的了解。下面，我们简单地做一下API选择上的推荐：</p>
<ul>
<li>对于加载完后即卸载的Bundle文件，则分两种情况：优先考虑速度（加载场景时）和优先考虑流畅度（游戏进行时）。<br>1）加载场景的情况下，需要注意的是避免WWW对象的逐个加载导致的CPU空间，可以考虑使用加载速度较快的WWW.LoadFromCacheOrDownload或AssetBundle.CreateFromFile，但需要避免后续大量地进行Load资源的操作，引起IO开销（可以尝试直接LoadAll）。<br>2）游戏进行的情况下，则需要避免使用同步操作引起卡顿，因此可以考虑使用new WWW配合AssetBundle.LoadAsync来进行平滑的资源加载，但需要注意的是，对于Shader，较大的Texture等资源，其初始化操作通常很耗时，容易引起卡顿，因此建议将这类资源在加载场景时进行预加载。</li>
<li>只在Bundle需要加密的情况下，考虑使用CreateFromMemory，因为该接口加载速度较慢。</li>
<li>尽量避免在游戏进行中调用Resources.UnloadUnusedAssets(),因为该接口开销较大，容易引起卡顿，可尝试使用Resources.Unload(obj)来逐个进行卸载，以保证游戏的流畅度。</li>
</ul>
<p><strong>需要说明的是，以上内存管理交适合于Unity5.3之前的版本。Unity引擎在5.3中对AssetBundle的内存占用进行了一定的调整，目前我们也在进一步的学习和研究中。</strong></p>
<p>原文链接：<a href="https://blog.uwa4d.com/archives/ABTheory.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/ABTheory.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/29/AI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/29/AI/" class="post-title-link" itemprop="url">AI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-29 19:44:39" itemprop="dateCreated datePublished" datetime="2017-09-29T19:44:39+08:00">2017-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ML（机器学习）与AI-人工智能）"><a href="#ML（机器学习）与AI-人工智能）" class="headerlink" title="ML（机器学习）与AI(人工智能）"></a>ML（机器学习）与AI(人工智能）</h1><p>首先来介绍下Machine Learning(机器学习，下文简称ML）和游戏Artificial Intelligence(人工智能，下文简称AI）间的关系。现存的大部分游戏AI都是手工源码，由大量决策树组成，有时会包含多达数千条规则。而且必须由手工维护和测试。而ML所依赖的算法可以自动从原始数据寻找规律，无需专家预先定义数据的解读方式。</p>
<p>以图片内容分类这个计算机视觉问题为例。直到几年前，专家们仍然通过手工编写过滤器，提取图像的有用特征，用于分辨某个图像中包含的是猫还是狗。而ML，特别是i最新的深度学习方法，仅需图像和类型标签，就可以自动学习有用的特征。我们相信这种自动化学习不仅可以扩展Unity平台的应用范围，例如用于ML场景模拟，还可以帮助所有开发者简化和加速游戏的开发过程。</p>
<p>这种自动化学习尤其可以应用于游戏代理（即NPC）的行为方面。我们可以使用Reinforcement Learning(增强学习，简称RL）来训练代理，预估某一环境中施行特定行为的价值。一旦训练完成，代理即可以最佳行为模式做出反应，无需通过程序对行为进行显示的编码。</p>
<h1 id="采用老虎机算法的增强学习"><a href="#采用老虎机算法的增强学习" class="headerlink" title="采用老虎机算法的增强学习"></a>采用老虎机算法的增强学习</h1><p>RL背后的一个核心概念是价值估计，并据此进行相应动作。在继续深入之前，最好先了解一些术语。</p>
<p>在RL中，实施动作的个体被称为agent(代理),它使用policy(策略)进行动作决策。一个代理通常嵌入一个environment中，并在任意给定的时刻都处于某个特定的state(状态).从哪个状态，它可以进行一系列actions(动作）。某个给定状态的value(值)指的是处于该状态的最终回报价值。在某个状态的value(值)指的是处于该状态的最终回报值。在某个状态执行一个动作可以让代理进入另一个新的状态，获得一个reward(回报),或者同事拥有两者。所有的RL代理都在尽可能最大化累计回报。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/29/Real-Time-Rendering-3rd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/29/Real-Time-Rendering-3rd/" class="post-title-link" itemprop="url">Real Time Rendering 3rd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-29 15:13:03" itemprop="dateCreated datePublished" datetime="2017-09-29T15:13:03+08:00">2017-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><img src="/2017/09/29/Real-Time-Rendering-3rd/overview.png" alt="overview"><br>url: www.realtimerendering.com</p>
<h1 id="The-Graphics-Rendering-Pipeline"><a href="#The-Graphics-Rendering-Pipeline" class="headerlink" title="The Graphics Rendering Pipeline"></a>The Graphics Rendering Pipeline</h1><p><img src="/2017/09/29/Real-Time-Rendering-3rd/tgrp.png"></p>
<h2 id="核心内容分节提炼"><a href="#核心内容分节提炼" class="headerlink" title="核心内容分节提炼"></a>核心内容分节提炼</h2><h3 id="图像渲染管线架构概述-Architecture"><a href="#图像渲染管线架构概述-Architecture" class="headerlink" title="图像渲染管线架构概述 Architecture"></a>图像渲染管线架构概述 Architecture</h3><p>渲染管线的主要功能就是决定在给虚拟相机，三维物体，光源，照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。</p>
<p><img src="/2017/09/29/Real-Time-Rendering-3rd/viewport.png"><br>上图，相机放在棱锥的顶端（四条线段的交汇点），只有可视体内部的图元会被渲染。<br>在概念上可以将图形渲染管线分为三个阶段：</p>
<ul>
<li>应用程序阶段（The Application Stage)</li>
<li>几何阶段(The Geometry Stage)</li>
<li>光栅化阶段(The Rasterizer Stage)</li>
</ul>
<p>绘制管线的基本结构包括3个阶段：应用程序，几何，光栅化。</p>
<p>几个要点：</p>
<ul>
<li>每个阶段本身也可能是一条管线，如图中的几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的光栅化阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。</li>
<li><p>最慢的管线阶段决定绘制速度，即图像的更新速度，这种速度一般用FPS表示，也就是帧率。</p>
<h3 id="应用程序阶段（The-Application-Stage）"><a href="#应用程序阶段（The-Application-Stage）" class="headerlink" title="应用程序阶段（The Application Stage）"></a>应用程序阶段（The Application Stage）</h3></li>
<li><p>应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件的基础上，因此要改变实现过程会非常困难。</p>
</li>
<li>正因应用程序阶段是软件方式实现，因此不能像集合和光栅化阶段那样继续分为诺干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在CPU设计商，称这种形式为超标量体系(superscalar)结构，因为它可以在同一个阶段同一个时间做不同的几件事情。</li>
<li>应用程序阶段通常实现的方法有碰撞检测，加速算法，输入检测，动画，力反馈以及纹理动画，变化仿真，几何变形，以及一些不在其他阶段执行的计算，如层次堆裁剪等加速算法就可以在这里实现。</li>
<li>应用程序阶段的主要任务：在应用程序阶段的末端，将需要在屏幕(具体形式取决于具体输入设备)显示出来绘制的几何体(也就是绘制图元,rendering primitives,如点，线，矩形等)输入到绘制管线的下一个阶段。</li>
<li>对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段-几何阶段。<h3 id="几何阶段-The-Geometry-Stage"><a href="#几何阶段-The-Geometry-Stage" class="headerlink" title="几何阶段 The Geometry Stage"></a>几何阶段 The Geometry Stage</h3></li>
</ul>
<p>几何阶段主要负责大部分多边形操作和顶点操作。</p>
<h1 id="GPU渲染管线和可编程着色器"><a href="#GPU渲染管线和可编程着色器" class="headerlink" title="GPU渲染管线和可编程着色器"></a>GPU渲染管线和可编程着色器</h1><h2 id="GPU渲染管线流程图"><a href="#GPU渲染管线流程图" class="headerlink" title="GPU渲染管线流程图"></a>GPU渲染管线流程图</h2><img src="/2017/09/29/Real-Time-Rendering-3rd/1.png"> <img src="/2017/09/29/Real-Time-Rendering-3rd/2.jpg"> 
<p>其中：</p>
<ul>
<li>绿色的阶段都是完全可以编程的。</li>
<li>黄色的阶段可配置，但不可编程。</li>
<li>蓝色的阶段完全固定。</li>
</ul>
<h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器（The Vertex Shader）是完全可编程的阶段，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器的必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。</p>
<h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>几何着色器（The Geometry Shader）位于顶点着色器之后，允许GPU高效的创建和销毁几何图元。几何着色器是可选的，完全可编程的阶段，主要对图元（点、线、三角形）的顶点进行操作。几何着色器接受顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化的其他处理后，会发送给片段着色器。<br>几何着色器可以改变信新传递进来的图元的拓扑结构，且几何着色器可以接受任何拓扑类型的图元，但是只能输出点、折线（line strip）和三角形条（triangle strips）。</p>
<h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p>裁剪（Clipping）属于可配置的功能阶段，在此阶段可选运行的裁剪方式，以及添加自定义的裁剪面。</p>
<h3 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h3><p>屏幕映射（Screen Mapping）、三角形设置（Triangle Setup）和三角形遍历（Triangle Traversal）阶段是固定功能阶段。</p>
<h3 id="像素着色器"><a href="#像素着色器" class="headerlink" title="像素着色器"></a>像素着色器</h3><p>像素着色器（Pixel Shader，Direct3D中的叫法）常常又称为片段着色器，片元着色器（Fragment Shader，OpenGL中的叫法），是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。<br>像素着色器常用来处理场景光照和与之相关的效果，如凹凸纹理映射和调色。称之为片段着色器似乎更加准确，因为对于着色器的调用和屏幕上的像素并非是一一对应的。比如，对于一个像素，片段着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。<br>需要注意，像素着色器通常在最终合并阶段设置片段颜色以进行合并，而深度值也可以由像素着色器修改。模版缓冲（stencil buffer）值是不是修改的，而是将其传递给合并阶段（Merge Stage）。在SM 2.0以及以上版本，像素着色器也可以丢弃（discard）传入的片段数据，即不产生输出。这样的操作会消耗性能，因为通常在这种情况下不能使用由GPU执行的优化。诸如雾计算和alpha测试的操作已经从合并操作转移到SM 4.0中的像素着色器里计算。<br>可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在Shader Model 4.0中，共有16个向量（每个向量含有4个值）可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出32个向量到像素着色器中。像素着色器的追加输入是Shader Model 3.0中引入的。例如，三角形的哪一面是可见的通过输入标志来假如的。这个值对于在单个通道中的正面和背面渲染不同材质十分重要。而且像素着色器也可以获得片段的屏幕位置。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并阶段（The Merger Stage）处于完全可编程和固定功能之间，尽管不能编程，但是高度可配置，可以进行一系列的啊哦做。其除了进行合并操作，还分管颜色修改（Color Modifying），Z缓冲（Z-Buffer），混合（Blend），模版（Stencil）和相关缓存的处理。</p>
<h2 id="可编程着色模型"><a href="#可编程着色模型" class="headerlink" title="可编程着色模型"></a>可编程着色模型</h2><ul>
<li>现代着色阶段（比如支持Shader Model 4.0，DirectX 10以及之后）使用了通用着色核心（common-shader core），这就表明顶点，片段，几何着色器共享一套编程模型。</li>
<li>早起的着色模型可以用汇编语言直接编程，但DX10之后，汇编就只在调试输出阶段可见，改用高级着色语言。</li>
<li>目前的着色语言都是C-like的着色语言，比如HLSL，CG和GLSL，其被编译成独立于机器的汇编语言，也称为中间语言（IL）。这些汇编语言在单独的阶段，通常实在驱动中，被转化成实际的机器语言。这样的安排可以兼容不同的硬件实现。这些汇编语言可以被看做是定义一个作为着色语言编译器的虚拟机。这个虚拟机是一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。</li>
<li><p>着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编译一系列指令的处理器。考虑到很多图形操作都使用短矢量（最高四位），处理器拥有4路SIMD（single-instruction multiple-data，单指令多数据）兼容性。每个寄存器包含四个独立的值。32位单精度浮点的标量和矢量是其基本数据类型；也随后支持32位整型。浮点矢量通常包含数据如位置（xyzw），法线，矩阵行，颜色（rgba），或者纹理坐标（uvwq）。而整型通常用来表示，计数器，索引，或者位掩码。也支持综合数据类型比如结构体，数组，和矩阵。而为了便于使用向量，向量操作如调和（swizzling，也就是向量分量和重新排序或复制），和屏蔽（masking，只是用指定的矢量元素），也能够支持。</p>
<img src="/2017/09/29/Real-Time-Rendering-3rd/3.jpg">
<p>上图为DX10下的通用Shader核心虚拟机架构以及寄存器布局。每个资源旁边显示最大可用编号。其中，用两个斜杠分开的三个数值，分别是顶点、几何、像素着色器对应的可用最大数量。</p>
</li>
<li><p>一个绘制调用（Draw Call）会调用图形API来绘制一系列的图元，会驱使图形管线的运行。</p>
</li>
<li>每个可编程着色阶段拥有两种类型的输入：<ul>
<li>uniform输入，在一个draw call中保持不变的值（但在不同draw call之间可以改变）</li>
<li>varying输入，shader里对每个顶点和像素的处理都不同的值。纹理是特殊的uniform输入，曾经一直是一张应用到表面的彩色图片，但现在可以认为是存储着大量数据的数组。</li>
</ul>
</li>
<li>在现代GPU上，图形运算中常见的运算操作执行速度非常快。通常情况下，最快的操作是标量和向量的乘法和加法，以及他们的组合，如乘加运算（multiply-add）和点乘（dot-product）运算。其它操作，比如倒数（reciprocal），平方根（square root），正弦（sine），余弦（cosine），指数（exponentiation），对数（logarithm）运算，往往会稍微更加昂贵，但依然相当快捷。纹理操作非常高效，但他们的性能可能受到诸如等待检索结果的时间等因素的限制。</li>
<li>着色语言表示出了大多数常见的操作（比如加法和乘法通过运算符+和*来表示）。其余的操作用固有的函数，比如atan()，dot()，log()等。更复杂的操作也存在内建函数，比如矢量归一化（vector normalization），反射（reflection）、叉乘（cross products）、矩阵的转置（matrix transpose）和行列式（determinant）等。</li>
<li>流控制（flow control）是指使用分支指令来改变代码执行流程的操作。这些指令用于实现高级语言结构，如“if”和“case”语句，以及各种类型的循环。Shader支持两种类型的流控制。静态流控制（Static flow control）是基于统一输入的值。这意味着代码的流在调用时是恒定的。静态流控制的主要好处是允许在不同的情况下使用相同的着色器（例如，不同数量的光源）。动态流控制（Dynamic flow control）基于不同的输入值。但动态流控制远比静态流量控制更强大但同时也需要更高的开销，特别是在调用shader之间，代码流不规律改变的时候。而评估一个shader的性能，是评估其在一段时间内处理顶点或像素的个数。如果流对某些元素选择“if”分支，而对其他元素选择“else”分支，这两个分支必须对所有元素进行评估（并且每个元素的未使用分支将被丢弃）。</li>
<li>Shader程序可以在程序加载或运行时离线编译。和任何编辑器一样，有生成不同输出文件和使用不同优先级别的选项。一个编译过的Shader作为字符串或者文本来存储，并通过驱动程序传递给GPU。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>SM 2.0/2.X</th>
<th>SM 3.0</th>
<th>SM 4.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>引入版本</td>
<td>DX 9.0,2002</td>
<td>DX 9.0c,2004</td>
<td>DX 10,2007</td>
</tr>
<tr>
<td>VS指令槽位</td>
<td>256</td>
<td>≥512</td>
<td>4096</td>
</tr>
<tr>
<td>VS最大执行步长</td>
<td>65536</td>
<td>65536</td>
<td>∞</td>
</tr>
<tr>
<td>PS指令槽位</td>
<td>≥96</td>
<td>≥512</td>
<td>≥65536</td>
</tr>
<tr>
<td>PS最大执行步长</td>
<td>≥96</td>
<td>65536</td>
<td>∞</td>
</tr>
<tr>
<td>临时寄存器</td>
<td>≥12</td>
<td>32</td>
<td>4096</td>
</tr>
<tr>
<td>VS常量寄存器</td>
<td>≥256</td>
<td>≥256</td>
<td>14×4096</td>
</tr>
<tr>
<td>PS常量寄存器</td>
<td>32</td>
<td>224</td>
<td>14×4096</td>
</tr>
<tr>
<td>流程控制，判断</td>
<td>Optional</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>VS纹理贴图</td>
<td>None</td>
<td>4</td>
<td>128×512</td>
</tr>
<tr>
<td>PS纹理贴图</td>
<td>16</td>
<td>16</td>
<td>128×512</td>
</tr>
<tr>
<td>整数支持</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>VS输入寄存器</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>插值寄存器</td>
<td>8</td>
<td>10</td>
<td>16/32</td>
</tr>
<tr>
<td>PS输出寄存器</td>
<td>4</td>
<td>4</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/26/Unity-Weather/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/26/Unity-Weather/" class="post-title-link" itemprop="url">Unity-Weather</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-26 06:58:54" itemprop="dateCreated datePublished" datetime="2017-09-26T06:58:54+08:00">2017-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>抄：<a href="https://zhuanlan.zhihu.com/p/29668925" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29668925</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/24/3的3D流水线处理流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/24/3的3D流水线处理流程/" class="post-title-link" itemprop="url">UE3的3D渲染流水线处理流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-24 10:56:00" itemprop="dateCreated datePublished" datetime="2017-09-24T10:56:00+08:00">2017-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/虚幻引擎/" itemprop="url" rel="index"><span itemprop="name">虚幻引擎</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><p>3D渲染流水线也类似一个工厂的流水线，它的原材料是一系列的3D网格数据，最终产品就是显示在2D屏幕的3D场景。<br>3D渲染流水线的处理和照相机的原理很像，它们都同样是通过将3D世界的内容放置到2D平面上，通过2D的方式来展示3D世界，<br>顶点管线中有这么几个坐标空间：局部空间-&gt;世界空间-&gt;相机空间-&gt;投影空间-&gt;屏幕空间(视口空间),初始的网格数据是在局部空间中的，顶点管线将其从局部空间变换到屏幕空间作为输入供”像素管线”处理。比如局部空间内，一个人物的骨骼模型，它的中心点就是根骨骼的位置，在进行骨骼层次计算的时候，根谷歌放在中心位置是易于计算的，如果将其放置到世界空间中进行骨骼计算，那么根骨骼的位置不在原点且朝向也不为0，计算起来相当复杂。而世界空间中，易于描述场景中各个物体间的关系，易于作碰撞处理，伤害计算，顶点光照计算等。在相机空间中，容易描述被观察物体与观察者之间的关系，利用相机视锥体对物体进行裁剪，把观察不到的物体剔除掉。</p>
<p>VertexShader—顶点着色器是用来替换这个阶段中固定管线的定点变换及光照计算的，传统管线处理顶点及光照的方式都是固定流程的，所以固定管线下的3D程序特效都有很大的局限性，引入顶点着色器之后，顶点在空间中的变换以及光照处理都可以可编程化了。顶点着色器主要是用来改变顶点固定流程中的变换过程，所以使用顶点着色器表现出来的大多是几何外形的变化以及顶点的光照，纹理等数据的变化。</p>
<p>在UE3中，是不能直接编写Shader语言的，UE3中把所有的Shader特效都绑定到材质中，只能通过材质编辑器来间接的编辑顶点着色器和像素着色器内容。UE3中修改顶点着色器的方式也是在材质编辑器中进行的，其中比较典型的一个输入节点叫做WorldPositionOffset，它就是在顶点管道阶段对材质对应的网络物体顶点进行编辑的一个节点，对应到底层是修改了该材质对应的顶点着色器代码(通过HLSL按钮能够看到该材质对应的Shader代码</p>
<p>这个阶段会逐像素地处理该像素的纹理映射，光照颜色，alpha融合，深度测试，模板测试等，并且根据该像素的距离信息进行雾化公式的应用，所以，顾名思义，像素管道主要处理的是像素信息，最终输出像素最终的颜色。</p>
<p>传统的3D管线只能通过有限几个图形API接口来操作像素，比如DX中设置多纹理的一些接口以及Alpha融合的接口，能够操作的范围很有限。</p>
<p>像素着色器所替换固定流水线的功能就是在这个阶段，在引入像素着色器之后，就可以根据需要对像素做许多自由的处理，因为帧缓存内的像素信息不止包含该像素的颜色、Alpha值、深度信息和模版信息，还可以包含该像素对应的法线贴图信息、高光贴图信息、凹凸贴图信息等（这些贴图实际上保存的是一系列向量信息），通过传入一定的参数，比如时间信息、物理量等，就能制作出各种贴近现实的精美特效。</p>
<p>UE3中的像素着色器也是通过材质编辑器中的表达式来处理的，UE3材质编辑器中的大部分输入节点都是用于处理像素着色的，如图所示</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/24/UGUIvsNGUI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/24/UGUIvsNGUI/" class="post-title-link" itemprop="url">UGUI vs NGUI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-24 10:56:00" itemprop="dateCreated datePublished" datetime="2017-09-24T10:56:00+08:00">2017-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="table-container">
<table>
<thead>
<tr>
<th>Tables</th>
<th>NGUI</th>
<th>UGUI</th>
</tr>
</thead>
<tbody>
<tr>
<td>锚点</td>
<td>Anchor</td>
<td>RectTransform Anchor</td>
</tr>
<tr>
<td>图片</td>
<td>Sprite</td>
<td>Image</td>
</tr>
<tr>
<td>文字</td>
<td>Label</td>
<td>Text</td>
</tr>
<tr>
<td>根节点</td>
<td>UIRoot</td>
<td>Canvas</td>
</tr>
<tr>
<td>UI面板</td>
<td>Panel</td>
<td>Canvas</td>
</tr>
<tr>
<td>UI容器</td>
<td>Lets you essentially lower the heightmap resolution used for rendering.</td>
</tr>
<tr>
<td>heightmapPixelError</td>
<td>An approximation of how many pixels the terrain will pop in the worst case when switching lod.</td>
</tr>
<tr>
<td>lightmapindex</td>
<td>The index of the lightmap applied to this renderer.</td>
</tr>
<tr>
<td>terrainData</td>
<td>The Terrain Data that stres htightmaps,terrain textures,detail meshes and trees.</td>
</tr>
<tr>
<td>treeBillboardDistance</td>
<td>Distance from the camera where trees will be rendered as billboards only.</td>
</tr>
<tr>
<td>terrCrossFadeLength</td>
<td>Total distance delta that trees will use to transition from billboard orientation to to mesh orientation.</td>
</tr>
<tr>
<td>treeDistance</td>
<td>The maximum distance at which trees are rendered.</td>
</tr>
<tr>
<td>treeMaximumFullLODCount</td>
<td>Maximum number of trees rendered at full LOD.</td>
</tr>
</tbody>
</table>
</div>
<h1 id="NGUI"><a href="#NGUI" class="headerlink" title="NGUI"></a>NGUI</h1><img src="/2017/09/24/UGUIvsNGUI/1.jpg">
<p>上图是UIWidget，UIGeometry和UIDrawCall的关系图<br>UIPanel用来收集和管理它下面所有的widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能被渲染出来。可以把UIPanel当作Renderer。</p>
<p>每一个UIWidget都有一个UIGeometry，但是并不都有一个UIDrawCall，而是要通过Batch合并达到减少DrawCall的数量。<br>所有Panel都有一个Depth值，会影响所有它包含的widget。Panel的depth权重要高于widget的depth权重，但是低于render queue。</p>
<p>当勾选static的时候，该panel下面所有的widget都不会被移动，这样可以提高性能。此时，NGUI会忽略所有的position/rotation/scale改变。所以在运行时移动widget不会有效。</p>
<h3 id="UIDrawCall"><a href="#UIDrawCall" class="headerlink" title="UIDrawCall"></a>UIDrawCall</h3><p>1.成员变量<br>a) List<uidrawcall> mActiveList和mInactiveList，mActiveList保持当前激活的UIDrawCall，mInactiveList主要是用于回收UIDrawCall.Destroy()的UIDrawCall，以达到循环利用避免内存的反复申请和释放，减少GC的次数。<br>b) Material mMaterial和mDynamicMat，mMaterial是图集的Material，mDynamicMat是实际采用的Material，因为UIPanel的Clipping有AlphaClip和SoftClip这两个是要通过切换Shader实现的，所以需要对应动态创建一个Material，这个就是mDynamicMat的存在。<br>c) bool mRebuildMat和isDirty，这两者表示UIDrawCall所处的状态，当改变UIDrawCall的Material和Shader，mRebuildMat就变成true，就会引起RebuildMaterial()的调用。isDirty若为true，表示UIDrawCall要进行重写“填充”，调用Set函数。</uidrawcall></p>
<p>负责将uv、顶点、color等信息输入到mesh中，继而绘制图形。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateGeometry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFilter == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mFilter = gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">        mMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">        mTriangles = (verts.size &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        mMesh.verticess = verts.buffer;</span><br><span class="line">        mMesh.uv = uvs.buffer;</span><br><span class="line">        mFilter.mesh = mMesh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mRenderer = gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    UpdateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上所有的buffer都是用BetterList来存储的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateMaterial</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDynamicMat == <span class="literal">null</span> || mRebuildMat || mClipCount != panel.clipCount)</span><br><span class="line">    &#123;</span><br><span class="line">        RebuildMaterial();</span><br><span class="line">        mRebuildMat = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mSharedMat != mDynamicMat)</span><br><span class="line">    &#123;</span><br><span class="line">        mSharedMaterials = <span class="keyword">new</span> Material[]&#123;mDynamicMat&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RebuildMaterial</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化DrawCall<br>使用相同material的连续UIWidget(UILbale,UISprite)共用一个UIDrawCall。对UIWidget.list进行排序，使得相同的material的UIWidget在UIWidget.list相连，而UIWidget.list是根据UIWidget的depth进行排序。（但是这样不会改变渲染顺序吗？）<br>1) 修改UIWidget(UILabel,UISprite)的depth，限定好UIWidget.list的排序<br>2) 重写UIWidget的CompareFunc方法。<br>夹层问题</p>
<h3 id="UIRoot"><a href="#UIRoot" class="headerlink" title="UIRoot"></a>UIRoot</h3><p>UIRoot的作用是缩放UI</p>
<p>PixelPerfect        保持原分辨率<br>FiexedSize          根据比例缩放<br>FixedSizeOnMobile   PC保持原分辨率，Mobile缩放</p>
<h3 id="UICamera"><a href="#UICamera" class="headerlink" title="UICamera"></a>UICamera</h3><p> 带有这个组件渲染出来的物体可以接受NGUI事件</p>
<h3 id="UIPanel"><a href="#UIPanel" class="headerlink" title="UIPanel"></a>UIPanel</h3><p>Panel的集合，一个Panel中包含多个Widget，负责更新会决定何时绘制Widget。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> List&lt;UIPanel&gt; list = <span class="keyword">new</span> List&lt;UIPanel&gt;();</span><br><span class="line"><span class="keyword">public</span> RenderQueue renderQueue = RenderQueue.Automatic; <span class="comment">//渲染次序类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> startingRenderQueue = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">public</span> List&lt;UIWidget&gt; widgets = <span class="keyword">new</span> List&lt;UIWidget&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;UIDrawCall&gt; drawcalls = <span class="keyword">new</span> List&lt;UIDrawCall&gt;();</span><br><span class="line"><span class="keyword">int</span> mDepth = <span class="number">0</span>; <span class="comment">// 深度</span></span><br><span class="line"><span class="keyword">int</span> mSortingOrder; <span class="comment">// 队列排序值</span></span><br><span class="line"><span class="keyword">bool</span> mRebuild = <span class="literal">false</span>;<span class="comment">//如果为true，需要重构所有的Drawcall，Panel中的OnEnable、RemoveWidget、AddWidget等和改变depth会将该值设置为true。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mUpdateFrame != Time.frameCount)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/09/24/UGUIvsNGUI/2.jpg" title="LateUpdate调用图">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/20/游戏对象和脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/20/游戏对象和脚本/" class="post-title-link" itemprop="url">游戏对象和脚本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-20 17:35:07" itemprop="dateCreated datePublished" datetime="2017-09-20T17:35:07+08:00">2017-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a href="http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/" target="_blank" rel="noopener">http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/</a></p>
<ul>
<li>用简单的脚本构建一个时钟</li>
<li>用C#写脚本</li>
<li>让时钟转动起来</li>
<li>完成</li>
</ul>
<p>这边文章通过创建简单的组件脚本来实现一个时钟。您仅需几分钟来熟悉Unity编辑器，如果您已经熟悉此部分，可以跳过本篇文章。<br><img src="/2017/09/20/游戏对象和脚本/tutorial-image.jpg" alt="是时候创建一个时钟啦"></p>
<h1 id="构建一个简单的时钟"><a href="#构建一个简单的时钟" class="headerlink" title="构建一个简单的时钟"></a>构建一个简单的时钟</h1><p>打开Unity创建一个3D对象，你不需要任何额外的资源包.<br><img src="/2017/09/20/游戏对象和脚本/default-layout.png" alt="默认的窗口布局"></p>
<h2 id="1-1-创建一个游戏对象"><a href="#1-1-创建一个游戏对象" class="headerlink" title="1.1 创建一个游戏对象"></a>1.1 创建一个游戏对象</h2><p>默认的场景包含两个游戏对象，他们在层次窗口中而且你能看到他们的图标在场景窗口中，第一个是主相机，它是用来渲染的，第二个是方向光，照明场景的。<br>使用GameObject-&gt;Create Empty 选项，也可以选择层级窗口添加一个新的对象在scene上。</p>
<p><img src="/2017/09/20/游戏对象和脚本/hierarchy.png" alt="层次窗口的时钟对象"></p>
<p>监视窗口(Inspector window)展示游戏对象的细节，当选择时钟对象的时候，Inspector会展示他的name和一些额外的属性,默认为可用，非静态，没有标签属于一个默认的层。并且展示了所有的组件，transform组件是一定有的。</p>
<p><img src="/2017/09/20/游戏对象和脚本/inspector.png" alt="clock对象的Inspector"><br>transform组件包括位置，旋转和缩放在3D空间，确保position和rotation是0，scale是1（这里指的都是本地坐标)</p>
<h2 id="1-2-创建一个时钟"><a href="#1-2-创建一个时钟" class="headerlink" title="1.2 创建一个时钟"></a>1.2 创建一个时钟</h2><p>虽然我们有了clock object,但是我们什么也做不了,我们还得创建3D模型来渲染，Unity包含一些原始的对象，用这些我们能构建一个简单的时钟，s首先添加一个cylinder(圆柱Gameobject-&gt;3D Object-&gt;Cylinder)<br><img src="/2017/09/20/游戏对象和脚本/cylinder.png" alt><br><img src="/2017/09/20/游戏对象和脚本/cylinder-inspector.png" alt></p>
<p>圆柱体有一个Mesh Filter包含一个圆柱体的mesh，第二个是Capsule Collider(胶囊碰撞体)用来搞物理的，第三是Mesh Renderer确保可以得到渲染的，也用来控制用那个材质来渲染，最后一个就是材质(Material).</p>
<p>虽然对象是一个圆柱体，但是它用了capsule collider,因为unity没有原生的cylinder collider,我们不需要它，干掉！如果你不需要物理的话，你可以选择Mesh Collider 组件,组件能被干掉。</p>
<p>为了搞一个时钟的脸，我们必须把这玩意搞平，缩减scale的y值，</p>
<p><img src="/2017/09/20/游戏对象和脚本/cylinder-scaled-scene.png" alt></p>
<p>将圆柱体的名字改为Face,表示clock的脸,<br><img src="/2017/09/20/游戏对象和脚本/child-object.png" alt></p>
<h2 id="1-3-创建时钟刻度"><a href="#1-3-创建时钟刻度" class="headerlink" title="1.3 创建时钟刻度"></a>1.3 创建时钟刻度</h2><p>时钟有一圈刻度来告诉你现在几点了。<br>添加一个立方体对象通过Gameobject-&gt;3D Object-&gt;Cube,改变缩放(0.5,0.2,1)<br>刻度是难以看到的，因为他和表盘的颜色相同，让我们通过材质来区分吧，Assets-&gt;Create-&gt;Material，或者Proect Window都可以的，这个材质是复制默认的材质的，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/20/Unity渲染1-材质/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/20/Unity渲染1-材质/" class="post-title-link" itemprop="url">Unity渲染1 材质</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-20 17:17:22" itemprop="dateCreated datePublished" datetime="2017-09-20T17:17:22+08:00">2017-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PS：翻译Catlike的文章</p>
<ul>
<li>创建一个立方体格子</li>
<li>支持缩放，位移，旋转</li>
<li>创建简单的相机投影</li>
</ul>
<p>这是关于渲染的第一篇文章，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2017/09/17/article-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/17/article-title/" class="post-title-link" itemprop="url">scene和prefab的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-17 13:08:18" itemprop="dateCreated datePublished" datetime="2017-09-17T13:08:18+08:00">2017-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:38" itemprop="dateModified" datetime="2021-06-17T10:39:38+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果一个场景有多个相同的pfb(指引用相同的pfb，具体每个pfb可能有参数不同），那么Scene里每个pfb都是独立的对象，加载时每个对象都要走全套的流程: 文件I/O -&gt;反序列化 (解析，new obj + ctor) -&gt; awake -&gt; shader\texture\vbo create\upload，如果走pfb+Instantiate，那么前面的流程(文件I/O，反序列化）只用走一遍，直接Instantiate复制内存中现有的对象就行.<br>另外pfb可以在合适的时候提前异步预加载，这样切场景的时候就更快了（场景也可以异步预加载，不过awake\upload to gpu这些必须在主线程做，所以会卡一下），pfb也便于做细粒度的热更. 但pfb对美术日常调整场景不友好，除非有个一键生成场景+一键存pfb.<br>单论切换速度，什么都比不过预加载 + 大内存永驻</p>
<p>CentOS<br>1.yum install subversion<br>2.创建svn版本目录: mkdir -p /var/svn/svnrepos<br>3.创建版本库: svnadmin create /var/svn/svnrepos<br>4.cd /var/svn/svnrepos/conf (authz文件是权限控制文件;passwd是帐号密码文件;svnserve.conf SVN服务器配置文件)<br>5.设置帐号密码<br>    vi passwd<br>    在[users]块中添加用户和密码，格式：帐号=密码，如zentia=zentia<br>6.设置权限<br>vi authz<br>在末尾添加如下代码<br>[/]<br>zentia=rw<br>liyanfeng=r<br>意思是版本库的根目录zentia对其有读写权限，liyanfeng只有读权限。<br>7.修改svnserve.conf文件<br>打开下面几个注释：<br>anon-access=read #匿名用户可读<br>auth-access = write #授权用户可写<br>password-db = passwd #使用哪个文件作为帐号文件<br>authz-db = authz #使用哪个文件作为权限文件<br>realm = /var/svn/svnrepos #认证空间名，版本库所在目录<br>8.启动svn版本库<br>svnserve -d -r /var/svn/svnrepos<br>ps aux | grep svnserve #查看服务是否启动</p>
<h1 id="SVN客户端搭建"><a href="#SVN客户端搭建" class="headerlink" title="SVN客户端搭建"></a>SVN客户端搭建</h1><p>1.修改host文件<br>    10.173.32.4 zentiasvr</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/32/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
