<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zentia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"W8FJT5MTZU","apiKey":"f4ca7ae2408d2e27ffc8269ad8d34273","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liyanfeng">
<meta property="og:url" content="http://zentia.github.io/index.html">
<meta property="og:site_name" content="liyanfeng">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liyanfeng">

<link rel="canonical" href="http://zentia.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liyanfeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liyanfeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2021/07/02/ue4-fmemory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/ue4-fmemory/" class="post-title-link" itemprop="url">UE4的内存分配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-02 10:00:23 / 修改时间：11:59:27" itemprop="dateCreated datePublished" datetime="2021-07-02T10:00:23+08:00">2021-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index"><span itemprop="name">UE4</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>起因，看spine，看到了string，想起了stringID，然后看里面直接裸memory，在想FMemory和memory有什么区别，以及适用情况。</p>
<p>FMemory内部是区分平台的，但是我没看到GameCore内部区分平台。<br>UE4的window平台直接用的是<code>GenericPlatformMemory</code>，IOS中间有一层包装，但是最后也是走的是<code>GenericPlatformMemory</code>，Android也是，所以其实也还好？</p>
<p>好吧，我们还是从头开始看吧。</p>
<h1 id="FMemory"><a href="#FMemory" class="headerlink" title="FMemory"></a>FMemory</h1><p>这个第一个接口是<code>FMemory::GCreateMalloc</code>这里面主要调的是<code>FMemory_GCreateMalloc_ThreadUnsafe</code>，在这里面我们逐步分析。</p>
<p>第一步先取统计接口<code>FPlatformMemory::GetStats()</code> ，但是这里有个非MAC的判定，不知道为啥。</p>
<p>然后就是取<code>GMalloc</code>这里是通过一些模式和命令行在加上架构去分析的，太偏底层的不太熟悉了，有熟悉的大佬可以在下方留言提醒。</p>
<p>在然后就是拉取Crash助手叫做<code>FPlatformMallocCrash</code>它有以下职责：</p>
<ul>
<li>当内存分配低于16字节对齐的时候会触发crash。</li>
<li>分配器的线程只能是当前线程。</li>
</ul>
<p>接着就是判断<code>GMalloc-&gt;IsInternallyThreadSafe()</code>里面针对不同的malloc做一些判定是否是线程安全的，这块不是太懂。</p>
<p>接着就是跑内存分析器，这里有个奇怪的宏是<code>IS_MONOLIGHTIC</code>是和mono相关的吗？先不管了。</p>
<p>下一步又判断了以下<code>GMalloc-&gt;IsInternallyThreadSafe()</code>这个感觉是针对profile的，就是说你如果非要非线程安全的，那我就帮你搞一个代理吧，叫<code>FMallocThreadSafeProxy</code>。<br>反正怎么说呢，我认为哈，所以的proxy都是认为，你把握不住的东西，我帮你搞一层代理，容易把你绕晕的地方你就不用管了，也不要瞎搞了。交给我吧。<br>然后在所有的内存操作之前都会做一个同步锁。</p>
<p>下一步又有一个校验器，里面又加了一把锁，外面通过宏切换开关，以我浅薄的认识，这两个可能是不会同时开启的，不然两把锁没有意义呀。<br>这个的作用注释上面写着是过滤无效的指针，原理就是存储了一下指针，做了校验。这个平时开发最好一直开启着。然后暴露出来。</p>
<p>下一步是检查内存泄露的，我猜测和上面的使用方式差不多。<br>不过里面逻辑还是挺多了，首先分配完内存之后，要先判断当前线程是否开启检查，是否开启捕获alloc，是否申请内存高于阈值，小内存你就不考虑了吗？<br>然后又是一把锁，果然很多线程呀。然后里面纪录了一件事情，就是记录内存申请的堆栈，这里感觉和AssetService很相似呀。</p>
<p>下一步就是叫啥有害内存分配代理<code>FMallocPosionProxy</code>又是代理，看到没，人与人之前的就这么不信任的吗？<br>这个主要职责就很简单了，因为我们内存基本都是从池子里面取出来的，可能还会残留一些之前的数据，如果你不清理的话又不赋值直接使用的话，可能会引用到一些奇奇怪怪的东西，<br>我们调试的时候看到空，就知道，哦，他们的忘记赋值了，一看到奇怪的内容，我擦，这是什么意思，怎么会这样呢，害人又害己。</p>
<p>下一步是打印了程序能用到多少内存。</p>
<p>下一步是搞一个看起来像是为了dump搞得，有点没看明白，直接贴代码<code>GMalloc = FMallocDoubleFreeFinder::OverrideIfEnabled(GMalloc)</code></p>
<p>下一个就是分析统计的<code>GMalloc = FMallocFrameProfiler::OverrideIfEnabled(GMalloc)</code></p>
<h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMemory::Malloc(SIZE_T Count, uint32 Alignment)</span><br></pre></td></tr></table></figure>
<p>使用其实比较简单的，就是根据不同的分配器去分配内存，<a href="https://zhuanlan.zhihu.com/p/81481072" target="_blank" rel="noopener">知乎的大佬</a> 举了一个<code>MallocTBB</code>的例子。</p>
<p>他大概是说分配超出了就回调<code>GetOutOfMemoryDelegate</code>，然后这里字节对齐是8字节的。超过就16字节，这里小伙伴可能会疑惑，你有个<code>FPlatformMallocCrash</code>上面不是说16字节的吗？是的，<br>但是其实这些是针对平台的，我看的那个实例其实是<code>FGenericPlatformMallocCrash</code>，聪明的小伙伴一看这个字面量就知道什么意思了，我这个是针对通用平台的逻辑，而他这个分配器应该是特殊平台的，<br>所以并不冲突。</p>
<p>好了，现在我们回到我们的问题，两个有什么区分，GameCore由于时间问题和一些其它原因，我就不便介绍了，基本可以按照自研项目那一套方式，底层采用操作系统接口，加一下统计分析逻辑，代码的兼容性和健全性肯定是没法和UE4的比了。</p>
<p>好吧，就这样了。时间原因我没法做太多的分析。</p>
<p>水一篇文章吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2021/07/02/spine-ue4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/spine-ue4/" class="post-title-link" itemprop="url">Spine UE4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-02 09:26:08 / 修改时间：09:57:31" itemprop="dateCreated datePublished" datetime="2021-07-02T09:26:08+08:00">2021-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spine/" itemprop="url" rel="index"><span itemprop="name">Spine</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前看的Spine都是Unity相关的，最近由于项目要转UE4，所以研究一下UE4下的Spine，然后分析一下手游中的Spine的规格是如何的。</p>
<p>explicit 指定构造函数或转换函数（C++11起）为显式，即踏板不能用于隐式转换和复制初始化。（老是忘）</p>
<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>好吧，google搜spine基本都是如何导入UE4的一些操作，只能自己看代码了。<br>spine分为两个部分，一个是spine底层的通用C++层，一个是对UE4的包装。我这边也分为两部分讲解。</p>
<h2 id="通用C-层"><a href="#通用C-层" class="headerlink" title="通用C++层"></a>通用C++层</h2><p>这里面结构其实都是这一套，动画，图集，附件，骨骼，颜色，约束，事件，IK反向动力学，蒙皮，很奇怪的是里面的代码明显是按照UE4去做的，比如直接用UE_LOG打日志，所以就比较搞不懂，为什么在github是分开的。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>看到一个有意思的东西，之前看别人说是FString里面是按照4字节存储的，但是如果我们只是存储非宽字节，可以自己写一套，而他这个就是很好的参考。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>这里很简单的就是一个长度，一个缓存区，然后里面采用的FMemory做一些内存分配器。简单，高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2021/07/01/ue4-anim-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/01/ue4-anim-system/" class="post-title-link" itemprop="url">UE4 动画系统 源码及原理刨析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 20:21:38" itemprop="dateCreated datePublished" datetime="2021-07-01T20:21:38+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 09:24:48" itemprop="dateModified" datetime="2021-07-02T09:24:48+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index"><span itemprop="name">UE4</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://blog.csdn.net/qq_23030843/article/details/109103433" target="_blank" rel="noopener">https://blog.csdn.net/qq_23030843/article/details/109103433</a><br>大佬原文，本文主要是对原文的二次解析和做一个备份，垃圾的CSDN，谁知道那天倒闭呢。<br>其实内心挺想分享给别人的，但是感觉这种东西大家都可以查得到，还是算了吧。内向的人果然精神内耗很严重。<br>原文其实分了两个，一块是解算每一帧的动作位置，一块是渲染。所以我这边也是按照这两块来讲。<br>其实看了一遍，怎么说呢，纸上得来终觉浅，绝知此事要躬行吧。所以这边先简单摸一下字面意思，下次在加工一下。<br>我这边也分两块分析</p>
<h1 id="解算动作"><a href="#解算动作" class="headerlink" title="解算动作"></a>解算动作</h1><p>先知道解算这块是可以开启多线程加快运算的，具体如何加快，看原文。<br>还有一个概念，AnimInstance是一个数据和运算集中性业务，外面把握不住，所以推出AnimInstanceProxy来配合使用。<br>再有一点是虽然主要讲的是骨骼蒙皮，即skeletonMesh，但是StaticMesh其实也包含进去了。只不过没讲，怎么说呢，其实都属于一块的，只不过没有动，所以就是一个简单的模型处理了。</p>
<h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2021/06/30/ue4-rendering-part-6-adding-a-newshading-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/ue4-rendering-part-6-adding-a-newshading-model/" class="post-title-link" itemprop="url">UE4渲染第6节：添加一个新的渲染模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 20:55:59" itemprop="dateCreated datePublished" datetime="2021-06-30T20:55:59+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 09:33:21" itemprop="dateModified" datetime="2021-07-01T09:33:21+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index"><span itemprop="name">UE4</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>带翻译的文章：<a href="https://80.lv/articles/river-editor-water-simulation-in-real-time/" target="_blank" rel="noopener">https://80.lv/articles/river-editor-water-simulation-in-real-time/</a> 水<br><a href="https://wickedengine.net/2018/05/21/scalabe-gpu-fluid-simulation/" target="_blank" rel="noopener">https://wickedengine.net/2018/05/21/scalabe-gpu-fluid-simulation/</a> 流体<br><a href="https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/" target="_blank" rel="noopener">https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/</a> 各种噪声，不玩了，深陷其中了</p>
<p>原文地址：<a href="https://medium.com/@lordned/ue4-rendering-part-6-adding-a-new-shading-model-e2972b40d72d" target="_blank" rel="noopener">https://medium.com/@lordned/ue4-rendering-part-6-adding-a-new-shading-model-e2972b40d72d</a></p>
<p>注意，译文和原文出入已经很大了，译文主要是按照4.26来操作的，如果有疑问，最好看着原文去操作，不过我想原文的版本大家应该都没有把。</p>
<p>（如果你没有读本系列的第五节，<a href="https://medium.com/@lordned/unreal-engine-4-rendering-part-5-shader-permutations-2b975e503dd4" target="_blank" rel="noopener">请点击这里</a>）</p>
<h2 id="添加一个新的渲染模型"><a href="#添加一个新的渲染模型" class="headerlink" title="添加一个新的渲染模型"></a>添加一个新的渲染模型</h2><p>UE支持几种通用的开箱即用的渲染模型来针对大多数游戏。UE不仅支持微面元反射的默认光照，同时也支持高质量的头发和眼睛效果。但是这些可能不是最合适的对于你的游戏或者你希望修改或者新增对于你的游戏，尤其是对于高度风格化的游戏。</p>
<img src="/2021/06/30/ue4-rendering-part-6-adding-a-newshading-model/1.png" title="使用阶梯照明处理的着色模型">
<p>集成一个新的光照模型只需要少量的代码但是编译引擎可能花费点时间。当你决定要增加之前，最好看一下上一节，这可能会节省10分钟左右的迭代时间。</p>
<p>大部分的代码是基于FelixK的blog，但是已经打不开了。</p>
<p>我们需要修改3个地方来支持新的渲染模型，材质编辑器，材质和一些shader代码。</p>
<h3 id="修改材质编辑器"><a href="#修改材质编辑器" class="headerlink" title="修改材质编辑器"></a>修改材质编辑器</h3><p>首先打开EngineTypes.h文件，然后找到EMaterialShadingModel。这个枚举决定了在材质编辑器显示那些渲染模型。我们添加一个新的枚举<code>MSM_StylizedShadow</code>在<code>MSM_MAX</code>之前。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: Check UMaterialInstance::Serialize if changed!</span></span><br><span class="line">UENUM()</span><br><span class="line"><span class="keyword">enum</span> EMaterialShadingModel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// … Previous entries omitted for brevity</span></span><br><span class="line">    MSM_Eye UMETA(DisplayName=”Eye”),</span><br><span class="line">    MSM_StylizedShadow UMETA(DisplayName=”Stylized Shadow”),</span><br><span class="line">    MSM_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>枚举可能是按照名字序列化的（如果存在？），但对于引擎来说任何地方的序列化的都加在最后。</p>
<p>UE在<code>UMaterialShadingModel</code>枚举警告开发者检查<code>UMaterialInstance::Serialize</code>函数如果我们改变了枚举。看起来我们不需要更改任何东西，当我们添加了新的渲染模型，所以我们忽略这个警告。（如果你却是对这个函数感到兴趣，它确实是改变了一些资产的加载顺序）</p>
<img src="/2021/06/30/ue4-rendering-part-6-adding-a-newshading-model/2.png" title="下拉可以看到我们新加的渲染模型">
<p>当我们编译完成之后（译者注：裂开了，不知道为什么要编译两千多个文件）我们可以在材质编辑器的下拉框中看到我们新加的渲染模型选项，但是它啥事也不能做。FelixK使用<code>Custom Data 0</code>来允许艺术家设置光照衰减的范围。我们需要修改代码来使<code>Custom Data 0</code>起效在我们自定的渲染模型中。</p>
<p>打开Material.cpp（不是Lightmass项目中的那个）然后查找<code>UMaterial::IsPropertyActive_Internal</code>(4.26是这个函数，有点慌，不知道这个文档能不能跟着做下去)函数。材质上的每个可能的引脚（PIN不知道咋翻译，知道的老铁留个言）每次都会去调用它。如果你尝试正在修改材质域（domain暂时不知道指的是啥，虽然源码中也有这个概念，等我以后知道了就改掉这块）（比如贴花，后处理等），你将需要特别小心的处理该函数的第一部分，查看他们的域对于那些引脚应该启用。如果你和我一样正在修改渲染模型，这里可能有点复杂，<br>你需要搞一个switch-case来针对不同的引脚做不同的处理。（我好像可以理解引脚这个概念，其实就是不同的情况吧）</p>
<p>在我们这个case，我们想开启<code>MP_CustomData0</code>这个引脚，我们找到<code>MP_CustomData0</code>然后添加<code>MSM_StylizedShadow</code>来结束它。<br>当你可以改变渲染模型在风格化窗口中的时候，说明这个引脚已经被开启了，允许你连接它在你的材质蓝图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MP_CustomData0:</span><br><span class="line">    Active = ShadingModels.HasAnyShadingModel(&#123; MSM_ClearCoat, MSM_Hair, MSM_Cloth, MSM_Eye, MSM_StyleizedShadow &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>以上是4.26的写法。</p>
<p>理解这段代码的修改UI在材质编辑器上是重要的。<br>然后你还要确保你的数据支持这些引脚在你的shader上。</p>
<p>注意：<code>Custom Data 0</code>和<code>Custom Data 1</code>是单通道的float属性，这个可能是不够支撑你扩展你的自定义渲染模型。<a href="https://twitter.com/stoopdapoop" target="_blank" rel="noopener">Javad Kouchakzadeh</a> 指出你可以创建一个新的引脚，<br>这将让你选择如何生成你的hlsl代码。不过这有点超出我们的教程了，而且也不是这个文章的主题。你如果想体验一下，可以看一下MaterialShared.cpp文件中<code>InitializeAttributeMap()</code>这个函数。</p>
<h3 id="修改HLSL预处理器定义"><a href="#修改HLSL预处理器定义" class="headerlink" title="修改HLSL预处理器定义"></a>修改HLSL预处理器定义</h3><p>一旦我们在材质编辑器上选择了我们自己的渲染模型之后，我们得需要让我们的shader知道我们做了这件事。</p>
<p>HLSLMaterialTranslator.cpp然后查找<code>FHLSLMaterialTranslator::GetMaterialEnvironment(EShaderPlatform InPlatform, FShaderCompilerEnvironment&amp; OutEnvironment)</code>函数。<br>(用RIDER直接两个shift就直接找函数吧。)这个函数可以看到各种变量配置（各种属性在你的材质上）然后修改<code>OutEnvironment</code>变量来添加定义。</p>
<p>在我们特殊的案例中我们滑倒最后的部分在switch的<code>Property</code>并且添加我们的<code>MSM_StylizedShadow</code>Case，给它一个名字在允许的匹配中。文档与当前的引擎差异已经很大了，我这都是按照语义改的，不知道是否正确，主要是引擎编译起来有点痛苦。我先不加，等全部翻译完在加。试试。</p>
<p>现在，我们把<code>MSM_StylizedShadow</code>设置到HLSL编译器将通过<code>MATERIAL_SHADINGMODEL_STYLEIZED_SHADOW</code>作为一个预定义的。<br>它将允许我们使用<code>#if MATERIAL_SHADINGMODEL_STYLIZED_SHADOW</code>在HLSL代码里面。</p>
<h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><p>这里需要修改C++代码，我们已经添加我们的渲染模型在编辑器中，我们也已经改变引脚使用自定义数据，我们也保证了shader能告诉我们在这个模式。不过编译engine的代码需要花费大量时间（早说啊）。<br>我们也不想更改.ush/.usf文件当我们打开编辑器的时候，这回导致重新编译我们的shader。（这里好坑）</p>
<h3 id="更新GBuffer-Shading-Model-ID"><a href="#更新GBuffer-Shading-Model-ID" class="headerlink" title="更新GBuffer Shading Model ID"></a>更新GBuffer Shading Model ID</h3><p>现在他是可能的构建shader的排列（a permutation of排列是啥意思呀）通过使用我们的光照模型通过使用<code>MATERIAL_SHADINGMODEL_STYLEIZED_SHADOW</code>。第一件事情，我们需要写一个新的Shading Model ID到GBuffer。<br>当运行光照计算的时候，允许DeferredLIghtPixelShader知道切换那个shading model在使用着。</p>
<p>打开 ShadingCommon.ush然后找到<code>#define SHADINGMODELID_UNLIT</code>。在这里我们定义自己的Shading Model ID，然后更新<code>SHADINGMODELID_NUM</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHADINGMODELID_STYLEIZED_SHADOW 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHADINGMODELID_NUM 13</span></span><br></pre></td></tr></table></figure>
<p>我们需要告诉shader来写shading Model ID到GBuffer，在离开这个文件之前我们应该更新Buffer Visualization &gt; Shading Model 颜色以便告诉那个像素在你的场景是来自你的shading model的渲染的。</p>
<p>在下面可以找到 <code>float3 GetShadingModelColor(uint ShadingModelID)</code>。</p>
<p>我们添加一个入口在<code>switch(ShadingModelID)</code>里面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ShadingModelID)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2021/06/29/LevelSequencer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/29/LevelSequencer/" class="post-title-link" itemprop="url">LevelSequencer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 20:55:59" itemprop="dateCreated datePublished" datetime="2021-06-29T20:55:59+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-30 19:56:53" itemprop="dateModified" datetime="2021-06-30T19:56:53+08:00">2021-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index"><span itemprop="name">UE4</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LevelSequence（关卡序列）使用说明"><a href="#LevelSequence（关卡序列）使用说明" class="headerlink" title="LevelSequence（关卡序列）使用说明"></a>LevelSequence（关卡序列）使用说明</h1><p>以下文档都来自官方文档，但是我这边还是单独拿出来分析以下，足以证明，这块还是很有意思的。</p>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/ReferenceEditor/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/ReferenceEditor/</a></p>
<p>仔细看文档，基础操作，没啥说的，但是要注意，文档和引擎有些许差异，影响不大。</p>
<h2 id="从摄像机导轨拍摄"><a href="#从摄像机导轨拍摄" class="headerlink" title="从摄像机导轨拍摄"></a>从摄像机导轨拍摄</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/CameraRigRail/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/CameraRigRail/</a></p>
<h2 id="在Sequencer中使用帧标记"><a href="#在Sequencer中使用帧标记" class="headerlink" title="在Sequencer中使用帧标记"></a>在Sequencer中使用帧标记</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/FrameMarkers/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/FrameMarkers/</a><br>一个书签的东西，运行时不会用，随便搞。</p>
<p>挺有意思的，但是感觉可以用其它方式代替。不过可以试试。</p>
<h2 id="切换Sequencer中Actor的材质"><a href="#切换Sequencer中Actor的材质" class="headerlink" title="切换Sequencer中Actor的材质"></a>切换Sequencer中Actor的材质</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/MaterialAnimation/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/MaterialAnimation/</a></p>
<p>没啥好说的，跟着做就好。</p>
<h2 id="混合动画属性"><a href="#混合动画属性" class="headerlink" title="混合动画属性"></a>混合动画属性</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/CharacterAnimation/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/CharacterAnimation/</a></p>
<h2 id="使用模板序列"><a href="#使用模板序列" class="headerlink" title="使用模板序列"></a>使用模板序列</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TemplateSequences/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TemplateSequences/</a></p>
<p>单个轨道复用的，相当于做一个template sequencer可以给多个level sequencer使用。<br>制作的时候可以想清楚，如果有复用的情况下可以用这个。</p>
<p>没啥好说的，两个动画做blend，可以选如何插值。</p>
<h2 id="CineCameraActor（电影摄像机Actor）"><a href="#CineCameraActor（电影摄像机Actor）" class="headerlink" title="CineCameraActor（电影摄像机Actor）"></a>CineCameraActor（电影摄像机Actor）</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/CineCameraActors/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/CineCameraActors/</a></p>
<p>这个镜头我还是非常喜欢的，如果项目中可以使用，我是极力推荐的。</p>
<ul>
<li>启用观看跟踪（Enable Look at Tracking） -选取此选项可以让摄像机跟踪Actor。</li>
<li>提取调试观看跟踪位置（Draw Debug Look at Tracking Position）-选取此项可以让我们看到摄像机正在观看的位置。</li>
<li>要跟踪的Actor（Actor to Track）-将此项设置为ThirdPersonCharacter，因为我们希望在镜头中跟踪此角色。</li>
<li>相对偏移（Relative Offset）-将Z设置为60以将跟踪位置从默认跟踪位置稍微提高。<br>在CineCameraActor的细节（Details）面板中，将菲林版设置（Filmback Settings）设置为使用Super 16mm。菲林板设置（Filmback Settings）提供了不同的格式，虽然我没看懂是啥意思，但是实验了一下，感觉镜头拉的更近了。</li>
</ul>
<h2 id="淡入淡出场景"><a href="#淡入淡出场景" class="headerlink" title="淡入淡出场景"></a>淡入淡出场景</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksFade/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksFade/</a></p>
<p>使用的轨道是Fade Track</p>
<h2 id="关卡可见性轨道（项目包装可能与此不同，谨慎使用）"><a href="#关卡可见性轨道（项目包装可能与此不同，谨慎使用）" class="headerlink" title="关卡可见性轨道（项目包装可能与此不同，谨慎使用）"></a>关卡可见性轨道（项目包装可能与此不同，谨慎使用）</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksLevelVisibility/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksLevelVisibility/</a></p>
<p>使用的轨道是Level Visibility Track<br>简单来说其实就是卸载一个关卡，在加载另一个关卡的表现形式，但是项目的关卡定义方式可能会与此不同，不过即使不同，我们应该也会有类似的实现方式。所以原理可以参考。<br>做过长动画用这个感觉挺好的。</p>
<h2 id="为材质参数集（Material-Parameter-Collections）设置动画"><a href="#为材质参数集（Material-Parameter-Collections）设置动画" class="headerlink" title="为材质参数集（Material Parameter Collections）设置动画"></a>为材质参数集（Material Parameter Collections）设置动画</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksMaterialParameter/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksMaterialParameter/</a></p>
<p>使用的轨道是Material Parameter Collection Track<br>设置材质的一些参数。</p>
<h2 id="调整场景的播放速率"><a href="#调整场景的播放速率" class="headerlink" title="调整场景的播放速率"></a>调整场景的播放速率</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksPlayRate/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksPlayRate/</a></p>
<p>使用的轨道是Time Dilation，这有点坑，文档上面写着是Play Rate，用的时候要注意，这个之前磊子哥用的挺多的，在AGE中叫SetTimeScale。</p>
<h2 id="创建镜头和副镜头"><a href="#创建镜头和副镜头" class="headerlink" title="创建镜头和副镜头"></a>创建镜头和副镜头</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksShot/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksShot/</a></p>
<h2 id="关于蒙太奇"><a href="#关于蒙太奇" class="headerlink" title="关于蒙太奇"></a>关于蒙太奇</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/MatineeConversionTool/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/MatineeConversionTool/</a></p>
<p>上面这个文档没啥用，他的意思是说之前有蒙太奇的过场动画，说是一个轻量的，但是后来官方不维护了，就没用了。一堆废话，总之，代码还在，但是我们不用了。<br>跟着官方做，没有找到方法，但是找了一个可以把蒙太奇录入到subsequence里面，也是蛮方便的。录入的前提是需要在运行中录入的，非运行时录入应该也可以，但是这时候你如果可以把这个蒙太奇动起来就可以录入吧，我猜的。</p>
<p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/SequenceRecorder/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/SequenceRecorder/</a></p>
<p>真正的是看这个文档，说的很清楚就是运行游戏，然后开始录制，不过这个不是录制视频，而是level sequencer，挺好的。感觉可以做新手引导之类的东西，或者找一个样本，然后二次加工。</p>
<h2 id="使用音频轨迹"><a href="#使用音频轨迹" class="headerlink" title="使用音频轨迹"></a>使用音频轨迹</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksAudio/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksAudio/</a></p>
<p>说是要用wwise，做demo感觉可以用这个，不过不管吧，毕竟没啥需求，将来加了wwise，可以在加一个wwise的音频轨道，也好加。</p>
<h2 id="自动关键帧"><a href="#自动关键帧" class="headerlink" title="自动关键帧"></a>自动关键帧</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/UsingAutoKey/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/UsingAutoKey/</a></p>
<p>没啥可说的，K帧最基本的东西。</p>
<h2 id="保留或存储通过Sequencer进行的修改"><a href="#保留或存储通过Sequencer进行的修改" class="headerlink" title="保留或存储通过Sequencer进行的修改"></a>保留或存储通过Sequencer进行的修改</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/WhenFinished/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/WhenFinished/</a></p>
<p>没啥可说的，播完之后选择如何设置绑定对象或者全局的状态。</p>
<h2 id="媒体轨道"><a href="#媒体轨道" class="headerlink" title="媒体轨道"></a>媒体轨道</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/UsingMediaTracks/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/UsingMediaTracks/</a></p>
<h2 id="使用摄像机镜头切换"><a href="#使用摄像机镜头切换" class="headerlink" title="使用摄像机镜头切换"></a>使用摄像机镜头切换</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksCameraCut/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/TracksCameraCut/</a></p>
<p>这个东西，反正我挺喜欢的，不过按照AGE来说，我们可能只会用一个镜头，但是说实在的，一个镜头却是靠操控性会差很多。而且程序这边还需要传一个主相机。<br>其实level sequencer和age来比，或者age和其它编辑器来说，最大的优势其实是多种坐标系这个概念，让发生的过场动画，跟你的环境不是受太大的影响。然后引导你去这种编辑一些东西。<br>但是其实这种不太好。美术做的东西本来就很容易受环境影响，不同的环境表现力肯定是不相同的，所以我比较倾向程序尽量少传递这些比如镜头和角色等之类的东西，如果在性能可以hold的情况下。</p>
<h2 id="使用动态变形创建关卡序列"><a href="#使用动态变形创建关卡序列" class="headerlink" title="使用动态变形创建关卡序列"></a>使用动态变形创建关卡序列</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/DynamicTransforms/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/DynamicTransforms/</a></p>
<p>标题有点难受，其实就是指定坐标原点，相对坐标系那种思路。但是这个是个全局的概念，而不是age那种可以指向到某个轨道上去。</p>
<h2 id="通过Sequencer混合动画蓝图"><a href="#通过Sequencer混合动画蓝图" class="headerlink" title="通过Sequencer混合动画蓝图"></a>通过Sequencer混合动画蓝图</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/BlendingAnimBPs/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/BlendingAnimBPs/</a></p>
<p>讲道理来说，我们项目是不推荐使用自带蓝图的，在项目自己的蓝图中没有出来的时候，可以使用这种方式。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="使用几何体缓存轨迹"><a href="#使用几何体缓存轨迹" class="headerlink" title="使用几何体缓存轨迹"></a>使用几何体缓存轨迹</h3><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/GeometryCacheTrack/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/HowTo/GeometryCacheTrack/</a></p>
<p>有点秀操作的东西，但是我们应该用不上。</p>
<h3 id="非线性动画和混合工具"><a href="#非线性动画和混合工具" class="headerlink" title="非线性动画和混合工具"></a>非线性动画和混合工具</h3><p><a href="https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/AnimationBlendingTools/" target="_blank" rel="noopener">https://docs.unrealengine.com/4.26/zh-CN/AnimatingObjects/Sequencer/AnimationBlendingTools/</a></p>
<p>反正官方说是测试功能，不建议使用，我们也就不要使用了吧。大概意思是说，在动画的过渡区域，普通的混合会出现由于骨骼的控制权的归属和权重控制问题导致的错乱。而这个主要是处理这个问题的。但是由于是测试功能，说明还是有些坑没有解决掉的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2021/06/29/UE4_Macro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/29/UE4_Macro/" class="post-title-link" itemprop="url">UE4常见宏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 20:55:59" itemprop="dateCreated datePublished" datetime="2021-06-29T20:55:59+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-30 19:54:56" itemprop="dateModified" datetime="2021-06-30T19:54:56+08:00">2021-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index"><span itemprop="name">UE4</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类说明符"><a href="#类说明符" class="headerlink" title="类说明符"></a>类说明符</h1><ul>
<li><p>Abstract</p>
<p>  抽象类说明符将类声明为“抽象基类”，防止用户在虚幻编辑器中向世界添加此类的参与者，或者游戏中创建此类的实例。这对于那些本身没有意义的类很有用。</p>
</li>
<li><p>AdvancedClassDisplay</p>
<p>  强制类的所有属性只显示在“Detail”面板的”Advanced”部分中，默认情况下隐藏在”视图“中。若要在某个属性上重写此项，请在属性上使用SimpleDisplay说明符。</p>
</li>
<li><p>AutoCollapseCategories=(Category1, Category2,…)/DontAutoCollapseCategories(Category,Category,…)</p>
<p>  AutoCollapseCategories类说明取消对父类AutoExpandCategories说明符的列出类别的影响。<br>  DontAutoCollapseCategories否定从父类继承的列出类别的AutoCollapseCategories的说明符。</p>
</li>
<li><p>AutoExpendCategories=(Category1,Category2,…)</p>
<p>  指定应在该类的对象”虚幻编辑器“属性窗口中自动展开的一个或多个类别。若要自动声明为无类别的变量，请使用声明变量的类的名称</p>
</li>
<li><p>Blueprintable/NotBlueprintable</p>
<p>  将此类公开为创建蓝图可接受的基类。默认是NotBlueprintable，除非继承，否则该说明符由子类继承</p>
</li>
<li><p>BlueprintType</p>
<p>  将类型公开可用于蓝图中的变量的类型</p>
</li>
<li><p>ClassGroup=GroupName</p>
<p>  表示在Actor浏览器中启用Group View后，Actor浏览器应该在指定的GroupName中包含此类以及它的任何子类</p>
</li>
<li><p>CollapseCategories/DontCollapseCategories</p>
<p>  表示不应该将此类的属性分组到属性窗口的类别中。这个说明符将传播给子类，但是，子类可以用DontCollapseCategories说明符来覆盖它</p>
</li>
<li><p>Config=ConfigName</p>
<p>  表示允许此类在配置文件中(.ini)中存储数据。如果有使用config或globalconfig说明符属性的任何类属性，则此指定夫将导致这些属性存储在命名的配置文件中。此说明符将传播到所有子类不能被否定，但是子类可以通过re-declaring配置说明符并提供不同的ConfigName来更改配置文件。常见的ConfigName值是”Engine”,”Editor”,”Input”,”Game”。</p>
</li>
<li><p>Const</p>
<p>  该类中所有属性和函数都是const的，并以const的形式导出。该说明符由子类继承</p>
</li>
<li><p>ConversionRoot</p>
<p>  Root转换符将一个子类限制为仅能够转换到为第一个Root类的子类，并上升到层级结构</p>
</li>
<li><p>CustomConstructor</p>
<p>  组织自动生成构造函数声明</p>
</li>
<li><p>DefaultToInstanced</p>
<p>  这个类的所有实例都被认为是”实例化“的。实例化的类（组件）在构建时被复制。该说明符由子类继承</p>
</li>
<li><p>DependsOn=(ClassName1,ClassName2,…)</p>
<p>  列出的所有类将在该类之前编译。类必须在同一个（或上一个）包中指定一个一个类。可以使用由逗号分隔的单个取决于指定多个依赖项类，也可以为每个类使用单独指定。当类使用在另一个类中声明的结构或枚举时，这一点很重要，因为编译器只知道它已编译的类中内容。</p>
</li>
<li><p>Deprecated</p>
<p>  这个类不推荐使用，而且这个类的对象在序列化的时候不会被保存。该说明符由子类继承</p>
</li>
<li><p>EditInlineNew/NotEditInlineNew</p>
<p>  表示可以从”虚幻编辑器“属性窗口创建此类的对象，而不是从现有资产引用。默认行为时只有对现有对象的引用才可以通过属性窗口分配。此说明符被传播到所有子类；子类可以使用NotEditInlineNew说明符来重写此说明符。</p>
</li>
<li><p>HideCategories=(Category1,Category2,…)/ShowCategories=(Category1,Category2,…)</p>
<ul>
<li>HideCategories列出隐藏在此类对象的”虚幻编辑器“属性窗口的一个或多个类别。若要隐藏声明为”no“类型的属性，请使用声明该变量的名称。此说明符将传播到子类。</li>
<li>ShowCategories为所列出的类别取消一个HideCategories说明符（从基类继承）</li>
</ul>
</li>
<li><p>HideDropdown</p>
</li>
</ul>
<p>防止在虚寒编辑器属性窗口组合框中显示此类</p>
<ul>
<li><p>HideFunctions=(Category1,Category2,…)/ShowFunctions=(Category1,Category2,…)</p>
<ul>
<li>HideFunctions从属性查看器隐藏指定类别的所有函数</li>
<li>ShowFunctions从属性查看器中显示列出的类别中所有函数</li>
</ul>
</li>
<li><p>Intrinsic</p>
<p>  这表明这个类是直接用C++声明，并且没有UHT生成的generate文件。不要在新类上使用这个说明符。</p>
</li>
<li><p>MinimalAPI</p>
<p>  仅导致要导出的类的类型信息供其它模板使用。类可以被强制转换，单不能调用类的函数（inline除外）。这提高了编译事件，因为不需要在其他模块中访问所有函数的类导出所有内容。</p>
</li>
<li><p>NoExport</p>
<p>  表示此类的声明不应包含由UBT自动生成的generate文件。必须在单独的头文件中手动定义C++声明。仅对本机类有效。不要将此用于新类。</p>
</li>
<li><p>Placeable/NotPlaceable</p>
<p>  表示可以在编辑器中创建此类，并将其放置于关卡、UI或蓝图中（具体取决于类类型）。此标志将传播到所有子类；子类可以使用NotPlaceable说明符来重写此标志</p>
</li>
<li><p>Transient/NonTransient</p>
<p>  属于此类的对象将永远不会保存到磁盘。这与某些非永久性的自然类（如播放器或窗口）结合使用非常有用。此说明符将传播到子类，但可以由NonTransient说明符重写</p>
</li>
<li><p>Within=OuterClassName</p>
<p>  这个类的对象不能存在于一个OuterClassName对象的实例之外。这意味着创建这个类的Object需要提供一个OuterClassName的实例将其作为外部对象</p>
</li>
</ul>
<h1 id="元数据修饰符"><a href="#元数据修饰符" class="headerlink" title="元数据修饰符"></a>元数据修饰符</h1><ul>
<li><p>BlueprintSpawnableComponent</p>
<p>  如果存在，组件类可以由蓝图生成</p>
</li>
<li><p>BlueprintThreadSafe</p>
<p>  仅对蓝图函数库有效。此说明符将此类的中函数标记为在动画蓝图中的游戏线程上可调用</p>
</li>
<li><p>ChildCannotTick/ChildCanTick</p>
<ul>
<li>ChildCannotTick用于Actor和Component类。如果host不能勾选，基于此Actor或Component的蓝图类永远不会勾选，即使bCanBlueprintsTickByDefault为true</li>
<li>CHildCanTick用于Actor和Component类。如果host不能勾选，则基于此参与者或组件的蓝图类可以覆盖bCanEverTick标记，即使bCanBlueprintsTickByDefault是false。</li>
</ul>
</li>
<li><p>DeprecatedNode</p>
<p>  对于行为树节点，指示该类已弃用，并在编译时显示警告</p>
</li>
<li><p>DeprecationMessage=”Message Text”</p>
<p>  如果该类被启用，则在尝试编译使用它的蓝图时，此消息奖杯添加到警告中</p>
</li>
<li><p>DisplayName=”Blueprint Node Name”</p>
<p>  蓝图中此节点的名称将替换为此处提供的值，而不是代码生成的名称</p>
</li>
<li><p>DontUseGenericSpaenObject</p>
<p>  不要在蓝图中使用泛型创建对象节点生成类的对象。此说明符仅对既非参与者也不ActorComponents的BlueprintType类是有意义的</p>
</li>
<li><p>ExposedAsyncProxy</p>
<p>  在异步任务节点中公开此类的代理对象</p>
</li>
<li><p>IgnoreCategoryKeywordsInSubcalasses</p>
<p>  用于使类的第一个子类忽略所有继承的ShowCategories和HideCategories说明符</p>
</li>
<li><p>IsBlueprintBase=”true/false”</p>
<p>  声明此类是（或不是）用于创建蓝图的可接受基类，类似与UCLASS说明</p>
</li>
<li><p>KismetHideOverrides=”Event1,Event2,…”</p>
<p>  不允许重写的蓝图事件列表</p>
</li>
<li><p>ProhibiteInterfaces=”Interface1,Interface2,…”</p>
<p>  列出与类不兼容的接口</p>
</li>
<li><p>RestrictedToClasses=”Class1,Class2,…”</p>
<p>  由蓝图函数库类使用，用于限定列表中命名的类的用法</p>
</li>
<li><p>ShortToolTip</p>
<p>  在某些上下文中使用的简短工具提示，其中完整的工具提示可能是压倒性的，如父类选择器对话框</p>
</li>
<li><p>ToolTip</p>
<p>  重写代码注释中自动生成的工具提示</p>
</li>
<li><p>ShowWorldContextPin</p>
<p>  表示放置在此类所拥有的关系图中的蓝图节点必须显示它们的世界上下文，即使它们通常是隐藏的，因为此类的对象不能用作世界上下文。</p>
</li>
<li><p>UsesHierarchy</p>
<p>  表示类使用分层数据。用于实例化detail面板中的分层编辑功能。</p>
</li>
</ul>
<h1 id="Shader中的宏"><a href="#Shader中的宏" class="headerlink" title="Shader中的宏"></a>Shader中的宏</h1><ul>
<li><p>MOBLIE_MULTI_VIEW</p>
<p>计算View复杂</p>
</li>
<li><p>PACK_INTERPOLANTS</p>
<p>是否使用了顶点雾，多了PackedInterps数组需要计算高度雾</p>
</li>
<li><p>USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSET </p>
<p>C++对应bNeedsWorldPositionExcludingShaderOffsets，是否需要世界位置，用于Decal计算</p>
</li>
<li><p>USE_PS_CLIP_PLANE</p>
<p>C++中对应r.AllowGlobalClipPlane，是否使用ps裁剪</p>
</li>
<li><p>OUTPUT_GAMMA_SPACE</p>
<p>C++中对应LDR_GAMMA_32，使用Gamma空间</p>
</li>
<li><p>FULLY_ROUGH </p>
<p>c++对应材质IsFullyRough，是否是fullrough，可以减少计算</p>
</li>
<li><p>NONMETAL</p>
<p>C++ MATERIAL_NONMETAL 材质是否金属化，非金属计算量少，EnvBRDFApproxNonmetal EnvBRDFApprox</p>
</li>
<li><p>LQ_TEXTURE_LIGHTMAP</p>
<p>是否使用了Lightmap</p>
</li>
<li><p>HQ_REFLECTIONS</p>
<p>High Quality 反射</p>
</li>
<li><p>ALLOW_CUBE_REFLECTIONS</p>
<p>High Quality 反射中的cube反射</p>
</li>
<li><p>MATERIAL_PLANAR_FORWARD_REFLECTIONS</p>
<p>Planar 反射</p>
</li>
<li><p>MATERIALBLENDING_SOLID</p>
<p>Blend方式</p>
</li>
<li><p>MATERIALBLENDING_MASKED</p>
</li>
<li><p>MATERIALBLENDING_APLHACOMPOSITE</p>
</li>
<li><p>MATERIALBLENDING_TRANSLUCENT</p>
</li>
<li><p>MATERIALBLENDING_ADDITIVE</p>
</li>
<li><p>MATERIALBLENDING_MODULATE</p>
</li>
<li><p>MATERIAL_SHADINGMODEL_UNLIT</p>
<ul>
<li>无光照模式</li>
</ul>
</li>
<li><p>ENABLE_SKY_LIGHT</p>
<p>是否拥有天光</p>
</li>
<li><p>MAX_DYNAMIC_POINT_LIGHTS</p>
<p>动态光</p>
</li>
<li><p>NON_DIRECTIONAL_DIRECT_LIGHTING</p>
</li>
</ul>
<p>这可以在DeferredLightingCommon.ush中找到，但似乎只在ForwardLightingCommon.ush定义</p>
<ul>
<li>SUPPORT_CONTACT_SHADOWS</li>
</ul>
<p>为unreal的contact Shadows Feature提供支持。</p>
<ul>
<li>REFERENCE_QUALITY</li>
</ul>
<p>在DeferredLightingCommon.ush的顶部定义为0，可能用于cinematic rendering</p>
<ul>
<li><p>ALLOW_STATIC_LIGHTING</p>
<p>如果r.AllowStaticLighting的控制台变量设置为1，则为true。这与Project Settings&gt;Rendering的Static Lighting support选项匹配</p>
</li>
<li><p>USE_DEVELOPMENT_SHADERS</p>
<p>如果COMPLIE_SHADERS_FOR_DEVELOPMENT是真的（并且平台支持它），则为true</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2021/06/17/SpatialAntiAliasingTechnology/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/SpatialAntiAliasingTechnology/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-17 10:54:47" itemprop="dateCreated datePublished" datetime="2021-06-17T10:54:47+08:00">2021-06-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/06/Mathematical-methods-in-3D-games-and-computer-graphics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/06/Mathematical-methods-in-3D-games-and-computer-graphics/" class="post-title-link" itemprop="url">3D游戏与计算机图形学中的数学方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-06 20:55:59" itemprop="dateCreated datePublished" datetime="2019-09-06T20:55:59+08:00">2019-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-graphics/" itemprop="url" rel="index"><span itemprop="name">Computer graphics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过像素包含测试、裁剪测试、Alpha测试、模版测试和深度测试，段数据的最终颜色值被混合到图像缓冲区。图像缓冲区的新颜色值通过将端数据的最终颜色值与图像缓冲区对应位置的颜色值进行混合操作而获得。段数据的Alpha值和保存在图像缓冲区中的Alpha值也可用来决定视见区中显示的最终颜色值。最简单的混合操作就是用段数据的最终颜色值替换图像缓冲区中的颜色值。混合操作也可用来产生透明一类的特殊视觉效果。</p>
<h2 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h2><p>两个向量的内积也被称为向量的点积或者标量积，是3D图形学忠应用最多的概念之一。内积可用来计算两个向量的方向差。<br><strong>定义2.3</strong> 两个n维向量$P$和$Q$的内积可以表示$P\cdot Q$，是一个标量，可以按以下公式计算：<br>$\vec P\cdot \vec Q=\sum_{i=1}^nP_iQ_i$<br>从该定义可以看出，两个向量的内积是每个分量乘积的和，对于三维向量，其内积可以表示为<br>$\vec P\cdot \vec Q=P_xQ_x+P_yQ_y+P_zQ_z$<br>接下来的定理2.4将揭示向量内积被广泛应用的原因。<br><strong>定理2.4</strong> 给定任意两个n维向量$\vec P$和$\vec Q$，内积$\vec P \cdot \vec Q$满足以下等式。<br>$\vec P \cdot \vec Q = ||P||\ ||Q||cos\alpha$<br>其中$\alpha$是坐标原点分别与向量$\vec P$和$\vec Q$对应的点之间连线的平面夹角。<br><strong>证明：</strong> 如图2.2所示，令其中$\alpha$为向量$\vec P$和向量$\vec Q$之间的夹角，根据余弦定义可知。<br><img src="/2019/09/06/Mathematical-methods-in-3D-games-and-computer-graphics/1.jpg"><br>图 2.2 等式$\vec P \cdot \vec Q = ||P||\ ||Q||cos\alpha$将两个向量的内积与它们的夹角联系在一起</p>
<h1 id="曲线与曲面"><a href="#曲线与曲面" class="headerlink" title="曲线与曲面"></a>曲线与曲面</h1><p>现代图形硬件已经具备对由大量顶点和平面组成的各类光滑曲面进行有效渲染的能力，因此弯曲几何体的表示与处理已经成为3D图形引擎的必备功能之一。另外，在几何造型系统中，曲线可以表示某个对象的运动轨迹。本章将介绍多种三维的三次曲线，并进一步介绍如何用这些曲线生成双三次参数曲面。</p>
<h2 id="三次曲线"><a href="#三次曲线" class="headerlink" title="三次曲线"></a>三次曲线</h2><p>三次多项式定义的曲线在操作灵活性和计算简单性方面比较均衡，因此在计算机图形学中被广泛应用。下面将介绍几种不同类型的三次曲线并比较它们之间的性质。<br>三次曲线的基本形式可用以下参数表达式表示。<br>$Q(t)=\vec a+\vec bt+\vec ct^2+\vec dt^3$<br>其中，a，b，c和d为常向量，Q(t)为曲线上与参数t对应的点。Q(t)的分部表达式为<br>$Q_x(t)=\vec a_x+\vec b_xt+\vec c_xt^2+\vec d_xt^3$<br>$Q_y(t)=\vec a_y+\vec b_yt+\vec c_yt^2+\vec d_yt^3$<br>$Q_z(t)=\vec a_z+\vec b_zt+\vec c_zt^2+\vec d_zt^3$<br>上式可以容易地写成矩阵乘积的形式：<br>$Q(t)=\begin{bmatrix}a_x&amp;b_x&amp;c_x&amp;d_x\\a_y&amp;b_y&amp;c_y&amp;d_y\\a_z&amp;b_z&amp;c_z&amp;d_z\end{bmatrix}\begin{bmatrix}1\\t\\t^2\\t^3\end{bmatrix}$<br>写成更紧凑的形式，如下所示：<br>$Q(t)=CT(t)$<br>其中，C为系数矩阵，$T(t)=(1,t,t^2,t^3)$，Q(t)的导数为曲线在t的切线方向，由于矩阵C为常数矩阵，可以很容易地计算出Q(t)的导数，如下式所示。<br>$Q^’(t)=Cd/dtT(t)=C$</p>
<h3 id="4-4-3-坐标w的几何意义"><a href="#4-4-3-坐标w的几何意义" class="headerlink" title="4.4.3 坐标w的几何意义"></a>4.4.3 坐标w的几何意义</h3><p>在利用$4\times 4$矩阵进行的变换中，四维向量的w坐标起了重要作用，除了这个作用外，w坐标还有重要的几何意义。前面，通过给三维点扩展一个等于1的w坐标，变成四维空间中的一个点。这里研究一下相反的情况，假设有一个4D点向量$\vec p = (x,y,z,w)$，其中w不为0.令向量$P’$为向量$P$在w=1的三维空间中的映射，如下式所示：<br>$P’=({x\over w},{y\over w},{z\over w})$</p>
<h3 id="4-6-2-四元数旋转"><a href="#4-6-2-四元数旋转" class="headerlink" title="4.6.2 四元数旋转"></a>4.6.2 四元数旋转</h3><p>三维空间的旋转可以看成函数$\varphi$在三维向量空间$R^3$内的映射变换。由于函数$\varphi$表示一个旋转变换，它必须保持长度、角度和偏手性不变。<br>如图4.5所示，图中为了方便省略了z轴，3D点向量$P’$为点$P$与坐标系原点的连线与w=1的三维空间的交点，因此，给4D向量P</p>
<h3 id="5-3-1-视场"><a href="#5-3-1-视场" class="headerlink" title="5.3.1 视场"></a>5.3.1 视场</h3><p>如图5.10所示，投影平面是一个与相机指向垂直的平面，该平面与相机的距离为e，左锥面与右锥面分别与该平面在x=-1和x=1处相交。距离e有时也被称为相机的焦距，与左锥面和右锥面之间的夹角$\alpha$有关，夹角$\alpha$被称为水平视场角。<br><img src="/2019/09/06/Mathematical-methods-in-3D-games-and-computer-graphics/2.jpg"><br>图5.10 相机到投影平面的距离e与水平视场角$\alpha$有关</p>
<p>对于给定的水平视场角$\alpha$，到投影平面的距离e可由以下三角关系表达式给出。<br>$e = {1\over tan( \alpha / 2)}$</p>
<p>焦距越短，则视场越大。视场角逐渐缩小，相机则进行放大成像，而焦距越大。<br>显示屏幕的宽高比等于显示屏幕的高度除以宽度，例如，像素分辨率为$640\times 480$的显示器的宽高比为0.75。由于大多数显示器不是正方形而是长方形，所以垂直视场不等于水平视场。低锥平面和顶锥平面与投影平面在$y=\pm a$处相交，a为显示器的宽高比，这可构成图5.11所示的三角形，则垂直视场角$\beta$的表达式如下：<br>$\beta=2tan^{-1}(a/e)$</p>
<img src="/2019/09/06/Mathematical-methods-in-3D-games-and-computer-graphics/3.jpg">
<p>图5.11 垂直视场角$\beta$与高宽比a有关</p>
<p>视锥的4个边平面在从投影平面切出一个长方形，该长方形与相机距离为e，它的四条边分别位于$x=\pm 1$和$y=\pm a$处。</p>
<h3 id="5-3-2-锥平面"><a href="#5-3-2-锥平面" class="headerlink" title="5.3.2 锥平面"></a>5.3.2 锥平面</h3><p>6个视锥平面在相机空间的法向量如图5.12所示，其中4个边锥平面的法向量向内，指向视锥内部，可以通过将边平面中的边的方向向里旋转90°获得。由于每个边锥平面都经过坐标系原点，其平面四锥表达式中的D=0。近锥平面与原点距离为n，与原点的相对方向与其法向量相同，所以D=-n。远锥平面与原点距离为f，与原点的相对方向与其法向量相反，所以D=f。表5.1总结了视锥的6个锥平面的四维平面表示向量。在表5.1中，4个边锥平面的法向量已经规范化成长度为单位长度的向量。<br><img src="/2019/09/06/Mathematical-methods-in-3D-games-and-computer-graphics/4.jpg"><br>图5.12 在OpenGL的相机空间中的视锥平面的法向量方向<br><strong>表5.1 在OpenGL的相机空间中的视锥平面向量</strong></p>
<h2 id="深度值偏移"><a href="#深度值偏移" class="headerlink" title="深度值偏移"></a>深度值偏移</h2><p>在很多游戏中，经常遇到渲染一些特殊效果的情况，如墙上的火烧痕迹和地面上的脚印，这些内容都不是原始场景的一部分，而是在游戏过程中产生的，在9.2节中将介绍这些特效的方法。这些修饰性的对象通常被贴到当前的物体表面上，因此这些对象包含的多边形与场景中的插值深度值，很少会等于与共面的另一多边形某一部分对应的渲染像素的插值深度值，这将导致一个不想要的渲染结果，即原始表面的多边形会透过贴上去的多边形而显示出来。<br>为了解决上述问题，需要寻找一个方法可以将多边形在场景中的深度适当偏移而不改变它的投影屏幕坐标或者调整多边形的纹理映射透视处理方法。多数3D图形系统包含一些多边形偏移函数，借用这些函数可实现处理目标。然而，这些办法缺少灵活的控制方法，常会导致逐顶点的复杂运算。本节将介绍一个通过修改投影矩阵而获得深度偏移效果的方法。</p>
<h3 id="投影矩阵调整"><a href="#投影矩阵调整" class="headerlink" title="投影矩阵调整"></a>投影矩阵调整</h3><p>首先分析标准的OpenGL透视投影矩阵对观察空间一点$P = (P_x,P_y,P_z,1)$的变换结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/06/Calculus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/06/Calculus/" class="post-title-link" itemprop="url">Calculus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-06 17:51:04" itemprop="dateCreated datePublished" datetime="2019-09-06T17:51:04+08:00">2019-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zentia.github.io/2019/09/06/ArchitecturalShadow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liyanfeng">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liyanfeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/06/ArchitecturalShadow/" class="post-title-link" itemprop="url">建筑场景的阴影实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-06 10:46:24" itemprop="dateCreated datePublished" datetime="2019-09-06T10:46:24+08:00">2019-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 10:39:37" itemprop="dateModified" datetime="2021-06-17T10:39:37+08:00">2021-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先看一下我们的效果需求，我们是一款SLG游戏，主程中的建筑都是3D的建筑，玩家到后期主城内有上百个建筑，而且建筑都是可以让玩家随意摆放的。我们的建筑要实现自身的阴影和在地面上的投影。如下图：<br><img src="/2019/09/06/ArchitecturalShadow/v2-6477cf3cf37a266372d7e8e09c763991_r.jpg"><br>一般我们在游戏中要实现建筑的阴影有两种方案：1.灯光的实时影音；2.使用Lightmap烘培阴影信息。</p>
<p>方案1在移动端使用的很少，如果没有实时光影的变化，类似天气系统之类的需求，基本上是不会使用的。要多一个pass去计算阴影，相当于场景中的三角面数翻倍。</p>
<p>方案2是目前大多数移动端上使用的，开销的话只是用第二套UV去采样一次Lightmap贴图而已。但是这种方法烘培Lightmap</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liyanfeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyanfeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
